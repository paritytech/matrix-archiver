# room: #jam:polkadot.io
# exported: 2025-10-11 03:20 UTC
2024-04-20 02:08 johnjiao123: 
2024-04-20 02:09 johnjiao123: 
2024-05-30 21:48 nradko: Hey everyone,
are the lectures explaining gray paper recorded and available online?
2024-05-31 10:54 gav: > <@nradko:matrix.org> Hey everyone,
> are the lectures explaining gray paper recorded and available online?

They are recorded but not online yet. Will be soon. 
2024-05-31 10:55 nradko: > <@gav:polkadot.io> They are recorded but not online yet. Will be soon.

can't wait.
2024-06-02 19:50 purpletentacle: A couple of quick questions:

- Are there any conformance tests already public? (as per rule 15)

- is FFI for external libs acceptable (e.g. crypto from a rust lib) or while libs are acceptable, they need to be native to the chosen language?

this was written in the w3f page but does not seem to be part of the rules: 
> Third-party libraries for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE), and networking (e.g. QUIC) are acceptable.


2024-06-02 20:38 gav: FFI is fine. 
2024-06-02 20:39 gav: Conformance tests are being worked on and we should be releasing the first batch in the next few weeks. 
2024-06-03 06:55 tomusdrw: Hello! Is TypeScript cude enough for set C? Or rather: does it qualify as JS?
2024-06-03 07:01 tomusdrw: Also, if I calculate correctly, in the happiest case, the maximal number of teams getting the maximal prize for each milestone in every set is ~2-3 (10M - minus extra auditing/operational costs / 5 milestones / 4 sets / 100k prize).
Hence I'm wondering is it public (maybe published already?) how many applications was there for each and every set? 
2024-06-03 12:33 purpletentacle: Is there any additional information about networking specs/protocol? I could only find that it will be based on QUIC.. but nothing more than that..‚Ä®This is not critical information for the first milestones.. but it can be useful to have in mind already. Any public information or hints about this? [edited]
2024-06-04 02:02 gav: Not really - expect QUIC with Ed25519 keys. 
2024-06-04 02:03 gav: And direct connections to all other validators. 
2024-06-04 02:03 gav: Networking specs probably won‚Äôt arrive for another 2-3 months.
2024-06-04 02:08 gav: 20240604T020818Z.jpg
2024-06-04 02:10 gav: Current thinking is that validators will be well connected with each other and then have a few extra proxy nodes which also are reasonably well connected. These then connect out to the public. 
2024-06-04 03:36 xlchen: will the graypaper to cover RPC spec as well?
2024-06-04 04:15 gav: No (since it‚Äôs app specific and not related to the protocol). 
2024-06-04 04:15 gav: But there should be a fellowship RFC. 
2024-06-04 04:16 gav: It can be something implementor teams can discuss in the implementation conferences. 
2024-06-04 04:17 gav: I expect to publish 0.2.0 of the paper today. 
2024-06-04 04:17 gav: This should more or less finalize the DA system.  [edited]
2024-06-04 04:18 gav: Safrole should also be final. And the trie spec. For all three we‚Äôll aim to have test vectors in the coming days. 
2024-06-04 04:19 gav: Block execution vectors should be ~6 weeks out. 
2024-06-04 04:20 gav: Availability system test vectors probably about the same timeline.  [edited]
2024-06-04 04:23 gav: Once we see some initial action on code from the first few teams then we‚Äôll sort out a mini implementation conference/seminar/hackathon. 
  ‚Ü≥ 2024-06-21 19:15 yikesawjeez: i like to organise usually-smallish-but-sometimes-big hackathaons online for fun, once you folks start heading that direction would love to get in touch with whoever's taking the lead on it and see how i can help if possible :)
2024-06-04 05:23 pos.digitalghost: > <@gav:polkadot.io> And direct connections to all other validators.


wonder how would this pan out in censored areas where data center IPs are blocked

2024-06-04 05:59 gav: The protocol does rely on high quality connections (400 Mbps sustained) between validators; if you‚Äôre running a validator node then you‚Äôd need to provide this level of connectivity. 
2024-06-04 06:01 gav: For regular (‚Äúfull‚Äù) nodes then you‚Äôd most likely connect to the validator proxies. For work-package authors, you‚Äôd want to connect to one of three guarantors of the core for the work package. Likely that would have a different protocol, and would not receive eg block updates over it. 
2024-06-04 06:02 gav: All this networking stuff is the last thing to be finalized as it doesn‚Äôt affect the core protocol. 
2024-06-04 09:36 tomusdrw: > <@tomusdrw:matrix.org> Hello! Is TypeScript cude enough for set C? Or rather: does it qualify as JS?

^^^ @gav any comments on this one?
2024-06-04 09:41 pos.digitalghost: guess so as it‚Äôll have to convert to js anyways
2024-06-04 09:43 gav: > <@tomusdrw:matrix.org> Hello! Is TypeScript cude enough for set C? Or rather: does it qualify as JS?

It qualifies as a major dialect of JS :)
2024-06-04 09:44 gav: > <@tomusdrw:matrix.org> Also, if I calculate correctly, in the happiest case, the maximal number of teams getting the maximal prize for each milestone in every set is ~2-3 (10M - minus extra auditing/operational costs / 5 milestones / 4 sets / 100k prize).
> Hence I'm wondering is it public (maybe published already?) how many applications was there for each and every set? 

Auditing would be paid separately to the prize fund. 
2024-06-04 09:45 gav: So it‚Äôs strictly a max of 500k DOT total (100k per milestone)
2024-06-04 09:46 gav: Gauging from interest thus far, I‚Äôd say it‚Äôs a reasonable expectation that teams delivering milestones pre-launch will be getting the full amount. 
2024-06-04 09:49 gav: But yeah, theoretically if there‚Äôs more than 20 teams delivering viable, audited implementations across the language sets pre-1.0 spec then even those in the first wave could end up with less. I‚Äôd say it‚Äôs rather an unlikely eventuality.  [edited]
2024-06-04 09:57 gav: If it‚Äôs an issue for teams then we could perhaps say that those teams who get to M1 first get prioritised for prizes if there is contention and they are at M4 or M5 at network launch. [edited]
2024-06-04 13:00 purpletentacle: > <@pos.digitalghost:matrix.org> 
> wonder how would this pan out in censored areas where data center IPs are blocked
> 

@gav It would be nice if networking is ipv6 based.. this would simplify a lot the networking, nat, etc.. given that the spec will require at least 400Mbps.. most providers will be able to support ipv6 without complaining much...
2024-06-04 21:51 gav: > <@purpletentacle:matrix.org> @gav It would be nice if networking is ipv6 based.. this would simplify a lot the networking, nat, etc.. given that the spec will require at least 400Mbps.. most providers will be able to support ipv6 without complaining much...

Yes indeed. 
2024-06-07 01:01 aedigix: > <@gav:polkadot.io> Yes indeed.

There should be support for ipv4 RPC endpoints unless RPC is outside of the scope of JAM
2024-06-07 04:01 gav: It‚Äôs essentially out of scope. 
2024-06-07 04:03 gav: There might be an RFC. But JAM usage should rely on light-clients rather than full-node+RPC. 
2024-06-10 20:37 purpletentacle: gav:  In the case of some small inconsistencies in the graypaper, would you prefer to discuss them here, or a PR in the repo is better?
2024-06-11 02:30 gav: Best to discuss in the graypaper channel rather than here but if they‚Äôre obvious corrections then a PR is fine too. 
2024-06-16 12:57 ltfschoen: it says here https://jam.web3.foundation/rules that "Clean-room implementation using the Graypaper and public implementor chat channels as the only resources.".

it is my understanding that the Graypaper chat channel is https://matrix.to/#/#graypaper:polkadot.io

where are the "public implementer" chat channels?

and is there a reason why it doesn't include the Jam chat channel here https://matrix.to/#/#jam:polkadot.io?

also, it says "Each team is only allowed to work on one implementation", but in the application form it says "What programming language(s) are you using and which language set are you applying for? e.g. "Rust, set B", so i don't understand why it's asking us "What programming language(s) are you using". is it just wanting to know if we'll be using multiple languages in the our single implementation (e.g. if we'll be doing an implementation in Rust and using FFI from Ruby and Python then we'd answer `Rust, Ruby, Python, set B`?

i was actually going to try and work on multiple implementations using multiple language sets (e.g. Rust, Swift Ruby, Python, JS/TS) in parallel as a contingency incase i got stuck and couldn't get support with one of them. after submission of our initial application form, will be possible for us to later on change what programming language(s) and language set that we'll be using for the one implementation that could be eligible for the JAM prize?
2024-06-16 20:09 sourabhniyogi: For rule 7, "Any JAM-implementation code which is viewed before or during implementation must be declared", is the following acceptable for declaration:

```
In our implementation, beyond the Graypaper, we relied on the following for either FFIs or our learning of JAM:
 1. Koute's PVM Implementation: (no FFI)
    https://github.com/koute/polkavm
 2. Ring VRF: (FFI [link](...))
    https://github.com/w3f/ring-vrf
 3. Sassafras (no FFI)
    https://github.com/paritytech/polkadot-sdk/pull/1336/
    https://github.com/polkadot-fellows/RFCs/pull/26
 4. Polkadot-SDK: Grandpa (no FFI)
    https://github.com/paritytech/polkadot-sdk/...
 5. Polkadot-SDK: Erasure Coding (FFI [link](...))
    https://github.com/paritytech/polkadot-sdk/...
```

Are all of (1)-(5) declarations actually necessary?  Do any of (1)-(5) break "clean room" expectations in some way?

If the FFI vs non-FFI boundary is made clear and what should NOT be peeked at (even for learning purposes), it will spare implementers some grief (implementing something where FFI is acceptable or preferred, peeking at something which should not be peeked at).  Can you make clear which components would ideally NOT use FFI and would ideally use FFIs?  [edited]
2024-06-16 20:49 sourabhniyogi: For rule 15, "For code developed in private, commit hashes should be placed, in a timely fashion, ..." what does "in a timely fashion" mean, e.g if we commit via system.remark via  
https://assethub-polkadot.subscan.io/extrinsic/6489450-2  on June 16 
and then again on July 16, Aug 16, Sept 16 (once a month) is that sufficient or is a higher frequency expected? [edited]
2024-06-17 03:07 ascriv: Will there be a public list of teams and their chosen programming language? I want to work on implementation but I also want not to spend a lot of time on one of the languages that has a seriously good team already on it
2024-06-17 03:07 ascriv: Could also be good for finding teams to join 
2024-06-18 03:11 gav: The only thing which really matters is the code and the ability to demonstrate that it is a reasonably independent implementation of your own. [edited]
2024-06-18 03:12 gav: Application forms are totally irrelevant.
2024-06-18 03:13 gav: The point of restricting a prize-teams to a single implementation project is: [edited]
2024-06-18 03:14 gav: - to disincentivize the submission of additional Milestone 1/2 submissions over developing an impl towards Milestones 3-5.
- to avoid getting multiple implementations with the same overall architecture and design (and bugs). [edited]
2024-06-18 03:18 gav: 1 compromises hygiene somewhat, 3 and 5 probably not since neither are compatible with GP. 2 and 4 are probably fine since they're not going to be defined in the GP. [edited]
2024-06-18 03:19 gav: Third-party libraries (FFI) for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE) and networking (e.g. QUIC) are acceptable. [edited]
2024-06-18 03:20 gav: Everything else should be properly implemented.
2024-06-18 03:21 gav: A proper Grandpa impl should be assumed to be a requirement of milestone 2 and above. This might be elevated to milestone 3, so treat it as the lowest priority feature. I haven't made this especially clear yet since it's not especially well-defined in the GP and I wouldn't expect impl teams to need it for some months to come yet. [edited]
2024-06-18 03:23 gav: > <@sourabhniyogi:matrix.org> For rule 15, "For code developed in private, commit hashes should be placed, in a timely fashion, ..." what does "in a timely fashion" mean, e.g if we commit via system.remark via  
> https://assethub-polkadot.subscan.io/extrinsic/6489450-2  on June 16 
> and then again on July 16, Aug 16, Sept 16 (once a month) is that sufficient or is a higher frequency expected?

Higher frequency
2024-06-18 03:24 gav: The point of this is to help _you_ prove that *you* wrote the code organically. [edited]
2024-06-18 03:25 gav: If you come to the Fellowship with one big commit of a working impl but the code design/arch looks similar to some other (maybe OSS) impl, then Fellowship are going to need further clear evidence that it's not just a port.
2024-06-18 03:26 gav: A Git history with credibly timestamped commit hashes are one way of helping with this.
2024-06-18 03:26 gav: If you don't provide this additional evidence then you run the risk of trouble with claiming the prize.
2024-06-18 03:27 gav: Teams which want to make their presence known can contact David at the W3F or post on here. [edited]
2024-06-18 03:28 gav: There is no requirement to pre-announce ones intention though. There is not a single prize per language: e.g. two teams writing an independent C++ impl can both claim the full prize in principle (clean room rules still apply!) [edited]
2024-06-18 03:29 gav: However, if you want to make it a bit more likely that you'll not be writing in the same language as some other team (for whatever reason), then consider selecting a less-common language. The language groupings are set with the intention of incentivising diverse impl languages. There's a single pot per grouping so that 20 teams all writing in C++ and Rust don't take the full pot. [edited]
2024-06-18 16:59 sourabhniyogi: For rule 24, "The repository must include a clear and permissive open-source license." are Business Source Licenses such as that of 
(1) Uniswap https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/LICENSE
(2) Arbitrum https://github.com/code-423n4/2024-05-arbitrum-foundation/blob/main/LICENSE.md
(3) Aave https://github.com/aave/aave-v3-core/blob/master/LICENSE.md
which mostly originate from https://mariadb.com/bsl11/ considered "clear and permissive open-source licenses"?

It may be useful to have JAM teams get a head start over TRON/BSC/... type actors with a mechanism like this:
https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/LICENSE#L18-L21 [edited]
2024-06-18 17:05 gav: Could you make this question clearer/more specific? [edited]
2024-06-18 17:19 sourabhniyogi: Sure -- for Rule 24  "The repository must include a clear and permissive open-source license." is this license acceptable:

```
Business Source License 1.1

License text copyright (c) 2017 MariaDB Corporation Ab, All Rights Reserved.
"Business Source License" is a trademark of MariaDB Corporation Ab.

-----------------------------------------------------------------------------

Parameters

Licensor:             JAM Team X

Licensed Work:        JAM X  
The Licensed Work is (c) 2024 JAM Team X

Change Date:          2029-04-19

Change License:       GNU General Public License v2.0 or later

-----------------------------------------------------------------------------

Terms

The Licensor hereby grants you the right to copy, modify, create derivative works, redistribute, and make non-production use of the Licensed Work. The Licensor may make an Additional Use Grant, above, permitting limited
production use.

Effective on the Change Date, or the fourth anniversary of the first publicly available distribution of a specific version of the Licensed Work under this License, whichever comes first, the Licensor hereby grants you rights under the terms of the Change License, and the rights granted in the paragraph above terminate.

If your use of the Licensed Work does not comply with the requirements currently in effect as described in this License, you must purchase a commercial license from the Licensor, its affiliated entities, or authorized
resellers, or you must refrain from using the Licensed Work.

All copies of the original and modified Licensed Work, and derivative works of the Licensed Work, are subject to this License. This License applies separately for each version of the Licensed Work and the Change Date may vary for each version of the Licensed Work released by Licensor.

You must conspicuously display this License on each original or modified copy of the Licensed Work. If you receive the Licensed Work in original or modified form from a third party, the terms and conditions set forth in this License apply to your use of that work.

Any use of the Licensed Work in violation of this License will automatically terminate your rights under this License for the current and all other versions of the Licensed Work.

This License does not grant you any right in any trademark or logo of Licensor or its affiliates (provided that you may use a trademark or logo of Licensor as expressly required by this License).

TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE LICENSED WORK IS PROVIDED ON AN "AS IS" BASIS. LICENSOR HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS OR IMPLIED, INCLUDING (WITHOUT LIMITATION) WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND TITLE.

MariaDB hereby grants you permission to use this License‚Äôs text to license your works, and to refer to it using the trademark "Business Source License", as long as you comply with the Covenants of Licensor below.

-----------------------------------------------------------------------------

Covenants of Licensor

In consideration of the right to use this License‚Äôs text and the "Business Source License" name and trademark, Licensor covenants to MariaDB, and to all other recipients of the licensed work to be provided by Licensor:

1. To specify as the Change License the GPL Version 2.0 or any later version, or a license that is compatible with GPL Version 2.0 or a later version, where "compatible" means that software provided under the Change License can be included in a program with software provided under GPL Version 2.0 or a later version. Licensor may specify additional Change Licenses without limitation.

2. To either: (a) specify an additional grant of rights to use that does not impose any additional restriction on the right granted in this License, as the Additional Use Grant; or (b) insert the text "None".

3. To specify a Change Date.

4. Not to modify this License in any other way.

-----------------------------------------------------------------------------

Notice

The Business Source License (this document, or the "License") is not an Open Source license. However, the Licensed Work will eventually be made available under an Open Source License, as stated in this License.
```

If not, is there a specific Change Date modification that could be acceptable? 
2024-06-18 17:21 gav: Without consulting a lawyer, no and no.  [edited]
2024-06-18 17:23 gav: The point is to ensure that any implementations are the property of the coders who deign to maintain them. The licenses should reflect that.  [edited]
2024-06-18 17:23 gav: Licenses which allow for individuals, organisations or other economic entities to retain a privilege over a code base regardless of others‚Äô contributions do not fulfil this goal.  [edited]
2024-06-19 05:49 hitchhooker: https://i.ibb.co/z2TNfrD/toaster.png tried to draw toaster based on images and 2049 specs. looks like we around 128kw in total? 
2024-06-19 12:16 sourabhniyogi: > <@gav:polkadot.io> Safrole should also be final. And the trie spec. For all three we‚Äôll aim to have test vectors in the coming days.

Are the test vectors for { Safrole, trie, DA system (?) } published already (if so, where?) or to be published still (if so, is there an ETA)? 
2024-06-19 12:25 tomusdrw: 
2024-06-19 13:23 gav: > <@sourabhniyogi:matrix.org> Are the test vectors for { Safrole, trie, DA system (?) } published already (if so, where?) or to be published still (if so, is there an ETA)? 

Not yet. Will notify here as soon as they‚Äôre compiled. 
2024-06-20 17:55 yikesawjeez: hey; is there a canonical resource for what all a jam client would entail? Closest thing I can find is the RFC, but i have a team working on a substrate solochain that's more-or-less what's being described in the greypaper; would love to find some more info
2024-06-21 09:57 gav: The Graypaper covers all of the main protocol elements. There‚Äôs a notable lack of spec for a full networking protocol, which doesn‚Äôt make much sense to do until the first team gets basic block importing working (Milestone 1).  [edited]
2024-06-21 09:58 gav: ‚ÄúMore or less‚Äù isn‚Äôt especially useful and it cannot be implemented utilising Substrate as there are several design decisions in Substrate which would preclude specifically this protocol.  [edited]
  ‚Ü≥ 2024-06-21 18:59 yikesawjeez: admittedly i'm mostly going off what the lead dev was telling me as opposed to being intimately familiar with the architecture myself; he seemed quite excited after listening to a podcast outlining the vision for JAM about being, presumably, at least headed in the same direciton. Would the various milestones be listed in the RFP, and would that be the best place to look if somone wanted to get involved in building/helping out with the project in general?
  ‚Ü≥ 2024-06-22 04:12 gav: Yes, the milestones will be effectively fixed as we have information for the conformance and performance tests required for them. Since this is a protocol-oriented approach rather than software-oriented, we don't yet have an implementation from which a reasonably tranche of test vectors can be produced.
  ‚Ü≥ 2024-06-22 04:13 gav: Until then you can assume Milestone 1, defined as a block-importer, is for the implementation of all on-chain logic in the GP, which you'll find is all sections up to and including section 12, taking into account all relevant appendices. [edited]
  ‚Ü≥ 2024-06-22 04:14 gav: Sections 13 onwards deal with the off-chain logic and will be for Milestone 2 - a block author and node - which will also need the yet to be written networking spec. [edited]
2024-06-21 15:43 jimboj21: Going off the previous question, is it imagined that certain components of JAM will use parts of substrate, or will everything be written from scratch? A specific example I am thinking of is grandpa. Is it imagined that the current implementation will be used (for one of the impls) or that it will be rebuilt? 
2024-06-21 17:59 sergei_astapov: Hey everyone,

Three passionate PBA 5 alumni have chosen to build a JAM client using Scala 3 (vanilla Scala). If you're familiar with Scala and interested, feel free to DM me without hesitation!

Thanks!
2024-06-22 04:16 gav: Mostly from scratch; Substrate specifically won't be helpful. [edited]
2024-06-22 04:16 gav: Substrate is a relatively opinionated blockchain framework. It is also software, not a protocol. [edited]
2024-06-22 04:16 gav: Jam is a protocol. That essentially precludes it from being based on Substrate, which is software.
2024-06-22 04:19 gav: Grandpa is also protocol-first, so pre-existing implementations can likely be leveraged provided they are compatible with the Grandpa spec paper and the (yet to be formalised) GP-integration spec.
2024-06-22 04:24 gav: For the full payout, we'll almost certainly require a clean-room implementation of Grandpa though. Basing all node impls on a single Grandpa impl could compromise the network in case a bug were found in it.

In general, the only exceptions we can make to this rule are where the logic is extremely well-specified and understood outside of the Jam/Polkadot community, audited, and/or in heavier or more economically significant use outside of Polkadot. For this reason we can make exceptions for some of the underlying crypto/networking/math primitives which are not especially specific to Jam/Polkadot, such as EC, Ed25519, BLS, QUIC, Bandersnatch. [edited]
2024-06-22 04:28 gav: As I mention above though, implementing Grandpa should not be considered an especially high-priority job. At present the definition of milestone 2 would include it, but this might very well change to milestone 3 in due course.
2024-06-22 04:58 tomusdrw: > <@gav:polkadot.io> - to disincentivize the submission of additional Milestone 1/2 submissions over developing an impl towards Milestones 3-5.
> - to avoid getting multiple implementations with the same overall architecture and design (and bugs).

Given the objective of the "one team = one implementation" rule is to have teams focus on milestones 3-5 is it allowed to change the implementation language at some point?

I'm thinking specifically about a situation, where say, the first two milestones are completed in a less performant language (e.g. lang set C) and then the team realises there is almost no way of completing 3-5 and switch to something faster.
Obviously the prize for Milestones 1-2 wouldn't be claimed twice, the second implementation would only claim 3-5.

Would that be acceptable?
2024-06-22 05:00 gav: Totally.
2024-06-22 05:01 gav: I'd also leave open the degree to which M1 and M2 could be claimable for the second language.
2024-06-22 05:03 gav: If the two languages are different to the point that one could reasonably claim that it would be difficult for bugs and design flaws to cross the linguistic divide (e.g. functional vs procedural), then the Fellows (or failing that, W3F) could reasonably decide to award some or all of the prize anyway. [edited]
2024-06-22 05:04 gav: Ultimately, the point of the prize is to build resilience through decentralisation and diversity. The rules are (hopefully) relatively conservative in preventing loopholes which might allow teams to claim the prize without contributing to the network's resilience. But where that conservatism might be judged by the Fellowship to be counter-productive, then it might reasonably choose to award prizes regardless. [edited]
2024-06-22 05:07 gav: Obviously if a team implements in C and then "reimplements" in a C-dominated "C++", then this would not be claimable.
2024-06-22 05:08 gav: But if they implement in Haskell and implement again in a very idiomatic C++, both _might_ be claimable. All prize decisions are made at the discretion of the (non-team) Fellows. [edited]
2024-06-22 05:13 gav: Languages from different language sets and which do not share syntactic DNA would be a sensible lower-bar (required but not sufficient) for multiple prizes. [edited]
2024-06-22 19:59 purpletentacle: I think it would be unfair to the ones that get to M3-4.... to see teams that just concentrate on doing many M1s.. 
The biggest risk I see, is that performance requirements are not very clear.. and very likely Rust will set the bar for every other language...
having some guidelines on what performance (%) is acceptable below the top implementation would be useful [edited]
2024-06-22 21:17 xlchen: the bottleneck is most likely to be pvm and for production performance we most likely need to translate it to native code and run it. in that case, the language will only impact the translation phase, which should be a relatively simple thing
2024-06-22 21:17 xlchen: so the implementation language shouldn‚Äôt matter too much
2024-06-22 21:20 xlchen: but of course we can‚Äôt say for sure without an implementation 
2024-06-23 03:05 gav: > <@purpletentacle:matrix.org> I think it would be unfair to the ones that get to M3-4.... to see teams that just concentrate on doing many M1s.. 
> The biggest risk I see, is that performance requirements are not very clear.. and very likely Rust will set the bar for every other language...
> having some guidelines on what performance (%) is acceptable below the top implementation would be useful

M5 should be a pretty easy milestone to achieve after M4 for any well-engineered codebase, so that helps mitigate against bias towards "reimplementing what you know". In fact, roughly half of the actual logic is in M1 and roughly the other half in M2. M3, M4 and M5 are essentially "just" optimisations and security, so teams who repeatedly reimplemented M1 would probably be losing out. But point taken, and this is why the rules are as they are and it cannot be taken for granted that the same milestones by the same people will receive multiple rewards.
2024-06-23 03:06 gav: > having some guidelines on what performance (%) is acceptable below the top implementation would be useful

One quite likely possibility is that likely performance requirements will be set at the lower of 80% of the most performant implementation and the third-most performant implementation. It will almost certainly need to be relative to the performance of the actual implementations. Another possibility would be to be just 90% of the 3rd most performant impl. [edited]
2024-06-23 03:11 gav: Indeed, performance bottlenecks will almost certainly be database (which is designed to be held entirely in-memory anyway), PVM (designed for recompilation) and crypto/EC (designed to allow SIMD and aggregation, and for which FFI/external libraries are acceptable). Actual on-chain business logic is pretty minimal. [edited]
2024-06-23 03:17 gav: It would be up to the team to figure out how to make the performance criteria happen. For example, a JVM-based language would probably have to do the same trick as native-built language and recompile PVM to native machine language and execute natively somehow, rather than doing the naive, fully-compatible thing and recompiling into JVM.
2024-06-23 06:46 sergei_astapov: Hi all,

In graypaper pg 8,9

```
(18) Œ≤‚Ä≤ ‚â∫ (H,EG,Œ≤‚Ä†,C)
(28) (..., C) ‚â∫ (EA,œÅ‚Ä≤,Œ¥‚Ä†,œá,Œπ,œÜ)
```

I'm unable to determine what 'C' really stands for.
Please correct me if I'm mistaken, but it seems there is no definition for C in GP.
Thank you! [edited]
2024-06-23 06:47 gav: It‚Äôs the beefy commitment set. 
2024-06-23 06:47 gav: It should be mentioned in the definitions section. 
2024-06-23 06:48 gav: It‚Äôs defined at the end of the accumulation definitions. 
2024-06-23 06:48 gav: Section 14 iirc. 
2024-06-23 15:13 sourabhniyogi: For our travel budget/life, I would very much like to see the implementer's hackathon/get-together at Devcon 7 https://devcon.org/en/ in November \[like 2 days before then, the 4 days during, and then maybe 2 days after with a bunch of JAM how-is-this-really-working nitty gritty\] -- is this possible to get on a calendar?  If you mean to have a get-together earlier than that, can you let us know so we can plan our travel life/budget accordingly?

I'd like to believe around 4+ teams can get Milestone 1 in "local tests passed!" shape before this get-together and have like "hey, lets see if we can network 4 different implementations together for real" sort of hacking happening there, and get ssh-login concrete about whatever private access to standard hardware / JAM TOASTER will mean.  Then we can all feel pretty good about getting Milestone 2 by Q1 2025 and finishing Milestone 1 by the end of the year.  What do you think? [edited]
2024-06-24 02:39 gav: This seems like a good target timeline.
2024-06-24 04:11 xlchen: I created some diagrams, will love a review https://hackmd.io/0gSmXyElT2iKawymS5jJKw?view
2024-06-24 04:30 sourabhniyogi: This is super helpful (and keeps us all grounded, thank you!).  Did we miss a lecture on the Asset Hub <=> JAM connection, or is this your idea on how to keep us grounded?   I was wondering what happened to this sketch/intuition:
 https://github.com/polkadot-fellows/RFCs/blob/gav-coreplay/text/coreplay.md#scaling-a-common-use-case

  ‚Ü≥ 2024-06-24 04:34 xlchen: The AssetHub part is not part of GP (so does the parachain service) but it is how I image it will be integrated and don't really see other possibilities
2024-06-24 05:32 gav: > <@xlchen:matrix.org> I created some diagrams, will love a review https://hackmd.io/0gSmXyElT2iKawymS5jJKw?view

Looks pretty accurate.  
2024-06-24 05:33 gav: I‚Äôd generally try to avoid RPC in Jam completely, and just try to push the use of one or more Smoldot-style light clients. 
2024-06-24 05:34 gav: At present there‚Äôs no prize allocated to specifically light clients, but I do expect to incentivise their creation in due course.
2024-06-24 05:41 xlchen: Users don't really need to access the JAM chain anyway so I can image we only need some RPC for operators/developers
2024-06-24 05:50 gav: Yes if it‚Äôs just about providing an FFI and if they are generally wanting to run a full node then fair enough. But a full node is not trivial to run - every 6-second block is projected to have ~3.5 seconds of PVM computing in it plus a large amount of signature verification and memory access for the DB. The blocks are big: maybe 17 MB every 6 seconds. For work package building nodes I‚Äôm not sure they‚Äôd necessarily want to be running a full node.  [edited]
2024-06-24 05:52 gav: Some will need the raw state read throughout. Many won‚Äôt: parachain collators for example probably only need to read 1 or 2 KB per block which could easily be managed by a light client and really doesn‚Äôt make sense to run a full node over.  [edited]
2024-06-24 05:53 gav: And we *really* don‚Äôt want them connecting to some random shared RPC for it.  [edited]
2024-06-24 06:00 xlchen: we could have a flag to disable most of the signature verifications and skip some other checks and only rely on grandpa/beefy instead and it will be lightweight enough for many use cases? but yeah I can totally see that majority of the nodes are light node and not much need to have rpc node/full node
2024-06-24 06:02 gav: Well you‚Äôd still need to be running 3.5s of PVM, 1M db iops and downloading 17MB every 6 seconds. 
2024-06-24 06:02 gav: Even if you skipped all the signature checks. 
2024-06-24 06:06 xlchen: right. so we still need a proper light client and some protocol for the light client to communicate with full node
2024-06-24 06:07 gav: Indeed; thankfully much of the work is already done with Smoldot. 
2024-06-24 10:57 purpletentacle: > 13. A clear Git history and public, credibly timestamped commits are necessary in order to help evidence organic code development by the team/s.

> 14. Timestamps may be by virtue of pushing code to GitHub on a timely basis.

> 15. For code developed in private, commit hashes should be placed, in a timely fashion, on a major public blockchain and readily visible on a block explorer.

Just to avoid any kind of future misunderstanding about this.

IF the project is done in GitHub, the requirement for pushing hashes into a blockchain is not necessary? Or for that to be fine, the github project needs to be made public and posted here? 
Or actually to be on the safe side, every project is expected to publish commit hashes to a blockchain every N days? [edited]
2024-06-24 13:17 gav: Fellowship will be looking for evidence that the team coded the software themselves from the GP. That it‚Äôs not a port or AI adjusted version of some other team‚Äôs software. To this extent it‚Äôs important for the teams to demonstrate an organic development process. Regular, sensibly-sized commits are one way of doing this and we assume GitHub is reasonably corruption-resistant (git alone obviously isn‚Äôt). But if you don‚Äôt want to use GitHub then make sure you credibly timestamp the commits elsewhere such as on a public blockchain.  [edited]
2024-06-24 13:18 gav: If you dump a codebase at the doorstep of the Fellowship with no way of proving that you actually coded it yourself then you run a risk of getting no prize.
2024-06-24 13:18 gav: This becomes especially important in the age of generative AI. 
2024-06-24 19:43 danicuki: I was wondering what programming language could result in the best performing implementation of JAM. 

If JAM is a CPU bound system, probably C, C++ or Rust could give me the best performance
If JAM is a I/O bound system, a language with more concurrent capabilities would be better. 

Which one would be the case? 

I am an enthusiast of Elixir, a very powerful language for concurring systems. I feel it could have a very elegant and yet performatic version of JAM 
2024-06-25 02:52 gav: Difficult to say at this stage though I can't see how there'd be any way around having PVM be recompiled into native and good optimised algorithms for EC and crypto, however these are very discrete components and with the latter two could reasonably be imported in. [edited]
2024-06-25 06:40 gav: @room The first test vectors have been merged into github.com/w3f/jamtestvectors [edited]
2024-06-25 06:41 gav: So far it's Safrole's STF with a couple of PRs open for the Merkle trie and PVM. [edited]
2024-06-25 06:41 gav: We'll work on getting vectors for the rest of the STF in the coming weeks, as well as the baseline crypto and EC. [edited]
2024-06-25 11:21 emielvanderhoek: I am looking forward to the Timeslot‚Äôs STF vectors. üòÜ
2024-06-27 04:56 xlchen: Screenshot 2024-06-27 at 4.56.16‚ÄØPM.png
2024-06-27 04:56 xlchen: Screenshot 2024-06-27 at 4.56.31‚ÄØPM.png
2024-06-27 04:56 xlchen: the order of the keys is different between GP and the test vector
2024-06-27 04:57 xlchen: https://github.com/w3f/jamtestvectors/blob/fa8699f94b2769cee5d05472072e6a5f839a57ed/safrole/safrole.asn#L35
2024-06-27 05:10 xlchen: looks like the safrole test vectors are encoded using JSON instead of the scale codec described in GP. i.e. a validator data is
```
{
                "ed25519": "0x837ce344bc9defceb0d7de7e9e9925096768b7adb4dad932e532eb6551e0ea02",
                "bandersnatch": "0xf16e5352840afb47e206b5c89f560f2611835855cf2e6ebad1acc9520a72591d",
                "bls": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                "metadata": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            },
```
instead of bunch bytes. Will it be better to offer a variant that's using the raw bytes instead of JSON?
2024-06-27 05:10 xlchen: asking because otherwise 1) we need to implement a JSON serialization function for the types 2) need to ensure the names matching to the tests vector
2024-06-27 05:14 xlchen: and we cannot use the test vectors to test the serialization part
2024-06-27 08:11 gav: > <@xlchen:matrix.org> the order of the keys is different between GP and the test vector

Yes indeed [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)could you fix this?
2024-06-27 08:13 gav: > <@xlchen:matrix.org> looks like the safrole test vectors are encoded using JSON instead of the scale codec described in GP. i.e. a validator data is
> ```
> {
>                 "ed25519": "0x837ce344bc9defceb0d7de7e9e9925096768b7adb4dad932e532eb6551e0ea02",
>                 "bandersnatch": "0xf16e5352840afb47e206b5c89f560f2611835855cf2e6ebad1acc9520a72591d",
>                 "bls": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
>                 "metadata": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
>             },
> ```
> instead of bunch bytes. Will it be better to offer a variant that's using the raw bytes instead of JSON?

Probably yes. I‚Äôm not against having smaller data items separately encoded (as it adds to the readability of the vectors) but in this case our primary definition is the blob, and the individual keys are just equivalence derivatives. 
2024-06-27 08:14 gav: [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)could you fix this also?
2024-06-27 15:51 davxy: Sure. I'll put the fix as part of an upcoming PR where I'll propose the vectors in two flavors: tiny (vals: 6, epoch len: 12) and prod (vals: 1023, epoch len: 600). PR very soon üôÇ
2024-06-27 15:55 davxy: Ah. As you may have noticed, both metadata and bls key are placeholders. Not a big deal BTW, as they are not influencing Safole's STF
2024-06-28 06:47 kianenigma: I am trying to make sure my understanding of the semi-coherence property of JAM is correct. 

My understanding of this property is that parts of the system (i.e. *services*) that need to talk a lot with one another should be close to one another to do so without needing to deal with asynchrony. The most ideal system would then be one in which services can talk synchronously to the services that happen to execute in the same core in that time-slot, and asynchronous with those that are not.  

That being said, I believe I heard in the Singapore Graypaper lecture that the interfaces for services to communicate with one another is always asynchronous. 

If correct, we can then say that services, as the lowest level programming primitive of JAM don't enable synchronous comparability yet, but synchronous composability as described in a semi-coherent system can be built on top of them. 

This is primarily possible because of the core-model, the possibility of flexible scheduling of services in cores, and the PVM's ability to be readily paused and resumed. One example of such system is CorePlay. 

Is that a correct description of where JAM service stand in terms of synchronous composability between one another? 
2024-06-28 06:50 emielvanderhoek: Have recordings of the university lectures been made available, or if not will they be made available? 
  ‚Ü≥ 2024-06-28 06:57 rtti-5220: yes, Key Pictures (creators of Behind the Code) along with The Kusamarian are recording and documenting all talks, and they will be made available after production I believe. [edited]
2024-06-28 07:12 gav: > <@kianenigma:parity.io> I am trying to make sure my understanding of the semi-coherence property of JAM is correct. 
> 
> My understanding of this property is that parts of the system (i.e. *services*) that need to talk a lot with one another should be close to one another to do so without needing to deal with asynchrony. The most ideal system would then be one in which services can talk synchronously to the services that happen to execute in the same core in that time-slot, and asynchronous with those that are not.  
> 
> That being said, I believe I heard in the Singapore Graypaper lecture that the interfaces for services to communicate with one another is always asynchronous. 
> 
> If correct, we can then say that services, as the lowest level programming primitive of JAM don't enable synchronous comparability yet, but synchronous composability as described in a semi-coherent system can be built on top of them. 
> 
> This is primarily possible because of the core-model, the possibility of flexible scheduling of services in cores, and the PVM's ability to be readily paused and resumed. One example of such system is CorePlay. 
> 
> Is that a correct description of where JAM service stand in terms of synchronous composability between one another?

Basically yes. The fact that the cores are stateless and that there's a mostly-coherent shared data lake and a fully-coherent reactor state means that there's no structural decoherence in the same way as with persistently sharded systems like the Polkadot Relay and the present direction of Eth2.
2024-06-28 07:12 gav: You can still build decoherent systems on this (the basic pre-Accords Parachains service will be an example of this). But CorePlay will (hopefully) use this model to create a coherent, performant and highly scalable platform on top.
2024-06-30 15:35 purpletentacle: > looks like the safrole test vectors are encoded using JSON instead of the scale codec described in GP

I think it makes sense to separate concerns correctly.
Otherwise, we will end up almost having something like integration tests... where the only test vector for M1 ends up being a complete block..

Moreover, some of us already implemented the JSON decoder.. because that's the way it was delivered ! ;)
Anyway, this is not a big deal at the moment.. but it would be good to have some stability on the test vectors anyway to avoid too much rework

Having said that... I would prefer if we can keep the JSON ones.. add some for encoding/decoding.. and later on, have complete ones for actual headers and blocks [edited]
2024-06-30 16:26 purpletentacle:  davxy I just saw that you have a PR with both json and scale! that's amazing üöÄ
2024-06-30 18:03 sourabhniyogi: I have been bothered by the following line of questioning for the last couple of months:

- RFC 32 set a "Minimal Relay Chain"  architecture for Polkadot where the functions of relay chain would be "split off" into new system chains: Asset Hub, People, Staking, Core Time, and so forth.  The idea was that the Relay Chain REQUIRED maximal resources for validating parachains, specifically on "accumulate" computations.  In particular, the relay chain should not have anything like contracts-pallets because that would compromise on "accumulate" scalability \[to validate parachains\].  Here is your view circa October 2023:
https://github.com/polkadot-fellows/RFCs/pull/32#discussion\_r1347502727
- But then you put together JAM in the last year (and, this contracts-pallet based on PVM appears to be coming together nicely!).  JAM will have as its first really big JAM Service a Parachain Validation Service (run in-core and on-chain in refine vs accumulate run in PVM byte code), validating system chains and parachains with work items in work packages, judgements, and so on.
- Then, as Polkadot Fellows follow through on RFC 32 AND the JAM Service, there will be, in the limit, nothing left for the old relay chain to do!  It leaves a black hole as baby JAM takes over.
- Question 1: Instead of leaving the relay chain with nothing left to do, why not revert RFC 32's "splitting off" of the relay chain components and just leave some (or all) of it on the relay chain?
- Question 2: In particular, in addition to contracts-pallet being on Asset Hub, can we revisit the old relay chain getting contracts-pallet now that the JAM Parachain Validation Service model is clear?  What are the blockers other than the big one \[of how parachain validation will "switch" from Polkadot Relay Chain to the JAM Parachain Validation Service\]?
- Question 3: If you believe the above is possible, then with a functioning JAM Parachain Validation Service, then what is presently called the "Polkadot relay chain" could become a (well connected) parachain like all others, complete with smart contracts.  Problems like CEX integration to Asset Hub ... disappear, UX improvements to integrate disparate parachains are pushed off to another day while people figure out if some of these "split off" decisions from RFC 32 are better solved within a JAM Service architecture or as a parachain ... or as a smart contract on Polkadot (no longer validating anything) ... or elsewhere.  Can we revert RFC 32 now that JAM is well architected in this way?  If not, why not? [edited]
2024-06-30 23:14 danicuki: I created a YouTube Playlist with the main videos I found about JAM. Open to recommendations of  videos to include.

https://www.youtube.com/playlist?list=PLjGN96vX3BTKjLfBd5LimBuDuch-QfKPy
  ‚Ü≥ 2024-07-01 09:04 tomusdrw: Getting an error that "The playlist does not exist.", could you check the link and/or permissions?
  ‚Ü≥ 2024-07-01 10:42 kianenigma: same
  ‚Ü≥ 2024-07-01 13:19 celadari: same
  ‚Ü≥ 2024-07-01 13:55 wirednkod: Same
  ‚Ü≥ 2024-07-01 15:28 philip.poloczek: Same. üòÖ

Anyways also can recommend the News section on graypaper.com . Although not specifically marked as videos, lot's of the recent entries are videos about JAM from gav.

https://graypaper.com/news/
  ‚Ü≥ 2024-07-01 17:08 danicuki: Sorry, the playlist was private. Now it is public!
  ‚Ü≥ 2024-07-01 17:09 subotic: Thanks, works now üëçÔ∏è
  ‚Ü≥ 2024-07-12 04:48 milawords: > <@danicuki:matrix.org> I created a YouTube Playlist with the main videos I found about JAM. Open to recommendations of  videos to include.
> 
> https://www.youtube.com/playlist?list=PLjGN96vX3BTKjLfBd5LimBuDuch-QfKPy

here is the link to the technical lecture in Singapore, which Jay recently published: https://youtu.be/QS9buJLt5jo?si=5Sh8Qc-teI-dxVJ_
  ‚Ü≥ 2024-07-12 13:36 danicuki: > <@milawords:matrix.org> here is the link to the technical lecture in Singapore, which Jay recently published: https://youtu.be/QS9buJLt5jo?si=5Sh8Qc-teI-dxVJ_

Awesome!!! Just added to the Playlist. Thanks
2024-07-01 08:03 gav: JAM can be considered a follow-on protocol, or upgrade, to ‚ÄúRelay‚Äù.  [edited]
2024-07-01 08:04 gav: Its aim is to be fully backwards compatible. With JAM deployed, the Relay chain would be redundant and have no native currency or economy. Nothing stops validators from hard-forking and continuing to validate on the defunct chain, but they couldn't be paid unless they also forked DOT. And I'm not sure why you'd think this a sensible idea. [edited]
2024-07-01 08:07 gav: JAM is in line with the original proposal of moving extraneous functionality off the central, parachain-STF security chain (currently the Relay chain, to become the JAM chain). Indeed JAM requires this to happen as it cannot accept process transactions. [edited]
2024-07-01 08:08 gav: Polkadot Relay couldn‚Äôt become a ‚Äúwell-connected parachain‚Äù for exactly the same reason that hierarchical parachains are not viable right now.  [edited]
2024-07-02 10:05 darkartistry: 
2024-07-02 14:23 danicuki: Are the PBA JAM lectures already available somewhere? 
2024-07-02 14:25 rtti-5220: danicuki: the recordings are a collab between Key Pictures and The Kus, and after post-production I am sure they will be published for everyone.
2024-07-02 14:25 rtti-5220: but not yet. 
2024-07-04 02:02 xlchen: For the Safrole test vectors, it includes an error code but the value are unspecified and the README said we should ignore those values. This is a bit annoying as we need to do extra work to patch the test vectors to ignore the error code. Can we just exclude it from the test vectors? Or make it always 0. I just want to do a simple equality check
2024-07-04 02:04 xlchen: Also the test vectors repo should come with a test runner as well. As a fellowship member, how can I verify an implementation actually runs the test vectors correctly? We won't have such issue if it includes a test runner and if the tests passed for an implementation, we know for sure it actually passed.
2024-07-04 02:07 xlchen: and if we have a buildin test runner, then it can do the error code handling and it wouldn't be a concern to teams
2024-07-04 09:22 purpletentacle: hi Bryan, we are actually using the error codes and find them useful :( 
about the test runner... would that involve defining APIs for tests? It sounds that it would introduce architectural constraints to implementations at a very early stage. I think these kind of tests should be applicable at an integration level much later..
At the moment, we just add jamvectors as a submodule in our code and treat them as external data for simple unit tests..
2024-07-04 09:24 xlchen: how are you using the error codes? are the meanings defined somewhere? 
2024-07-04 09:25 xlchen: I am not sure what kind of constraints will the API introduces. The most simple way will be require some CLI interface and use stdin/stdout to pipe test cases and results
2024-07-04 09:26 xlchen: all those tests are pure functional
2024-07-04 09:27 purpletentacle: There is a very small amount of tests... so it is easy to link the error code to the failure mode described in the README
```
- [publish-tickets-no-mark-3](publish-tickets-no-mark-3.json)
  - Fail: Re-submit tickets from authority 0.
- [publish-tickets-no-mark-4](publish-tickets-no-mark-4.json)
  - Fail: Submit tickets in bad order.
- [publish-tickets-no-mark-5](publish-tickets-no-mark-5.json)
  - Fail: Submit tickets with bad ring proof.
- [publish-tickets-no-mark-7](publish-tickets-no-mark-7.json)
  - Fail: Submit a ticket while in epoch's tail.
```
2024-07-04 09:28 purpletentacle: and we can match our own error code to that in the test.. at least it is not FAIL = true/false
2024-07-04 09:28 purpletentacle: anyway, different teams can try their own approaches.. of course!
that's the beauty of having "only" the graypaper as a guide.... [edited]
2024-07-04 09:29 xlchen: in that case we should define them. as someone with C++ experience, I am scared of UB
2024-07-04 09:31 purpletentacle: well.. I don't think those have any relation to our code.. or any team's code for that matter.. those are 100% external data.. completely unrelated to implementations.
worst case, they would affect the code in your tests.
If those were to be defined.. they should be defined in the GP, right? which I find unnecessary [edited]
2024-07-04 09:32 xlchen: they can be defined in asn.1 file. there are other util types defined there as well
2024-07-04 09:33 purpletentacle: ok, if by definition you mean the test vectors ASN.1 and restrict that to only the test vectors.. welcome!
I thought you wanted this defined and standardized for all implementations at the GP level. [edited]
2024-07-04 09:36 xlchen: yeah I just want it to be written down explicitly somewhere to have some stability guarantee and reduce guess work that we need to do
2024-07-04 09:36 purpletentacle: about external testing via stdio/stdout.. sounds good! happy to help with it if there is anything to do...
actually having that as a github action would be actually cool... so we can all integrate it in our CI
that way we can keep out own unit tests.. but also everyone can provide a "test cli" to run the "jam vectors action" ..  [edited]
2024-07-04 09:47 gav: Error codes are not going to be defined in GP - way too implementation-specific. They're included in the test vectors as an aid for development only; for the purposes of determining conformance they can be collapsed into just "invalid"; implementations are not expected to be able to match the error code. [edited]
2024-07-04 09:48 gav: davxy: perhaps we should prefix the error-code field with an "\_" or something else to make clear it's not related to conformance? the only thing which should be officially there is that the posterior(s) are undefined due to invalid priors/inputs. [edited]
2024-07-04 10:25 davxy: Well for sure having error codes as an aid of "what went wrong" is useful.
But I agree that it is an implementation detail and it must not go in the GP.
So IMHO a good compromise is to:

1. (As Juan suggested) define the error codes only in the ASN.1 (as a hint to the implementer of why the test fails)
2. (As Gav suggested) make more explicit that the error code field is not related to conformance. Unfortunately `_` can't be used in standard ASN.1 LOL. But I can rename it to something like `application-specific-errno` (with a big warning that this is not specified in the GP). [edited]
2024-07-09 00:13 danicuki: > <@gav:polkadot.io> @room The first test vectors have been merged into github.com/w3f/jamtestvectors

A curiosity: how do you create these test vectors? And how can we be sure or prove they are correct?
2024-07-09 06:22 gav: They‚Äôre created with prototype implementations of the GP. If you think they‚Äôre incorrect, then raise an issue in the repo. 
2024-07-09 06:24 gav: The GP is the canonical definition of JAM. At this point the test vectors are provided as a development aid to teams. 
2024-07-09 06:24 gav: They will eventually mutate into a series of conformance tests for milestones 1 and 2. 
2024-07-09 06:26 gav: You can prove (in)correctness in the usual way. The test vectors are formal and the GP is formal - show that one does (not) follow from the other.
2024-07-09 21:17 kianenigma: I have been working on a blog post explaining JAM in short form and super high level, sharing it here to gather feedback. I have yet to improve the graphics and enhance it with animations, but the content is more or less there. I hope it can also help implementors getting just started. 

I have done my best to explain the content ground-up: each section building on top of the previous one(s), and not making too many unstated assumptions. I particularly hope to receive feedback on this, and how the story of Polkadot 1 -> 2 -> JAM can be better explained. 

https://blog.kianenigma.nl/posts/tech/demystifying-jam/
2024-07-10 12:31 darkartistry: Hi, I think for the part of coherent or non-coherent systems, based on the decision of a Timing Model (Async/Sync) can be better explain with a table break down of the combinations of the Timing Model to the Failure Model and Channel Model. For technical readers. Good read. :) Could also add some information that it is a 5-10 min read. Cause the page looked really long at the start. [edited]
  ‚Ü≥ 2024-07-10 16:51 kianenigma: thanks
Timing Model to the Failure Model and Channel Model
What do yo mean by each, and what does it add to the understanding of the reader? I am not familiar with these myself and happy to add, but it has to have some added value for the reader, or else it is another keyword/terminology that they would have to be familiar with. [edited]
  ‚Ü≥ 2024-07-10 16:52 kianenigma: > Could also add some information that it is a 5-10 min read.

4000 words, around 20mins for an average reader :) and indeed a lot of the page is graphs.
  ‚Ü≥ 2024-07-10 23:50 darkartistry: > <@kianenigma:parity.io> thanks
> 
> > Timing Model to the Failure Model and Channel Model
> 
> What do yo mean by each, and what does it add to the understanding of the reader? I am not familiar with these myself and happy to add, but it has to add a added value for the reader, or else it is another keyword/terminology that they would have to be familiar with. 

There are decisions to be made, and they can be broken down to the combinations of type of the timing model, the type of fault tolerance and the type of agreeable failures of the message channels. I can‚Äôt remember but it was taught in a distributed systems lesson üò¨ü´£ I‚Äôll try to find the lecture notes if I still have them hahahaha 
  ‚Ü≥ 2024-07-10 23:51 darkartistry: I think the decisions that are to be made is what makes it ‚Äúcoherent‚Äù 
  ‚Ü≥ 2024-07-12 04:18 darkartistry: kianenigma: the node types are classified under reliable, crash, * wild card, Byzantine. While the Channel types are Drop messages or reliable.
  ‚Ü≥ 2024-07-12 04:19 darkartistry: thereby the various version of impossibility to solve some scenarios. 
2024-07-10 19:18 sourabhniyogi: Strongly Web3 talk: https://x.com/thewhiterabbitM/status/1811009553565114766
2024-07-12 17:44 dakkk: Hi, I have few question about the JAM Prize Competition:
1. Can I apply as an individual?
2. After I submit the Apply form, should I receive any feedback from the foundation? 
3. How can I know that I'm the only one working on a specific language?
4. How milestones works? After my software reaches a milestone what I'll have to do?
2024-07-12 18:31 gav: 1. The application is unimportant as far as the prize is concerned. The prize is for software. There‚Äôs no restrictions on the team behind it. 
2. No idea about this form. As I say, it‚Äôs unimportant for the prize. 
3. You can‚Äôt. But it doesn‚Äôt matter because teams need not implement in a unique language. 
4. Just publish the milestone and notify here. The Polkadot Fellows will take a look. 
2024-07-14 05:09 proxy720: Hi all! I have a question related to the one in the one above:
- Since I'm very good with niche functional languages, I'm considering entering the competition with Haskell, Elixir, OCaml, F# or Scala.
- Is it preferable to aim for the language that is more rare (the first 3), has some specific advantage over the others (Elixir)?
- There is a restriction that a team can only enter with a single language, but can one person be part of multiple teams?
2024-07-14 05:14 proxy720: - Also, I'm considering implementing only a PVM interpreter/evaluator in Coq, which would allow formal verifications for pvm programs (smart contracts). Is there a prize for something like this?
2024-07-14 07:05 gav: Rarer languages are probably going to be in the less-likely language sets (C and especially D) and thus more likely to have the full prize pot available by the time of Jam‚Äôs launch. 
2024-07-14 07:06 gav: Implementations are assumed to be clean room. If someone works on two different ones then obviously that‚Äôs no longer the case. 
2024-07-14 07:09 gav: Basically all members of the team must adhere to the rules as if they were the only one. 
2024-07-14 07:09 gav: > <@proxy720:matrix.org> - Also, I'm considering implementing only a PVM interpreter/evaluator in Coq, which would allow formal verifications for pvm programs (smart contracts). Is there a prize for something like this?

No
2024-07-15 08:55 masapr: It's hard for me to estimate the effort to get to milestone 1. to get a better feeling for this: @gav if you had to implement milestone 1 by yourself in Rust, can you tell us how many hours you would expect to have on this? 
2024-07-15 08:57 gav: Lol.
2024-07-15 08:58 gav: I really wouldn't base any of your projections on my productivity.
2024-07-15 09:16 masapr: Well, it's just a big risk to put a team on an unknown amount of work with unknown payment. If I know your estimate, I can draw my own conclusions on how that relates to our own productivity. ... Of course, we would have quite some additional effort understanding the graypaper in detail. But it would give some indication on the actual implementation effort. I understand, if you don't want to give a number. Just thought I'd ask. It would help me to know, if I should go further with this or stop right here ... 
2024-07-15 09:18 gav: The spec is published and aims to be unambiguous. For milestone 1, I think it's pretty much there, too. [edited]
2024-07-15 09:18 gav: I see little risk beyond your own expertise.
2024-07-15 09:19 gav: I suggest you look at the JAM Prize as a *prize*, not a corporate SLA.
2024-07-15 09:25 gav: For what it's worth, while pre-existing companies are 100% welcome to code up JAM and claim the prize, the structure of the prize (along with Fellowship membership and support structures) is aimed more at individuals and small unincorporated teams: Those who believe themselves capable of bringing the Graypaper to life and don't mind taking a risk on their time and talent. If you're looking for a low risk way of getting a monthly income on some blockchain engineering, it may not be the most appropriate opportunity. [edited]
2024-07-15 09:34 masapr: Fair enough. Either way, it is an investment. Also for individuals. So, it does make sense to calculate an estimate of the costs. Anyone has to do that, really. Thanks for the feedback, though. It does give me an idea.
2024-07-15 09:35 xlchen: if you just want a number, I will say 3 to 6 months
2024-07-15 09:36 masapr: > <@xlchen:matrix.org> if you just want a number, I will say 3 to 6 months

for 1 person?
2024-07-15 09:38 xlchen: yes. M1 is relatively easy when all the test vectors are out (which currently only Safrole is released and few others are WIP) as you can use the test cases to help understand GP
2024-07-15 09:38 xlchen: and it is pure functional without performance requirement 
2024-07-15 09:39 masapr: Bryan Chen | Laminar & Acala: Thank you :-)
2024-07-15 10:25 gav: > <@masapr:matrix.org> Fair enough. Either way, it is an investment. Also for individuals. So, it does make sense to calculate an estimate of the costs. Anyone has to do that, really. Thanks for the feedback, though. It does give me an idea.

I'd disagree wholeheartedly with any assertion that established businesses are anywhere near as capable of the agility, insight or risk-propensity as individuals.
2024-07-15 10:25 gav: But it's rather OT.
2024-07-15 10:26 gav: > <@masapr:matrix.org> Bryan Chen | Laminar & Acala: Thank you :-)

Lol. One person who should be no more capable of reading and assessing the GP that you or your team says casually "3 to 6 months" and somehow you think it's helpful?
2024-07-15 10:27 gav: Perhaps it might be sensible to read and understand the specification *you* want to implement (enough to make a rough estimate of how long you think it might take *you* to implement, anyway) before considering the case closed.
2024-07-15 10:28 gav: I'll put it another way: if you cannot get far enough through the paper to understand how much effort it might take you or your team to implement, perhaps that's not a great sign for things to come? Basing your predictions not on the specification of what you'd have to implement or you/your team's skills, talents and background but rather on the casual opinion of a single self-selected member of the public seems like an extraordinarily ill-considered approach. [edited]
  ‚Ü≥ 2024-07-15 10:34 darkartistry: That was what was on my mind. I think the requirement is to at least first get through the paper before deciding to implement. This will be the first time I attempt to write a client from scratch. Any tips are very much welcome. :)  [edited]
2024-07-15 10:56 gav: Perhaps one point which could be clearer is the purpose of the JAM-prize: the W3F is not handing $60m+ out specifically in order to get lots of redundant code into the ecosystem. The reason for such a large prize fund is to help create a lot of experts on the protocol. Experts who understand, *inside-out*, both the strict protocol _and_ the numerous factors in creating a viable implementation. The prizes denominated in DOT, Fellowship membership and other long-term benefits and support are all there to help incentivise those experts to stick around for the long-haul whether to continue improving their implementations, to help evolve the protocol or to build atop of it. In pursuit of this, we'll take a rather sink-or-swim tactic with teams: beyond corrections and clarifications to the GP, we'll be offering no great help along the way and will expect teams to solve their own problems in their own way. It's not the fastest way of getting from A to B, but this forges a rare asset: the kind of expertise you get from innovators learning through first-principles. Furthermore, it also helps ensure an intellectually diverse ecosystem less constrained by the biases and design-decisions of a single engineering team, leading to a more resilient engineering ecosystem. [edited]
2024-07-15 11:00 gav: They say there are no Dumb Questions. Perhaps. But there are certainly Lazy Questions. If any come my way I'll mark them `LQ` and  move on. Be warned :P [edited]
2024-07-15 11:04 masapr: I'm sorry, I really didn't want to upset you. Yes, it certainly was a lazy question. But I still believe, it's a fair question. These things are hard to estimate and it's not dumb to ask the expert.
2024-07-15 11:04 gav: The point is to make *you* the expert :)
2024-07-15 11:04 gav: Without that expertise, you may find the prize difficult to collect: it's certainly the intention.
2024-07-15 11:07 prematurata: Hello, I submitted the application form for section C, specifically JavaScript. Is JavaScript vanilla required or can the code be developed in something more robust like TypeScript which is a superset of JS?
2024-07-15 11:07 gav: Major dialects are generally fine. TypeScript certainly. [edited]
2024-07-15 16:02 erkt: I know things like some crypto libs such as the RingVRF are FFI eligible. Are projects that FFI into the PVM eligible as well? Or is every impl expected to implement the PVM? 
2024-07-15 16:32 gav: Every project is expected to implement. However, since M1 and M2 do not have any performance requirements, you can get away with implementing a simple interpreter, which shouldn't take too long (Jan managed to implement it in [less than 24 hours](https://forum.polkadot.network/t/exploring-alternatives-to-wasm-for-smart-contracts/2434)). [edited]
  ‚Ü≥ 2024-07-15 16:35 erkt: ack. thanks for the reply 
  ‚Ü≥ 2024-07-15 16:37 gav: For M3 and M4 it'll likely need more substantial work (though the post above indicates that Jan implemented a JIT RISCV-x86 recompiler in 2 days...)
2024-07-16 09:54 dylanverstraete: Hi everyone, is there a team working on an implementation in Go? I could help out. Otherwise, who wants to start a team?
  ‚Ü≥ 2024-07-16 17:10 timwu20: We the Gossamer team from ChainSafe are working on an implementation in Go
2024-07-16 10:03 darkartistry: > <@dylanverstraete:matrix.org> Hi everyone, is there a team working on an implementation in Go? I could help out. Otherwise, who wants to start a team?

Hi I‚Äôd like to work in a team. Have you read the paper ? 
2024-07-16 12:35 oliver.tale-yazdi: I create this page so that teams can be peripherally aware of each other's existence: https://jamcha.in/clients  
It should help to discover under/over-saturated language(sets) to better spread out our efforts. It is an unofficial page though, so its not at all required üòÑ [edited]
  ‚Ü≥ 2024-07-16 13:09 darentuzi: thanks for creating this, very helpful, submited our project
  ‚Ü≥ 2024-07-16 13:28 subotic: Oliver Tale-Yazdi: thank you very much! We jam4s also just submitted our project. [edited]
2024-07-16 12:46 darentuzi: > <@dylanverstraete:matrix.org> Hi everyone, is there a team working on an implementation in Go? I could help out. Otherwise, who wants to start a team?

yeah we have a team of 5 working on it right now
2024-07-16 12:48 dylanverstraete: > <@darentuzi:matrix.org> yeah we have a team of 5 working on it right now

Alright good to hear, good luck!
2024-07-16 12:54 dakkk: > <@oliver.tale-yazdi:parity.io> I create this page so that teams can be peripherally aware of each other's existence: https://jamcha.in/clients  
> It should help to discover under/over-saturated language(sets) to better spread out our efforts. It is an unofficial page though, so its not at all required üòÑ

cool; I submitted mine
2024-07-16 15:00 ainhoa_a: same, submitted too, Jam jammy, thanks for the initiative!
2024-07-16 16:01 eclesiomelo: 
2024-07-16 16:03 eclesiomelo: hello everyone! I've started a zig implementation of scale-codec thinking in expand the implementation possibilities, the decoding is not fully implemented tho. Would be nice if fellow zig coders could take a look and provide feedbacks :) here's the repo https://github.com/EclesioMeloJunior/zig-scale-codec
  ‚Ü≥ 2024-07-16 17:21 oliver.tale-yazdi: I'm a Zig noob, so my code is probably not good, but for whats its worth: https://github.com/ggwpez/zcale  
Either way, if you use it for JAM then maybe not look too closely as to not influence your implementation üòÖ
  ‚Ü≥ 2024-07-16 17:25 eclesiomelo: nice!! yeah, I don't have a plan to write a client in zig atm, just supporting the zig scale codec lib would be great
2024-07-16 17:23 sourabhniyogi: Devcon 7 https://tickets.devcon.org/ went on sale  (Nov 12-15th) today -- It would be awesome to have a "JAM0" weeklong hackathon (like 9th-17th) at some venue for teams to try to pass Milestone 1 together and (with some luck) have us all trying to get our QUIC networking working with each other, fill in our knowledge gaps, have clear todos for Milestone 2.   If this is reasonable, how can people get their travel (and $599 Devcon ticket) reimbursed to such an event?  

Should this event be OpenGov or W3F funded?  What would be some good criteria to get people a $2K voucher to attend?
  ‚Ü≥ 2024-07-16 17:35 tomusdrw: ‚ùå clean room?
  ‚Ü≥ 2024-07-16 17:39 sourabhniyogi: Surely we can connect different implementations together and go through details of networking/... without sharing code and "colluding".  It appears most people are doing closed source to make "clean room" the default.  I don't see why we can't have GP discussions on a dry erase board esp for implementation interoperability
  ‚Ü≥ 2024-07-16 18:13 gav: Cooperation between teams is essential but anything which goes beyond trivial misunderstandings of the graypaper should be documented, either as issues in the GP repo or as side notes of the implementation to be submitted at the time of Fellowship review. Teams should stay away from implementation specifics and definitely not be sharing code. [edited]
  ‚Ü≥ 2024-07-16 18:15 gav: It's ok to ruminate on high level approaches to solve problems or optimize, it's not so ok to be looking at some other implementation's specific solution. 
  ‚Ü≥ 2024-07-16 18:16 gav: What the Fellowship will be looking out for is for undeclared collusion between teams. Code which appears to be a little too similar for it to have been independently written. A big red flag would be the same bug popping up in two implementations.
  ‚Ü≥ 2024-07-16 18:17 gav: But this is not to detract from the fun of getting two cleanroom impls talking to each other. Of course this is a big part of it and you mustn't feel like it's not allowed.
  ‚Ü≥ 2024-07-16 18:17 gav: Just be sure to document anything which you discover alongside another team so everyone can benefit. [edited]
2024-07-16 18:09 gav: W3F will probably not arrange any official Jam presence at Devcon unless it's clear most serious implementors plan to be there anyway. There might be some co-hosting with Sub0, but it‚Äôs TBC. Definitely do want to arrange some sort of seminar conference. Of course you‚Äôre free to go to the treasury yourself.  [edited]
  ‚Ü≥ 2024-07-25 17:21 sourabhniyogi: gav - off grid, slow to respond:  I think we have enough serious implementors

https://polkadot.polkassembly.io/referenda/1024

Should we be clamoring for you to give a Devcon 7 keynote on Cynical vs Optimistic Rollups ala https://x.com/TheKusamarian/status/1816413081523900683 ?   Seems like its silly to ask you to submit a talk proposal (as an OG from Devcon 0) but having the key guys mentioned in GP submit proposals { PVM, Solidity-to-PVM, ELVES, Safrole } would be appropriate, and would seal the deal.   [edited]
  ‚Ü≥ 2024-07-25 17:22 sourabhniyogi: Deadline for submitting talks is July 30, which is also when tickets go on sale. [edited]
2024-07-16 19:47 sourabhniyogi: Is this reasonable? 
 https://polkadot.polkassembly.io/post/2397 
I am not sure how we could objectively know who are "serious implementors" for travel reimbursement, perhaps there is some "Block Importer" test that could be objectively or subjectively applied?   We need some protocol engineers / fellows / W3F, maybe in a 1:10 ratio to implementers for this to fly, I think.   [edited]
2024-07-17 07:41 philip.poloczek: Thanks Olivier, this is a great addition!

I'm the maintainer of the graypaper.com website. In the initial draft of the website we had an `Implementation` section like this in mind. We removed it for the launch as it was just empty.

Would it be fine for you and everyone, if I add it to the graypaper website based on the teams already collected on https://jamcha.in/clients? [edited]
2024-07-17 08:18 ainhoa_a: > <@philip.poloczek:parity.io> Thanks Olivier, this is a great addition!
> 
> I'm the maintainer of the graypaper.com website. In the initial draft of the website we had an `Implementation` section like this in mind. We removed it for the launch as it was just empty.
> 
> Would it be fine for you and everyone, if I add it to the graypaper website based on the teams already collected on https://jamcha.in/clients?

fine for us let us know if we need to submit a PR or if the info on the site is enough 
2024-07-17 10:45 oliver.tale-yazdi: > <@philip.poloczek:parity.io> Thanks Olivier, this is a great addition!
> 
> I'm the maintainer of the graypaper.com website. In the initial draft of the website we had an `Implementation` section like this in mind. We removed it for the launch as it was just empty.
> 
> Would it be fine for you and everyone, if I add it to the graypaper website based on the teams already collected on https://jamcha.in/clients?

yep sounds good, will dm
2024-07-17 13:37 gav: Here's my (unofficial) summary of the prize rules - I'll try to keep it up to date with any questions/answers in here: https://hackmd.io/@polkadot/jamprize
2024-07-17 15:54 philip.poloczek: fyi Oliver and I synced on the already submitted teams/clients for jamcha.in and now share a single source of truth for the data available on both sites:

https://jamcha.in/clients
https://graypaper.com/clients [edited]
2024-07-17 16:05 prematurata: hello, hopefully not a stupid question. about C.1.5 or Bit Sequence Encoding or (278).
variable length sequence. There is no formal definition in the bit sequence encoding so i guess that it's going to be Discriminator Encoding + bitsequenceencoding?
 [edited]
2024-07-17 17:20 gav: > <@prematurata:matrix.org> hello, hopefully not a stupid question. about C.1.5 or Bit Sequence Encoding or (278).
> variable length sequence. There is no formal definition in the bit sequence encoding so i guess that it's going to be Discriminator Encoding + bitsequenceencoding?

are you referring to this?...
2024-07-17 17:20 gav: image.png
2024-07-17 17:20 gav: b is a bit sequence - this formula provides the byte sequence which is the encoding.
2024-07-17 17:37 prematurata: Sorry yes, I am referring to that. It says that in case of variable length sequences, then the length is prefixed  as in the general case. I am not sure what the "general case" is. So I was speculating that in case of variable length, the "discriminator encoding" defined above would need to be used
2024-07-17 17:42 gav: Yeah, that sentence is a bit superfluous. 
2024-07-17 17:43 gav: There are no variable length sequences afair. 
2024-07-17 17:43 gav: And where there are I‚Äôm careful to make an explicit length prefix.  
2024-07-17 17:43 gav: So you can basically ignore it. 
2024-07-19 12:45 asmie: Hello. A quick clarification: We can use third-party libraries for cryptographic primitives, codecs, and networking. Does rule #4 (idiomatic code) apply to the external code or our work only?
2024-07-19 14:57 gav: Your work only. 
2024-07-20 13:58 sourabhniyogi: @room: JAM implementors!  If you would like to have a 4-7 day "JAM0" implementers room @ Devcon 7 (in Bangkok) where you and other serious implementers network your/our implementations together \[while following the official / unofficial Rules\], please comment here: 
  https://polkadot.polkassembly.io/post/2397 
and get listed here:
  https://jamcha.in/clients
A simple comment like this:
https://polkadot.polkassembly.io/post/2397#Zgpa0MJvU0LsDITa5kHe
from 3-4 more serious teams would be sufficient to justify getting an OpenGov-supported venue.   [edited]
2024-07-20 18:06 sisco0: I am interested at joining a C team of Jam. How could I do it? :) Thank you!
I could observe only Rust implementation at https://jamcha.in/clients [edited]
2024-07-21 07:52 gav: > <@sisco0:matrix.org> I am interested at joining a C team of Jam. How could I do it? :) Thank you!
> I could observe only Rust implementation at https://jamcha.in/clients

Perhaps you should start one:)
2024-07-22 14:25 sisco0: Thank you gav , I would set a plan for the current C implementation of Jam.
2024-07-23 12:35 sourabhniyogi: @room: JAM implementors, thank you for showing interest!  We have a quorum of JAM implementors -- I posted this accordingly: 
https://polkadot.polkassembly.io/referenda/1024  

I am coordinating with yaxun@OneBlock on securing a venue (and food arrangements) [see OpenGov Ref 897], hope we can report some good news soon.
2024-07-23 20:34 rmagon: 
2024-07-23 20:36 rmagon: Hello! I'm from the team behind airlyft & we're planning to start a client implementation but wondering what would be the best way forward in terms of the language? My first thoughts were Go, Rust, Typescript but I see we already have some implementations working on those languages. Another option would be C++. In terms of our strengths, these are the languages we feel we can make a difference with. But in terms of the prize pool, does a different language in the same set make a difference? Any suggestions? [edited]
2024-07-23 21:14 rmagon: > <@rmagon:matrix.org> Hello! I'm from the team behind airlyft & we're planning to start a client implementation but wondering what would be the best way forward in terms of the language? My first thoughts were Go, Rust, Typescript but I see we already have some implementations working on those languages. Another option would be C++. In terms of our strengths, these are the languages we feel we can make a difference with. But in terms of the prize pool, does a different language in the same set make a difference? Any suggestions?

Okay, I think I got the answer to my question. It's the Language Set which makes a difference and not the language. Right?
2024-07-25 22:55 gatesma: [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]][[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]][]]]]]]]]]][[]][[]][[][]][[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]][][][[][][][][][][][][][][][][][][][][][][][][][][][][][][][][]=][
2024-07-25 22:55 gatesma: [][][][][][][][]
2024-07-25 23:00 gatesma: sorry, my son is a bit wild on the keyboard.
2024-07-25 23:07 xlchen: oh it is not some private key encoded with brainf*ck?
2024-07-26 13:00 tomusdrw: > <@sourabhniyogi:matrix.org> @room: JAM implementors, thank you for showing interest!  We have a quorum of JAM implementors -- I posted this accordingly: 
> https://polkadot.polkassembly.io/referenda/1024  
> 
> I am coordinating with yaxun@OneBlock on securing a venue (and food arrangements) [see OpenGov Ref 897], hope we can report some good news soon.

Hey! Is there still a chance to join? 3 typeberry developers would be interested to come along as well.
  ‚Ü≥ 2024-07-26 18:17 sourabhniyogi: Glad to have you and everyone in the "serious implementer" category.  There is a  budget of at least $75K which can support ~ 30 people @ $2.5K/person \[$7.5K/team\], which might be exhausted but we're getting venue quotes with others.  I'll build a headcount model for teams on #1024 by July 30 so we know if we're over budget, but I think if we have 40 people we "fix" it in Dec/Jan.  We do need serious people and probably we'll learn the rough boundary between serious and non-serious together at November's Devcon.  Passing all available test vectors or being clear about whatever the bottlenecks are for each team is my idea of "serious".  Hopefully the spirit of getting each other unstuck and having fun while honoring "clean room" rules can be satisfied.   [edited]
2024-07-26 14:08 danicuki: Maybe this is a dumb question, but I decided to ask anyway...
I noticed that most implementers decided to keep their evolution and code private for now (https://github.com/w3f-webops/graypaper-website/blob/main/src/data/clients.json). Why?
  ‚Ü≥ 2024-07-26 14:19 subotic: I guess as a precaution ü§∑‚Äç‚ôÇÔ∏è This is how I have interpreted the "no collusion" part of the rules, i.e., no one can have similar code to ours.
  ‚Ü≥ 2024-07-26 14:20 rmagon: > <@subotic:matrix.org> I guess as a precaution ü§∑‚Äç‚ôÇÔ∏è This is how I have interpreted the "no collusion" part of the rules, i.e., no one can have similar code to ours.

Hmm, yes
  ‚Ü≥ 2024-07-26 14:20 rmagon: I had the same question but did not ask :D
  ‚Ü≥ 2024-07-26 14:21 subotic: but if everyone would be willing to open their codebase and this is ok with Gav and W3F, then we will certainly think about it. [edited]
  ‚Ü≥ 2024-07-26 14:22 subotic: Just my personal opinion.
  ‚Ü≥ 2024-07-26 14:24 danicuki: Initially I thought about leaving our code completely open, but as I saw everyone closing it, I asked myself...
  ‚Ü≥ 2024-07-26 14:26 rmagon: > <@danicuki:matrix.org> Initially I thought about leaving our code completely open, but as I saw everyone closing it, I asked myself...

We started our repo as opensource but then went private because of the same reason. 
  ‚Ü≥ 2024-07-26 14:26 danicuki: I far as I understand we are not competing against each
  ‚Ü≥ 2024-07-26 14:26 danicuki: This is a good Game Theory use case ‚úåÔ∏è
  ‚Ü≥ 2024-07-26 14:27 rmagon: > <@danicuki:matrix.org> This is a good Game Theory use case ‚úåÔ∏è

Haha, yes
  ‚Ü≥ 2024-07-26 14:29 subotic: Well, we are competing with time. As I understood it, after there are 3 good implementations, the race will be over. So not helping other teams can be to ones advantage. On the other hand, the more implementations, the better for the ecosystem. [edited]
  ‚Ü≥ 2024-07-26 15:26 danicuki: > <@subotic:matrix.org> Well, we are competing with time. As I understood it, after there are 3 good implementations, the race will be over. So not helping other teams can be to ones advantage. On the other hand, the more implementations, the better for the ecosystem.

I don't have the understanding that after 3 good implementations the race is over. Where did you see this?
  ‚Ü≥ 2024-07-26 15:26 danicuki: It doesn't make any sense. If there is 10M DOTs in prize, 500k per team, there can be 20 teams to get the prize
  ‚Ü≥ 2024-07-26 15:28 subotic: let me see if I can find it. It was somewhere in this chat. Maybe I misunderstood it (would actually be glad) [edited]
  ‚Ü≥ 2024-07-26 15:29 oliver.tale-yazdi: For us it was a consideration to not have a 3rd party copy our code and apply with it for the prize.
  ‚Ü≥ 2024-07-26 15:38 cisco: We shouldn't be influencing our implementations in any way, so we don't risk having the same bug in two implementations. I don't see why we would want to make the repos open source? Collaborating is a must, but only on the interpretations of the paper, not on code
  ‚Ü≥ 2024-07-26 15:43 rmagon: > <@danicuki:matrix.org> It doesn't make any sense. If there is 10M DOTs in prize, 500k per team, there can be 20 teams to get the prize

Hmm yes, I don't think I read the 3 teams rule anywhere?
  ‚Ü≥ 2024-07-26 15:55 subotic: It wasn't a rule. It was more an indirect conclusion. Maybe I got this whole thing wrong. I cannot find anything in the chat. He spoke about when 1.0 of the GP is published, which will happen once a few teams have managed to get an implementation. But don't quote me on that.
  ‚Ü≥ 2024-07-26 16:05 sourabhniyogi: > <@cisco:parity.io> We shouldn't be influencing our implementations in any way, so we don't risk having the same bug in two implementations. I don't see why we would want to make the repos open source? Collaborating is a must, but only on the interpretations of the paper, not on code

See FAQ "Clean room?" here
https://hackmd.io/@polkadot/jamprize

"A: Cooperation between teams is essential but anything which goes beyond trivial misunderstandings of the graypaper should be documented, either as issues in the GP repo or as side notes of the implementation to be submitted at the time of milestone review. To stay safe, teams should stay away from the implementation specifics of other implementations and definitely not be sharing code.
It's ok to ruminate on high level approaches to solve problems or optimize, it's not so ok to be looking at some other implementation's specific solution.
What the Fellowship will be looking out for is for undeclared collusion between teams. Code which appears to be a little too similar for it to have been independently written. A big red flag would be the same bug popping up in two implementations.
But this is not to detract from the fun of getting two cleanroom impls talking to each other. Of course this is a big part of it and you mustn't feel like it's not allowed.
Just be sure to document anything which you discover when working alongside another team so everyone can benefit."
  ‚Ü≥ 2024-07-26 16:23 danicuki: Now I get the full picture. Sharing code is not a problem itself, but looking at other's code is. Then, no one shares code so no one is able to copy code. 
2024-07-26 14:19 rmagon: I had the same question, tbh but did not ask :D
I'm guessing it's due to the clean room principles ? [edited]
2024-07-26 17:18 gav: I have previously proposed that the Polkadot JAM chain should not be launched until there are at least 3 implementations which perform adequately for mainnet (ie pass Milestone 5). This doesn‚Äôt affect the prize in any way. 
2024-07-26 21:50 sourabhniyogi: For Rule 19 - "Prizes are paid no earlier than the ratification by the Polkadot Fellowship of version 1.0 of the JAM protocol. Payment of the prize by the Web3.0 Foundation is conditional upon the successful completion of all KYC/AML processes." -- what are the preconditions that need be satisfied for you (or the Fellowship)  to decide to ratify version 1.0 of the JAM protocol?

Could version 1.0 of the JAM protocol be ratified with 0 teams passing Milestone 1 -- where ratification is _just_ about the GP?
Would a single implementation team passing Milestone 1 or 2 or 3 be sufficient to trigger 1.0 ratification? If so, which milestone?
Would a N implementation teams passing Milestone 1 or 2 or 3 be sufficient to trigger 1.0 ratification? If so, for what N and what milestone?

2024-07-27 14:09 gav: > <@sourabhniyogi:matrix.org> For Rule 19 - "Prizes are paid no earlier than the ratification by the Polkadot Fellowship of version 1.0 of the JAM protocol. Payment of the prize by the Web3.0 Foundation is conditional upon the successful completion of all KYC/AML processes." -- what are the preconditions that need be satisfied for you (or the Fellowship)  to decide to ratify version 1.0 of the JAM protocol?
> 
> Could version 1.0 of the JAM protocol be ratified with 0 teams passing Milestone 1 -- where ratification is _just_ about the GP?
> Would a single implementation team passing Milestone 1 or 2 or 3 be sufficient to trigger 1.0 ratification? If so, which milestone?
> Would a N implementation teams passing Milestone 1 or 2 or 3 be sufficient to trigger 1.0 ratification? If so, for what N and what milestone?
> 

The preconditions are not stated and it is the Fellowship‚Äôs decision to ratify the protocol specification when it believes it ready.
2024-07-27 14:09 gav: Realistically, it will need to be stable, useful, capable of hosting a service compatible with the relay chain and secure. The latter point will imply an external audit. 
2024-07-27 14:11 gav: However that‚Äôs just a rough guide. The Fellowship‚Äôs decision is final (notwithstanding Root-level governance, of course). 
2024-07-27 14:58 sourabhniyogi: Is the Fellowship ratification of the protocol specification just about ratifying written specifications of
(a) GP alone
(b) GP + JAMSNP
(c) GP + JAMSNP + documentation of how the service compatible with the relay chain will work
or
(d) something else ?
Is the external audit about GP + \_\_\_ written specifications (one of (a)-(d)) or about an implementation?

A serious concern is that serious implementers may (very likely) pass Milestone 1 + 2 + ..  in early 2025 handily, but, because of unknown ratification timing they aren't winning prizes for their Milestone 1 + 2 + .. until an external audit that would only be completed in late 2025 _or later_.  If this is a valid concern, then we may have teams only working on this as a hobby to part-time (\< 20%), and slowing down bringing JAM into the world.  Obviously, JAM teams would like prizes paid out when Milestone 1 is completed, when Milestone 2 is completed, ... -- and not be faced with some unstated preconditions of Rule 19.  Is there any route to get teams working on JAM implementations full-time, fully incentivized to bring JAM into the world? [edited]
2024-07-27 15:12 gav: The JAM Prize a prize, not a service agreement.  [edited]
2024-07-27 15:12 gav: Approaching this as a service agreement is going to result in unrealistic expectations. 
  ‚Ü≥ 2024-07-28 16:07 sourabhniyogi: gav - off grid, slow to respond: 
Can you let me know what you think of this JAM Accelerator Bounty idea:
https://docs.google.com/document/d/1nKGi9UzWca0gIugW8UYfIrY\_uVLKVVC8FydLIHwjpWY/edit
 [edited]
  ‚Ü≥ 2024-07-28 16:23 gav: > <@sourabhniyogi:matrix.org> gav - off grid, slow to respond: 
> Can you let me know what you think of this JAM Accelerator Bounty idea:
> https://docs.google.com/document/d/1nKGi9UzWca0gIugW8UYfIrY\_uVLKVVC8FydLIHwjpWY/edit
> 

I think such a bounty would be too generous. W3F have had bad experiences with client-development SLAs in the past. One good element of the prize is to help weed out the mercenaries from the missionaries; we would not especially want to attract those who would refuse to take a risk on Polkadot and its development timeline: indeed we would active want to have people who have skin-in-the-game in this regard. 
  ‚Ü≥ 2024-07-28 19:05 sourabhniyogi: Both this child bounty approach and the JAM prize are driven by the same basic bounty criteria, except with unfinalized networking added (bar raised) and accepting an unratified evolving GP spec (bar lowered).     There is no "service agreement" implied after the JAM prize nor after any child bounty to continue to support the implementation, but you can certainly expect to see the entities receiving the child bounties to continue into the JAM prize because its literally 3x higher.  You could add a rule to ensure that  any payments from OpenGov could be subtracted.  Seems fairer to me to add now rather than at the end.   But what makes the "SLA" label appropriate?

I gather the underlying "SLA" expectation is that if you receive 500K DOT after having spent 2 years building something for a prize that doesn't have any SLA after it, the team will endeavor to spend many more years after as if there was an SLA.  Is that it? [edited]
  ‚Ü≥ 2024-07-29 02:32 sourabhniyogi: If mercenaries are valued at $0, this is about the cost¬†to get a JAM protocol missionary.

I conjecture that the 500K DOT bounty gets AT MINIMUM 3 missionaries + 3 mercenaries completing M3 by Q2 2025, where 4 of them get compensated.¬† If you believe that 100% of teams with a Fellow are missionary teams, then there are 3 missionary teams already.

I actually conjecture that it is far more likely that there are 5 missionaries and 2 mercenaries that get compensated with this bounty, all of whom continue on to earn some JAM Prize.¬† The cost to get a JAM protocol missionary: 100K DOT (500K/5 missionaries).

With the JAM Prize alone, I conjecture you get 10 missionaries and 10 mercenaries.¬† The cost to get each missionary, if all 10MM DOT are actually exhausted, is 1MM DOT/missionary.

With both in place, you get 5 more missionaries.¬† The cost is 10.5MM DOT/10 = 1.05MM DOT/missionary.  If you deduct any OpenGov received amounts from Prize winnings, its less than that.  So the additional cost is just the number of mercenaries funded by the bounty.  Do we have a mercenary detector mechanism to minimize this cost?

If you think you get 20 missionaries and 0 mercenaries, you'll be at 500K DOT/missionary with the JAM prize alone.  For a cost conscious missionary buyer, where does that leave the generosity?

I see so little difference between paying 1MM DOT/missionary vs 1.05MM DOT/missionary that the "generosity" is pretty clearly on the JAM Prize side.¬† 5% is noise of the week.¬†¬† I'm happy as a lark to see so many teams implementing this month, now I just want to see acceleration because the ideas are all done.

This price of accelerating JAM execution, the 4th generation blockchain architecture, is probably the absolute best use of OpenGov resources I know of.

You can suggest curator requirements (e.g there must be at least 3 teams with a fellow on them) to increase the probability that we get the cost per missionary even lower than 100K DOT/missionary, but this accelerant is only intended to get JAM execution in a better state in early to mid-2025 than without it.  That's the basic analysis. [edited]
2024-07-27 15:14 gav: Fellowship ratification of the JAM protocol would be on the JAM protocol definition which is the Gray Paper.
2024-07-27 15:17 gav: The GP will include JAMNP. 
2024-07-27 15:17 gav: This is not a priority at present since it is not required for M1. Furthermore it is the only part of the protocol which is heavily reliant on practical concerns which cannot easily be modelled. It will likely be the very last protocol element to be finalized.  [edited]
2024-07-27 15:18 gav: The JAM protocol is independent of any implementation. 
2024-07-27 15:19 gav: Most of these answers are plainly obvious. Please note that further questions with obvious answers may elicit a more blunt response.  [edited]
2024-07-27 15:56 sourabhniyogi: Thank you for clarifying, everything is now more obvious =)
2024-07-27 16:39 tebdev: > <@philip.poloczek:parity.io> Thanks Olivier, this is a great addition!
> 
> I'm the maintainer of the graypaper.com website. In the initial draft of the website we had an `Implementation` section like this in mind. We removed it for the launch as it was just empty.
> 
> Would it be fine for you and everyone, if I add it to the graypaper website based on the teams already collected on https://jamcha.in/clients?

Client diversity got my attention. I used this at NASA, etc. impressed it being considered for JAM. Bravo
2024-07-28 16:24 gav: Furthermore, canonical M1 test vectors will not be available before 1.0 is ratified. 
2024-07-28 16:25 gav: Fellowship is the basis of technical expertise in Polkadot and should generally be relied upon for judgements of a protocol/technical nature. 
2024-07-28 16:27 gav: You quoted me from this room and followed it with: ‚ÄúIn particular, SCALE-encoding details are likely to change and as such, teams should design to have networking protocol versioning within it for efficient reasoning‚Äù. 
2024-07-28 16:28 gav: I did not say this nor did I say anything to this meaning. 
2024-07-28 16:28 gav: It is not my expectation that the underlying method for serialization/encoding will change and I would urge to refrain from writing such misleading phrases.  [edited]
2024-07-28 16:29 sourabhniyogi: Removed, is there anything else misleading?
2024-07-28 16:29 gav: Perhaps *you* should read it. I am not your fact-checker. 
2024-07-28 16:49 sourabhniyogi: On networking, https://hackmd.io/@polkadot/jamsnp 
is all we have right now, its very new and fresh since you only posted it at the start of this month =).  I cannot guess the difference betweeen JAMSNP, JAMNP-S, or JAMNP -- - is there a difference?  Its definitely not obvious with a lot of TBDs.  If you say the networking will be the one of the last things to be finalized, we understand.    

On *canonical M1*  test vectors, is this a different set than what you referred to on June 3: "Block execution vectors should be ~6 weeks out.  Availability system test vectors probably about the same timeline."  The existence of these test vectors, even in draft PR form, are highly valuable accelerants for M1/M2 well well in advance of 1.0 ratification.

But given how well described the GP is, implementers can fill in many details of block import vectors + JAM network details, some/most of which are easy to infer from the GP alone.  The more complete the test vectors are, and closer to the "prize" requirements, the better, but I understand pestering won't help. We imagine honest test vectors can come from the implementers themselves as well, however not canonical.   

Some of the leading teams have fellowship talent within their ranks, and we understand its a side goal to develop fellowship talent through increased JAM protocol expertise.  Earning your rank could be done through this kind of contribution. [edited]
2024-07-28 17:09 emielvanderhoek: If you ask me more/alternate funding in addition to the prize leads to poor incentives and attracts the wrong people. Also cringe: ‚Äúserious implementers‚Äù. [edited]
  ‚Ü≥ 2024-07-28 18:33 sourabhniyogi: I removed the word "serious".  I also find it problematic but the substance of the issue is what the difference is between "mercenaries" and "missionaries".  The JAM protocol needs to limit the number of long-term mercenaries,  not limit the number of people who cringe at words.  This is not playschool =).   Some short-term mercenaries can become long-term missionaries. [edited]
2024-07-28 17:38 sourabhniyogi: The notion of "serious implementers" comes from "W3F will probably not arrange any official Jam presence at Devcon unless it's clear most serious implementors plan to be there anyway."   Perhaps that will make some people cringe, but the notion of what constitutes "serious" is  difficult to discern from observing https://jamcha.in/ right now.  I gather it is "you will stick around after completing M5 and claiming the prize, and become a valued fellowship member" like a missionary instead of "We will leave after claiming X milestone bounty" like a mercenary.  Can anyone spot the mercenaries in  https://jamcha.in/ now without  ever having interacted with them? 

The mercenaries within the JAM implementer set are those that are just like "what do we have to do to pass Milestone X and get Milestone X prize money (or bounty)".  The missionaries  want to build the whole thing, are curious as to how and why it works, and will want to improve it/attack it/...    Interviewers can often detect the difference.  Unfortunately, its hard for bounty curators, JAM Prize judges or any human to read peoples minds objectively the way you can objectively check whether some implementation does or does not pass a test vector.   Every incentive structure will have some type 1 and type 2 "errors", if you can call them "errors".  After all, some "missionaries" will have kids to feed, mortgages to pay off, parents to take care of -- and some "mercenaries" can become "missionaries" after falling in love with the protocol and proving to themselves that they are good at implementing and maintaining it.  Its easy to be black-and-white about it and pretend that this kind of real life doesn't exist.     [edited]
2024-07-28 18:31 emielvanderhoek: Well, call me a purist.
‚ÄúSerious implementers‚Äù is a silly notion period. There‚Äôs only ‚Äúimplementers‚Äù. It is: conformance, performance & security and in that particular order. Some teams will finish first and some teams will finish later.
Any additional incentive structure distorts the objectives of Jam Implementers Prize and unlevels the playing field.
I‚Äôd suggest a new moderation rule for this channel: to disallow any talk about alternate/additional funding for JAM implementation teams (besides the Prize) in this channel.
If we don‚Äôt I fear this channel may become a toxic as some of the other channels.
You can do what you want in the regular governance channels of course.
My 2cts. [edited]
2024-07-28 21:43 emielvanderhoek: ‚ÄúMore money will make JAM arrive sooner.‚Äù: This to me seems like a big MISconception. 
2024-07-29 04:05 xlchen: I am confused about trap vs halt vs panic in PVM. In GP, the trap instruction will exit with the black square, so does the jump to `2^32-2^16` address. To my understanding that is `exit 0`. But in the pvm testvector, trap is panic and the test of the trap instruction will result trap exit status but the `inst_ret_halt` test results `halt`. There is some inconsistency.
https://github.com/w3f/jamtestvectors/blob/a2b18702aac7d15b9f51cd1ffcf0be95f987b2f7/pvm/schema.asn#L53-L55 
2024-07-29 06:49 xlchen: Screenshot 2024-07-29 at 6.49.40‚ÄØPM.png
2024-07-29 06:50 xlchen: this means `jump_ind` could be used to exit the program, but how about the one using `branch`? e.g. `jump`
2024-07-29 06:51 xlchen: Screenshot 2024-07-29 at 6.50.56‚ÄØPM.png
2024-07-29 06:51 xlchen: does it become panic?
2024-07-29 13:24 mkalohood: > <@emielvanderhoek:matrix.org> Well, call me a purist.
> ‚ÄúSerious implementers‚Äù is a silly notion period. There‚Äôs only ‚Äúimplementers‚Äù. It is: conformance, performance & security and in that particular order. Some teams will finish first and some teams will finish later.
> Any additional incentive structure distorts the objectives of Jam Implementers Prize and unlevels the playing field.
> I‚Äôd suggest a new moderation rule for this channel: to disallow any talk about alternate/additional funding for JAM implementation teams (besides the Prize) in this channel.
> If we don‚Äôt I fear this channel may become a toxic as some of the other channels.
> You can do what you want in the regular governance channels of course.
> My 2cts.

It is strange now to consider what is called serious implementers before enough participants. Any good ecosystem is profit-driven, and any project it wants to participate in will consider the input-output ratio, rather than competing in an uncertain competition.
2024-07-29 13:52 tebdev: > <@mkalohood:matrix.org> It is strange now to consider what is called serious implementers before enough participants. Any good ecosystem is profit-driven, and any project it wants to participate in will consider the input-output ratio, rather than competing in an uncertain competition.

 Agreed, "serious" subjective. if anyone contributes to moving the needle; it is a positive contribution and should not be discounted. Incentives is a NASH to accelerate work, but if you "serious" about blockchain being a movement then "one" would encourage participation and teamwork for democratization as the ultimate payoff. Strength in Numbers.
2024-07-29 17:17 tebdev: > <@xlchen:matrix.org> I created some diagrams, will love a review https://hackmd.io/0gSmXyElT2iKawymS5jJKw?view

Very nice. I started late, but this is an equalizer... Bravo
2024-07-30 10:29 gav: As of [PR #52](https://github.com/gavofyork/graypaper/pull/52), `trap` will panic. [edited]
2024-07-30 10:33 gav: > <@gav:polkadot.io> Looks pretty accurate.

Actually, there's one slight (probable) anomaly...
2024-07-30 10:33 gav: > Parachain collator submit work to packager

Probably the collator would be the packager.
2024-07-30 10:34 gav: Theoretically they might not be, but if you make them different you add a further degree of latency into the pipeline which could delay finality.
2024-07-30 10:46 xlchen: but for more advanced use cases such as synchronous xcmp call, do we not need something like MEV bundler to search for the best way to allocate the work?
2024-07-30 10:47 xlchen: to build multiple parachain blocks in a single work package
2024-07-30 10:48 gav: Yeah, but then each collator would need to be aware that they‚Äôre being co-bundled. 
2024-07-30 10:49 gav: So we‚Äôd need some sort of multi-parachain collator node. 
2024-07-30 10:49 gav: Probably a pluggable thing or a standard synchronous-composable parachain collation API. 
2024-07-30 10:53 xlchen: I see. Will adjust the diagram when I get the chance. 
2024-07-30 10:57 xlchen: we will need to figure out a new collator selection algorithm to maximize number of processed xcmp messages. another thing to think about in future 
2024-07-30 11:03 bkchr: > <@xlchen:matrix.org> but for more advanced use cases such as synchronous xcmp call, do we not need something like MEV bundler to search for the best way to allocate the work?

But then these parachains will also need to share one core. Probably if you have some profitable MEV that you want to execute, it may be useful. But then the question arises on who pays for the core and do the parachain agree to be bundled. Clearly will require some substantial changes to the parachains to support this I think
2024-07-30 11:06 xlchen: yeah I will imagine something similar flashbots that allow MEV searcher to build bundles from tx pool (across all parachains) and share profits with collator
2024-07-30 11:07 bkchr: The general logic of finding out what to bundle together will also be required for coreplay
2024-07-30 11:07 xlchen: but instead of a single chain MEV, it will be a crosschain and presumably there will be fees for XCMP and that‚Äôs another source of income 
2024-07-30 11:07 bkchr: But there the idea was that there exists one leader that lays out the plan for all the tasks for the work package producers 
2024-07-30 11:12 xlchen: the leader can always delegate the work out just like mining pools. it is unlikely that we can just figure out a optimal algorithm so it is something the implementors can compete 
2024-07-30 11:15 bkchr: Yes
2024-07-30 16:11 sourabhniyogi: JAM implementers if you haven't gotten tickets to Devcon yet (and want to go to this: https://polkadot.polkassembly.io/referenda/1024), they went on sale a few minutes back:
 https://tickets.devcon.org/
They tend to get sold out quickly.   There will be another wave but it might be the last one so I ask that you act quickly.  
2024-07-30 16:28 sourabhniyogi: We are getting quotes from venues still, but would like a headcount of who is committed to attend -- if you can fill in your team size and # of people who are committed to attend here:
 https://docs.google.com/spreadsheets/d/1_Ar0CWH8cDq_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0
That would help us decide whether we get a 30 vs 50 vs 70 person venue.  The good news is that the venue costs are lower than expected so we may have bigger travel budgets; the bad news is that we are on waiting lists for the best places and I can't tell you what the venue is quite yet.
2024-07-30 16:37 sourabhniyogi: As some people have had some difficulty adding a comment on Polkassembly [due to identity not being set] feel free to add your name to the sheet.  I will create a new room with the key team contacts so we don't get off JAM topics.  Thank you!
2024-07-30 20:42 shawntabrizi: I want to present an idea having only really high level understanding of JAM, so I apologize in advance if I am just talking air.

My comments basically encapsulates the issue opened on Polkadot here: https://github.com/paritytech/polkadot-sdk/issues/811

As I understand with how services are being designed in JAM, their only ability to read and write data is to the DA layer.

This is of course the preferred and most scalable method for services to place data. Services that want to store long term data are asked to have their own data shard.

However, when thinking about the kinds of services which can be built on JAM, and affording those services the most flexibility, I can imagine that services will want to be able to write to a long term storage without having to maintain their own collators or data shards. This is basically what existing smart contract platforms afford to contracts.

My high level suggestion is that JAM should also include an API where services can write data to the main JAM database, probably under the general opaque key/value store of preimages.

Then, executing the state transition function of services should be able to read from a combination of the DA and the stored preimages in the JAM database.

Writing here could be super expensive, such that we encourage good behavior to NOT use it frivolously, but to not have it at all seems like a missed scenario.

I think if JAM is going to be the most general web3 computer, it does make sense to have such an API, and can help provide a feature which can onboard more services to use JAM. [edited]
  ‚Ü≥ 2024-07-31 06:54 sourabhniyogi: There is long-term storage for services in the State (kept in a binary Patricia Merkle Trie).  Section 12.1 of GP describes the basic service data storage you are looking for, Appendix D.1's Equation (291)'s last 4 lines describe the service storage state, which I think will have codehash => code in the dictionary along with other preimages. [edited]
  ‚Ü≥ 2024-07-31 06:55 sourabhniyogi: The host function `write` (showing up in PVM compiled byte code) enables JAM "accumulate" invocations to write to this service storage. [edited]
  ‚Ü≥ 2024-07-31 06:55 sourabhniyogi: Someone correct me if I got it wrong =)
2024-07-31 05:37 ltfschoen: > <@shawntabrizi:matrix.org> I want to present an idea having only really high level understanding of JAM, so I apologize in advance if I am just talking air.
> 
> My comments basically encapsulates the issue opened on Polkadot here: https://github.com/paritytech/polkadot-sdk/issues/811
> 
> As I understand with how services are being designed in JAM, their only ability to read and write data is to the DA layer.
> 
> This is of course the preferred and most scalable method for services to place data. Services that want to store long term data are asked to have their own data shard.
> 
> However, when thinking about the kinds of services which can be built on JAM, and affording those services the most flexibility, I can imagine that services will want to be able to write to a long term storage without having to maintain their own collators or data shards. This is basically what existing smart contract platforms afford to contracts.
> 
> My high level suggestion is that JAM should also include an API where services can write data to the main JAM database, probably under the general opaque key/value store of preimages.
> 
> Then, executing the state transition function of services should be able to read from a combination of the DA and the stored preimages in the JAM database.
> 
> Writing here could be super expensive, such that we encourage good behavior to NOT use it frivolously, but to not have it at all seems like a missed scenario.
> 
> I think if JAM is going to be the most general web3 computer, it does make sense to have such an API, and can help provide a feature which can onboard more services to use JAM.

> As I understand with how services are being designed in JAM, their only ability to read and write data is to the DA layer.

in contrast to Polkadot where "parachains's code never read from the DA layer"
source: https://blog.kianenigma.nl/posts/tech/demystifying-jam/
2024-07-31 08:37 gav: > <@shawntabrizi:matrix.org> I want to present an idea having only really high level understanding of JAM, so I apologize in advance if I am just talking air.
> 
> My comments basically encapsulates the issue opened on Polkadot here: https://github.com/paritytech/polkadot-sdk/issues/811
> 
> As I understand with how services are being designed in JAM, their only ability to read and write data is to the DA layer.
> 
> This is of course the preferred and most scalable method for services to place data. Services that want to store long term data are asked to have their own data shard.
> 
> However, when thinking about the kinds of services which can be built on JAM, and affording those services the most flexibility, I can imagine that services will want to be able to write to a long term storage without having to maintain their own collators or data shards. This is basically what existing smart contract platforms afford to contracts.
> 
> My high level suggestion is that JAM should also include an API where services can write data to the main JAM database, probably under the general opaque key/value store of preimages.
> 
> Then, executing the state transition function of services should be able to read from a combination of the DA and the stored preimages in the JAM database.
> 
> Writing here could be super expensive, such that we encourage good behavior to NOT use it frivolously, but to not have it at all seems like a missed scenario.
> 
> I think if JAM is going to be the most general web3 computer, it does make sense to have such an API, and can help provide a feature which can onboard more services to use JAM.

The DA system is not the only storage available. There is also the service state.
2024-07-31 10:08 tebdev: 
2024-07-31 13:00 tebdev: Please excuse, trying to set a tempo for my team. is the goal to have M1 - Dec, M2 - ???, etc.? If documented somewhere, please help me with a URL.
2024-07-31 14:10 gav: See the chat around here. [edited]
2024-07-31 14:10 gav: > <@tebdev:matrix.org> Please excuse, trying to set a tempo for my team. is the goal to have M1 - Dec, M2 - ???, etc.? If documented somewhere, please help me with a URL.

See ^^^
2024-07-31 15:32 sourabhniyogi: For those of you who are trying to write their first refine / accumulate code (or connect PVM + Patricia Merkle Tries + DA to your first attempt at host functions), this assembly compiler is going to be insanely useful:

```
# cat tools/spectool/spec/src/inst_branch_greater_or_equal_signed_ok.txt 
pub @main:
    a0 = 10
    a1 = -10
    jump @target if a0 >=s a1
    trap
@target:
    a0 = 0xdeadbeef

# cargo run -p polkatool -- assemble tools/spectool/spec/src/inst_branch_greater_or_equal_signed_ok.txt -o output.polkavm
# cargo run -p polkatool disassemble --show-raw-bytes output.polkavm
// RO data = 0/0 bytes
// RW data = 0/0 bytes
// Stack size = 0 bytes

// Instructions = 5
// Code size = 16 bytes

      :                          @0 [export #0: 'main']
     0: 04 07 0a                 a0 = 0xa
     3: 04 08 f6                 a1 = 0xfffffff6
     6: 2b 87 04                 jump 10 if a0 >=s a1
      :                          @1
     9: 00                       trap
      :                          @2 [export #1: 'target']
    10: 04 07 ef be ad de        a0 = 0xdeadbeef
```

This is from beloved @koute https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2257688558 -- having this assembler spares everyone from hand-assembling PVM byte code like its 1964, but at least for now we have to figure out the closest thing to read/write/solicit/lookup/historical\_lookup/import/export and do a bit of hand assembling.  But it won't be _too bad_. [edited]
2024-07-31 18:01 tebdev: > <@gav:polkadot.io> See ^^^

Perfecto. Expert is greater payoff than money. Money is easy. LQ --> LA (answer) ;)
2024-07-31 22:19 danicuki: I was thinking about organizing a JAM meetup in Lisbon. Would you come? Register here: https://lu.ma/fqg0ktn0
2024-08-01 13:22 ltfschoen: 
2024-08-01 13:38 ltfschoen: > <@danicuki:matrix.org> I was thinking about organizing a JAM meetup in Lisbon. Would you come? Register here: https://lu.ma/fqg0ktn0

i think you need to have rules for attendees like "Everyone will be required to follow the official W3F rules and unofficial "Rules" (from Gav)" as shown in https://polkadot.polkassembly.io/referenda/1024
2024-08-01 13:44 gav: There's really nothing problematic about meeting; my suggestions are there to help ensure that nobody is accidentally disenfranchised. Ultimately, if you can prove clear expertise over the code you're writing, and explain all design and interpretation decisions, then there really shouldn't be a problem. Just be sure to document and declare any non-trivial "coordinated learning"! [edited]
2024-08-01 16:43 s_saxemberg: Hello Jam implementers, we just wanted to invite you to let us know (the community and tokenholders) more about the identities of the Jam implementers that would be the beneficiaries of referendum 1024 https://polkadot.subsquare.io/referenda/1024 (trip to Thailand Devcon7) allegedly this will benefit +15 teams and many more people we would like to meet. We are reaching to you guys through this channel because this is the linked chat that was provided on the referendum. 
Thank you and sorry for the unrelated interruption. 
  ‚Ü≥ 2024-08-01 17:23 celadari: I just posted a comment for jam4s
  ‚Ü≥ 2024-08-01 19:56 vinsystems: Me too
  ‚Ü≥ 2024-08-01 21:55 sourabhniyogi: Thanks for checking up, we appreciate it.  I have tabulated a headcount:

https://docs.google.com/spreadsheets/d/1\_Ar0CWH8cDq\_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0

Most of the teams are asking questions.  If you find any sock puppet candidates let me know!   Note there is some People Chain/Identity issue and some kind of Polkassembly issue (or polkadot.js extension update) that prevented new people commenting without an identity, so failing to comment alone is not a robust sock puppet detector =)

I don't want _everyone_ to be required to write a report (we will do our best as proponent) nor be present for 72 hours (12 hours x 6 days), but I will ask everyone what teams they learned from and who they taught what.  If there are any Michiko Watanabes, they would not appear on anyone's list.  We have 100 days before the event to know each other on matrix rooms, and at least for our part on reimbursement, I'll probably be able to remember 40 some people.   [edited]
  ‚Ü≥ 2024-08-04 00:41 ltfschoen: s_saxemberg: i can't post due on that referendum thread due to reasons outlined here https://forum.polkadot.network/t/people-chain-launch-and-identity-migration-plan/5930/32?u=ltfschoen

i've added my identity and estimated budget here https://github.com/users/ltfschoen/projects/3/views/1?pane=issue&itemId=73400075

2024-08-01 18:33 celadari: Hi davxy ,

I checked the chat and read your discussion with Sourabh regarding signature verification. I also checked the two repositories `ark-ec-vrfs` and `bandersnatch-vrfs-spec`

I wanted to confirm my understanding: Is `pub type RingCommitment<S> = ring_proof::FixedColumnsCommitted<BaseField<S>, PcsCommitment<S>>; `the ring root commitment ($\gamma_z$) mentioned in the Gray Paper?

If yes, when we need a verifier for the ring commitment, we need `PcsParams`. What should I use? From the code, it seems we take these params from the ring context, and there appears to be some randomness when instantiating ring context. Is this normal? Should I just initialize the ring context with `RingContext::from_seed(RING_DOMAIN_SIZE, [0; 32])` in the code and not worry about the rest ?

Thanks in advance !
2024-08-02 05:56 xlchen: Any suggestions on in what order to implement the protocols? Considerations: stability of the spec, availability and stability of test vectors, coupling with other protocols (e.g. can't do B unless A is implemented and size/complexity. e.g. First thing should be the codec, and then Safrole (which depends on the codec) is a good starting point as it is relatively simple, presumably no plan to update it in GP, and with test vectors merged (i.e. stable). and then?
  ‚Ü≥ 2024-08-02 06:18 celadari: I don't think you need codec to work on safrole. You just need to parse the json files to your data structures for testing. The way you parse the json shouldn't really matter for codec no ? ü§î
  ‚Ü≥ 2024-08-02 06:20 xlchen: I guess I didn‚Äôt give the best example but the safrole test vector does have a encoded one which will need codec to be implemented to use
  ‚Ü≥ 2024-08-02 06:45 celadari: What do you mean by encoded one ? I think you can evenly divide into two tests: pure safrole protocol implementation with json and later codec
  ‚Ü≥ 2024-08-02 07:15 xlchen: my point will be true if there isn‚Äôt any json test case provided but only scale one
  ‚Ü≥ 2024-08-02 10:59 oliver.tale-yazdi: I went by the state dependency graph. Sure there is a risk to do things wrong without test vectors, but most corrections to the GP so far were quite minor (modulo the judgement/dispute/verdict alterations).  
SCALE is still a good idea IMHO to pass all the Safrole tests.
  ‚Ü≥ 2024-08-02 14:26 sourabhniyogi: I think every team will be different.

For a team of 3+ all the major "starting" components can be done in parallel:

1. Safrole (FFI)
2. PVM
3. State DB : Tries, DA abstraction
4. Erasure coding (FFI)
5. Scale
where trying to pass the test vectors is basically educational.

Then doing this serially:
6. JAMNP for some small V with a matching RS different than 4
7. Producing blocks with 1, 3, 5, 6 coming together validating tickets,  sending tickets, authoring blocks and validating blocks, write to state trie; set up your DB
8. Wiring up (2) with tiniest refine and accumulate you can write with enough host functions to put (4) together with importing and exporting.
9. work packages with core assignments (V=6, C=2)

We are putting the bones of (6)-(9) together now, then I imagine:
10. treatment of assurances, audits, and judgements/disputes (not sure how to order these yet)
11. statistics
12. authorization, transfer, gas+storage bookkeeping
13. filling in validation TODOs for conformance
14. All remaining host functions needed for serious JAM services, including privileged

===
15. Beefy
16. GRANDPA
17. General polish: Expiring items, edge cases of PVM

Along the way we'll get more test vectors and then polish and optimize polish and optimize.

We can stand up a "tiny" that doesn't do any work, then one that does work with basic JAM services, then one that does work that is guaranteed/ assured/audited, then one that has evil actors doing increasing amounts of evil, then one that has increasing numbers of cores together, ending up in the "full" toaster =).

My (increasingly less wild guess) is that I see 2 man years of work for 95-99th+ percentile engineers so having a team of 4 is best to cut it down to like 6 months (your guess), but I'd guess 2 99th percentile engineers could do it all in less than 6 months.  But the sheer diversity of different types of things seem to require a bunch of different kinds of people, so I'd worry about the team of 1.

I would hate teams to not get started on this exciting journey just because 100% of all test vectors aren't available.  They have been immensely valuable to understand all the basic components though, even if in draft form. [edited]
  ‚Ü≥ 2024-08-02 23:04 xlchen: I guess I worried too much with getting it right at this stage (writing test takes more than than code because I don't exactly know what is the right behaviour).
  ‚Ü≥ 2024-08-02 23:07 xlchen: Just throwing some component that most likely need to be done at some stage: tracing and diagnostic tool integration, DB management (e.g. pruning), RPC (at least some basic ones to get data out of the a running node without the needs to parse logs)
2024-08-02 05:57 xlchen: I see open PR on the testvectors so that means they are available but because not yet merged I have no idea on how stable they are.
2024-08-02 05:59 xlchen: I am a bit hesitated on working on the protocols without test vectors because I could do it completely wrong and won't be able know until related test vectors are released
2024-08-02 07:55 asmie: Hi! qq about in-memory db - can we use anything external (eg.: RocksDB, ParityDB) or it should be something implemented from scratch?
2024-08-02 15:07 gav: > <@xlchen:matrix.org> I am a bit hesitated on working on the protocols without test vectors because I could do it completely wrong and won't be able know until related test vectors are released

The protocol definition is 0.3.2. There are going to be changes. Nothing is final. 
  ‚Ü≥ 2024-08-02 23:02 xlchen: I mainly want to know in relatively terms which part is more stable. But I guess that could be an unknown as well
2024-08-03 15:13 ltfschoen: does anyone know where i can find out more information about the **zkSNARK Service** that Gav mentioned at 51mins in this old discussion "Gavin Wood on JAM: The next disruptor in Web3" https://x.com/paritytech/status/1788847203622043974 [edited]
2024-08-05 15:19 tebdev: > <@asmie:matrix.org> Hi! qq about in-memory db - can we use anything external (eg.: RocksDB, ParityDB) or it should be something implemented from scratch?

This a good question. I also need advice.
2024-08-06 09:35 dudley_kilt: Dudley from the KILT Protocol team. We are currently putting a team of Parachain members to build a JAM Client in Rust. We are looking to comprise multiple ecosystem partners of a team around 4-6 people either part time or full time that would implement the graypaper. We would be beginning in the following weeks. We were wondering the state of play considering the stiff competition in the B category.

Our goal is to build knowledge from the existing ecosystem teams and share that expertise of the JAM Clients to build a stronger ecosystem when the JAM comes around consider it ‚ÄúSpreading the butter over the toast then the JAM .‚Äù

We are looking for team members in the ecosystem Rust from Parachain teams to include. KILT would be leading the team.
2024-08-06 10:37 darentuzi: > <@asmie:matrix.org> Hi! qq about in-memory db - can we use anything external (eg.: RocksDB, ParityDB) or it should be something implemented from scratch?

Can anyone help clarify this, my guess is that an existing DB should be fine?
2024-08-06 10:47 subotic: > <@darentuzi:matrix.org> Can anyone help clarify this, my guess is that an existing DB should be fine?

This is one of previous Gav's responses: "Third-party libraries (FFI) for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE) and networking (e.g. QUIC) are acceptable. Everything else should be properly implemented."

So from that I understand that DB falls under "everything else".
2024-08-06 17:31 gav: > <@subotic:matrix.org> This is one of previous Gav's responses: "Third-party libraries (FFI) for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE) and networking (e.g. QUIC) are acceptable. Everything else should be properly implemented."
> 
> So from that I understand that DB falls under "everything else".

Sorry missed this. It‚Äôs fine to use a third-party DB. 
2024-08-06 17:32 gav: Same goes for anything similarly generic. 
2024-08-06 20:43 erkt: Point of Clarification: The latest version of the GP removes any mention of the old SCALE codec, however, in some convos/threads in the chat, SCALE is still being mentioned. I know the variable integer encoding scheme in GP is already different from the compact integer encoding in SCALE. So is it safe to say that SCALE will not be used in JAM? 
2024-08-06 20:46 erkt: 
2024-08-06 20:55 erkt: Also, on the note of Integer encoding, I'm having a bit of confusion with the 29-bit serialization rules (Eqn 274). Did the writer mean to say the 3rd condition is: "otherwise if x <2^29" similarly to Eqn 275? Alternatively should `l` be in `N_2` instead of `N_3`?
  ‚Ü≥ 2024-08-06 21:07 prematurata: N_3 should mean 0,1,2 if I remind properly
  ‚Ü≥ 2024-08-06 21:07 erkt: Doh, you're totally right. Thanks a lot 
  ‚Ü≥ 2024-08-06 21:08 erkt: Doing a quick search of the GP, i don't see the 29-bit serialization being used anywhere. Anyone know what is the intended use case of it?
  ‚Ü≥ 2024-08-06 21:08 erkt: Why would I use that instead of the general varint encoding?
  ‚Ü≥ 2024-08-06 21:14 prematurata: Is It e4*?
  ‚Ü≥ 2024-08-06 21:14 erkt: Yep
  ‚Ü≥ 2024-08-06 21:15 erkt: image.png
  ‚Ü≥ 2024-08-06 21:15 prematurata: Gav already said it's not currently used and most likely to be removed 
  ‚Ü≥ 2024-08-06 21:15 prematurata: I would not spend much time on it If I were you :)
  ‚Ü≥ 2024-08-06 21:15 erkt: Ah i must have missed that. Do you know where he said that?
  ‚Ü≥ 2024-08-06 21:15 erkt: Thanks a lot again for responding, you're awesome. 
  ‚Ü≥ 2024-08-06 21:16 prematurata: I asked about it some days ago
  ‚Ü≥ 2024-08-06 21:16 prematurata: Don't remember the context sorry
  ‚Ü≥ 2024-08-06 21:16 erkt: no problem 
  ‚Ü≥ 2024-08-06 21:16 erkt: ü´°
2024-08-07 09:38 gav: > <@erkt:matrix.org> Point of Clarification: The latest version of the GP removes any mention of the old SCALE codec, however, in some convos/threads in the chat, SCALE is still being mentioned. I know the variable integer encoding scheme in GP is already different from the compact integer encoding in SCALE. So is it safe to say that SCALE will not be used in JAM? 

Yes. 
2024-08-08 19:21 celadari: Is the size in bytes of gamma_z always the same ? If not, is there a limit on the number of bytes of gamma\_z Or a way to know it in advance before computing it ?
(I ask this because we use a ffi to execute the rust code ark-bandersnatch and to get the result back from our language we provide a pointer with free memory and the length of this memory) [edited]
2024-08-08 19:31 celadari: So far I've only seen gamma_z with size of 144 bytes in the test vectors but I wanted to confirm the size in bytes of gamma_z instead of assuming [edited]
2024-08-08 19:32 prematurata: it's 144
2024-08-08 19:34 prematurata: you can confirm it also by checking appendix `I` which states `Y_r` is a subset of `Y_144` and if u check (49) then `gamma_z` is defined to be in `Y_r`
  ‚Ü≥ 2024-08-08 19:37 celadari: I should have remembered that...
Thanks a lot
  ‚Ü≥ 2024-08-08 19:37 prematurata: np
  ‚Ü≥ 2024-08-08 19:38 prematurata: what ffi language allows u to give a pointer in memory? im curious
  ‚Ü≥ 2024-08-08 19:41 celadari: > <@prematurata:matrix.org> what ffi language allows u to give a pointer in memory? im curious

Java
It's not a pointer with * per say (it doesn't exist in java) but it's an object called Memory that when it arrives to rust is a raw pointer
2024-08-09 11:41 vinsystems: 
In the test enact-epoch-change-with-no-tickets-4.json of Safrole, the value of the parameters in post_state indicates that there has been an epoch change (e' > e). However, if I calculate the value of e and e', they are the same... 
e = tau / E; e = 10 / 600 = 0
e' = tau' / E; e' = 15 / 600 = 0

Therefore, e' = e. What I missing here? 
https://github.com/w3f/jamtestvectors/blob/master/safrole/tiny/enact-epoch-change-with-no-tickets-4.json
  ‚Ü≥ 2024-08-09 11:44 celadari: You're talking about tiny or full ? Because if you're talking about tiny then E=12 [edited]
  ‚Ü≥ 2024-08-09 11:46 vinsystems: About tiny. Thank you!
2024-08-09 11:44 xlchen: https://github.com/w3f/jamtestvectors/blob/master/safrole/tiny.asn#L4
2024-08-09 16:25 celadari: Hello, I have a doubt regarding **ordering of extrinsic** in file `tiny/publish-tickets-with-mark-2.json`.

We have the following extrinsic:

```json
{
        "attempt": 1,
        "signature": "0x8e.......cf7"
      },
      {
        "attempt": 0,
        "signature": "0x38.....92"
      },
      {
        "attempt": 0,
        "signature": "0xa7....38"
      },
      {
        "attempt": 1,
        "signature": "0x52....f0"
      },
      {
        "attempt": 1,
        "signature": "0x16......53"
      }
```

Verifying signatures and thus getting VRF output I get in the same order:
0x3a....ad
0x5d....98
0x8b....d9
0xae....b4
0xb1.....75

but then they are not in any order (ascending or descending) if taken as LITTLE-ENDIAN.
(They are in ascending order if taken as BIG-ENDIAN though...)

**Is there a problem with the order of extrinsic in this file or there is something I am missing ?** [edited]
  ‚Ü≥ 2024-08-09 21:10 xlchen: I think you are confused how le/be works between hex string vs binary number
  ‚Ü≥ 2024-08-09 21:11 xlchen: for data [1,2,3,4], written in hex using le will be 0x01020304
  ‚Ü≥ 2024-08-09 21:11 xlchen: lsb is on left, unlike numbers
  ‚Ü≥ 2024-08-09 21:23 celadari: The example you provided is accurate, but I'm having trouble understanding how it relates to ordering.

The representation of a hex string is independent of endianness (big-endian or little-endian). However, if you're trying to define an ordering between arrays of bytes, endianness will have an impact. 

When comparing two arrays of bytes, you need to decide whether the arrays are in big-endian (BE) or little-endian (LE) format. This will determine how you compare the bytes one by one until a strict comparison is established.
  ‚Ü≥ 2024-08-09 21:37 xlchen: yes and they are le
  ‚Ü≥ 2024-08-09 21:39 celadari: Oh wait, thank you, Bryan.

You've just made me realize that my code already assumes endianness; otherwise, I wouldn't have been able to print the hex format correctly. The hex representation was derived from an array of bytes from the start. If the hex values are among the postState gamma_a, then they are correct
2024-08-12 11:00 dakkk: 
2024-08-12 11:28 dakkk: Regarding the definition of Y in appendix G, the two functions "decode" and "hashed_output" are referenced; where are defined?  I can't find a valid "name match" in the linked papers
  ‚Ü≥ 2024-08-12 11:34 celadari: In the code (https://github.com/davxy/bandersnatch-vrfs-spec/blob/main/example/src/main.rs), you have line 163 `let vrf_output_hash: [u8; 32] = output.hash()[..32].try_into().unwrap();` where they "apply Y"
  ‚Ü≥ 2024-08-12 11:46 celadari: My bad, you were asking about linked/referenced papers. Paper "Jeff 2023" defines the function "rVRF.Verify(comring, in, ad, sigma)" (in part 4 of the paper) that returns the output if it verifies and false otherwise. The decode function I don't know how to "name match" it
I hope it answers your question ü§∑‚Äç‚ôÇÔ∏è [edited]
  ‚Ü≥ 2024-08-12 13:31 dakkk: yep, thank you (y) 
2024-08-14 17:48 davxy: ‚ö†Ô∏è First proposal for Disputes STF test vectors (Section 10) : https://github.com/w3f/jamtestvectors/pull/9
Be aware, it may not be final, and some adjustments might be made. However, you can start using it.
2024-08-15 07:23 bkchr: > <@sourabhniyogi:matrix.org> JAM implementers if you haven't gotten tickets to Devcon yet (and want to go to this: https://polkadot.polkassembly.io/referenda/1024), they went on sale a few minutes back:
>  https://tickets.devcon.org/
> They tend to get sold out quickly.   There will be another wave but it might be the last one so I ask that you act quickly.  

With the recent proposal of having a sub0 next to devcon, this event should be scrapped and included in sub0. The sub0 proposal is any way about having a hackathon style event thst wants to attract different kind of peoples. First, this will reduce costs for the ecosystem and secondly it will also have a much bigger impact if the ecosystem can participate. 
2024-08-15 07:25 bkchr: This was also directly proposed by rtti-5220 as comment to the proposal: https://polkadot.polkassembly.io/referenda/1024#GJjjWhHPJSlZt2NObHFO
2024-08-15 07:25 gav: > <@bkchr:parity.io> With the recent proposal of having a sub0 next to devcon, this event should be scrapped and included in sub0. The sub0 proposal is any way about having a hackathon style event thst wants to attract different kind of peoples. First, this will reduce costs for the ecosystem and secondly it will also have a much bigger impact if the ecosystem can participate. 

When you say ‚Äúnext to‚Äù, do you mean in time or space?:)
2024-08-15 07:26 bkchr: Time and space. 
2024-08-15 07:27 gav: Ahh right - actually during devcon and in Bangkok.  [edited]
2024-08-15 07:30 bkchr: https://forum.polkadot.network/t/sub0-reset-devcon-bangkok-back-to-the-roots/9626
2024-08-15 07:31 bkchr: 9-11 November. Devcon starts at the 12th
2024-08-15 07:31 rtti-5220: > <@gav:polkadot.io> Ahh right - actually during devcon and in Bangkok.

which is the case for this proposal, but i think something in parallel to sub0, same venue, 1 day completely focused on JAM would make more sense for JAM impl devs who can attend both events easily (sub0 and Jam0), and it would reduce costs (instead of organising 2 separate events in different parts of the city, we get two events in one) - we are also experimenting with this first JAM event so something in a more controlled enviroment like Sub0 and getting support from the Sub0 organisers might make more sense. 
2024-08-15 07:33 gav: Perhaps we could run a parallel event in Europe at the same time. 
  ‚Ü≥ 2024-08-15 07:39 rtti-5220: i dont think running an event in asia and one in europe in parallel is the best idea for devs who might want to see both, which in general happens - since JAM is on the first stage of development and is the first event focused on this impl. Furthemore, it makes it more costly. 
2024-08-15 07:40 emielvanderhoek: Although it may not be official I believe lots of JAM teams are making preparations for attending JAM0 as a side event for Devcon in Bangkok. 
2024-08-15 07:42 emielvanderhoek: 15 teams already last I read. 
2024-08-15 07:43 gav: Out of 23, but if the other 8 happen to be within easy travelling distance of Lisbon then it could be nice to host something small at the Parity office there. 
2024-08-15 07:43 gav: Cost would be minimal compared to the 100k being asked for Jam0 Bangkok. 
2024-08-15 07:44 emielvanderhoek: Sure it would be nice to have a shared agenda/objective at least. 
2024-08-15 07:44 gav: And personally I probably can‚Äôt make Bangkok in November.  [edited]
  ‚Ü≥ 2024-08-15 07:48 rtti-5220: OK, then given your role on JAM development it might not make sense to do it at all then. You could join virtually, but I think key people working on the protocol should be there - I think all of these events are running on the idea you would present on them, so its a pity. 
  ‚Ü≥ 2024-08-15 08:05 gav: > <@rtti-5220:matrix.org> OK, then given your role on JAM development it might not make sense to do it at all then. You could join virtually, but I think key people working on the protocol should be there - I think all of these events are running on the idea you would present on them, so its a pity. 

I think it‚Äôs probably fine; it‚Äôd be nice to meet everyone but assuming I can‚Äôt make it we can always organise JAM1 in early 2025. The idea of engendering cross-pollination between Eth and Jam communities is a good one, and if it‚Äôs mostly about M1 interop then physical presence is a bit less important. 
2024-08-15 07:53 emielvanderhoek: The assumption I believe is that half November we‚Äôd get as far as running a M1 ‚Äòtiny‚Äô importer network between clients. Timing at least makes this reasonable perhaps given it is three month ahead of us. 
2024-08-15 08:00 bkchr: Also JAM could be helpful to "lure in" more people to sub0. Getting actually people from ETH interested on JAM and through this learning some stuff about the current stack could be quite helpful for the entire ecosystem
2024-08-15 12:09 sourabhniyogi: Guys, thank you for entertaining the JAM0 event.  It was about travel budgets for like 38 people, which are not covered under the sub0 proposal, which has dates which are too early for most people to sustain a 9-10 day trip.  I hope JAM implementers didn't buy Devcon 7 tickets and nonrefundable airfare. [edited]
2024-08-15 12:15 bkchr: The sub0 proposal is not up yet and they would be happy to extend the proposal by including the proposed travel budgets
2024-08-15 12:15 sourabhniyogi: Let us consider 1024 JAM0 scrapped.  If you bought tickets/airfare/hotel in expectation that it would be covered by 1024, please get them refunded.  
2024-08-15 12:17 bkchr: I don't get why you want to scrape it? 
2024-08-15 12:20 sourabhniyogi: https://polkadot.polkassembly.io/referenda/1024 won't pass at this stage?
2024-08-15 12:21 bkchr: Yeah, but just let it integrate into sub0. Why not? 
2024-08-15 12:24 sourabhniyogi: Some of us literally can't make 9th/10th ( In particular, me ).   Here is the list of teams for Roman to work with:

 https://docs.google.com/spreadsheets/d/1_Ar0CWH8cDq_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0
2024-08-15 12:27 bkchr: You can still join on the 11th as you had planned before
2024-08-15 12:27 bkchr: I mean this is not really about one single individual, but instead of getting some benefit for the entire ecosystem 
2024-08-15 12:32 sourabhniyogi: Is Roman / WebZero in this room?  Or, Basti.await  can you lead the JAM portion of the sub0 event and get the travel budget added and approved for people?  [Or delegate to someone who wants to lead it]
2024-08-15 12:37 sourabhniyogi: Hi rektormoon thanks for joining =)
2024-08-15 12:37 rektormoon: Hey everyone, glad to be here
2024-08-15 12:39 sourabhniyogi: We would like to fuse the JAM0 event concept into sub0 which I understand is on the 9th-11th -- Basti.await believes it is reasonable to get some JAM implementer travel budget added in.  
2024-08-15 12:40 sourabhniyogi: https://docs.google.com/spreadsheets/d/1_Ar0CWH8cDq_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0

has the list of interested people from 1024.  

2024-08-15 12:40 rektormoon: I think it makes sense to add the program, which ofc would change the nature of your original plan, as we are more interested in showcasing the concepts and progress to ppl not involved with building JAM (yet)
2024-08-15 12:41 rektormoon: Budget wise we don‚Äôt really comp travel for speakers and such, but that could also be dealt with by a treasury tip for example. We just don‚Äôt really have capacity to be a ‚Äútravel agency‚Äù for idk 30-40 ppl 
2024-08-15 12:42 bkchr: The point is more about including the travel budget in the sub0 proposal
2024-08-15 12:43 rektormoon: > <@bkchr:parity.io> The point is more about including the travel budget in the sub0 proposal

Ofc, but we would be responsible for that budget
2024-08-15 12:44 bkchr: Okay, I think we can find a way for getting and handling the budget 
2024-08-15 12:45 rektormoon: As long as we find good ways to transparently report‚Ä¶
2024-08-15 12:46 rektormoon: At web3 summit we are paying partial travel comp for hackers for the first time, so it‚Äôs a new thing for us 
2024-08-15 12:46 bkchr: I had misunderstood you, I had thought you had said earlier today that you would be okay to include this in the sub0 proposal. I will figure something out 
2024-08-15 12:47 rektormoon: Program wise absolutely!
2024-08-15 12:47 rektormoon: When it comes to payments and budgets, I just want to understand how you see it working and who would be responsible for what :-)
2024-08-15 12:49 sourabhniyogi: Did you lock down an exact venue + dates yet?  For pre 11th, you own everything.  For 12-17th dates, I can be an assistant to Basti.await .
2024-08-15 12:51 bkchr: I think the general idea would be to move everything earlier
2024-08-15 12:51 gav: > <@gav:polkadot.io> And personally I probably can‚Äôt make Bangkok in November.

Can't promise anything yet but I might be able to make 9th-11th.
2024-08-15 12:52 sourabhniyogi: To state the obvious, a sub0 without you is barely a sub0 =)
2024-08-15 12:54 rektormoon: That would be sub-par
2024-08-15 12:55 sourabhniyogi: Basti.await: I have a Valia room for the 11th - 16th.  
https://www.valiahotelbangkok.com/meetings-venues/
This can be a room for JAM Implementers to work after sub0 (assuming 9th-11th)  Can you approve this as being addable to the budget?  This would be \< $20K [edited]
2024-08-15 13:04 bkchr: I mean I'm not doing the budget, but did you already booked this? 
2024-08-15 13:05 sourabhniyogi: I did [50%]  
2024-08-15 13:06 bkchr: So you mean you already paid 50% upfront? 
2024-08-15 13:08 emielvanderhoek: I would be great to have some center of gravity mid November. Obviously there is some risk for the organizing party if funding is required. It would be good to get some consensus on date (and later content) for an event planning wise. 
2024-08-15 13:08 sourabhniyogi: image.png
2024-08-15 13:09 sourabhniyogi: Approximately, yes.  There is a OneBlock Polkadot hackathon where I'm not sure where they ended up.
2024-08-15 13:10 sourabhniyogi: They originally wanted 13th+14th so since it opened up I asked for it.  
2024-08-15 13:11 emielvanderhoek: My JAM team (3x) has devcon tickets already. We have not yet booked flight and accommodation. Nice if we can get some reimbursement but not strictly necessary. 
2024-08-15 13:11 rektormoon: So from the WebZero side I would like to involve the teams building on JAM to be on the sub0 program on the 11th. 
2024-08-15 13:11 rektormoon: > <@sourabhniyogi:matrix.org> They originally wanted 13th+14th so since it opened up I asked for it.  

Overlaps with devcon, not wise
2024-08-15 13:13 emielvanderhoek: We‚Äôll travel to where center of gravity is for JAM0 if any. 
2024-08-15 13:13 gav: > <@sourabhniyogi:matrix.org> To state the obvious, a sub0 without you is barely a sub0 =)

Well it certainly wasn‚Äôt my preference to run it twice in Bangkok in the same year. 
2024-08-15 13:14 rektormoon: We felt the opportunity is too good to pass up üòÖ
2024-08-15 13:23 sourabhniyogi: Ok rektormoon 11th being the JAM day of sub0 makes sense, thanks for jumping in here -- I'll check if I can swap out the Valia room on the 11th for the 13th / 14th.  We really want more time to work together in person than just 1 day.
2024-08-15 13:24 rektormoon: We plan to have a hacker space in sub0, so you could start work together there on the 9th and 10th
2024-08-15 13:24 rektormoon: Also open at night
2024-08-15 14:01 bkchr: > <@sourabhniyogi:matrix.org> Ok rektormoon 11th being the JAM day of sub0 makes sense, thanks for jumping in here -- I'll check if I can swap out the Valia room on the 11th for the 13th / 14th.  We really want more time to work together in person than just 1 day.

It would also be nice to be more cost efficient. Aka only one event. Can you cancel it? Or at least partly? People will also go to devcon, not sure that much will then appear there to code after a long day of conference 
  ‚Ü≥ 2024-08-18 19:26 sourabhniyogi: Basti.await: rtti-5220   We hope JAM Implementers travel budgets can be covered to Lisbon and other JAM0/1/2/.. events and this sub0 and the upcoming sub0's with JAM content.

It seems natural to combine JAM events with both sub0 + PBA.  But it is just a passing thought, especially since this channel is not appropriate to talk about treasury expenditures and cost efficiencies. [edited]
2024-08-15 14:11 sourabhniyogi: Alright updated https://polkadot.polkassembly.io/referenda/1024 -- its cost-efficient in that the cost is $0.  I don't want to let anyone down.
2024-08-17 06:47 xlchen: While it is great if we can get a multi client testnet running on JAM0/Sub0 RESET, it is a relatively involved work and I am sure the first try wouldn't work. And I can already foresee some struggles that we are going to have due to number of components required for the whole thing to work especially many of the components are still in draft stage (e.g. networking). In simple words, this is too much for an initial MVP and there will be a good chance we won't be able to deliver it as there are too much uncertainties. It is a good target for us to try, but I won't bet for it.

When a task is too big, what we do is to break it down. So here is my suggestion:

Figure out a simple way for implementations to communicate. It needs to be simple, so pipes (i.e. stdout/stdin). Every program can print and shouldn't take more than 10 line of code to allow it to read. In that way we can have many standalone binaries confirming a same interface and we can assemble all those binaries together for lot more interesting tests. For example, team A have implemented all the components and team B only implemented Safrole, team C only implemented PVM. We can replace the Safrole@TeamA to Safrole@TeamB and PVM@TeamA to PVM@TeamC and still be able to setup a multi client testnet covers some work from team B and C. This also forces everyone to write modular code, which is a good thing as well.
and this will be the first step https://github.com/w3f/jamtestvectors/issues/7
2024-08-17 11:32 sourabhniyogi: Awesome Bryan Chen | Laminar & Acala , thank you for suggesting it.  The "pipes" model standing in place of QUIC and the binary from teams being the core deliverable would be immensely valuable -- is repurposing a fraction of ZombieNet \[which works using chain binaries\] useful for this?

Its immediately clear this pipes+binaries approach is clearly a LOT easier for teams working together with as a proxy for JAMNP, automating the ip/port "setup", but probably can continue into JAMNP with "binaries trading" with a few flags switching modes.

Having a test runner for the existing test vector set makes sense, but the PVM test vector case is quite a different character than all the others in that its almost totally removed from networking -- to use your concrete example, if "team C" only implemented PVM, they would only be able to run through the test runner on just the PVM, and not be able to do anything with "team A" and "team B".  In contrast, team A+B will talk Safrole and can continue onto the other 4 extrinsics, which are .. not very modular.    Team C hasn't gotten very far, not to pass too much judgement here, but has a LOT of catching up to do.

We do have a tiny (V=6, C=2) QUIC passing Ticket + Blocks  (with JSON serialization/deserialization instead of SCALE encoding/decoding) and are proceeding along with our own little RS code (with W\_C x W\_S \<\< 4104, like 24) to get the other 4 extrinsics with DA over the next 4-6 weeks, going from "Team B" to "Team A".   We believe deviating from GP Appendix H to support a tiny RS code is essential for multi-team MVP success and hope we can "pick some parameters" together matched to the "tiny" Safrole test vectors.

We believe a battery of "trivial" jam work packages / services (refine+accumulate, then adding in the auth+transfer) that utilize the host functions are critical for education and enabling team As to keep going.   (In the absence of this, we are currently hand assembling our own little sum of squares battery, replacing a byte here and there for host function calls).  We imagine the first A teams that publish 4-5 epochs (48-60 blocks) covering this battery can argue between themselves about state roots, but it would be even better if we had a  authoritative "M0" 48-60 block dump that covered all the extrinsics, modeled DA, to make arguments tend to zero.  Then we all would just try to get M0 to work on our own first as a prereq to binary trading.

We would be happy to supply whatever binary works by early Oct and hope there are a bunch of "A teams" and "B teams" where we can do pre-work in October.   If there are any A candidates who get to pipes model before Oct, we'll be inspired to match you, pls share! [edited]
2024-08-17 12:42 gav: > <@sourabhniyogi:matrix.org> Awesome Bryan Chen | Laminar & Acala , thank you for suggesting it.  The "pipes" model standing in place of QUIC and the binary from teams being the core deliverable would be immensely valuable -- is repurposing a fraction of ZombieNet \[which works using chain binaries\] useful for this?
> 
> Its immediately clear this pipes+binaries approach is clearly a LOT easier for teams working together with as a proxy for JAMNP, automating the ip/port "setup", but probably can continue into JAMNP with "binaries trading" with a few flags switching modes.
> 
> Having a test runner for the existing test vector set makes sense, but the PVM test vector case is quite a different character than all the others in that its almost totally removed from networking -- to use your concrete example, if "team C" only implemented PVM, they would only be able to run through the test runner on just the PVM, and not be able to do anything with "team A" and "team B".  In contrast, team A+B will talk Safrole and can continue onto the other 4 extrinsics, which are .. not very modular.    Team C hasn't gotten very far, not to pass too much judgement here, but has a LOT of catching up to do.
> 
> We do have a tiny (V=6, C=2) QUIC passing Ticket + Blocks  (with JSON serialization/deserialization instead of SCALE encoding/decoding) and are proceeding along with our own little RS code (with W\_C x W\_S \<\< 4104, like 24) to get the other 4 extrinsics with DA over the next 4-6 weeks, going from "Team B" to "Team A".   We believe deviating from GP Appendix H to support a tiny RS code is essential for multi-team MVP success and hope we can "pick some parameters" together matched to the "tiny" Safrole test vectors.
> 
> We believe a battery of "trivial" jam work packages / services (refine+accumulate, then adding in the auth+transfer) that utilize the host functions are critical for education and enabling team As to keep going.   (In the absence of this, we are currently hand assembling our own little sum of squares battery, replacing a byte here and there for host function calls).  We imagine the first A teams that publish 4-5 epochs (48-60 blocks) covering this battery can argue between themselves about state roots, but it would be even better if we had a  authoritative "M0" 48-60 block dump that covered all the extrinsics, modeled DA, to make arguments tend to zero.  Then we all would just try to get M0 to work on our own first as a prereq to binary trading.
> 
> We would be happy to supply whatever binary works by early Oct and hope there are a bunch of "A teams" and "B teams" where we can do pre-work in October.   If there are any A candidates who get to pipes model before Oct, we'll be inspired to match you, pls share!

Indeed, such a dump is in line with my expectations of what we‚Äôll provide for M1 tests.
2024-08-18 16:28 shwchg: davxy: Hi, I have a question about your dispute test vector
You mentioned in your README that when an execution error occurs, the post-state must match the pre-state. But some of your vectors are still being updated.
https://github.com/davxy/jam-test-vectors/blob/disputes/disputes/tiny/progress_with_culprits-3.json
```
"pre_state": {
        "psi": {
            "psi_g": [],
            "psi_b": [],
            "psi_w": [],
            "psi_o": []
        },
        "rho": [
            null,
            null
        ]
"post_state": {
        "psi": {
            "psi_g": [],
            "psi_b": [
                "0x11da6d1f761ddf9bdb4c9d6e5303ebd41f61858d0a5647a1a7bfe089bf921be9"
            ],
            "psi_w": [],
            "psi_o": []
        },
        "rho": [
            null,
            null
        ]
```
So are there specific errors that you handle in a way that allows the process to continue running?

2024-08-18 16:32 davxy: Nice catch. I'll fix it. For what concerns test vectors, on error post matches pre
2024-08-18 16:40 shwchg: ok thanks!
2024-08-18 17:01 davxy: Fixed. Thank you for reporting :-) 
2024-08-18 19:34 gav: This is not the place to argue over treasury expenditure. Go to Polkassembly or wherever to do that and vote with your stake. 
2024-08-18 19:37 gav: [@sourabhniyogi:matrix.org](https://matrix.to/#/@sourabhniyogi:matrix.org) Please remove the offending text and be more careful in the future. 
2024-08-20 20:14 danicuki: I am organizing an informal JAM enthusiasts meetup at Lisbon, for those who are nearby: https://lu.ma/fqg0ktn0 
2024-08-20 20:41 danicuki: For those who are building JAM, I suggest adding your org / repo to the Electric Capital Crypto Report repo: https://github.com/electric-capital/crypto-ecosystems

Here is a PR reference to follow:
https://github.com/electric-capital/crypto-ecosystems/pull/1443
2024-08-20 20:57 vinsystems: > <@danicuki:matrix.org> I am organizing an informal JAM enthusiasts meetup at Lisbon, for those who are nearby: https://lu.ma/fqg0ktn0

We are from Spain but we won't be able to attend at that date
2024-08-21 05:59 xlchen: I am refactoring our codec (i.e. ditch the existing ScaleCodec library) and just realize that was the Safrole test vector using Scale codec instead of Jam codec? davxy 
2024-08-21 06:00 xlchen: the length prefix in the provided tests are encoded using compact encoding, not the Jam natural number serialization method
2024-08-21 06:19 luka99: Regarding availability using erasure-coding, it says in 14.2.2 that the justification data needed to verify the segments/chunks is too large to be stored by every validator and that it too goes through the same availability framework. Doesn't that create the same problem as to why the justification data is needed in the first place? Someone can give a corrupted chunk of the justification data and we can't restore it? 
2024-08-21 06:27 davxy: Current vectors are provided in two flavors. SCALE and JSON. [edited]
2024-08-21 06:28 davxy: Indeed at the beginning only json was provided. But IIRC someone asked for a scale version as well [edited]
2024-08-21 06:30 davxy: I guess SCALE vectors will be probably replaced at some point 
2024-08-21 06:45 xlchen: it was me asking for it with assumption that scale is used for jam, but that‚Äôs actually not the case so will need a version for Jam codec
2024-08-21 06:46 xlchen: I think the only difference is just the encoding format for compact number 
2024-08-21 09:11 tomusdrw: Hi all! Our team was recently working on a PVM implementation and we've also built a tool that we hope will help other implementors. https://pvm.fluffylabs.dev/ <-- here you can find our PVM Disassembler.

It can load a JSON test case file and visualise what instructions are used in the code. By plugging a PVM implementation you can also turn it into a debugger. If any of the teams is interested we want to make it possible to upload a WASM blob of your PVM implementation and run it instead of ours (see open issue on github regarding the interface). We plan to support running two PVMs in parallel and checking their state (registers / memory / gas) at every step and display the exact instruction when they start to differ.

Tool's code is open source on github, so feel free to fork or report any issues or feature requests there. We are looking forward for your feedback.
2024-08-21 09:11 tomusdrw: Huge kudos for Wojciech Kwiatek Krystian Fras who are behind the code of this one :) üëèüëèüëè
2024-08-21 15:10 rmagon: Hi - for those who are implementing in Go, are there any native libraries for cryptographic primitives like the ones in Rust? For, say, Bandersnatch, RingVRF etc. ? I can see that it is allowed to use such libs but couldn't find anything that we could rely on, specially in Go. Or are you implementing them from scratch Or using FFI for M1 atleast?
  ‚Ü≥ 2024-09-10 21:14 rick: Hi Rachit -- I did find a bandersnatch implementation in go with a partial audit: 

https://github.com/Consensys/gnark-crypto/tree/master/ecc/bls12-381/bandersnatch

No guarantees for side channels but this should be plenty good enough to get started. 
2024-08-21 15:23 rick: I don‚Äôt think there are specific implementations but Filipo Valsorda has published a few of the necessary lower level primitives.

I‚Äôll post here if I find more specific ones. Other people to check out are probably David Stainton from katzenpost, Yawning, and I will probably post mine as a separate oss lib if I get to it. [edited]
2024-08-21 15:24 subotic: > <@rmagon:matrix.org> Hi - for those who are implementing in Go, are there any native libraries for cryptographic primitives like the ones in Rust? For, say, Bandersnatch, RingVRF etc. ? I can see that it is allowed to use such libs but couldn't find anything that we could rely on, specially in Go. Or are you implementing them from scratch Or using FFI for M1 atleast?

FFI is explicitly allowed in these cases (for all milestones).
2024-08-22 09:40 luke_f: image.png
2024-08-22 09:40 luke_f: @davxy:matrix.org
looking at bandersnatch-vrf code example here
https://github.com/davxy/bandersnatch-vrfs-spec/blob/ae82b19e99cdc1301820d9cbd978e0a73b9de2a8/example/src/main.rs#L52

i see that Prover has `prover_idx` field

I'm assuming this corresponds to the index into the validator set of said signer/ prover

could you confirm please?@davxy:matrix.org  [edited]
2024-08-22 09:45 davxy: Confirmed
2024-08-22 09:45 luke_f: Thank you :)
2024-08-23 12:33 rmagon: > <@subotic:matrix.org> FFI is explicitly allowed in these cases (for all milestones).

Makes sense! thank you!
2024-08-23 12:33 rmagon: > <@rick:carback.us> I don‚Äôt think there are specific implementations but Filipo Valsorda has published a few of the necessary lower level primitives.
> 
> I‚Äôll post here if I find more specific ones. Other people to check out are probably David Stainton from katzenpost, Yawning, and I will probably post mine as a separate oss lib if I get to it.

That would be great if you can find anything. I will do the same :)
2024-08-23 18:43 sourabhniyogi: sub0 with a bit of JAM is up for vote at https://polkadot.polkassembly.io/referenda/1113 -- This is followed by 5 days of "JAM0" for Implementers (venue sponsored by us, let me know if you are JAM implementers and want in =).  If you intend to trek to sub0 in Bangkok and Devcon but haven't gotten tickets, here is where you can get the final wave on September 3:
 https://devcon.org/en/tickets/ 
If you want discounted hotel rooms use "JAM0" at https://valiahotelbangkok.com [edited]
2024-08-23 19:41 emielvanderhoek: There was discussion on a Bangkok & Lisbon JAM0 gathering. With the Sub0 addition is it now all happening in Bangkok? [edited]
2024-08-24 09:29 bmaas: > <@sourabhniyogi:matrix.org> sub0 with a bit of JAM is up for vote at https://polkadot.polkassembly.io/referenda/1113 -- This is followed by 5 days of "JAM0" for Implementers (venue sponsored by us, let me know if you are JAM implementers and want in =).  If you intend to trek to sub0 in Bangkok and Devcon but haven't gotten tickets, here is where you can get the final wave on September 3:
>  https://devcon.org/en/tickets/ 
> If you want discounted hotel rooms use "JAM0" at https://valiahotelbangkok.com

That sounds like a brilliant idea. I will definitely be up for it.
2024-08-24 17:20 prematurata: Hello all i'm trying to implement the verification for the ticket extrinsic (74),

I am using the data coming from https://github.com/w3f/jamtestvectors/blob/master/safrole/tiny/publish-tickets-no-mark-2.json

so basically this inputs: 
- so signature from `input.extrinsic[0].signature` = `0xb342bf8f...85a8`
- and ringroot commitment `pre_state.gamma_z` = `0x96a4b4...74cf`
- posterior eta_2 from `post_state.eta[2]` = `0xbb30..14aa`

according to paper i just need to concatenate `$jam_ticket_seal` with `posterior eta 2` and the attempt (`1` in the json)

this (if i understand properly) should be the input data. 

I am not able to get the code to verify the signature. I basically checked this piece of code for it
https://github.com/davxy/bandersnatch-vrfs-spec/blob/ae82b19e99cdc1301820d9cbd978e0a73b9de2a8/example/src/main.rs#L134

and modified to have the ring context to be of size 6 and pass an empty aux_data... but `Public::verify().is_err()` is always `true` 

I am a bit lost to be honest any help would be appreciated. 
  ‚Ü≥ 2024-09-23 05:43 turuslan: 
Thanks, prematurata, davxy

Couldn't find "\$..." definition in notation section of graypaper.

So latex "\$jam\_ticket\_seal" is "jam_ticket_seal" without "$".

([davxy answer outside thread](https://matrix.to/#/!wBOJlzaOULZOALhaRh:polkadot.io/$r3qxlOvQdQAKRJs8mFPLf0Q6ag8oK2XzGutiilGKJvw?via=polkadot.io&via=matrix.org&via=parity.io))

2024-08-24 17:42 gav: > <@prematurata:matrix.org> Hello all i'm trying to implement the verification for the ticket extrinsic (74),
> 
> I am using the data coming from https://github.com/w3f/jamtestvectors/blob/master/safrole/tiny/publish-tickets-no-mark-2.json
> 
> so basically this inputs: 
> - so signature from `input.extrinsic[0].signature` = `0xb342bf8f...85a8`
> - and ringroot commitment `pre_state.gamma_z` = `0x96a4b4...74cf`
> - posterior eta_2 from `post_state.eta[2]` = `0xbb30..14aa`
> 
> according to paper i just need to concatenate `$jam_ticket_seal` with `posterior eta 2` and the attempt (`1` in the json)
> 
> this (if i understand properly) should be the input data. 
> 
> I am not able to get the code to verify the signature. I basically checked this piece of code for it
> https://github.com/davxy/bandersnatch-vrfs-spec/blob/ae82b19e99cdc1301820d9cbd978e0a73b9de2a8/example/src/main.rs#L134
> 
> and modified to have the ring context to be of size 6 and pass an empty aux_data... but `Public::verify().is_err()` is always `true` 
> 
> I am a bit lost to be honest any help would be appreciated.

One for davxy to look at.
2024-08-24 17:49 motifnetwork: > <@emielvanderhoek:matrix.org> There was discussion on a Bangkok & Lisbon JAM0 gathering. With the Sub0 addition is it now all happening in Bangkok?

Hear the same at the AAG 
2024-08-24 17:49 motifnetwork: yep, here
https://polkadot.polkassembly.io/referenda/1113
2024-08-25 19:58 davxy: prematurata: https://gist.github.com/davxy/54892e1ebd548040615a9fdc627de632
I hope it helps
2024-08-26 10:46 davxy: Another batch of test vectors: https://github.com/w3f/jamtestvectors/pull/11
This one focuses on the "Recent History" STF (section 7). 
Overall, it's fairly straightforward, but the update to MMR peaks adds some interesting elements.
Any feedback or notes are appreciated. Thanks!
2024-08-27 07:09 ksc85pwpj5: 
2024-08-27 07:09 ksc85pwpj5: 
2024-08-27 07:09 ksc85pwpj5: 
2024-08-27 07:12 ksc85pwpj5: 
2024-08-27 07:12 ksc85pwpj5: 
2024-08-27 07:12 ksc85pwpj5: 
2024-08-27 09:06 niubob: Hi, I just saw Gav's notes, where can I see the current progress of each team? Or are there any language sets that no one is participating in?
  ‚Ü≥ 2024-08-27 09:08 cisco: You can see the teams in https://graypaper.com/clients/ albeit without the progress of each team.

All language sets have been picked, unless you want to challenge yourself with language set Z üòÇ
  ‚Ü≥ 2024-08-27 09:16 niubob: > <@cisco:parity.io> You can see the teams in https://graypaper.com/clients/ albeit without the progress of each team.
> 
> All language sets have been picked, unless you want to challenge yourself with language set Z üòÇ

Thanks! set Z lol:
2024-08-28 18:36 sourabhniyogi: 
2024-08-29 03:33 xlchen: Can someone start merging PRs at https://github.com/w3f/jamtestvectors? Otherwise we have to use our own forks to be able to run all the tests on different branches and they are start getting merge conflicts now
2024-08-29 14:02 ntnntn: Is there any rules regarding using FFI for stuff that is implemented in-house? E.g. we run for a TS implementation, can we offload any of the lower-level stuff that require performance to Rust components we would also write from scratch and expose them via FFI?
  ‚Ü≥ 2024-08-29 14:36 dakkk: FFI Is allowed only for "Third-party libraries for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE), and networking (e.g. QUIC) are acceptable". You can use rust and FFI if you implement yourself one of these things.
  ‚Ü≥ 2024-08-29 14:37 dakkk: Otherwise "Code must be idiomatic for languages which define idiom."
  ‚Ü≥ 2024-08-29 14:57 ntnntn: Thanks a lot!
  ‚Ü≥ 2024-08-29 14:58 ntnntn: I'm wondering if performance could be taken into account. Not sure it will be possible to reach M4 with some languages.
  ‚Ü≥ 2024-09-09 06:36 gav: It probably won't. The point on idiomaticness does not imply that an implementation must use all the same language. Only that for code written in some language must be idiomatic for that language.
  ‚Ü≥ 2024-09-09 06:38 gav: For less performant languages, it's perfectly reasonable for a team to write e.g. a database or VM in some lower-level higher-performance language and utilize it through FFI.
  ‚Ü≥ 2024-09-09 06:42 gav: In the (I'd hope) unlikely event that a team writes 50% of their impl in a language from one set and 50% in a language from another, it will be totally at the discretion of the Fellowship/Foundation to determine how the prize should be allotted from the prize pots. One _possible_ strategy would be to split the prize fund according to the ratio of lines of code written in each language. [edited]
  ‚Ü≥ 2024-09-09 06:51 jan: I'd expect that for some languages it will be essentially impossible to write even a half speed implementation without resorting to a systems language for the low level performance critical parts, so I would expect in those cases people will not be penalized when it comes to prize. In my opinion people should only be penalized if they use another language unnecessarily.
  ‚Ü≥ 2024-09-09 06:57 gav: Well, "unnecessarily" is rather vague, but point taken. I updated my notes accordingly.
  ‚Ü≥ 2024-09-09 07:08 jan: But of course most likely one might not want to implement something in another language right off the bat. Initially it's usually simpler/more convenient to just keep everything in a single language, you don't need to be fast for the first two milestones anyway, and also because probably the easiest way to prove that you _had_ to use another language for speed is to compare it with an implementation in your original language and show the difference.

Once we get to the point where people will reach the latter milestones and will want to optimize the performance of their implemenations then (if there's interest) I could probably host a workshop/presentation/whatever on how to write a fast VM, to help people write more performant PVM implementations (this could be especially useful if your team doesn't have any VM or low-level performance experts) [edited]
2024-08-29 14:02 ntnntn: Or does FFI only apply for the existing libraries that are allowed to be used?
2024-08-29 18:42 davxy: I'm working on a version of the vectors using the codec prescribed by GP. It's almost ready. So maybe it's worth waiting? I'll submit the vectors for the codec first [edited]
2024-08-30 16:37 davxy: https://github.com/w3f/jamtestvectors/pull/12
Your feedback is appreciated 
2024-08-30 17:01 philip.poloczek: 
2024-08-30 17:01 sourabhniyogi: This is awesome and gives us a lot to chew on, thank you!  All the components of Eq (289), C(1)-C(13) and at least 1 test case for service state (the last 4) would be awesome, culminating in  state root that we can strive for.

Generally having a codectest  for all the JAMNP objects would be useful as well, most of which are inside your test vectors already, but not all.  Having  network-centric test vectors would be awesome alongside this "block" centric view.

We are wondering if `Vote` would be broadcasted by validators instead of `Dispute` objects in JAMNP. [edited]
  ‚Ü≥ 2024-08-30 20:05 dave: Re the last bit, yes I believe validators will only broadcast their votes (judgements) and announcements. The block author will construct the disputes extrinsic based on what they have seen.
  ‚Ü≥ 2024-08-31 07:54 shwchg: David Emett: As far as I know, the extrinsic ED is processed before the audit is conducted. 

So, is this extrinsic formed during the audit phase and then passed on to the author of the next block?
  ‚Ü≥ 2024-08-31 15:35 dave: The extrinsic ED is a result of the auditing process. If a block author has sufficient information to put something in ED then they will, otherwise they won't. Note that in normal operation ED is always empty. It will only be non-empty if some validator misbehaves.
  ‚Ü≥ 2024-08-31 15:53 dave: FWIW auditing is an off-chain activity that may stretch over multiple time slots. While it is triggered by work reports becoming available, which is reported on-chain, the chain doesn't really wait for auditing to finish as such. If, as a result of the auditing process, a block author discovers that some other validator has misbehaved, then they will include this in ED. They may also build on an older block, if accumulation of some bad work reports needs to be reverted
  ‚Ü≥ 2024-08-31 16:21 shwchg: https://youtu.be/Ed--83UTLPk?t=115
The lecture mentioned that disputes will slash the bad work reports before accumulation.
  ‚Ü≥ 2024-08-31 16:26 dave: Yes, in the case that a bad work report was made available, it is removed before accumulation. However note that in this case the chain is being rewound; this will happen in wall time well after the work report was accumulated
  ‚Ü≥ 2024-08-31 16:26 dave: The fork on which the work report was accumulated will never be finalized though, and will be discarded by validators once they see the that the work report was bad
  ‚Ü≥ 2024-08-31 16:28 dave: The first block author which has enough information to determine that the work report is faulty will wind back the chain to just before accumulation, place the information in the ED extrinsic, and the bad work report will get erased
  ‚Ü≥ 2024-08-31 17:26 shwchg: I get it.Thank you very much!
  ‚Ü≥ 2024-08-31 18:10 dave: Nice! Glad I could help üòÉ
  ‚Ü≥ 2024-09-03 14:23 shwchg: David Emett: Hi again, I'd like to ask you some further questions.
In ELVES, an initial small group of auditors is selected to audit the block. If all members of this group vote in favor, the block is approved. However, if someone is absent or votes against, the process either enters the dispute phase or additional auditors are selected to vote until a sufficient number of approvals are obtained.

In Jam, a work report group is selected for auditing, and each validator performs this task. 
Here, does each validator select ten others to issue announcements, or is it a single validator selecting ten?
After the announcement is made, do others who receive it also perform the corresponding audit work?

I might have many questions. If it's convenient, could you please give me a more detailed explanation? I believe there are some differences between ELVES and the audit process described in the Gray Paper, and it seems like there are many aspects in the GP that aren't clearly explained.
  ‚Ü≥ 2024-09-03 14:26 dave: In each tranche, each validator makes its own decision of whether to audit the work report or not. This decision is made based on the outcome of a VRF. An announcement is made by each validator that decides it should perform an audit
  ‚Ü≥ 2024-09-03 14:27 dave: As validators choose randomly whether to perform an audit or not, the number in each tranche isn't really fixed, it's an expected number
  ‚Ü≥ 2024-09-03 14:28 dave: The announcements are used by other validators to determine if auditing was successful and if not how many auditors to aim for in the next tranche (the more missing auditors there are in a tranche, the more auditors there should be in the following one)
  ‚Ü≥ 2024-09-03 14:30 dave: FWIW I'm not really familiar with the details of the elves paper, not sure exactly how what's in the GP differs from what is described there
  ‚Ü≥ 2024-09-03 14:30 dave: The fundamental idea is the same though
  ‚Ü≥ 2024-09-03 14:54 shwchg: 

I think what you said makes sense to me. So, if a validator wants to participate in the audit, they will use this function to select the initial work reports to audit and will issue announcements for these 10 work reports in tranche 0. At the same time, other validators will also be doing this.

https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMWIiLCJBdWRpdGluZyBhbmQgSnVkZ2luZyIsIlNlbGVjdGlvbiBvZiBSZXBvcnRzIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHhkYiBoYiB5ZTc2IGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeGFmIGhiIHllN2YgZmYxNiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d

In tranche 1, they will use this function to check if there are any missing or false judgments and then decide whether or not to join the audit for that work report.

https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMWMiLCJBdWRpdGluZyBhbmQgSnVkZ2luZyIsIlNlbGVjdGlvbiBvZiBSZXBvcnRzIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHgxNDYgaDIgeWVjOCBmZjFjIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4NDQgaGIgeWVjOCBmZjE2IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iXV0=


  ‚Ü≥ 2024-09-03 15:24 dave: The first tranche works a bit differently to the others. _Every_ validator will select 10 cores at random to audit, these are chosen according to the first set of equations you linked. Note that this means each report will get on average 30 validators auditing it (at most one report per core per block, 3 validators per core), but there may be more or less depending on how the randomness works out
  ‚Ü≥ 2024-09-03 15:27 dave: In tranches 1 and later yes the second set of equations you linked are used. The |An‚àí1(w)‚àñ J‚ä∫(w)| term is the number of missing judgements (the number of announcements without matching judgements)
  ‚Ü≥ 2024-09-03 15:28 dave: These equations effectively evaluate each work report separately
  ‚Ü≥ 2024-09-03 15:29 dave: Note that in the case that a negative judgement is seen, a validator should always audit the work report. So the equations only apply in the case of missing judgements
  ‚Ü≥ 2024-09-03 15:33 shwchg: Nice! Thank you for answering 
2024-08-30 20:03 dave: 
2024-08-30 23:31 sourabhniyogi: https://github.com/davxy/jam-test-vectors/blob/codec-vectors/codec/data/work_package.json#L36-L45
2024-08-30 23:31 sourabhniyogi: image.png
2024-08-30 23:32 sourabhniyogi: Issue: We were expecting arbitrary length blobs in the "extrinsics" attribute of a Work Package, not (hash, length) combinations.   Section 14.3 says "In general this data will be passed to the guarantor alongside the work-package."  I guess the "alongside" doesn't mean "inside" here but then we're left wondering how these work packages could get _audited_ if only the guarantors get the extrinsics "alongside" the work package rather than inside the work package. [edited]
2024-08-31 06:56 davxy: 
2024-08-31 06:57 davxy: That doesn't seem to be what the gray paper suggests, see eq 285 (GP 0.3.6)
  ‚Ü≥ 2024-08-31 08:10 sourabhniyogi: I believe the easter egg design that Gav is aiming for with JAM is:
(1) work packages with `refine` that have arbitrary length extrinsic blobs, but
(a) assurable by the MANY (2/3) \[183\] but
(b) auditable by the FEW
(2) SLIM blocks with just (hash, length) pairs sharable with ALL, validated by ALL, thus (285)

Clearly, JAM departs from the classic FAT block paradigm where all transactions/extrinsics are stored in every block (and validated by ALL), all state transitions verifiable from genesis, in favor of SLIM blocks ala (2) with as much "work" **and data** pushed out to cores ala (1).  (285) shows the FAT extrinsics are gone, but   the question is how audits can be done with the TINY onion of (183)+(184). [edited]
  ‚Ü≥ 2024-08-31 08:18 sourabhniyogi: The contention on the work packages + work items on whether FAT extrinsics are kept "alongside" vs "inside" work packages is also to keep work packages SLIM like the blocks, by keeping FAT extrinsics out of work items _as well_, while also meeting assurance/auditability concerns and keeping the availability proof onion TINY.

Just a guess (since we have not reconstructed the onion yet) but its seems clear of the whole extrinsic by the FEW when audited is necessary.  The key bits doesn't have to be in the block or the work package, and maybe not in the work items either so long as it makes it into the onion.

I think the bottom line is we need to get clarity on where "extrinsic data" represented by the symbol ${\bf x}$ are 
(a) (hash, len) pairs  
vs 
(b) arbitrary length blobs 
From [my guess of] the design considerations I believe the Work Items will use (a) but we need to know where (b) is exactly.   The "alongside" imply the first guarantor erasure encode (b) and then everyone else deals with (a).  Can you confirm this? [edited]
  ‚Ü≥ 2024-08-31 09:37 sourabhniyogi: It appears all of FAT extrinsics of (b) slips into $\bar{x}$ of eq 251
  ‚Ü≥ 2024-08-31 09:45 sourabhniyogi: image.png
  ‚Ü≥ 2024-08-31 09:45 sourabhniyogi: Is this in fact the only place?
  ‚Ü≥ 2024-08-31 10:20 dave: The extrinsic data is placed into the availability system alongside the work package, so it is available to all validators. This is necessary as all validators may need to audit the work report. One possible confusion here is that "extrinsic" is used to describe both extrinsic block data (guarantees, assurances, disputes, etc) _and_ extrinsic work item blobs
  ‚Ü≥ 2024-08-31 10:29 dave: The full extrinsic block data is shared amongst all validators, though only via block publication. I see now that my reply earlier saying that disputes are not broadcast is not entirely true; I meant they are not broadcast prior to block construction. They do effectively get broadcast when the block containing them gets broadcast
  ‚Ü≥ 2024-08-31 10:33 dave: FWIW I'm not sure what the purpose of the extrinsic work item data is as AFAIK it is passed everywhere the work package is
  ‚Ü≥ 2024-08-31 14:56 sourabhniyogi: > <@dave:parity.io> The full extrinsic block data is shared amongst all validators, though only via block publication. I see now that my reply earlier saying that disputes are not broadcast is not entirely true; I meant they are not broadcast prior to block construction. They do effectively get broadcast when the block containing them gets broadcast

Which part of GP (or JAMNP) describes this "The full extrinsic block data is shared amongst all validators"?

I believe 
(a) ${\bf x}$ are the hashes of 
(b) $\bar{x}$ 
where (b) is erasure-encoded into "Audit DA system" for a few hours, and just for auditing to reduce bandwidth/storage.  

Work items/work packages only have (a).  The availability proof (eq 183) only concerns (a) but auditors can reconstruct (b) for just a few hours.  
  ‚Ü≥ 2024-08-31 15:03 dave: "To reduce bandwidth/storage" is not really accurate. The extrinsic data for a work report is made available until the report is considered audited, at which point it is no longer needed
  ‚Ü≥ 2024-08-31 15:04 dave: The reason for erasure coding is so that the data can be retrieved by auditors even if the original guarantors refuse to present it upon request
  ‚Ü≥ 2024-08-31 15:04 dave: In normal operation, auditors will not reconstruct via the erasure coded chunks but simply ask the guarantors for the data
  ‚Ü≥ 2024-08-31 15:05 dave: Possibly in the initial version the just-ask-the-guarantors thing will not exist, as it's just an optimisation
  ‚Ü≥ 2024-08-31 15:10 dave: Re which part of the GP describes this, I guess 14.4 is what you want to read
  ‚Ü≥ 2024-08-31 15:15 dave: In particular the stuff talking about "availability specifiers". The bundle erasure coded for the Audit DA is Encode(p, x, i, j), where p is the package, x is the referenced extrinsic data, i is the imported data, and j the justifications for this imported data
  ‚Ü≥ 2024-08-31 15:18 dave: > <@dave:parity.io> The reason for erasure coding is so that the data can be retrieved by auditors even if the original guarantors refuse to present it upon request

Sorry I guess this is not really accurate. The reason for distributing amongst all validators is this. Erasure coding rather than eg sending the full data to each validator _is_ to save bandwidth/storage
  ‚Ü≥ 2024-08-31 15:31 dave: > <@sourabhniyogi:matrix.org> Which part of GP (or JAMNP) describes this "The full extrinsic block data is shared amongst all validators"?
> 
> I believe 
> (a) ${\bf x}$ are the hashes of 
> (b) $\bar{x}$ 
> where (b) is erasure-encoded into "Audit DA system" for a few hours, and just for auditing to reduce bandwidth/storage.  
> 
> Work items/work packages only have (a).  The availability proof (eq 183) only concerns (a) but auditors can reconstruct (b) for just a few hours.

FWIW the message you replied to was talking about the block extrinsic data E, though it seems this is not actually what you're interested in. Not sure if the GP says anywhere explicitly that this is shared, but it's not really possible to validate blocks etc unless it is
  ‚Ü≥ 2024-08-31 16:55 sourabhniyogi: Validation of the "off-chain" refine extrinsic data is done through the auditing (which re-executes the same refine after reconstruction), which is a requirement for finalization of blocks.  Validation of blocks (which is done by all validators) does not require this auditing of the `refine` execution to be done by every validator, but just a few.    The `accumulate` execution must be done by all validators to validate a block.  We need to peel all the layers of the availability specifier to maximally appreciate the beauty/novelty of this =) [edited]
2024-08-31 16:57 sourabhniyogi:  davxy  After review we don't have an issue =)  We need a fully worked out case (in your style =)) of the Availability Specifier inputs ${\bf b}$ and ${\bf s}$, intermediate Encode(p, x, i, j), where p is the package, x is the [hash, len], i is the imported data, and j the justifications for this imported data -- culminating in a JAMP instruction for sharing (justified) DA chunks, which gav says will likely just be `Vec<Hash>` (blob subtree) ++ `Blob` ++ `Vec<Hash>` (segments subtree) ++ `Vec<SegmentChunk>` ++ `Vec<Hash>` (super-tree) and maps onto these Encoded inputs.  It is super helpful to have you choose verbose JSON attribute names both consistent with everything else and disambiguating.   Even better would be a diagram though =)
2024-09-02 10:22 rhee: kianenigma: Hey Kian, this is the first Korean_translated version of your [JAM summary blog](https://blog.kianenigma.nl/posts/tech/demystifying-jam/). I've invited a professional local technical writer + one of the research firms to deliver your contents in a correct tone & manner. Hope you like it and link to your blog article: https://research.despread.io/ko/report-jam/
  ‚Ü≥ 2024-09-02 15:30 kianenigma: that's awesome, thanks for sharing! 

1. if any comments or feedback, please open a PR in the corresponding repository 
2. would it be useful if I share the original SVG files as well, so you can edit the images to your liking? 
  ‚Ü≥ 2024-09-02 15:31 kianenigma: for the drawings and such. 
  ‚Ü≥ 2024-09-02 15:31 kianenigma: actually they are technically already public, you just have to know where to look for them 
  ‚Ü≥ 2024-09-02 15:45 kianenigma: Screenshot 2024-09-02 at 16.45.13.png
2024-09-04 07:54 vinsystems: Where do you guys define the PVM's ram memory: in the stack or in the heap? The max ram size of a 32bit proccessor is 4GB, so defining it in the stack may be better in terms of performance, but will also consume a lot of system resources.  [edited]
2024-09-04 08:12 vinsystems: Where do you guys have define the PVM's ram memory: in the stack or in the heap? The max ram size of a 32bit proccessor is 4GB, so defining it in the stack may be better in terms of performance but will also consume a lot of system resources. 
2024-09-04 08:16 dakkk: > <@vinsystems:matrix.org> Where do you guys have define the PVM's ram memory: in the stack or in the heap? The max ram size of a 32bit proccessor is 4GB, so defining it in the stack may be better in terms of performance but will also consume a lot of system resources.

I'm currently using the heap
2024-09-04 08:16 jan: 1. Competently implemented there is no performance difference.
2. No one sane ever puts something as big as 4GB on the stack, nevermind that by default it's not even possible since every OS has a strict stack limit that is at most a few megabytes (it can be increased, but the idea of putting a 4GB value on the stack is so insane that I don't even know if you can increase it that much, as no on ever does this). [edited]
2024-09-09 07:09 gav: > <@sourabhniyogi:matrix.org> Issue: We were expecting arbitrary length blobs in the "extrinsics" attribute of a Work Package, not (hash, length) combinations.   Section 14.3 says "In general this data will be passed to the guarantor alongside the work-package."  I guess the "alongside" doesn't mean "inside" here but then we're left wondering how these work packages could get _audited_ if only the guarantors get the extrinsics "alongside" the work package rather than inside the work package.

A Work Package contains only (hash, length) pairs to define extrinsic data. Guarantors may disregard a Work Package if they have been failed to be furnished with the correct preimages (it's up to the submitter to give them the real extrinsic data in addition to the WP).
2024-09-09 07:10 gav: As for auditors, extrinsic data is contained in the Work Package Bundle, which is made available.
2024-09-09 12:25 davxy: Could I kindly request concise feedback from the various teams regarding this PR: https://github.com/w3f/jamtestvectors/pull/12? If you encounter any issues, please report them directly in the PR.
2024-09-09 12:26 davxy: Please give a thumbs up if you process it correctly, and a thumbs down if you encounter any issues.
2024-09-09 13:05 emielvanderhoek: 
2024-09-09 13:09 emielvanderhoek: Added a comment in the Safrole PR for one more Safrole testvector. 
2024-09-11 08:50 luke_f: 
2024-09-11 08:55 luke_f: Screenshot from 2024-09-11 15-50-26.png
2024-09-11 08:55 luke_f: davxy: question for you sir:
I have a problem with decoding "blank" public key into an AffinePoint when creating epoch root  / ringCommitment

in the attached image, we see that we create a new epoch root with possibly some "blank" public bandersnatch keys

when i try to decode these into an AffinePoint using `point_decode`  https://github.com/davxy/ark-ec-vrfs/blob/main/src/codec.rs
the decoding fails
could you suggest please how to handle these [edited]
2024-09-11 09:15 gav: > <@luke_f:matrix.org> davxy: question for you sir:
> I have a problem with decoding "blank" public key into an AffinePoint when creating epoch root  / ringCommitment
> 
> in the attached image, we see that we create a new epoch root with possibly some "blank" public bandersnatch keys
> 
> when i try to decode these into an AffinePoint using `point_decode`  https://github.com/davxy/ark-ec-vrfs/blob/main/src/codec.rs
> the decoding fails
> could you suggest please how to handle these

Don't decode them.
2024-09-11 09:15 gav: https://www.goodreads.com/quotes/7570350-the-patient-says-doctor-it-hurts-when-i-do-this
2024-09-11 09:19 luke_f: right, but then the size of the ring would change.
by your answer i gather that's ok


edit:
what i mean is, if I'm not decoding them back to a point, then i understand i just filter these keys out when creating a new epoch root, but the GP does not  mention any filtering action here, 
so I'm not sure how to procceed
 [edited]
2024-09-11 09:26 gav: From the GP perspective, there is no filtering action.
2024-09-11 09:26 gav: However, said filtering should be defined within the Bandersnatch appendix. I introduced a note [Bandersnatch: Ignore bad keys](https://github.com/gavofyork/graypaper/pull/77/commits/f1c867f163b326d21a7654f0cb7898754f1750f4)
2024-09-11 09:27 gav: In general bad keys should just be noops (in the case of adding to a ring) or fail (in the case of signature verification). The GP doesn't care about specific representations of the key. From its perspective keys are just opaque 32-byte blobs. It's only within the Bandersnatch def that we attempt to make sense of the blob, and thus it is there where the meaning of "bad" keys is defined. [edited]
2024-09-11 09:28 gav: (This is not limited to the nullifier key either: we don't prevent validators from uploading bad keys.) [edited]
2024-09-11 09:30 luke_f: understood. Thank you gav 
2024-09-11 10:25 davxy: luke_f: Your question reminded me of an interesting missing case in the test vectors, which I had noted earlier here: https://github.com/w3f/jamtestvectors/pull/8#issuecomment-2275460028.
Thank you for the reminder! I will proceed with adding it. :-)
2024-09-11 10:26 luke_f: > <@davxy:matrix.org> luke_f: Your question reminded me of an interesting missing case in the test vectors, which I had noted earlier here: https://github.com/w3f/jamtestvectors/pull/8#issuecomment-2275460028.
> Thank you for the reminder! I will proceed with adding it. :-)

my pleasure :)
2024-09-12 03:01 gav: > <@gav:polkadot.io> However, said filtering should be defined within the Bandersnatch appendix. I introduced a note [Bandersnatch: Ignore bad keys](https://github.com/gavofyork/graypaper/pull/77/commits/f1c867f163b326d21a7654f0cb7898754f1750f4)

Note: After davxy's comment, the GP appendix was updated to state that when building the ring, do *not* skip but instead use the Bandersnatch padding point for any keys with no point of their own.
2024-09-12 13:17 prematurata: question about the host call definition. Appendix A.6. it looks like that the invocation shouldreturn `x'` when a page fault happen when callling `f` but `x'` is not defined anywhere so i guess it's just a typo and instead of `x'` we want `x`... is this assumption correct?


Also I have a couple of questions about gammax (green underline). 

- my understanding is that since it should be a type any of the Accumulate functions can be expected there. is it correct?
- also not sure its intended but there are 2 gamma x definitions. one in accumulate and one in general functions 

2024-09-12 13:17 prematurata: image.png
2024-09-12 15:07 jimboj21:  Hey davxy I saw in the codec PR that you are keeping tabs on teams that are able to process the codec test vectors, so wanted to say we (Gossamer team) are able to fully process them üëçÔ∏è Thanks for the work getting us the vectors!
2024-09-12 15:18 prematurata: I also think the `B.2` is-authorized invocation `Œ®I` has something strange.

- `Œ®M` is being called with 1st param `p_c`
- `p` is of type workpackage ( `P` )
- `_c` is codehash
- `Œ®M` first param is a member of `Y`or generic blob but that is being used for `Y()` fn in `239`
- `239` implies that if all the statements cannot be satisfied, then basically `Y()` output is "empty/nil"
- this means that since the `Œ®I` always passess a code hash then `Œ®M` is always returning `panic` due to `246` [edited]
2024-09-12 15:46 gav: here it is p_c where the c is bold and not italic, thereby referring to the code preimage not the hash. 
2024-09-12 15:50 gav: > <@prematurata:matrix.org> question about the host call definition. Appendix A.6. it looks like that the invocation shouldreturn `x'` when a page fault happen when callling `f` but `x'` is not defined anywhere so i guess it's just a typo and instead of `x'` we want `x`... is this assumption correct?
> 
> 
> Also I have a couple of questions about gammax (green underline). 
> 
> - my understanding is that since it should be a type any of the Accumulate functions can be expected there. is it correct?
> - also not sure its intended but there are 2 gamma x definitions. one in accumulate and one in general functions 
> 

Yes that should be x not x‚Äô. Will be fixed in next release. 
2024-09-12 15:52 gav: [@prematurata:matrix.org](https://matrix.to/#/@prematurata:matrix.org)this stuff is OT in here. In future please use the gray paper channel.  [edited]
2024-09-13 04:13 gav: > <@prematurata:matrix.org> question about the host call definition. Appendix A.6. it looks like that the invocation shouldreturn `x'` when a page fault happen when callling `f` but `x'` is not defined anywhere so i guess it's just a typo and instead of `x'` we want `x`... is this assumption correct?
> 
> 
> Also I have a couple of questions about gammax (green underline). 
> 
> - my understanding is that since it should be a type any of the Accumulate functions can be expected there. is it correct?
> - also not sure its intended but there are 2 gamma x definitions. one in accumulate and one in general functions

prematurata: please explain what you mean by "gamma x".
2024-09-13 07:54 prematurata: > <@gav:polkadot.io> prematurata: please explain what you mean by "gamma x".

 sorry I meant omega
2024-09-13 08:12 gav: > <@prematurata:matrix.org> sorry I meant omega

Fixed in https://github.com/gavofyork/graypaper/pull/77/commits/b1f172bdf98a52b12cebd9d5064b22230730b5d9
2024-09-13 08:13 prematurata: > <@gav:polkadot.io> Fixed in https://github.com/gavofyork/graypaper/pull/77/commits/b1f172bdf98a52b12cebd9d5064b22230730b5d9

movin discussion in graypaper chan
2024-09-13 10:41 bmaas: > <@davxy:matrix.org> Please give a thumbs up if you process it correctly, and a thumbs down if you encounter any issues.

https://github.com/w3f/jamtestvectors/pull/12#issuecomment-2348625189 I have a question here davxy 
2024-09-13 11:59 davxy: I reviewed your comments. The reasons are design decisions, so you should eventually raise your concerns in the graypaper. In any case, IMHO, it is better to maintain a uniform design for u16/u32 encoding in the protocol rather than saving 1 byte here and there by introducing pitfalls related to variable-length encoding.
2024-09-13 12:10 davxy: Side note for slot number. Even though the test vectors are using small slot numbers, in production the slot count begins with the "JAM common era" (1 Jan 2024 = 1704110400). As of today, you would already have a slot = (1726229014 - 1704110400) / 6 = 3686435 = 0x384023 (3 bytes). [edited]
2024-09-13 12:15 bmaas: image.png
2024-09-13 12:24 bmaas: Thanks for the prompt reply davxy . I'm not suggesting saving everything in just one byte. When I study the formula‚Äî272‚ÄîI expect that the length of the encoding should be derivable from the l-value. Thus in the example `header-0.json` case, `l` would be 0, and thus following the formula it would produce 0 extra octets. For this reason I was not expecting the extra 3 bytes. 

2024-09-13 12:29 bmaas: > <@davxy:matrix.org> Side note for slot number. Even though the test vectors are using small slot numbers, in production the slot count begins with the "JAM common era" (1 Jan 2024 = 1704110400). As of today, you would already have a slot = (1726229014 - 1704110400) / 6 = 3686435 = 0x384023 (3 bytes).

I believe I found the misunderstanding, 272 , there is a note: at present utilized only in encoding the length prefix of variable-length sequences.
2024-09-13 12:41 davxy: Screenshot from 2024-09-13 14-41-11.png
2024-09-13 12:42 davxy: Also H_t is explicitly encoded as E_4 , so you need to refer to the formula for fixed length integers (just above the one you're looking at)
2024-09-16 07:53 xlchen: gav: there are many open PR here https://github.com/w3f/jamtestvectors/pulls can we have the ready one merged? i.e. #2 and #12
2024-09-18 01:12 gav: Merged
2024-09-18 08:13 stephenta: Hi Gavin and fellowship,

Our team has an interest in working on JAM implementation. Can I ask a question is there any criteria of a success deliverable milestone?
  ‚Ü≥ 2024-09-18 08:15 jan: Have you read https://jam.web3.foundation ?
  ‚Ü≥ 2024-09-18 08:15 xlchen: https://hackmd.io/@polkadot/jamprize
  ‚Ü≥ 2024-09-18 08:27 stephenta: > <@xlchen:matrix.org> https://hackmd.io/@polkadot/jamprize

Thank you Bryan! It's much helpfulüôè
2024-09-19 08:41 luke_f: davxy: apologies in advance for the kinda silly question:
is there ANY CHANCE that the order of gamma_s in tiny/enact-epoch-change-with-no-tickets-4.json is wrong?

asking because I'm getting different order üòÖ
  ‚Ü≥ 2024-09-19 10:23 celadari: Has there been a merge ? Last time we checked we had the same order. Did you check that your language is working on untyped bytes ? Otherwise you might get surprises [edited]
  ‚Ü≥ 2024-09-27 10:48 luke_f: celadarithanks, we figured it out. it was(of course) a bug on our end
2024-09-20 03:11 xlchen: Some question about Safrole ticket submission. https://hackmd.io/@polkadot/jamsnp
To confirm my understanding first:

- On each epoch, every next epoch validator (`Œ≥k`) can submit to up two tickets
- Block authors are incentivized to include up to 16 tickets in extrinsic
- Potential block authors should maintain an tickets pool and include top tickets when authoring new blocks
- Tickets are not gossiped. So every next epoch validators should submit their two tickets to every current epoch validators.
- Next epoch validators shouldn't need to resubmit their tickets or it could be counted as spam?
- So current validators should persist the pending tickets pool across restarts
- In order to make it possible for the first block of an epoch to include full 16 tickets, next next epoch validators (`Œπ`) should start generating and submit tickets before they become `Œ≥k`. The ring commitment will depends on `œào` but it is unlikely for it to change at and of an epoch as we are not expecting punishments in more than 99.9% of the time.
- So validators should be expected to receive tickets for both current and next ring commitment

And my questions:
As JAMSNP currently defined, ticket submission seems like is only for 1 ticket only? But validator are almost always want to send two tickets. So better to make it to expect two tickets
What exactly does the success / bad mean? Ack the data is received or expecting the receiver to validate the data? i.e. verify it is a valid ticket and not a duplicated etc. I will image it will be just ack but need to confirm.
What is the expected optimal behaviour of ticket submission? Every next next epoch validators (`Œπ`)  submit tickets at and of an epoch and resubmits at start of an epoch in case the expected ring commitment changed?
So validators are expected to receive tickets for two different epoch. In that case, should the ticket submission protocol to include an epoch index to keep things simpler? Otherwise the receiver may need to verify the tickets twice to figure out if it is valid or not. [edited]
2024-09-20 07:53 gav: > <@xlchen:matrix.org> Some question about Safrole ticket submission. https://hackmd.io/@polkadot/jamsnp
> To confirm my understanding first:
> 
> - On each epoch, every next epoch validator (`Œ≥k`) can submit to up two tickets
> - Block authors are incentivized to include up to 16 tickets in extrinsic
> - Potential block authors should maintain an tickets pool and include top tickets when authoring new blocks
> - Tickets are not gossiped. So every next epoch validators should submit their two tickets to every current epoch validators.
> - Next epoch validators shouldn't need to resubmit their tickets or it could be counted as spam?
> - So current validators should persist the pending tickets pool across restarts
> - In order to make it possible for the first block of an epoch to include full 16 tickets, next next epoch validators (`Œπ`) should start generating and submit tickets before they become `Œ≥k`. The ring commitment will depends on `œào` but it is unlikely for it to change at and of an epoch as we are not expecting punishments in more than 99.9% of the time.
> - So validators should be expected to receive tickets for both current and next ring commitment
> 
> And my questions:
> As JAMSNP currently defined, ticket submission seems like is only for 1 ticket only? But validator are almost always want to send two tickets. So better to make it to expect two tickets
> What exactly does the success / bad mean? Ack the data is received or expecting the receiver to validate the data? i.e. verify it is a valid ticket and not a duplicated etc. I will image it will be just ack but need to confirm.
> What is the expected optimal behaviour of ticket submission? Every next next epoch validators (`Œπ`)  submit tickets at and of an epoch and resubmits at start of an epoch in case the expected ring commitment changed?
> So validators are expected to receive tickets for two different epoch. In that case, should the ticket submission protocol to include an epoch index to keep things simpler? Otherwise the receiver may need to verify the tickets twice to figure out if it is valid or not.

davxy: ^^
2024-09-20 08:26 dave: I've got some pending changes to JAMSNP. For Safrole ticket submission I currently have this...

### CE 128/129: Safrole ticket submission

Sharing of a Safrole ticket for inclusion in a block.

Safrole tickets are distributed in the epoch prior to the one in which they are to be used. They
are distributed in two steps. Each ticket is first sent from the generating validator to a
deterministically-selected "proxy" validator. This proxy validator then sends the ticket to _all_
current validators.

The first step should be performed shortly after the connectivity changes for a new epoch are
applied. The index of the proxy validator for a ticket is determined by interpreting the last 4
bytes of the ticket's VRF output as a big-endian unsigned integer, modulo the number of validators
minus 1. The proxy validator is selected from the next epoch's validator list, excluding the
generating validator.

Proxy validators should verify the signature of any ticket they receive, and verify that they are
the correct proxy for the ticket. If these checks succeed, they should forward the ticket to all
current validators. Forwarding should be delayed until a fixed point in the epoch (eg 3 minutes
in), to avoid exposing the timing of the initial message. Forwarding should be spaced out over the
first half of the Safrole lottery period. Forwarding may be stopped if the ticket is included in a
block.

Protocol 128 is used for the first step (generating validator to proxy validator), protocol 129 is
used for the second step (proxy validator to all current validators).

```
Attempt = { 0, 1 }
Ticket = Attempt ++ Signature

Validator -> Validator

--> Ticket
--> FIN
<-- FIN
```

2024-09-20 08:32 xlchen: when does the connectivity change applies? it must happen before the new epoch starts right?
2024-09-20 08:32 dave: > As JAMSNP currently defined, ticket submission seems like is only for 1 ticket only? But
> validator are almost always want to send two tickets. So better to make it to expect two tickets

Might be changed in the full protocol but for simplicity we decided to stick with a single ticket for JAMSNP.

> What exactly does the success / bad mean? Ack the data is received or expecting the receiver to validate the data? i.e. verify it is a valid ticket and not a duplicated etc. I will image it will be just ack but need to confirm.

I've taken out success/bad. Failure should be indicated by resetting/stopping the stream. I think
for Safrole you can finish (= succeed) as soon as you have received the data, ie just ack.

> What is the expected optimal behaviour of ticket submission? Every next next epoch validators (Œπ)
> submit tickets at and of an epoch and resubmits at start of an epoch in case the expected ring
> commitment changed?

I think this is described now.

> So validators are expected to receive tickets for two different epoch. In that case, should the
> ticket submission protocol to include an epoch index to keep things simpler? Otherwise the
> receiver may need to verify the tickets twice to figure out if it is valid or not.

Validators should only expect tickets for the next epoch.

2024-09-20 08:33 dave: > <@xlchen:matrix.org> when does the connectivity change applies? it must happen before the new epoch starts right?

No. I currently have this defined as follows...

### Epoch transitions

At the beginning of a new epoch, validators should wait to apply connectivity changes until both:

- The first block in the epoch has been finalized.
- At least 2 minutes have elapsed since the beginning of the epoch.

This rule is intended to synchronize connectivity changes across validators, making epoch
transitions smoother.

2024-09-20 08:34 dave: FWIW this is still all subject to change...
2024-09-20 08:39 xlchen: i see. I will assume all tickets are for current epoch
2024-09-20 08:41 dave: To be included in current epoch blocks, yeah. I don't think you should get tickets for other epochs unless a node is really confused üòÖ
2024-09-20 09:12 davxy: > <@luke_f:matrix.org> davxy: apologies in advance for the kinda silly question:
> is there ANY CHANCE that the order of gamma_s in tiny/enact-epoch-change-with-no-tickets-4.json is wrong?
> 
> asking because I'm getting different order üòÖ

[@luke_f:matrix.org](https://matrix.to/#/@luke_f:matrix.org) I'll take a look. I'll be afk until tomorrow üòÖ


2024-09-20 12:56 danicuki: I am organizing a JAM meetup in Lisbon on Oct 21th right after ETH Lisbon. The meetup will be at Parity's office and everyone is invited to join. 

https://lu.ma/fqg0ktn0

We are looking for sponsors for foods and drinks. DM me if you are interested 

  ‚Ü≥ 2024-09-20 12:58 rtti-5220: danicuki: for sponsoring, have you checked the events bounty? All the info you might need: 

https://x.com/dotevents_/status/1806020324678349038
  ‚Ü≥ 2024-09-23 19:27 bmaas: Not sure I am going yet, if so I will let you know danicuki 

2024-09-21 02:54 gav: > <@danicuki:matrix.org> I am organizing a JAM meetup in Lisbon on Oct 21th right after ETH Lisbon. The meetup will be at Parity's office and everyone is invited to join. 
> 
> https://lu.ma/fqg0ktn0
> 
> We are looking for sponsors for foods and drinks. DM me if you are interested 
> 

I‚Äôll probably stop by. 
2024-09-23 22:11 celadari: Regarding ticket submission for Safrole, would it make sense to adopt an onion routing approach? Not for initial release but for latter. Each ticket could be sent through 3 different routes, with 3 proxies per route. The message would be encrypted for each proxy along the way, and only the final proxy decrypts the ticket without knowing the original sender.

We can deterministically choose the routes using VRF output for different inputs and require a ring root signature for validation.
  ‚Ü≥ 2024-09-23 22:11 celadari: Regarding the last part to be a bit more specific:
  ‚Ü≥ 2024-09-23 22:11 celadari: idea_routing_anonymous.png
2024-09-23 22:49 gav: This is indeed the plan. Perhaps davxy wants to comment further.
2024-09-24 09:59 davxy: The idea has been considered and maybe, in some variant, will become part of the final protocol for ticket submission. Initially, however, the protocol described by David Emett  (JAMSNP CE 128/129) will be adopted, where the ticket is submitted via a proxy whose identity is pseudo-randomly determined by the ticket ID. This means that anyone can infer the proxy responsible for a given ticket T (i.e., the proxy is f(T) and he knows who is the ticket creator).

In the upcoming weeks, various possibilities will certainly be discussed. However, it is important to understand whether the existence of this "public" actor (aka proxy) who knows the identity of the ticket author is required, for instance, to efficiently submit information directly to the next block author directly via the proxy. Honestly this point is not 100% clear to me yet.

If the presence of a public proxy to the ticket author is indeed required, the relevance of onion routing becomes a bit less relevant. Although it may still useful for some other aspects, such make traffic analysis more complicated. Proxy can still exist even with onion routing, e.g. by disclosing ticket's author identity only to the exit node and reusing the idea of CE 128 for deterministic proxy in function of T.

I would be happy to hear more ideas in this area, indeed!
  ‚Ü≥ 2024-09-24 10:18 celadari: I'm not sure to see why the public actor is required but I'm curious to learn more about it.
Let us know when discussions about it start üôå
2024-09-24 15:14 danicuki: > <@danicuki:matrix.org> I am organizing a JAM meetup in Lisbon on Oct 21th right after ETH Lisbon. The meetup will be at Parity's office and everyone is invited to join. 
> 
> https://lu.ma/fqg0ktn0
> 
> We are looking for sponsors for foods and drinks. DM me if you are interested

I am preparing the agenda for the JAM meetup Oct 21st. If anyone has a proposal for lightning talk / panel, workshop or whatever, DM me.
2024-09-24 17:42 davxy: I have updated the outstanding test vectors PRs (safrole, history, disputes) to include vectors encoded using the new compact integer codec as prescribed by the GP.

- The vectors using the new codec have the extension *.bin. The old *.scale files are temporarily maintained in case anyone is still working with the old codec. These will be removed in the near future.
- Safrole vectors have also been updated in content. The ring-proof backend introduced some internal changes which invalidate the old signatures (and tickets). If you are using `ark-ec-vrfs`, please update to the latest revision, as ticket verification will fail otherwise.
- `ark-ec-vrfs` now provides a function to retrieve the padding point to be used to replace invalid keys when computing the ring commitment (https://github.com/davxy/ark-ec-vrfs/blob/e491b41b48d9132f59ff2a4d4f1c6c3e853deab7/src/ring.rs#L212) [edited]
2024-09-24 18:26 darentuzi: Hi, two questions about preimage lookups for service accounts:
1. Is all the raw data, meaning preimage data itself stored in the preimage dictionary, or can it reference external storage?
2. Is the preimage data being deleted when unrequested, and if not, when requested again, is it available within the service or needs to be supplied from an external source?
2024-09-24 20:16 danicuki: 
2024-09-24 20:16 danicuki: 
2024-09-24 20:17 danicuki: 
2024-09-25 03:11 xlchen: I am trying to figure out what is the best way to know if I am the block author of the next block and it seems a bit tricky for the first block on an epoch. `Œ≥s'` determines the block authors and it is only updated at the first block on an epoch. That means for validators to check if they are the block author, they need to figure out `Œ≥s'` first and then check for it.
2024-09-25 03:29 xlchen: What I really want is at begin of an epoch, check `Œ≥s`, and then I know exactly when I need to spawn the block producing task in this epoch. However this won't work for the edge case.
  ‚Ü≥ 2024-09-25 06:08 celadari: At the begin of a new block the ticket submission period should be over for I think 100 time slots so you should have an updated gamma_s by then I would say. Unless your node has been malfunctioning and two epochs have passed.
Can someone correct me on this one ?
  ‚Ü≥ 2024-09-25 06:08 xlchen: yes but that's the happy path
  ‚Ü≥ 2024-09-25 06:18 celadari: Can you elaborate on the unhappy case ? Fallback mode or divergence with grandpa to solve
  ‚Ü≥ 2024-09-25 06:21 xlchen: fallback mode, punishments, and maybe forks
  ‚Ü≥ 2024-09-25 06:53 celadari: - Fallback mode you should know as well gamma_s because there is a 100 timeslots delay between end of ticket submission and next epoch

- forks are handled with using grandpa. Safrole should make the forks only for one epoch when they happen. Grandpa with most normal tickets should be used

- punishment: I don't know yet
  ‚Ü≥ 2024-09-25 06:58 xlchen: in very extreme case, the end phase could be completely skipped
  ‚Ü≥ 2024-09-25 07:49 celadari: I think if that happens then you should update gamma_s according to what you had before the skipped end phase: can be normal or fallback mode
  ‚Ü≥ 2024-09-25 07:58 xlchen: what I don't want to do is figure out every single edge case and handle them with different code
  ‚Ü≥ 2024-09-25 08:02 celadari: I don't think you need to do this.
I think you need to update gamma_s accordingly after end ticket submission as soon as possible: best is before new epoch but if as you said the whole end phase is skipped then you do it before "taking in" the new block you receive

Does it make sense ?
  ‚Ü≥ 2024-09-25 08:14 xlchen: I don't 100% get it but I ended up wait until last timeslot of an epoch and simulate safrole STF for next block
2024-09-25 06:09 gav: 1. Data available for lookup is always stored in the service account state. 
2. Whether and when it is deleted from service account state is determined according to the relevant logic described in the host function `forget`. Once deleted from state it must be resupplied to the chain if a fresh request arrives.  [edited]
  ‚Ü≥ 2024-09-25 06:12 darentuzi: Are there risks of bloat, or are there limitations to how much data can be put there?
  ‚Ü≥ 2024-09-25 06:16 darentuzi: Thinking about an underlying storage layer for larger amounts of data and the source for resupplying  [edited]
  ‚Ü≥ 2024-09-25 06:57 gav: As you can see if you read the GP, the amount of data a service is able to store for lookup in state is constrained by its account balance. See specifically (94): https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMTEiLCJTZXJ2aWNlIEFjY291bnRzIiwiQWNjb3VudCBGb290cHJpbnQgYW5kIFRocmVzaG9sZCBCYWxhbmNlIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHgxMiBoNiB5NzlhIGZmNyBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeGYxIGhkIHk3YzcgZmYxOCBmczUgZmMwIHNjMCBsczAgd3MwXCI+Il1d
  ‚Ü≥ 2024-09-25 06:59 gav: Lookup can be helpful for data which is regularly needed by Refine as fairly large amounts of data can be stored and retrieving it is almost free. Parachain code is the obvious use-case here.
  ‚Ü≥ 2024-09-25 07:01 gav: However, it is expensive (for the reason you mention: on-chain bloat must be controlled). For use-cases where data can change often or is not used very regularly in Refine, keeping it in the DA system may be better.
  ‚Ü≥ 2024-09-25 07:21 darentuzi: thank you
2024-09-25 07:39 bamzedev: 
2024-09-26 17:03 danicuki: We have a question about the JAM prize payment. Rule 20:

```
Prizes are paid to the earliest Polkadot /
 Kusama account IDs stated in the
 repository's README. In the case of a tie,
 payment is split equally. Local (Swiss) law
 requires that Web3.0 Foundation take
 KYC/AML information on the recipient
 together with proof of account control.
```

What if the prize will be divided between individuals? Even if these individuals create a multisign wallet, the wallet itself does not belong to any specific entity (individual or company). Who should KYC? All multisign signers? Do individuals need to create an entity that "owns" the multisign wallet? [edited]
2024-09-26 17:09 tomusdrw: > <@danicuki:matrix.org> We have a question about the JAM prize payment. Rule 20:
> 
> ```
> Prizes are paid to the earliest Polkadot /
>  Kusama account IDs stated in the
>  repository's README. In the case of a tie,
>  payment is split equally. Local (Swiss) law
>  requires that Web3.0 Foundation take
>  KYC/AML information on the recipient
>  together with proof of account control.
> ```
> 
> What if the prize will be divided between individuals? Even if these individuals create a multisign wallet, the wallet itself does not belong to any specific entity (individual or company). Who should KYC? All multisign signers? Do individuals need to create an entity that "owns" the multisign wallet?

Curious as well. Note that the tokens are also vested so it needs to be not a one-off distribution between multisig members, but rather a 24-months+ active collective
2024-09-26 22:55 gav: > <@danicuki:matrix.org> We have a question about the JAM prize payment. Rule 20:
> 
> ```
> Prizes are paid to the earliest Polkadot /
>  Kusama account IDs stated in the
>  repository's README. In the case of a tie,
>  payment is split equally. Local (Swiss) law
>  requires that Web3.0 Foundation take
>  KYC/AML information on the recipient
>  together with proof of account control.
> ```
> 
> What if the prize will be divided between individuals? Even if these individuals create a multisign wallet, the wallet itself does not belong to any specific entity (individual or company). Who should KYC? All multisign signers? Do individuals need to create an entity that "owns" the multisign wallet?

More of a question for W3F financial. In principle it is a prize, nothing more. W3F will do what it can to make things smooth but don‚Äôt *expect* anything more  than one payment to an account or entity nominated by that person or persons who prove(s) ownership/control/knowledge of codebase. 
2024-09-26 22:55 gav: IANAL but I‚Äôd expect KYC would be on those persons which the W3F could reasonably know or suspect are in receipt of funds. 
2024-09-28 19:09 danicuki: In Formula 139: on part (kv)E, shouldn't this "E" be lowercase as defined in formula 54? 
2024-09-28 19:10 danicuki: 
2024-09-29 09:19 gav: In fact the other way around. E was meant to be upper case. Feel free to make an issue in the repo.  [edited]
2024-09-29 11:28 danicuki: > <@gav:polkadot.io> In fact the other way around. E was meant to be upper case. Feel free to make an issue in the repo.

Do you mean e should be uppercased here: https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiZCIsIkJsb2NrIFByb2R1Y3Rpb24gYW5kIENoYWluIEdyb3d0aCIsIktleSBSb3RhdGlvbiIsWyI8ZGl2IGNsYXNzPVwidCBtMCB4ZmUgaGMgeTRlOCBmZjE1IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4NzEgaGQgeTRlOSBmZjE3IGZzNSBmYzAgc2MwIGxzMCB3czBcIj4iXV0= ?
2024-09-29 11:38 gav: Yes
2024-10-07 03:10 xlchen: A question about timing. Say current time t = 60, timeslot = 10, for block author of timeslot 11, when should it start producing block? what time is the deadline? say we provide 2s for block production (what is the max time allowed for block production?), then the block author should start producing block at t = 66 and sending blocks at t = 68? other validators should receive block by t = 70 and have it confirmed before t = 72?

How about guaranteeing? For guarantors of cores at timeslot 11, what time should it start producing work report and what's the deadline of sending it out? Does it need to make sure the work report is available at t = 66 so the block author can accumulate it in block #11? So it should start the work at t = 60?
2024-10-07 06:57 gav: A block of time slot t = 10 becomes valid once the clock reads 60. On this basis, an optimal block author for t=10 will have sent the block to arrive at all other validator nodes by then. Validators should then have distributed all relevant extrinsic information for this block to arrive in time for the author to include it in a block and then send the necessary block information back to them (we‚Äôre working on merklising the extrinsic commitment so that not the whole block needs to be distributed if the receiver has the various extrinsic components). We‚Äôre still working on having specific timing guidelines as this will be affected by practical matters ; indeed ideal timing probably won‚Äôt be properly fixed until we have the toaster running.  [edited]
2024-10-07 06:57 gav: [@dave:parity.io](https://matrix.to/#/@dave:parity.io) might be able to shed a bit more light. 
2024-10-07 07:09 xlchen: I see. I will put some placeholder values for now. 
2024-10-07 07:52 dave: FWIW, at the moment, our node starts authoring at the start of its timeslot. Guaranteeing is fairly flexible as a block author can include reports from both the current and previous core rotations. I expect guarantor timing will be mostly down to builders as, unless guarantors are already busy with previous packages, there seems little point in waiting to refine a package. As Gav says though I don't think we will have a good idea of when things should be scheduled until we have a test network running, so I would just make sure any values are easy to change.
2024-10-07 08:13 voliva: Hi everyone!

I wanted to share that after reading about decentralized JAM, Whitespace caught my curiosity. So, during my spare time, I decided to give it a try and implemented Keccak-256 in Whitespace. The code is available here under GPLv3: https://github.com/voliva/wsa/blob/main/examples/keccak.ws. It's an initial version, and it may have a few bugs, but for the few words I've tried, it hashes them correctly.

To facilitate this, I've also built a Whitespace assembler/interpreter/debugger, which helped me work on it. It‚Äôs released under the MIT license here: https://github.com/voliva/wsa. Additionally, I've developed a memory layout convention and a "standard library" to make it a bit more practical.

I thought I'd share this in case someone finds it interesting. I don't think I'll be building JAM (probably not even the first milestone) in Whitespace, as I really don't have time for it, but I find it fun to solve small objectives in esoteric languages like these.
  ‚Ü≥ 2024-10-07 08:14 voliva: image-2.png
2024-10-07 10:16 gav: > <@voliva:matrix.org> Hi everyone!
> 
> I wanted to share that after reading about decentralized JAM, Whitespace caught my curiosity. So, during my spare time, I decided to give it a try and implemented Keccak-256 in Whitespace. The code is available here under GPLv3: https://github.com/voliva/wsa/blob/main/examples/keccak.ws. It's an initial version, and it may have a few bugs, but for the few words I've tried, it hashes them correctly.
> 
> To facilitate this, I've also built a Whitespace assembler/interpreter/debugger, which helped me work on it. It‚Äôs released under the MIT license here: https://github.com/voliva/wsa. Additionally, I've developed a memory layout convention and a "standard library" to make it a bit more practical.
> 
> I thought I'd share this in case someone finds it interesting. I don't think I'll be building JAM (probably not even the first milestone) in Whitespace, as I really don't have time for it, but I find it fun to solve small objectives in esoteric languages like these.

awesome :) what's the next thing to implement?
  ‚Ü≥ 2024-10-07 11:01 voliva: I have to read the JAM graypaper again to find achievable goals, maybe ed25519 it would be one of the hard ones, but there could be other easier parts.
Another challenge I'm interested to solve is how to do other IO like network requests, as stdin/stdout is a bit limited üò¨
  ‚Ü≥ 2024-10-07 11:25 gav: fwiw, for M1 you only need block import logic so network wouldn't actually be a requirement 
2024-10-07 19:54 danicuki: Does anybody have the vectorized version of the JAM logo combined with the Polkadot - I found only this one: https://github.com/w3f-webops/graypaper-website/blob/main/src/images/faviconjam.svg ? gav  [edited]
2024-10-07 20:05 gav: There‚Äôs no vectorized logo - it‚Äôs a slightly processed photo of my handwriting on paper. 
2024-10-07 20:05 gav: I can dig out the png though. 
2024-10-07 20:09 tebdev: I plan to use Keccak-256 and other algo from a Crypto Library. Is that allowed?
  ‚Ü≥ 2024-10-07 21:58 xlchen: yes https://hackmd.io/@polkadot/jamprize
  ‚Ü≥ 2024-10-07 23:13 tebdev: > <@xlchen:matrix.org> yes https://hackmd.io/@polkadot/jamprize

Thank you for reminding me of the rules reference. Sorry
2024-10-08 00:01 xlchen: Anyone have started implement some RPC? What will be the best way for us to collaborate it so we all implements a same set of RPC methods?
2024-10-08 00:04 xlchen: There are few key decisions I would like to confirm with everyone before I invest too much time on our RPC implementation :

- Which RPC protocol?
  - JSONRPC
  - gRPC
  - Restful
  - something else?
- How high level should the RPC be?
  - e.g. like Substrate, the RPC provide metadata and raw data and it is up to the SDK to decode the data
    - we don't need metadata here as the types are all spec'ed in GP
  - or make it more complicated but dev friendly by returning typed data directly (e.g. JSON)
2024-10-08 00:09 xlchen: And once we have some RPC implemented, I plan to build some simple TUI/webapp (TDB). Something like substrate telemetry
2024-10-08 01:28 tebdev: Sounds good. I am flexible. You have my proxy since you taking the lead.
2024-10-08 05:01 xlchen: I think we will go for JSONRPC + HTTP. i.e. something similar to Substrate for the reasons:

- Target users are only JAM devs and network operators. Note: dapp devs, service providers (e.g. CEX), wallets are NOT target users. They should not deal with JAM chain directly. Therefore most of the downsides of the existing Substrate JSONRPC doesn't apply (e.g. requires heavy SDK to decode data returned from JSONRPC). Block explorer / Indexer may have some interests on fetching JAM chain data but it is still only for devs only. No user should worry about JAM chain data.
- Most if not all JAM devs will already be familiar with JSONRPC.
- JSONRPC with WebSocket supports pushing, which is a very useful feature. RESTful is out of option then. We could do RESTful + WebSocket but then it will be extra work for benefits not super relevant. This RPC does not need to be easy to use.
- JSONRPC is not efficient. But under the context of JAM chain, that's something we can deal with. We may want to have some HTTP methods for methods that needs to return large binary payload to avoid the overhead of hex encode / decode the binary data.

2024-10-08 08:35 tomusdrw: I wonder if it's really worth to have every client build it's own RPC (especially based on JSON+HTTP). Have you considered writing a standalone application that would connect to the node via mmap/IPC or some lower-than-http-and-ws-level API and just speak JAM-codec data, possibly just a subset of JAMSNP?
I think that would save a lot of time to implement JSON serialisation and could be re-used between client implementaitons.
2024-10-08 08:36 tomusdrw: Initially it would expose JSONRPC over HTTP/WS just for devs, but in future it could evolve into a user-facing RPC
2024-10-08 09:56 xlchen: Substrate RPC are exposing raw data directly and we can do similar thing here so we don‚Äôt need to define the JSON shape
2024-10-08 09:57 xlchen: JAM chain are not for users to access so no need to worry about user friendliness. for example, exchanges only integrate with parachains/jam services but never need to deal with JAM chain
2024-10-08 09:59 xlchen: there must be a way to get data out of the node for diagnostic purpose so all the implementations have to implement some sort of it
2024-10-08 10:00 xlchen: we might as well make the interface to be the same so we can reuse tools. that‚Äôs one of the reason I think JSONRPC is better compared to to gRPC due to simplicity 
2024-10-08 10:06 oliver.tale-yazdi: > <@xlchen:matrix.org> There are few key decisions I would like to confirm with everyone before I invest too much time on our RPC implementation :
> 
> - Which RPC protocol?
>   - JSONRPC
>   - gRPC
>   - Restful
>   - something else?
> - How high level should the RPC be?
>   - e.g. like Substrate, the RPC provide metadata and raw data and it is up to the SDK to decode the data
>     - we don't need metadata here as the types are all spec'ed in GP
>   - or make it more complicated but dev friendly by returning typed data directly (e.g. JSON)

JSONRPC + Websocket sounds good to me, i would integrate this into our node if it existed. About metadata: for most of them we probably dont need it, only if we want to have extensions or something later that should be forward-compatible with future clients. I think for the beginning maybe not needed?
2024-10-08 10:08 tomusdrw: > <@xlchen:matrix.org> Substrate RPC are exposing raw data directly and we can do similar thing here so we don‚Äôt need to define the JSON shape

I get your point. What I'm arguing about is:
1. Why wrap binary data into JSON if we can just return binary data directly.
2. Why introduce another layer of API methods if we have JAMSNP already that should cover the case of getting and even announcing required raw data from the node.
3. Why integrate HTTP/WS server into the node if this can be a middleware that's shared between all implementations.

So my idea would be to:
1. define a low-level IPC/mmap socket that can speak JAMSNP (or some subset of it) (every implementation)
2. have a "RPC app" connect to that socket and expose JSONRPC or whatever more human/browser friendly protocol to display the data (shared between implementations)
2024-10-08 10:16 emielsebastiaan: JSON introduces an extra layer of opinionation that you don‚Äôt want for testing purposes I suppose. All implementation teams should be capable of working with the codec data.
2024-10-08 10:18 xlchen: I see. JAMSNP is basically jamcodec over QUIC. Then we can probably find some existing proxy convert QUIC to websocket or the node can just doing jamcodec over websocket directly to serve requests to browser [edited]
2024-10-08 10:21 xlchen: the only downside is that to build a dashboard, we need to implement jamcodec in JS to parse the data. but hopefully one of the nodejs implementation team can provide the codec part for use
2024-10-08 10:25 tomusdrw: > <@xlchen:matrix.org> I see. JAMSNP is basically jamcodec over QUIC. Then we can probably find some existing proxy convert QUIC to websocket or the node can just doing jamcodec over websocket directly to serve requests to browser

Either this or have the nodes create this IPC/memory-mapped file endpoint that can be used. You don't need QUIC for that, pure in-out, new-line delimited, etc.
2024-10-08 10:26 xlchen: that will require two binary to run side by side, which may cause some trouble on some deployment setup
2024-10-08 10:27 tomusdrw: > <@xlchen:matrix.org> the only downside is that to build a dashboard, we need to implement jamcodec in JS to parse the data. but hopefully one of the nodejs implementation team can provide the codec part for use

Ah, that's true. That could either be done in the shared middleware or if there is something that could be used out of the box to just translate the transport then yes, that would be in the app.
We do have the codec ready and we happen to write in TypeScript - I'm happy to publish it separately to npm.js It wasn't my intention to plug our solutions stuff here, so sorry about that.
2024-10-08 13:12 tebdev: > <@xlchen:matrix.org> There are few key decisions I would like to confirm with everyone before I invest too much time on our RPC implementation :
> 
> - Which RPC protocol?
>   - JSONRPC
>   - gRPC
>   - Restful
>   - something else?
> - How high level should the RPC be?
>   - e.g. like Substrate, the RPC provide metadata and raw data and it is up to the SDK to decode the data
>     - we don't need metadata here as the types are all spec'ed in GP
>   - or make it more complicated but dev friendly by returning typed data directly (e.g. JSON)

Please excuse, I am a little confused. How will this help collaboration and avoid feedback becoming collusion? What is the incentive?
2024-10-08 13:20 oliver.tale-yazdi: > <@tebdev:matrix.org> Please excuse, I am a little confused. How will this help collaboration and avoid feedback becoming collusion? What is the incentive?

From what i understood this targets non-GP functionality, like logs monitoring and telemetry etc
2024-10-08 13:33 tebdev: Please excuse, could logs/monitoring/telemetry indicate health and status. If problem detected and team T(i) makes suggestion to T(i+1) could that be collusion? The incentive of "prize reduction to boost network security" may need clarification so we can collaborate without a lawyer ;) If I am reading rules wrong, please correct me.
2024-10-08 13:40 oliver.tale-yazdi: yea it could be good to have some examples of things that teams are allowed to work on together (if any). [edited]
2024-10-08 13:42 tebdev: I am eager to collaborate - Strength in Numbers. The prize is not my primary motivation, but it is an incentive ;)
2024-10-08 16:03 lucas: Any Gossamer team members interested in chatting? I am interested in networking with the Gossamer team. 
  ‚Ü≥ 2024-10-16 15:15 p1sar: Hey hey, yeah, we can have a chat maybe you can drop a message to @jimboj21:matrix.org
2024-10-08 17:03 gav: Anything not specified nor referenced in the GP is probably fine. If you don‚Äôt need to do it for a milestone then it‚Äôs fine to chat about.  [edited]
2024-10-08 17:06 gav: Examples: database structure and formats, CLI arguments, RPCs, xUIs. 
2024-10-08 20:56 tebdev: > <@gav:polkadot.io> Examples: database structure and formats, CLI arguments, RPCs, xUIs.

Sounds reasonable. Focus on interface agreements and treat GP as black box. There is value in that.
2024-10-11 12:58 sebastian: > <@danicuki:matrix.org> We have a question about the JAM prize payment. Rule 20:
> 
> ```
> Prizes are paid to the earliest Polkadot /
>  Kusama account IDs stated in the
>  repository's README. In the case of a tie,
>  payment is split equally. Local (Swiss) law
>  requires that Web3.0 Foundation take
>  KYC/AML information on the recipient
>  together with proof of account control.
> ```
> 
> What if the prize will be divided between individuals? Even if these individuals create a multisign wallet, the wallet itself does not belong to any specific entity (individual or company). Who should KYC? All multisign signers? Do individuals need to create an entity that "owns" the multisign wallet?

Hi danicuki. For payments, see rule 8.5 of the [T&Cs](https://github.com/w3f/jam-milestone-delivery/blob/main/docs/T%26Cs.md). As for KYC, all beneficiaries have to KYC if no legal entity exists.
2024-10-11 14:23 dave: I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

2024-10-11 14:26 dave: I do not intend to change this any more, except to correct errors, and to add stream protocols for Grandpa (which is not currently specified). Any changes for e.g. efficiency will be made in the full network protocol, which won't be defined any time soon
  ‚Ü≥ 2024-10-12 01:27 sourabhniyogi: David Emett: Thank you for putting JAMSNP together with high precision, we can execute on this.  

One issue we're looking is that in CE 137 / 138  
https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-137-shard-distribution

you have  Assurers *pulling* from Guarantors by "Shard Index" rather than Guarantors *pushing* to Assurers.   GP uses "distribute" + "send" vocabulary here:
* Section 11: "At this point, the work-package is erasure coded into a multitude of segments and each segment *distributed* to the associated validator who then attests to its availability through an assurance placed on-chain"

* Section 14: "Validators are incentivized to **distribute** each newly erasure-coded data chunk to the relevant validator, .... Given our work-package p, we should therefore **send** the corresponding work-package bundle chunk and exported segments chunks to each validator whose keys are together with similarly corresponding chunks for imported, extrinsic and exported segments data, such that each validator can justify completeness according to the work-report‚Äôs erasure-root.

Is this done as a simplification in your JAMSNP?  Or is there a technical reason for switching from GP's "push" to your "pull" in CE 137?

In August @gav suggested this sharing (justified) DA chunks:  
```
Vec<Hash> ++ Blob ++ Vec<Hash> ++ Vec<SegmentChunk> ++ Vec<Hash>

The Vec<Hash> will just be complementary Merkle-node-hashes from leaf to root.  The first will contain hashes for the blob-subtree, the second for the segments subtree and the third for the super-tree.
```
which appeared to us to be "push" oriented and consistent with the GP's active "distribute/send" in Section 11/14?
  ‚Ü≥ 2024-10-12 08:36 dave: > <@sourabhniyogi:matrix.org> David Emett: Thank you for putting JAMSNP together with high precision, we can execute on this.  
> 
> One issue we're looking is that in CE 137 / 138  
> https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-137-shard-distribution
> 
> you have  Assurers *pulling* from Guarantors by "Shard Index" rather than Guarantors *pushing* to Assurers.   GP uses "distribute" + "send" vocabulary here:
> * Section 11: "At this point, the work-package is erasure coded into a multitude of segments and each segment *distributed* to the associated validator who then attests to its availability through an assurance placed on-chain"
> 
> * Section 14: "Validators are incentivized to **distribute** each newly erasure-coded data chunk to the relevant validator, .... Given our work-package p, we should therefore **send** the corresponding work-package bundle chunk and exported segments chunks to each validator whose keys are together with similarly corresponding chunks for imported, extrinsic and exported segments data, such that each validator can justify completeness according to the work-report‚Äôs erasure-root.
> 
> Is this done as a simplification in your JAMSNP?  Or is there a technical reason for switching from GP's "push" to your "pull" in CE 137?
> 
> In August @gav suggested this sharing (justified) DA chunks:  
> ```
> Vec<Hash> ++ Blob ++ Vec<Hash> ++ Vec<SegmentChunk> ++ Vec<Hash>
> 
> The Vec<Hash> will just be complementary Merkle-node-hashes from leaf to root.  The first will contain hashes for the blob-subtree, the second for the segments subtree and the third for the super-tree.
> ```
> which appeared to us to be "push" oriented and consistent with the GP's active "distribute/send" in Section 11/14?

I did this for simplicity. Pretty sure the final protocol will be a push protocol. That said I think Gav is keen to change it even for JAM-SNP.
  ‚Ü≥ 2024-10-12 18:58 sourabhniyogi: Got it.  We did a push method but the pull is a great simplification for PoC work, that's great.  We can reimplement in pull, no problem.

If you could map these terms into GP symbols that probably will help

Bundle Shard, 
[Segment Shard], 
Justification = [Hash OR (Hash ++ Hash)]

We are pretty sure we know the first 2 having implemented it and drawn our own diagrams... but are not sure whats going on with the OR üòÖ and having confirmations that map onto our various diagrams will help us and everyone else attack this head on üòÄ

  ‚Ü≥ 2024-10-12 21:08 dave: [Segment Shard] is simply a sequence of 12-byte segment shards, with no length prefix (in cases where a length prefix is required this is made explicit with "len++")
  ‚Ü≥ 2024-10-12 21:16 dave: [Hash OR (Hash ++ Hash)] is effectively just a sequence of 32-byte hashes, also with no length prefix. The OR (Hash ++ Hash) bit is because for the final item of the proof/justification you will in most cases need two hashes: a work-bundle shard hash and a segment shard merkle root
  ‚Ü≥ 2024-10-12 21:17 dave: The erasure root is defined here in the GP https://graypaper.fluffylabs.dev/#/c71229b/1b76001bba00
  ‚Ü≥ 2024-10-12 21:19 dave: And the proofs should be built as per the function T in the General Merklization appendix. Note that the return of this function is [H OR Y_n] where n is the byte length of the leaves of the tree
  ‚Ü≥ 2024-10-12 21:20 dave: In the case of the erasure root merkle tree, Y_n = Y_64 = Hash ++ Hash
  ‚Ü≥ 2024-10-12 21:23 dave: A Bundle Shard is simply a raw byte sequence, corresponding to one of the items returned by C_‚åà|b|/W_E‚åâ(P_W_E(b)) in the bit of the GP linked above
  ‚Ü≥ 2024-10-12 21:23 dave: That is, one of the shards resulting from erasure coding a work-package bundle
  ‚Ü≥ 2024-10-12 21:32 dave: > <@dave:parity.io> [Segment Shard] is simply a sequence of 12-byte segment shards, with no length prefix (in cases where a length prefix is required this is made explicit with "len++")

These segment shards are constructed by the C_6^#(s ‚å¢ P(s)) expression in the bit of the GP linked above
  ‚Ü≥ 2024-10-14 17:22 sourabhniyogi: We'll give it a shot and follow up, thank you for explaining!

Some quick+easy questions:

1. You don't use JAM Codec  except the "As in GP" cases (UP 0 - Header, CE 128 - Block, CE 133 - Work Package, CE 134-Work Package Bundle, CE 135+136 - Work Report) -- so teams who pass the codec test (which cover all of these except "Work Package Bundle") have little-to no "extra" codec work to do since everything else is just byte-level work.  Can you confirm this?
2. What is the type of `len` in the `len++` prefixes?   Is it u32/... or is it following JAM codec (being the only other exception to (1))?
3. Why is CE 136 needed if the block contains the work report within a guarantee, contained within a block?  See https://github.com/w3f/jamtestvectors/blob/master/codec/data/guarantees\_extrinsic.json#L3
4. What should happen where some object (Block, Work Report, Bundle Shard, Audit Shard, Segment Shard, Preimage) is "not found"?
5. Since most teams haven't gotten to auditing+GRANDPA implementations yet, is the expected behavior of handshake to dump of headers from genesis (the only finalized states) to the tip?
6. Many of us grew up with easily shared "curl" for JSON-RPC calls -- what do you recommend as an equivalent tool for QUIC testing?  Specifically, for CE 133, is there some way to have an easy to use builder package submission that eliminates any need to have JSON-RPC `jam_submitWorkPackage` methods?
7. Is feedback like "It might be nice to have Work Report at the end for CE 135" useful?
8. You didn't have "Ticket" as one of the "As in GP" cases because you felt the need to split out "Epoch" in there.  Would you agree that the JAM-codec encoded Ticket should have "Epoch" so "CE 131/132" could have "Ticket" transmission be "As in GP"?
 [edited]
  ‚Ü≥ 2024-10-14 17:31 dave: > You don't use JAM Codec except the "As in GP" cases (UP 0 - Header, CE 128 - Block, CE 133 - Work Package ), CE 134-Work Package Bundle, CE 135+136 - Work Report) -- so teams who pass the codec test have no "extra" codec work to do since everything else is just byte-level work. Can you confirm this?

Not sure that's true. Sequences and integers are encoded as per the JAM codec ("Encoding is as per the serialization codec defined in the gray paper"). The things where I've said "As in GP" are simply entire structures that are already well-defined in the GP.
  ‚Ü≥ 2024-10-14 17:32 dave: > What is the type of len in the len++ prefixes? Is it u32/... or is it following JAM codec (being the only other exception to (1))?

As in the JAM codec; `len++` is the same as the up/down arrow symbol in the GP. Maybe there is a unicode character for that symbol that I can use instead.
  ‚Ü≥ 2024-10-14 17:36 dave: > Why is CE 136 needed if the block contains the work report within a guarantee, contained within a block?

That's currently how blocks are defined in the GP, but Gav had tentatively agreed to change blocks to only contain work-report hashes, to improve distribution efficiency (work-reports should be distributed to all validators via CE 135, so also distributing them as part of blocks is quite wasteful). Either this change will get made in the GP or the SNP will need updating.
  ‚Ü≥ 2024-10-14 17:41 dave: > What should happen where some object (Block, Work Report, Bundle Shard, Audit Shard, Segment Shard, Preimage) is "not found"?

Simply stop/reset the stream: "Unless otherwise specified, resetting/stopping of a CE stream by the stream initiator should be considered cancellation of the request, and resetting/stopping of a stream by the stream acceptor should be considered rejection of the request or failure to process the request". QUIC allows an error-code to be passed when stopping/resetting a stream; currently, I've not defined error codes, but it may prove useful to define some in the future.
  ‚Ü≥ 2024-10-14 17:45 dave: > Since most teams haven't gotten to auditing+GRANDPA implementations yet, is the expected behavior of handshake to dump of headers from genesis (the only finalized states) to the tip?

We've implemented a dummy finalizer which simply finalizes blocks which have at least 5 descendants. I don't think we'll specify this anywhere but something like this should do until Grandpa is in place. Note that the handshake should only include _leaves_, so even in the case where no finality has occurred it would only include the tips of all known forks
  ‚Ü≥ 2024-10-14 17:48 dave: > Many of us grew up with easily shared "curl" for JSON-RPC calls -- what do you recommend as an equivalent tool for QUIC testing? Specifically, for CE 133, is there some way to have an easy to use builder package submission that eliminates any need to have JSON-RPC jam_submitWorkPackage methods?

We've added an RPC like that to our node. Don't think a tool like this exists at the moment unfortunately, but if someone wants to make one... ;)
  ‚Ü≥ 2024-10-14 17:50 dave: > Is feedback like "It might be nice to have Work Report at the end for CE 135" useful?

Sure, you should be able to open issues on the repo for things like this.
  ‚Ü≥ 2024-10-14 17:55 dave: > You didn't have "Ticket" as one of the "As in GP" cases because you felt the need to split out "Epoch" in there. Would you agree that the JAM-codec encoded Ticket should have "Epoch" so "CE 131/132" could have "Ticket" transmission be "As in GP"?

I think I didn't say "as in GP" in this case because the definition of a ticket is so simple. The epoch index isn't really required, as it's implied by the time at which the ticket is sent/received, but I figured it was sensible to include it anyway as a sanity check. I'll reword things a bit to clarify that the rest of the ticket _is_ as in the GP.
  ‚Ü≥ 2024-10-14 18:44 dave: I've clarified things a bit in the SNP doc, note that assurances currently aren't exactly as in the GP as the validator index is implicit
  ‚Ü≥ 2024-10-24 04:30 sourabhniyogi: > <@dave:parity.io> We've implemented a dummy finalizer which simply finalizes blocks which have at least 5 descendants. I don't think we'll specify this anywhere but something like this should do until Grandpa is in place. Note that the handshake should only include _leaves_, so even in the case where no finality has occurred it would only include the tips of all known forks

Alright we did the same "dummy finalizer" and since we're closing in on Recent Blocks/C3=Beta we can attack Section 18 "Beefy Distribution".  Is there going to be some on chain aggregation of BLS Signatures every epoch or something like that?  If so, don't we need a CE for individual sigs to be gossiped around.   If not, where do these go?

https://graypaper.fluffylabs.dev/#/439ca37/1e88001e8f00

  ‚Ü≥ 2024-10-24 07:34 dave: Something will be needed but as with Grandpa, not specified yet
  ‚Ü≥ 2024-10-24 09:44 gav: > <@dave:parity.io> Something will be needed but as with Grandpa, not specified yet

The beefy signatures aren‚Äôt likely to be aggregated on-chain. 
  ‚Ü≥ 2025-04-24 10:16 knight1205: Any updates to this? Till now we only have pull protocol. I guess each assurer have to request chunks when it receives report? 

Shouldn't the guarantor itself ensure that each validator receives chunk when it is erasure coded as per GP?
  ‚Ü≥ 2025-04-25 13:12 knight1205: David Emett: Do you have any updates on this?
  ‚Ü≥ 2025-04-25 13:15 dave: Almost certainly there will be a push protocol in the final network protocol. Not intending to change SNP though.
  ‚Ü≥ 2025-04-25 13:16 knight1205: Alright. Thanks for the confirmation.
  ‚Ü≥ 2025-04-25 15:51 knight1205: David Emett: Could you please elaborate on how is shard index mapped to a particular validator at time of distribution? Like which particular validator will recive which particular shard?
  ‚Ü≥ 2025-04-25 15:54 dave: Hmm good question, not sure if this is documented anywhere!
  ‚Ü≥ 2025-04-25 16:07 dave: So shard index = ((core index * systematic threshold) + val index) % num vals, will add this to the SNP doc
  ‚Ü≥ 2025-04-25 16:08 dave: core index meaning the core the package was refined on
  ‚Ü≥ 2025-04-25 16:09 dave: systematic threshold meaning the minimum number of shards required to reconstruct, this is 342 with the "full" params, 2 with the "tiny" params
  ‚Ü≥ 2025-04-25 16:34 dave: I've added a section to the SNP doc covering this, see https://github.com/zdave-parity/jam-np/blob/main/simple.md
  ‚Ü≥ 2025-04-25 16:34 dave: ("Shard assignment" section)
  ‚Ü≥ 2025-04-25 17:36 jaymansfield: Oh good to know! I previously assumed shard index = validator index.
  ‚Ü≥ 2025-04-25 17:37 knight1205: Thanks a ton!!
  ‚Ü≥ 2025-04-25 17:53 knight1205: >shard index = validator index

in that case few initial nodes will receive too many requests to handle, and they will form most traffic for an epoch for responding to them.
2024-10-11 14:26 dave: AFAIK Gav does not intend to include this initial "simple" network protocol in the Gray Paper; only the full network protocol will be included, once it has been defined
2024-10-11 14:27 dave: So as far as the simple protocol is concerned, the linked repo can be considered definitive
2024-10-11 15:25 oliver.tale-yazdi: > <@dave:parity.io> I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

Included it here: https://docs.jamcha.in/advanced/networking/SNP  
I will try to keep aggregating all non-graypaper docs in there for easy discovery in the future 
  ‚Ü≥ 2024-10-11 15:26 dave: Ah, thanks!
2024-10-11 22:55 danicuki: Shouldn't this test vector have an error code? 
infinite: 1, halt: 2, bad: 3, big: 4

https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_result_1.json

(panic: null) should be (panic: <number>) 

or am I missing something?
2024-10-11 23:01 rick: Generally speaking they are "syntactically correct only" according to the README, I took that to mean per the binary format it decodes.. 

In this case, WorkExecResult in the ASN defines panic as null and not having a byte sequence: 

https://github.com/w3f/jamtestvectors/blob/master/codec/schema.asn#L93

The only one that has a specified by sequence is the "ok" result. So `"panic": null` looks correct to me as none of the errors have byte sequences.  [edited]
2024-10-11 23:10 danicuki: understood. A suggestion for changing this would be

WorkExecResult ::= CHOICE {
ok \[0\] ByteSequence,
error \[1\] INTEGER
}

and return the error number:
out\_of\_gas: 1, panic: 2, bad-code: 3, code-oversize: 4

because the way it seems ambiguous. E.g. when bad-code is not defined, it is null, as well as the panic being explicitly defined as null [edited]
2024-10-11 23:20 rick: > <@danicuki:matrix.org> understood. A suggestion for changing this would be
> 
> WorkExecResult ::= CHOICE {
> ok \[0\] ByteSequence,
> error \[1\] INTEGER
> }
> 
> and return the error number:
> out\_of\_gas: 1, panic: 2, bad-code: 3, code-oversize: 4
> 
> because the way it seems ambiguous. E.g. when bad-code is not defined, it is null, as well as the panic being explicitly defined as null

When it's an error, the binary encodes 0x01, 0x02, 0x03, or 0x04. When it's not, it encodes 0x00 [len encoding] [bytesequence]. This is proposing  0x01 [4 byte integer], so an additional 4 bytes when there is an error. That doesn't seem unreasonable to me, but worth mentioning. 
2024-10-12 08:41 danicuki: > <@rick:carback.us> When it's an error, the binary encodes 0x01, 0x02, 0x03, or 0x04. When it's not, it encodes 0x00 [len encoding] [bytesequence]. This is proposing  0x01 [4 byte integer], so an additional 4 bytes when there is an error. That doesn't seem unreasonable to me, but worth mentioning.

Understood. The binary indeed is better to keep small as you mentioned. I was just wondering if there is another way of the json be more intuitive. 
2024-10-12 11:10 danicuki: rick do you know whether the `work_item` and `work_package` test vectors already updated to the latest GP version (0.4.1)?
2024-10-12 14:05 rick: > <@danicuki:matrix.org> rick do you know whether the `work_item` and `work_package` test vectors already updated to the latest GP version (0.4.1)?

No, sadly I am just a lowly implementer like yourself üòÖ
2024-10-15 14:45 luke_f: Hello.
is chapter 19, Grandpa and the Best chain part of the requirements for milestone 1?
2024-10-16 09:03 gav: No. 
2024-10-16 09:05 gav: > <@danicuki:matrix.org> rick do you know whether the `work_item` and `work_package` test vectors already updated to the latest GP version (0.4.1)?

I expect they‚Äôre still 0.3 since we have not yet finished the changes for 0.4 internally yet. 
2024-10-16 09:07 gav: Fwiw, I‚Äôll be bringing a few limited-edition 0.4.2 ‚ÄúLisbon‚Äù gray paper prints to the Monday night Lisbon Jam meetup. 
2024-10-16 13:24 danicuki: For those JAM implementors who will be at the meetup next Monday, would be nice to have you for 10min on stage sharing your experience with the audience. Please reach out to me ASAP so I can organize the agenda.  
2024-10-16 13:28 danicuki: From what I saw in the event subscription, we will have people from these teams:
PyJAMaz, JAM Zig, GrayMatter, Gossamer and Jamixir. Please reach out
  ‚Ü≥ 2024-10-16 15:13 p1sar: No one from Gossamer probably will join
  ‚Ü≥ 2024-10-17 16:36 lucas: Kyrylo Pisariev: noticed a message from you in notifications, can't see it in the client. Feel free to message me if you'd like to chat further.  There may be some issue with my client with receiving messages properly. Are you also on Discord or another channel?  
2024-10-17 16:32 dave: > <@dave:parity.io> I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

FYI I've made a fix to the epoch transition section and tweaked relevant bits of the Safrole ticket protocol section. Diff here: https://github.com/zdave-parity/jam-np/commit/6d2cba57f45fb1af52baab6618c9a32f71dc185b
2024-10-17 19:56 stanleyli: Hi David Emett (also davxy), sorry I still have questions about work package and work package bundle:

(1) For the import_segments sitting inside of work_item. what's the definition of tree_root & index in import_segments? Is the tree_root here referring to certain work report's exported_segment_root and exported_segment_idx, which will include justification going up erasure_root(u), or is this are the exported_segment_root with justification going up to expoerted_segment_root(e)?

https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_package.json#L22-L62
{
  "tree_root": "0x461236a7eb29dcffc1dd282ce1de0e0ed691fc80e91e02276fe8f778f088a1b8",
  "index": 0
}

(2) When looking at published codec data, I can see both work package have workItem containing importedSegment always starting from index 0 ... up to 3 with no gap. Is it a coincidence, or index here actually mean the index within a workItem?

(3) In CE134, you mentioned "All import segments have been retrieved..." and "a full work-package bundle is sent, along with any necessary work-package hash to segment root mappings". [Work Package Hash ++ Segment Root] how does this allow other guarantor to validate anything? Also what does the original Guarantor have to do to get the exportedSegment, by doing CE 139?

(4) Is there a work_package_bundle data available so we can make sure we got the format correct conforming to 14.1.1 in GP 0.4.2 and your jam_np?
  ‚Ü≥ 2024-10-17 20:55 dave: > Is the tree_root here referring to certain work report's exported_segment_root and exported_segment_idx

Yes.
  ‚Ü≥ 2024-10-17 20:58 dave: > which will include justification going up erasure\_root(u), or is this are the exported\_segment\_root with justification going up to expoerted\_segment\_root(e)

Not sure I understand what you're asking here. Individual segment shards can be proven up to the erasure root. Reconstructed segments can be proven up to the segment root. These proofs of segments up to the segment root are packed into proof pages and erasure coded alongside the segments. When you fetch the shards for a segment and reconstruct it, you will also need to fetch the shards for the relevant proof segment and reconstruct it in order to be able to (a) confirm that the segment was reconstructed correctly and (b) prove this to auditors [edited]
  ‚Ü≥ 2024-10-17 21:04 dave: > (2) When looking at published codec data, I can see both work package have workItem containing importedSegment always starting from index 0 ... up to 3 with no gap. Is it a coincidence, or index here actually mean the index within a workItem?

This sounds like a coincidence to me, but I am not really familiar with the released test vectors.
  ‚Ü≥ 2024-10-17 21:07 dave: > how does this allow other guarantor to validate anything?

The other guarantor can check the work-package in the same way the original guarantor checked it when receiving it from the builder. It doesn't need to fetch the import segments though, as the work-package bundle should contain these plus proofs of them; the logic for verifying the import segments can be the same as for auditors.

If you mean how should the WPH->SR mapping be checked, then the answer can simply be by constructing a mapping in the same way the original guarantor did and seeing if it matches. The point of sending this mapping is just to avoid wasting time in the case where the guarantors don't agree on a mapping. [edited]
  ‚Ü≥ 2024-10-17 21:14 dave: > Also what does the original Guarantor have to do to get the exportedSegment, by doing CE 139?

Yes, exactly.
  ‚Ü≥ 2024-10-17 21:14 dave: > Is there a work_package_bundle data available so we can make sure we got the format correct conforming to 14.1.1 in GP 0.4.2 and your jam_np?

I don't know, sorry. I'll leave this one for davxy
  ‚Ü≥ 2024-10-17 22:11 stanleyli: I believe you are describing the "H‚äû" variant of import_data_segment_i - which guarantors can fetch data using (exporting_work_package, exporting_segment_idx).  That makes sense.

But for the regular (H,i) case, which I think it's the hash is the segmentroot of a single segment itself? In this case, how can guarantor recover the segment as using this segmentRoot alone if builder only provide the guarantor single segmentRoot?

I think the more difficult case is recovering  exported segments using its own segement root and I don't know how guarantor can get such mapping
  ‚Ü≥ 2024-10-17 22:11 stanleyli: https://graypaper.fluffylabs.dev/#/293bf5a/19a00019a500
  ‚Ü≥ 2024-10-17 22:14 dave: For the H‚äû variant the first thing guarantors should do is map the work-package hash to a segment root, making it the same as the segment root case
  ‚Ü≥ 2024-10-17 22:15 dave: A segment root is not the hash of a single segment, it is the root of the merkle tree of the segments exported by some work package. The work-report for the package contains this segment root.
  ‚Ü≥ 2024-10-17 22:17 dave: To fetch a particular import segment, you need to map the segment root to an erasure root and a set of assurers, request appropriate segment shards from these assurers, and reconstruct
  ‚Ü≥ 2024-10-17 22:18 stanleyli: oh so you are referring to this root: https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_report.json#L6?
  ‚Ü≥ 2024-10-17 22:18 dave: In order to map segment root to erasure root + assurers, you will need to keep a record of all the work-reports you have seen in the past ~28 days in a database. A work-report associates work-package hash + segment root + erasure root + timeslot
  ‚Ü≥ 2024-10-17 22:19 dave: (Obviously you don't need to keep the entire work reports, just these bits of information from them)
  ‚Ü≥ 2024-10-17 22:20 dave: > <@stanleyli:matrix.org> oh so you are referring to this root: https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_report.json#L6?

Yes, exports_root = segment root
  ‚Ü≥ 2024-10-17 22:27 dave: I should probably have used the term "segments-root" in the SNP doc, will fix this
  ‚Ü≥ 2024-10-17 22:32 stanleyli: Originally I was thinking about the case when a builder submit a WP for processing, it can store the result as segments [G] ... it seems natural from PVM exception's perspective to have exportSegment maps to something that's H(exportSegment) and then continue using the segment by requesting the segment using H(exportSegment) in the next refine WP. But looks like you are saying Builder must gather the WP to recover the "segment_root, idx" in order to use in next import?
https://graypaper.fluffylabs.dev/#/293bf5a/309102309102
  ‚Ü≥ 2024-10-17 22:35 dave: I think one reason it's not specified this way is that you would need to remember ~2000x as many hashes -- each work-package can export ~2000 segments
  ‚Ü≥ 2024-10-17 22:36 dave: So instead of remembering the hash of each exported segment, we just remember the merkle root of all the up-to 2000 segments, and require importing work-packages to specify this root plus the index of the segment they want
  ‚Ü≥ 2024-10-17 22:39 stanleyli: thanks for your explanation. it makes sense now
  ‚Ü≥ 2024-10-17 22:40 dave: Re the PVM import function, I'm not really familiar with how that works
  ‚Ü≥ 2024-10-17 22:44 dave: Looks like you just specify the index of the import segment in the manifest that you want though
  ‚Ü≥ 2024-10-17 22:44 dave: So no hashes involved
  ‚Ü≥ 2024-10-17 23:00 stanleyli: Originally I thought having "constant/stable" identifier -- where correctness of the segment can be verified by doing H(recovered\_data) in pvm (similar to how work\_pacake\_hash can be used  identify workpackage\_byte or codeHash -> codeBlob  would be straight forward). But I understand your concerns of having to memorize 2k hash. 

In our implementation, we decided to provide segmentRoot for each segment\_shard to enable direct segment fetch. This endup being quite wasteful since the shard is only 12 bytes. We will remove it and follow your design. 

Our remaining question is the size of pageproof: https://graypaper.fluffylabs.dev/#/293bf5a/1a4f001a5100

 Is the ‚Üïs here the actual segment or the segmentHash? If it's segment, then each element within the pageproof (encode as 6Hash + G) will make this pageproof super large (up to 64G).

Can you predict the size of pageproof? I think you might be saying that pageProof will not include the segment itself?  which is different than what I see in eq 196
 [edited]
  ‚Ü≥ 2024-10-17 23:06 dave: The function P which produces the proof pages takes the sequence of exported segments (the actual segments, not their hashes), and produces a sequence of proof segments
  ‚Ü≥ 2024-10-17 23:06 dave: The number of proof segments is ceil(number of exported segments / 64)
  ‚Ü≥ 2024-10-17 23:08 dave: Though I agree that something looks wrong here
  ‚Ü≥ 2024-10-17 23:09 dave: I think some hash calls are missing in P
  ‚Ü≥ 2024-10-17 23:10 dave: Or perhaps P should take the segment hashes instead, though this is not what its type implies, and is not how it is used in eg 202
  ‚Ü≥ 2024-10-17 23:10 dave: Would ask Gav about this in the GP channel
  ‚Ü≥ 2024-10-17 23:14 dave: I think probably the ‚Üïs_{i‚ãÖ‚ãÖ‚ãÖ+64} bit just needs tweaking to ‚ÜïH^#(s_{i‚ãÖ‚ãÖ‚ãÖ+64})
  ‚Ü≥ 2024-10-18 02:45 stanleyli: Sorry, I have one more question.

For CE 140, since "j‚å¢\[b\]" are the same for all segments, should it just be

--> \[Erasure-Root ++ Shard Index ++ len++\[Segment Index\]\]
--> FIN
\<-- \[Segment Shard\]
\[Protocol 140 only\] j‚å¢\[b\] \<--- CE\_137
\[Protocol 140 only\] for each segment shard {
\[Protocol 140 only\]  T(s,i,H) 
\[Protocol 140 only\] }
\<-- FIN [edited]
  ‚Ü≥ 2024-10-18 07:47 dave: Not necessarily the same for all segment shards as you can request segment shards from multiple erasure roots in the same stream. For all the shards returned for one erasure root this could be done. I didn't do this primarily to keep things simple. Protocol 140 should only be used in exceptional circumstances so efficiency is not super important
  ‚Ü≥ 2025-04-21 10:58 knight1205: Any testcases for this function or merklization functions?
2024-10-18 07:08 xlchen: I am confused about JAMNP ALPN
> The protocol name, version, and chain are identified using QUIC/TLS "ALPN" (Application Layer Protocol Negotiation). The protocol identifier should be either jamnp-s/V/H or jamnp-s/V/H/builder. Here V is the protocol version, 0, and H is the first 8 nibbles of the hash of the chain's genesis block header.

firstly, I guess the V and H are ASCII encoded? so it will be `jamnp-s/0/12345678` encoded using ASCII?
2024-10-18 07:09 xlchen: And shouldn't it be using genesis state hash rather genesis block header hash? surely it can't be the first block in the network
2024-10-18 07:13 xlchen: so just searched genesis header in GP so I guess it will be something predefined along with genesis state. i.e. something should be included the chainspec file
2024-10-18 07:51 dave: > <@xlchen:matrix.org> I am confused about JAMNP ALPN
> > The protocol name, version, and chain are identified using QUIC/TLS "ALPN" (Application Layer Protocol Negotiation). The protocol identifier should be either jamnp-s/V/H or jamnp-s/V/H/builder. Here V is the protocol version, 0, and H is the first 8 nibbles of the hash of the chain's genesis block header.
> 
> firstly, I guess the V and H are ASCII encoded? so it will be `jamnp-s/0/12345678` encoded using ASCII?

Yes
2024-10-18 07:55 dave: > <@xlchen:matrix.org> so just searched genesis header in GP so I guess it will be something predefined along with genesis state. i.e. something should be included the chainspec file

Yes
2024-10-18 11:33 sourabhniyogi: David Emett: We need a way for users interact with ‚Äúalways accumulate‚Äù services, at least the assign privileged service right now but maybe all of them in the same way.  Should we use CE130 to prototype this on our own or maybe you have a design in mind?  
2024-10-18 11:35 dave: > <@sourabhniyogi:matrix.org> David Emett: We need a way for users interact with ‚Äúalways accumulate‚Äù services, at least the assign privileged service right now but maybe all of them in the same way.  Should we use CE130 to prototype this on our own or maybe you have a design in mind?

I don't understand what you mean by this
2024-10-18 11:35 gav: sourabhniyogi: please read [the Code of Conduct effective across all public Polkadot channels](https://hackmd.io/@puaoX3mpTI-9hXSB8NeGEw/B1WUlNqvV) [edited]
2024-10-18 11:36 gav: > This is a room for informal and inclusive conversation. It is not an opportunity to call out for a **specific individual** to answer arbitrary questions. Questions that are made directly to a room member not already in direct conversation with the asker will not be tolerated. [edited]
2024-10-18 11:37 gav: If you have a question, ask it. Do not address a particular person unless as part of a pre-existing and on-topic conversation.
2024-10-18 11:47 sourabhniyogi: > <@gav:polkadot.io> If you have a question, ask it. Do not address a particular person unless as part of a pre-existing and on-topic conversation.

Sorry I was asking as a follow up to a preexisting conversation from a week ago.  How are users supposed to interact with the assign service or privileged/ always accumulate services? 
2024-10-18 11:51 gav: In the same way as any other service. [edited]
2024-10-18 11:51 gav: By sending Work Packages.
2024-10-18 11:52 gav: There will need to be a "bootstrap" service, specified in the genesis config and already in state, which accepts simple Work Packages with instructions in them, such as for assigning coretime, creating new services, requesting preimages and changing the validator keysets. [edited]
2024-10-18 11:53 gav: We already have an early revision of this internally (just used for tests at present) and will tidy up and publish in due course. [edited]
2024-10-18 11:54 gav: It doesn't make much sense to have this service sitting around until we have a testnet going.
2024-10-18 12:27 sourabhniyogi: We have single-team testnet  and can definitely have multi-team testnets after getting this genesis state containing the bootstrap service.  Definitely ready.

We have our "tiny" V=6/C=2 testnet with CE133/134/135 (work package submission/sharing => work report distribution) with 1 core being assured now via CE141 and hitting accumulate entry points, updated with the new JAMSNP details.   We currently have "hard coded" a `fib` test service into state trie (via the service's preimage) -- we can totally improve this to have a genesis state with this "bootstrap" assign service (with a `new` host call) instead of our current "hard coded" situation.

Ok -- so my questions concerning privileged / always accumulate services (which are not GP but JAMSNP related, but its blurry here):

1. if a user sends their Work Package into the bootstrap assign service via CE133 containing their service code blob, presumably to any validator on any core (since the assign service does not belong to a core ... or does it?), what happens next?
2. In JAMSNP,  CE134 has the first guarantor sharing with 2 others, resulting in a work report distribution -- should it share with all V-1 instead if its known to be among the 3 privileged  or always-accumulate  services in `\chi_g`?
3. Does a work report need to be distributed at all then via CE 135 for the privileged / always accumulate service?
4. Can CE 141 be skipped then?  

We will take the answers to this and accommodate in our revisiting "Accumulate" (to cover ordered accumulation since we finally have real assurances in our testnet), covering both the normal work packages and the above "always-accumulate".  We can publish our genesis state and believe many other teams can use the same genesis state + publish exact same answers to get single-team testnets and then proceed to multi-team testnets now. [edited]
2024-10-18 12:39 dave: AFAIK there is nothing special about work packages containing items for always-accumulate services. They are guaranteed and audited in the same way as any other work package
2024-10-18 13:07 gav: There is indeed nothing special about privileged services. Also note that *privileged services* do not always accumulate. There is now (GP-0.4) a separate item which contains a mapping of always-accumulate services and the free gas they get.  [edited]
2024-10-18 13:09 gav: 1. There will likely be a single bootstrap service which is given all three privileges.
  ‚Ü≥ 2024-10-19 15:35 sourabhniyogi: How should we envision JAM service builders publishing something equivalent to Contract ABIs for Services?

We're writing our "Create New Service" service (for this bootstrap service) with code/code length coming through payload ${\\bf y}$, in a very byte-y way and find ourselves wishing for ABIs for calls "createService(uint32 code\_length, \[\]byte code)" and something like event logs like "ServiceCreated(uint32 service\_id)".

Some other bootstrap design could have used extrinsics ${\\bf x}$ to do the same basic function, another might use imported segments to  exported segments, or have multiple methods (to cover changing the validator keysets) to cover all 3 functions.   Is there some convention services should use to publish their invocation for the 4 entry points?

What is the role of JAM Codec for the key input and outputs { y, x, i, e, o, ...  } in such a convention?

Any recommendation on how a service should emit Events / Logs, for JAM Service indexers/explorers? [edited]
2024-10-18 13:11 gav: There‚Äôs nothing special about the service (other than being privileged). The WP will be processed as long as there is a core whose assignment is acceptable. Probably we‚Äôll start with a null-authorizer assigned to all cores which allows any core to accept any WP.  [edited]
2024-10-18 13:12 gav: 2. It shouldn‚Äôt do anything different. 
2024-10-18 13:12 gav: 3. Same. 
2024-10-18 13:12 gav: 4. Same. 
2024-10-18 13:14 davxy: > <@stanleyli:matrix.org> Hi David Emett (also davxy), sorry I still have questions about work package and work package bundle:
> 
> (1) For the import_segments sitting inside of work_item. what's the definition of tree_root & index in import_segments? Is the tree_root here referring to certain work report's exported_segment_root and exported_segment_idx, which will include justification going up erasure_root(u), or is this are the exported_segment_root with justification going up to expoerted_segment_root(e)?
> 
> https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_package.json#L22-L62
> {
>   "tree_root": "0x461236a7eb29dcffc1dd282ce1de0e0ed691fc80e91e02276fe8f778f088a1b8",
>   "index": 0
> }
> 
> (2) When looking at published codec data, I can see both work package have workItem containing importedSegment always starting from index 0 ... up to 3 with no gap. Is it a coincidence, or index here actually mean the index within a workItem?
> 
> (3) In CE134, you mentioned "All import segments have been retrieved..." and "a full work-package bundle is sent, along with any necessary work-package hash to segment root mappings". [Work Package Hash ++ Segment Root] how does this allow other guarantor to validate anything? Also what does the original Guarantor have to do to get the exportedSegment, by doing CE 139?
> 
> (4) Is there a work_package_bundle data available so we can make sure we got the format correct conforming to 14.1.1 in GP 0.4.2 and your jam_np?

The content of the **codec** test vectors is not supposed to be significant. These vectors are only used to test your codec encode/decode functions
https://github.com/w3f/jamtestvectors/tree/master/codec#semantic-correctness

2024-10-18 13:14 gav: The above should all be clear from reading the GP carefully. 
2024-10-18 13:14 sourabhniyogi: Alright, thank you for clarifying, this is simpler.  Is the bootstrap service assigned to just one core?  
2024-10-18 13:14 gav: Cores are not assigned to services  [edited]
2024-10-18 13:14 gav: Nowhere in the GP is this implied. 
2024-10-18 13:15 gav: Cores are assigned to authorizers. Authorizers authorize (sets of) work packages. Work packages contain work items. Work items are associated with a service.  [edited]
2024-10-18 13:15 sourabhniyogi: Ok understood, thank you.
2024-10-18 13:49 carlos379: 
2024-10-18 15:31 dvladco: Hello, I have a question regarding the milestone 1. What does "PVM instancing" imply? having a general PVM that will be later used for the four types of invocations (is-authorized, refine, accumulate, on-transfer) or does this mean implementing each of the four invocation types. In short does "PVM instancing" mean implementing only `Œ®` and `Œ®H` and perhaps `Œ®M` or  does that also involve `Œ®I`, `Œ®A`, `Œ®R`, `Œ®T`? [edited]
2024-10-18 15:58 gav: The former.
2024-10-18 15:59 gav: But it must be possible to implement each of the other things with it. 
2024-10-18 16:00 gav: (M1 necessarily includes the last two PVM invocation functions too since they‚Äôre used on-chain)
2024-10-18 16:01 dvladco: last two meaning accumulate and on-transfer?
2024-10-18 16:01 gav: Yes
2024-10-18 16:01 dvladco: thanks
2024-10-18 16:04 dvladco: I was trying to implement the is-authorized first but it required work packages, cores and what not, so I was not sure if we needed all that for the M1, thanks for clarifying it üôÇ
2024-10-18 20:16 xlchen: about JAMNP, can we have explicit length prefix for CE stream request/response and length prefix for UP messages?
2024-10-18 20:18 xlchen: because otherwise it will be much more work to be able to reject bad data
2024-10-18 20:19 xlchen: many streams have implicit fixed size data so they maybe don‚Äôt need such prefix, but in that case will be good to explicit note the expected message size in the spec
2024-10-18 21:59 dave: Possibly I misunderstand, but all messages are length prefixed on the wire: "A message is transmitted in two parts. First, the size (in bytes) of the message content is transmitted, encoded as a little-endian 32-bit unsigned integer. Second, the message content itself is transmitted."
2024-10-19 04:53 xlchen: my bad. not sure why I missed that part ü§¶‚Äç‚ôÇÔ∏è
2024-10-19 15:16 gav: 
2024-10-19 15:56 gav: Services are not smart contracts. 
JAM is not intended to be used directly as an application chain since it‚Äôs primarily a roll-up host. If you‚Äôre desperate to get information out of JAM you can write to a service‚Äôs storage and inspect that. 
  ‚Ü≥ 2024-10-21 17:38 sourabhniyogi: Regarding JAM‚Äôs primary role being a roll-up host, is the intention for it to be exclusively used for Polkadot parachains/rollups built with the Polkadot SDK/Substrate, or extend to support non-Polkadot "foreign" rollups?

You suggest the foreign possibility in GP: ‚ÄúSmart-contract state may be held in a coherent format on the Jam chain, as long as any updates are made through the 15kb/core/sec work results, which would only need to contain the hashes of the altered contracts‚Äô state roots.‚Äù     Would it be worthwhile to build shims between smart contract platforms like OP Stack, ArbOS, etc., to leverage JAM DA+Work packages, or would this be a futile effort given the native capabilities of Polkadot SDK/Substrate-built chains, extending to revive+PVM?

A Rollup host that can have "semi-coherent" messaging between different kinds of rollup platforms would be very awesome.  Is there some spam-resistant DMP-like process out of accumulate/transfer or HRMP-like messaging service that could support both native and foreign rollups ... if foreign rollups belong in JAM?

These questions are not directly related to JAM implementation life but helpful to understand the big picture! [edited]
  ‚Ü≥ 2024-10-22 10:29 gav: Jam is intended to be generally usable and not at all constrained to validating substrate/cumulus chains. The point was that it‚Äôs not designed to supplant a smart contract platform in terms of end-user experience, at least not directly.  [edited]
  ‚Ü≥ 2024-10-22 16:58 sourabhniyogi: This foreign possibility suggestion is super titillating, do you see a way for it to apply to Ethereum L2 optimistic rollups?   

Not sure about this, but from your suggestion, I assume you mean being able to prove the next state root of an optimistic rollup (e.g. OP Stack, ArbOS)  with a JAM work package containing JUST the hashes of the altered contracts‚Äô state roots, correct?    But what about { Account balances/Nonces, Contract storage, Contract code, remaining unaltered state }, which also affect the state root?  You must have some key simplification/insight to make it fit within JAM, maybe coupled with a particular enabling technology.   

The lazy/stay-optimistic approach would be to have another rollup (Asset Hub or whatever else with revive) represent ETH L1 and get the messaging service in place.  Making optimistic rollups into "cynical/pessimistic" rollups for foreign rollup platforms would be groundbreaking but needs these simplifications/insights.   Can you share your insights on how Polkadot ecosystem can break ground with foreign rollups in this way? [edited]
2024-10-19 18:59 sourabhniyogi: Understood about JAM services not intended to be used directly as application chain.

But what about the bootstrap service itself: how should a new service creator learn that the newly created service has a particular new service index (from check/bump entropy driven processes, via 4.2 (281)'s check ala hostfunction `new` after `accumulate` completes).  

Do you mean that a new creator of a service should look in the bootstrap service's storage?  This is fine for PoC -- but do you mean for production multifunction bootstrap service as well? [edited]
2024-10-21 11:07 gav: > <@sourabhniyogi:matrix.org> Understood about JAM services not intended to be used directly as application chain.
> 
> But what about the bootstrap service itself: how should a new service creator learn that the newly created service has a particular new service index (from check/bump entropy driven processes, via 4.2 (281)'s check ala hostfunction `new` after `accumulate` completes).  
> 
> Do you mean that a new creator of a service should look in the bootstrap service's storage?  This is fine for PoC -- but do you mean for production multifunction bootstrap service as well?

Production would be different. Most likely it will be the parachains service which is given all three privileges. The Staking/CoreTime chains would be able to set validators, assign cores, request blobs and create services. 
2024-10-21 11:08 gav: > how should a new service creator learn that the newly created service has a particular new service index

The most obvious way (and what I'm doing in my little test) is to write to a known storage key the new index.
2024-10-21 11:23 gav: FWIW logs/receipts are basically an unsolved problem in blockchain. It's not at all clear how to build a secure decentralised scalable service capable of indexing arbitrarily large numbers of state-change events. Ethereum's bloom filter became saturated shortly into its lifetime. Deterministic hash-maps are trivially spammable. Non-deterministic hash-maps are difficult to validate. Maybe there's something clever which can be done with ZK these days, but overall it's a hard one to solve and not one I especially want to bundle into the core of JAM.
2024-10-22 09:18 prematurata: Not sure if this is the right place and if it is allowed to ask. But I was thinking it could be helpful and cool to have some "voting" support for jam teams right now in the polkadot chain as a perk for jam implementors. 

Especially now that the number of validators in the dot chain was (and is being) raised.
2024-10-22 10:31 gav: > <@prematurata:matrix.org> Not sure if this is the right place and if it is allowed to ask. But I was thinking it could be helpful and cool to have some "voting" support for jam teams right now in the polkadot chain as a perk for jam implementors. 
> 
> Especially now that the number of validators in the dot chain was (and is being) raised.

To some extent this is already provided for via the Fellowship membership rules. But I suppose there could be an additional collective for the maintainers of all milestone-achieving teams. 
2024-10-22 12:14 jaymansfield: Hey all. Should we be updating anyone at w3f about our progress as we go or only after completing milestones? 
2024-10-22 12:58 gav: Feel free to give updates - we‚Äôre interested to know.
2024-10-22 15:24 dakkk: > <@jaymansfield:matrix.org> Hey all. Should we be updating anyone at w3f about our progress as we go or only after completing milestones?

It would be interesting to know at what stage are all the teams working on a jam implementation
2024-10-22 15:24 dakkk: (at least those using the language I'm using üòÑ) 
2024-10-22 17:22 gav: JAM should be easily performant enough to be able to verify most Ethereum L2 transitions in a single WP. Along with a secure ethereum bridge, it should be viable to provide cheap, fast and secure Ethereum L2s from JAM. It may even be possible to grandfather in pre-existing L2s. 
  ‚Ü≥ 2024-10-27 08:34 sourabhniyogi: Can you explain the grandfathering idea a bit?  Touching on it here 

https://github.com/polkadot-fellows/RFCs/pull/127#discussion_r1817937026

Basically having pre-existing L2s prove finality with *both* ETH + JAM as anchors is a winning solution.  But I'm  not sure how we get Ethereum finality into `accumulate` to feed back into `refine`'s  `historical_lookup`.



  ‚Ü≥ 2024-10-28 09:23 gav: > <@sourabhniyogi:matrix.org> Can you explain the grandfathering idea a bit?  Touching on it here 
> 
> https://github.com/polkadot-fellows/RFCs/pull/127#discussion_r1817937026
> 
> Basically having pre-existing L2s prove finality with *both* ETH + JAM as anchors is a winning solution.  But I'm  not sure how we get Ethereum finality into `accumulate` to feed back into `refine`'s  `historical_lookup`.
> 
> 
> 

One not entirely dismissible possibility is to run an Ethereum full-node as a JAM service. 
2024-10-22 17:24 gav: It‚Äôs still in the early stages of ideation but I don‚Äôt see any obvious flaws with the approach. It is perhaps something which could be discussed at JAM0. 
2024-10-22 22:54 danicuki: ima_8984eb0.jpeg
2024-10-22 22:54 danicuki: ima_779bc41.jpeg
2024-10-22 22:54 danicuki: ima_ab4d75d.jpeg
2024-10-22 22:54 danicuki: ima_53184c7.jpeg
2024-10-22 22:54 danicuki: ima_ddab933.jpeg
2024-10-22 22:54 danicuki: ima_e241c29.jpeg
2024-10-22 22:54 danicuki: ima_43b6c06.jpeg
2024-10-22 22:54 danicuki: ima_b13309a.jpeg
2024-10-22 22:54 danicuki: ima_1f92268.jpeg
2024-10-22 22:54 danicuki: ima_03602d0.jpeg
2024-10-22 22:54 danicuki: video_af05d68.mp4
2024-10-22 22:54 danicuki: Pictures from the JAM Meetup yesterday in Lisbon. 
2024-10-23 04:24 lucas: I am intersted in chatting with Gossemer team members. 

I am also interested in networking with other JAM engineers. 

I saw that a solo JAM implementation may also be desired, & beneficial. 

I am also wondering if  there are any set vcs practices that aren't mentioned anywhere on the relevant web resources? Is there any universal agreement among teams with VCS or other engineering practices? What happens if I am engineering solo, parts of my implementation are copied by another team & put in their implementation? How would anyone know if it was originally my implementation vs theirs or vice versa?  

Wondering as well if anyone is working on JAM related projects that aren't specifically implementations? 

I am also wondering if I build for example a dApp or something similar on top of a new JAM client implementation if that is more desired than for example an improved JAM client implementation by itself even if the client may perform better by focusing only on that & not building on top of it?   

For example, I think it'd be cool to build a decentralised gaming server, that could also be a good experiment to test decentralised network performance & benchmark it against non decentralised server clusters. 

Some questions that can be explored for example, are all server clusters a form of decentralisation if some resources are distributed or only if they are distributed in a certain way? 

What defines a decentralised http or protocol request? 

I haven't discovered any universal answers for the above, or agreement related to them. 

Is there a stack exchange or similar forum, where it is better to ask these questions? 
2024-10-23 04:28 xlchen: I didn't read all the fine print of the prize rule but I assume copyright infringement is an immediate disqualify. KYC/KYB is required so it should be possible to take legal action if necessary
2024-10-23 04:29 xlchen: we definitely need all sorts of tools and applications built on top of JAM but I will say it is a bit too early to actually working on it until we have a public JAM testnet 
2024-10-23 04:37 xlchen: JAM is the foundation. it is very low level. users are not suppose to use JAM directly. we need all sorts of services to make JAM useful. however, to build such service, we also need some framework for it. I presume Parity is working on some internal experimental framework and it will take time and many trial and error for such framework to be mature enough for use
2024-10-23 06:07 bill: > <@lucas:digitale-gesellschaft.ch> I am intersted in chatting with Gossemer team members. 
> 
> I am also interested in networking with other JAM engineers. 
> 
> I saw that a solo JAM implementation may also be desired, & beneficial. 
> 
> I am also wondering if  there are any set vcs practices that aren't mentioned anywhere on the relevant web resources? Is there any universal agreement among teams with VCS or other engineering practices? What happens if I am engineering solo, parts of my implementation are copied by another team & put in their implementation? How would anyone know if it was originally my implementation vs theirs or vice versa?  
> 
> Wondering as well if anyone is working on JAM related projects that aren't specifically implementations? 
> 
> I am also wondering if I build for example a dApp or something similar on top of a new JAM client implementation if that is more desired than for example an improved JAM client implementation by itself even if the client may perform better by focusing only on that & not building on top of it?   
> 
> For example, I think it'd be cool to build a decentralised gaming server, that could also be a good experiment to test decentralised network performance & benchmark it against non decentralised server clusters. 
> 
> Some questions that can be explored for example, are all server clusters a form of decentralisation if some resources are distributed or only if they are distributed in a certain way? 
> 
> What defines a decentralised http or protocol request? 
> 
> I haven't discovered any universal answers for the above, or agreement related to them. 
> 
> Is there a stack exchange or similar forum, where it is better to ask these questions?

1. Yes, there is a 10 million DOT pot available for implementations of JAM. Many different teams are already working on it https://jam.web3.foundation/
2. As Bryan said, teams that copy/paste from others are disqualified. You can timestamp your code in a variety of ways, e.g., making a system.remark of the latest commit hash at regular intervals. I recommend reading through the rules here: https://jam.web3.foundation/rules

2024-10-23 11:00 emielsebastiaan: Could anyone please update me on JAM-related Bangkok events in November?

The bits and pieces I have:
- Last day at sub0 (11 Nov) will focus on JAM
- JAM0 scheduled on 12-16 Nov. But treasury proposal got rejected. Is this still happening? If yes is there a rough idea of objectives?

Where can I find the latest info and keep updated? üôèüèª
2024-10-23 13:22 gav: I had understood it was to be on the 9th and 10th November. 
  ‚Ü≥ 2024-10-23 14:15 sourabhniyogi: Between sub0 and JAM0 everything you want to happen between the 9th and the 16th can be arranged.  sub0 (9th-11th)is best for recorded talks as usual but JAM0 (11th evening - 16th) for seminars, office hours with teams in whatever form you'd like (within room space constraints).  

Anything you want to do will create Schelling points for all of us schedule-wise.  What would you like to see?
  ‚Ü≥ 2024-10-24 04:47 gav: I'll be there 9th and 10th, and I'm fairly flexible over how the time is used.
  ‚Ü≥ 2024-10-26 14:35 sourabhniyogi: Thank you for making yourself super accessible for all of us here.   

I myself would be  most keen to get your concrete ideas on how to properly design/develop a JAM Service for ETH L2 optimistic rollups.  Here is my first attempt at a write up:

 https://github.com/polkadot-fellows/RFCs/pull/127

We can find you at the end of the 10th, but if we should study something beforehand to gain some competence in how to approach this better, we will do that.  If we're on the right track, we can take a stab at reducing it to practice, or course correct based on your advice right now.  
2024-10-23 13:49 sourabhniyogi: sub0 is 9th through the 11th -- You should register for a free ticket https://sub0.gg/ and look for JAM related content on the schedule, which is under prep there.    127 Na Ranong Rd. , Khlong Toei, Bangkok is the address.  rektormoon can speak to other details not on the site but... Hackerspace is open to all implementers 24h!

JAM0 is a mostly open ended hackathon type arrangement with 2-3x/day "sessions" where we cover whatever topics anyone wants for 30-90 mins (e.g at 10:30am and 2pm and 5pm) as a group and any team can network with any other team \[always following official/unofficial rules\].   We have a big room that can hold everyone for up to 80 people on the 11th,12th,15th,16th so we can do whatever we want.  On the 13th and 14th we have a smaller room that can hold up to 30.  For 11th-16th both rooms are available 9am-9pm.  I'm collecting a headcount here so we can buy everyone a lunch or dinner if there is quorum of people:

https://docs.google.com/spreadsheets/d/1\_Ar0CWH8cDq\_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0

You can add your topics \[I put 2\] but no prep is required.  If you are a JAM implementer (and have ever asked a JAM-related GP question to qualify you), I'll put you in a JAM0 room so you can find everyone else.  We are happy to sponsor the venue + food but have no travel budget.  If you have any questions/wishes, you can DM me @sourabhniyogi and we'll do our best to be a good host.  Address is 95,370 Sukhumvit Soi 24, Khwaeng Klongton, Khet Klongtoey

Devcon 7 is Nov 12th-15th and a 25 min walk from both places.  Tickets are sold out but there is a waitlist.  I'm not seeing a schedule but everyone is welcome to go back and forth between the JAM0 rooms at Valia and Devcon 7 all through 4 days from 9am-9pm. [edited]
2024-10-23 14:29 dave: > <@dave:parity.io> I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

FYI I've pushed a fix to CE 142. Previously, only the hash of the preimage was sent, which isn't really enough to check whether the preimage has been requested on chain or not. Now the ID of the requesting service and the length of the preimage are also sent.
  ‚Ü≥ 2024-10-23 19:28 mkchung: Can you clarify who is "non-validator" node in your CE 142, and whether CE 142 is primarily designed for covering the "solicit=13" case?

Is the "non-validator" a node outside of V=1023? I initially thought this "non-validator" could be the wp "builder" submitting a wp that ultimately triggers the "new=9" or "solicit=13" at the accumulation stage. If that were the case, it would make sense that the builder wouldn't know which service account is being created, thus only allowing the `preimageHash` to be announced. It would also make sense that builder would want to get its preimage into on-chain state, thus it will resume preimage announcement responsibility.

However, if CE 142 is also intended to cover the "new=9" case, then the "non-validator" cannot be just the builder -- as the `service_id` must go through the check-and-bump logic [here](https://graypaper.fluffylabs.dev/#/439ca37/2b5c012b5c01). (I interpret builder as core user who only cares about using it, but not actually running it)

If non-validator != builder, how does non-validator know the `service_id` and `preimageData` in general, especially when a new service is being created? If non-validator implies that the announcement responsibility is from someone outside of [active validator set](https://graypaper.fluffylabs.dev/#/439ca37/183400183700), then what's the incentive or penalty to make sure requested preimages are being answered promptly?
  ‚Ü≥ 2024-10-23 21:58 dave: "Non-validator node" was just to clarify that you should allow these announcements from essentially any node. You probably don't need to prevent validator nodes from using this protocol, but a normal validator node would have no reason to use it, as these announcements are not intended to be gossiped.
  ‚Ü≥ 2024-10-23 22:17 dave: CE 142 is intended for both the solicit case and the new case. In the new case, the party providing the preimage will need to learn what the new service ID is by following the chain somehow. How exactly this is done is not prescribed as there is no need for everyone to do it in the same way.
  ‚Ü≥ 2024-10-23 22:17 dave: > then what's the incentive or penalty to make sure requested preimages are being answered promptly?

This is a concern of the service requesting the preimages, not a concern of JAM. [edited]
  ‚Ü≥ 2024-10-23 22:24 dave: That is to say, if you write a service which requests some preimage, you should have a plan for who is responsible for providing the actual preimage. Maybe your service allows people to pay to create smart contracts, in which case the creator of a contract will have an incentive to upload the contract code.
  ‚Ü≥ 2024-10-26 11:34 tebdev: Q1: Is this required for M1 Q2: Will Public CA be required for OCSP Stapling for MITM? Comment: That could pin us to "Stoppable"
2024-10-23 18:20 sourabhniyogi: Excellent, thank you for this fix -- I think its workable to complete the picture and implement a bootstrap service like this now:
https://github.com/jam-duna/jamtestnet/blob/main/services/jam-duna/bootstrap/README.md

Let me know what you think I got wrong?  Or if you have a bootstrap assembly that does it better/right, maybe that is ready for sharing?  I understand there are problems that are useful as exercises for the reader, and this is a great one, but perhaps achieving consensus on this is worth it. [edited]
  ‚Ü≥ 2024-10-23 19:11 sourabhniyogi: ?  We believe the `Service ID` was necessary in your fix, but don't see why `Preimage Length` was needed as well.  What is the reason for its inclusion in CE142?
  ‚Ü≥ 2024-10-23 22:31 dave: The dictionary **l** in each service has keys of type (Hash, Preimage Length). You will want to look into this dictionary to determine if a preimage has been requested or not. Without the preimage length it's not easy to do this (not strictly speaking impossible of course) [edited]
  ‚Ü≥ 2024-10-23 22:41 dave: Re the proposed bootstrap service, sounds like that would work to me. That is certainly how CE 142/143 are intended to work.
2024-10-24 00:34 charliewinston14: I have a question about "publish-tickets-no-mark-4" which is "Fail: Submit tickets in bad order.". Where in the grey paper can i find information about how to properly order tickets? I see "in order of their implied identifier." on page 15 but unsure what that means exactly. 
2024-10-24 00:35 xlchen: they need to be ordered by output in ascending order. it is specified somewhere
2024-10-24 01:31 charliewinston14: > <@xlchen:matrix.org> they need to be ordered by output in ascending order. it is specified somewhere

Thanks!
2024-10-25 01:43 xlchen: For JAMNP CE128 block request, does the response have to give exact amount of block requested?
2024-10-25 01:44 xlchen: the response appears to not having a length prefix
2024-10-25 01:44 xlchen: but the wording is that the number is request is maximum so response can give something less than that
2024-10-25 09:55 dave: Yeah the intent is that some number of blocks up to the given maximum is returned
2024-10-25 09:56 xlchen: in that case shouldn‚Äôt it have a length prefix?
2024-10-25 09:57 xlchen: so I can decode it as Array<Block> directly with jam codec
2024-10-25 10:13 dave: I was assuming you would decode one block at a time in a streaming fashion, stopping once you had read the entire message. Perhaps an additional length prefix would be useful, that's not particularly clear to me though
2024-10-25 10:20 xlchen: it is lot more complicated to implement an online decoder and for what benefit? save 1 to 2 bytes?
2024-10-25 10:25 xlchen: > len++ preceding a sequence indicates that the sequence should be explicitly prefixed by its length. If a sequence is not preceded by len++, the length is either fixed or implied by context.

and in this case, neither the length is fixed or implied by context
2024-10-25 10:33 dave: It is implied by the message length? If you want to read the entire message and decode it into an array I don't see what the difficulty is with this?
2024-10-25 10:34 xlchen: it is doable but the wording is confusing. there is no way to derive the block count purely from total message length 
2024-10-25 10:36 dave: > <@xlchen:matrix.org> it is doable but the wording is confusing. there is no way to derive the block count purely from total message length 

I agree, does that matter?
2024-10-25 10:36 xlchen: it is ok to keep as it is, but you could say something like when the array does not have length prefix, people should repeatedly decode the type until all the data are read [edited]
2024-10-25 10:37 xlchen: I am suggesting to improve the wording to make it less ambiguous otherwise you may get similar questions in future 
2024-10-25 10:58 dave: I'll try to clarify this
2024-10-25 13:33 dave: I've added a few sentences covering this particular case, hopefully clearer now
2024-10-27 19:42 danicuki: Screenshot 2024-10-27 at 19.42.22.png
  ‚Ü≥ 2024-10-28 08:45 jan: I don't have a better name for this column, but the "RISC-V VM" doesn't really mean much. Just because a VM is RISC-V based doesn't mean squat. For example, see this table here in my benchmarks:

https://github.com/paritytech/polkavm/blob/master/BENCHMARKS.md#oneshot-execution-for-pinky

The "CKB VM" is also a RISC-V VM (and it's arguably even more RISC-V than PolkaVM/PVM, because it uses completely vanilla RISC-V) and yet it's, well, not that great if you look at the benchmarks. :P
  ‚Ü≥ 2024-10-28 16:15 danicuki: Agreed. Maybe the advantage then is PVM itself? 
  ‚Ü≥ 2024-10-28 16:55 tebdev: This was great work. Thank you for pulling it together. I can use this with some stakeholders on fence about Polkadot.
2024-10-27 19:42 danicuki: People pay attention when there is a table comparing different products. We all know JAM is the amalgamation of different breakthrough technologies. I tried to put this in a map, so we can use it when we explain JAM to others. It came from a conversation with ChatGPT, helping me to identify other chains that partially implement what we are doing in full on JAM. 

Here is the conversation link:
https://chatgpt.com/share/671e96b7-1e8c-800f-989a-04acc01f1bee

and this is the generated table (food for thought and debate)
Feedback is very welcome [edited]
2024-10-27 19:44 danicuki: Blockchain_Technology_Comparison_with_Finalized_Corrections.csv
2024-10-28 09:25 gav: The less ostentatious way would be to implement an Ethereum light client within a JAM service (or just use eg Snowfork, which essentially does that but in a parachain)
  ‚Ü≥ 2024-10-28 15:45 sourabhniyogi: I don't see a way to follow your suggestion here
https://graypaper.fluffylabs.dev/#/293bf5a/206500206500
to make non-Polkadot ORUs validated in JAM. 

We would like to implement a Eth light client to do what Snowfork does and apply it usefully but don't see how it helps the non-Polkadot ORUs get validity.  It can only help non-Polkadot ZKRUs achieve finality more quickly, but its non-Polkadot ORUs that need their challenge window to disappear. [edited]
  ‚Ü≥ 2024-10-28 15:56 sourabhniyogi: With non-Polkadot ORUs you don't win much of anything with verification of storage proofs against state root at B and storage proofs against the child of B.  For an ORU, the best we can really do is ensure blocks are available in DA, which is fine, but not the giant win -- you still need fraud proofs and a challenge window.  Or, I missed some critical insight of what you mean here
https://graypaper.fluffylabs.dev/#/293bf5a/206500206500
Did you mean for this to apply to ETH L2 ORU?

For useful JAM Services for non-Polkadot rollups its these:
(1) Basic DA for non-Polkadot RUs (ORU or ZKRU) 
(2) ETH Light Client Service
(3) Grandfatherable ZKRU, using (2)
but not
(4) Grandfatherable ORU, except for (1) [edited]
2024-10-28 09:48 tebdev: > <@gav:polkadot.io> The less ostentatious way would be to implement an Ethereum light client within a JAM service (or just use eg Snowfork, which essentially does that but in a parachain)

Very interesting, Help: would it be safe to say this is probabilistic trust versus absolute as a performance tradeoff?
2024-10-28 10:04 gav: Light clients generally are, yes. 
2024-10-28 10:10 gav: The good ones will only rely on sensible assumptions about the behaviour of validators. Most are not so good. A full node would manually verify the state transition and therefore give a solid guarantee of correctness. But regarding finality, it‚Äôs not so much about correctness and more about the validators committing to one of (potentially) several options. Such a commitment is generally correct per se and therefore about as secure on light (finality-tracking) as full (block-executing) nodes. 
2024-10-28 10:37 tebdev: > <@gav:polkadot.io> The good ones will only rely on sensible assumptions about the behaviour of validators. Most are not so good. A full node would manually verify the state transition and therefore give a solid guarantee of correctness. But regarding finality, it‚Äôs not so much about correctness and more about the validators committing to one of (potentially) several options. Such a commitment is generally correct per se and therefore about as secure on light (finality-tracking) as full (block-executing) nodes.

Yes non-sensible versus "sensible" in today's world may be more when versus if. ;) Games relying on rational actors is a concern. Bravo on using/funding multi programming languages. That is Nobel prize level stuff towards unstoppable ;) For direct multi-objective incentive mechanisms to counter non-rational actors, could the JAM framework consider incorporating game-theoretic approaches that weigh reputational and non-financial factors? In my humble view and experience NASH is not absolute with state actors when stoppable is a goal..
2024-10-28 11:33 tebdev: image.png
2024-10-28 11:37 tebdev: I could be way off, but I could not find this in Jam paper. Normal payoff with deviation added for irrational ... Mixed strategy. Resilience ... [edited]
2024-10-28 13:00 tebdev: Off-Equilibrium Paths thinking out loud... , Maybe Cantelli's inequality can help bound Dj irrational cost which may need treatment in ELVES. ELVES may deal with this, but not clear. Maybe update Game theory payoff model first as foundation to PoS, then show how ELVES would deal with system sensitivity to irrational actions. Maybe mixed incentives plus redistribution of stake. Slashing seems one dimensional, maybe slash and redistribute. [edited]
2024-10-28 17:21 charliewinston14: Hello. Question about erasure coding in JAM. I‚Äôve broken the blob into pieces, and then those pieces into the octet pairs. The pairs were then converted to 16 bits. I‚Äôm now trying to figure out the field element formula. It looks to be the summation of each bit multiplied by ‚Äúvj‚Äù and this is where I‚Äôm not sure what value to use. If j = 7, then vj = Œ±14 +Œ±4 +Œ±. What is Œ± here?‚Ä®
2024-10-28 17:21 charliewinston14: Screen Shot 2024-10-28 at 1.20.33 PM.png
2024-10-28 22:30 danicuki: Presentations from teams at the JAM Meetup in Lisbon:

https://www.youtube.com/watch?v=7N2x6ulVA-E
https://www.youtube.com/watch?v=j-Qf25zuQ8w

Unfortunately, the camera didn't catch the two last presentations from PolkaJAM and Jamixir, so we will have to wait for sub0 / jam0 meeting in Bangkok for those. 
2024-10-29 04:39 xlchen: https://github.com/open-web3-stack/jam-dashboard we created a simple telemetry dashboard displaying chain head for Boka nodes. I can spend a bit time to document the RPC if anyone else is interested
2024-10-29 04:39 xlchen: Screenshot 2024-10-29 at 5.39.36‚ÄØPM.png
2024-10-29 07:00 dakkk: > <@xlchen:matrix.org> https://github.com/open-web3-stack/jam-dashboard we created a simple telemetry dashboard displaying chain head for Boka nodes. I can spend a bit time to document the RPC if anyone else is interested

I'm interested in the RPC, and would be awesome to have the genesis state you used
2024-10-29 08:21 xlchen: we currently only have a helper to create genesis state in code directly. i can export it in some json format 
2024-10-29 17:50 dave: > <@dave:parity.io> I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

FYI I've made a minor modification to the availability protocols to discriminate elements of the justification sequences. This should hopefully allow simpler implementations. I've also removed some statements which I now realise were not accurate! See https://github.com/zdave-parity/jam-np/commit/7637e963cfd22fc452a957904b2f8d5ff181e67b and https://github.com/zdave-parity/jam-np/commit/032a7f14264c0e441c8e50d9c3c8504d5ac0c62c
2024-10-29 18:01 sourabhniyogi: image.png
2024-10-29 18:02 sourabhniyogi: Is the above suggestion to interpret EVM byte code using PolkaVM sane?  I didn't think it was sane until this week with the suggestion that JAM run an Ethereum full node and the above, which is truly ostentatious!  This is from 
https://vitalik.eth.limo/general/2024/10/26/futures5.html [edited]
2024-10-30 09:57 gav: > <@sourabhniyogi:matrix.org> Is the above suggestion to interpret EVM byte code using PolkaVM sane?  I didn't think it was sane until this week with the suggestion that JAM run an Ethereum full node and the above, which is truly ostentatious!  This is from 
> https://vitalik.eth.limo/general/2024/10/26/futures5.html

Optimistic to the max, as usual. 
2024-10-30 09:59 gav: Definitely reads like it‚Äôs written by a mathematician and not an engineer. 
2024-10-30 09:59 gav: But if you mean the bottom bit, yes it‚Äôs an idea. I don‚Äôt see it being readily implementable from what is written here. It is however something that Parity is working on within the smart contracts team.   [edited]
  ‚Ü≥ 2024-11-05 06:46 sourabhniyogi: Here is my JAM Service design to follow through on the ostentatious suggestions
https://github.com/polkadot-fellows/RFCs/pull/130
I followed Rob H's feedback on "pursue all forks" instead of Jeff's for now (as well as the intuition of all the other Polkadot heavyweights, see #127) -- basically geth's Consensus API [recently added by karalabe in Sept] gets the state witnesses and it can feed into revm -- all good with JAM refine.  I am not sure how much work it will be to put revm through polkatool, but I am now optimistic we can do this.  

In addition to general feedback, do you have a better choice of Rust EVM interpreter than revm such that we can more easily achieve the goal of interpret EVM in PolkaVM?    [edited]
  ‚Ü≥ 2024-11-05 07:33 gav: Not really. There may be some possibility of recompiling EVM bytecode into PVM, but Alex T and Jan would have a better idea of the feasibility of that than me.
2024-10-30 09:59 gav: I don‚Äôt see much in there except half-baked ideas and a general lamenting of the realities of building and maintaining real systems (rather than mathematical constructs).  [edited]
2024-10-30 11:19 dakkk: Should usage of LLM and similiar be allowed in JAM implementations? I think that since they are trained by the same data, they may introduce the same bug across multiple implementations
2024-10-30 11:56 gav: What do you mean ‚Äúin JAM implementations‚Äù?
2024-10-30 11:56 dakkk: graypaper implementations*
2024-10-30 11:57 gav: By implementers to write code? Or by the code itself to govern its behaviour?
2024-10-30 11:57 dakkk: by implementers to write code using those tools 
2024-10-30 11:58 gav: No. LLMs shouldn‚Äôt generally be used to write code to be submitted. This would count as collusion.  [edited]
2024-10-30 12:01 dakkk: ok üëçÔ∏è  it was already my opinion, but I asked since it is not specified in JAM prize rules.
2024-10-31 23:30 ycc3741: Hi I can't find my country in JAM Prize Interest Form 
2024-10-31 23:30 ycc3741: I'd already sent the mail to jam@web3.foundation and might need so help.
2024-11-01 04:17 keegan: Thanks ycc3741 just responded
2024-11-02 07:24 sourabhniyogi: sub0 schedule is up! üíì üòç ü•∞

 https://agenda.sub0.gg/sub0-reset-2024/schedule/#2024-11-11 

Nov 11th is packed with JAM talks (or closely related topics) on the Main Stage, but also plenty of time and space to meet each other over lunch/coffee.

Registration is at: https://sub0.gg/
  ‚Ü≥ 2024-11-02 08:07 prematurata: Sounds great. Unfortunately I cannot attend in person. Will talks be available on demand after the event?
  ‚Ü≥ 2024-11-02 08:23 tomusdrw: No one from my team can attend too and we are fomoing hard, also curious if there is going to be a live stream or recordings available.
  ‚Ü≥ 2024-11-05 19:01 vinsystems: Yes, Im interested as well if there is a live stream or recordings
2024-11-02 07:59 gav: Do we have somewhere to congregate on the 9th/10th?
  ‚Ü≥ 2024-11-02 08:27 rektormoon: Yes you are welcome at sub0, we have the hacker space floor which is 24h and also some breakout rooms for more private sessions. 
2024-11-02 08:15 dakkk: > <@sourabhniyogi:matrix.org> sub0 schedule is up! üíì üòç ü•∞
> 
>  https://agenda.sub0.gg/sub0-reset-2024/schedule/#2024-11-11 
> 
> Nov 11th is packed with JAM talks (or closely related topics) on the Main Stage, but also plenty of time and space to meet each other over lunch/coffee.
> 
> Registration is at: https://sub0.gg/

will it be available a live stream?
  ‚Ü≥ 2024-11-02 08:36 rektormoon: Main stage will be live streamed :-)
2024-11-04 03:14 jam_man: Are we still accepting teams that work in python? I‚Äôm a PhD candidate in computation neuroscience and have a team interested in working on a python implementation. 
2024-11-04 03:17 jam_man: > <@jam_man:matrix.org> Are we still accepting teams that work in python? I‚Äôm a PhD candidate in computation neuroscience and have a team interested in working on a python implementation. 

I submitted an official application already. I am just wondering while we wait to hear back. 
2024-11-04 03:41 jam_man: Second question. How many milestones / how many rewards are left to be paid out. I don‚Äôt see an easy place to see that. Thanks !
2024-11-04 03:42 xlchen: GP is not yet finalized so it is not yet currently for anyone to deliver any milestones 
2024-11-04 03:43 jam_man: Thank you. Sorry but could you clarify what a GP is ?
2024-11-04 03:43 xlchen: graypaper
2024-11-04 03:43 jam_man: Gotcha thank you.üëç
2024-11-04 03:44 xlchen: here are the participating teams: https://graypaper.com/clients/
2024-11-04 03:44 jam_man: Does that mean teams have not begun working yet? Or just that submission are halted until a finalized GP is out.
2024-11-04 03:46 xlchen: not everything are defined but many components are stable and people are working on those
2024-11-04 03:47 xlchen: https://github.com/gavofyork/graypaper this have bit more details
2024-11-04 03:47 jam_man: Are new teams still being accepted. Or is that list of clients you sent solidified
2024-11-04 03:47 xlchen: there is no acceptances, anyone are welcome to start a new implementation at any time
2024-11-04 03:48 xlchen: the list I shared is just a list of teams sharing they are participating. it is most likely not the complete list
2024-11-04 03:49 xlchen: the only thing matters is deliveries. e.g. no prize will be reserved for any teams
2024-11-04 03:51 jam_man: okay awesome thank you. 
2024-11-04 06:49 dakkk: > <@jam_man:matrix.org> Are we still accepting teams that work in python? I‚Äôm a PhD candidate in computation neuroscience and have a team interested in working on a python implementation. 

There are other two teams working using python here, you are in good company ;)
2024-11-04 06:51 jam_man: Exciting! What are the rules on how many python implementations can get rewards for each milestone, I don‚Äôt see any rules on that. 
2024-11-04 06:51 jam_man: Could all 3 python teams get rewards for all 5 mile stones?
2024-11-04 06:51 xlchen: https://jam.web3.foundation/rules
2024-11-04 06:52 jam_man: Ahh great thanks 
2024-11-04 06:52 jam_man: Was looking for something that extensive üëç
2024-11-04 06:55 jam_man: Oh actually I have seen / read that before. I didn‚Äôt see any clarification on how many times a specific language could produce an implementations. I know one team can only do one implementation for each milestone. But hypothetically could all the rewards go to teams that happen to be working on python. 
2024-11-04 06:57 xlchen: it is first-come, first-served so yes if for some reason all the python teams are faster than other teams in the same language set
2024-11-04 06:58 jam_man: Thank you good to know 
2024-11-04 07:01 jam_man: I assume the answer to this first question is no. But Is it considered colluding to join a team that has already been working.
‚Ä®Secondly would it be considered colluding or against the rules to have communication with a teams even if it simply the prospect of joining their team. [edited]
2024-11-04 07:05 jam_man: Colluding I assume no to either. But would either of these need to be officially disclosed.
2024-11-04 07:06 xlchen: not sure if there is written rule about those situation but IMO, teams can definitely be able to grow. I guess the only thing that's not allowed is to having people transferring between two teams
2024-11-04 07:08 jam_man: Okay yeah, i assumed once two teams had already begun working the transfer of members between groups would be prohibited. But growing with new independent members was fine. 
2024-11-04 16:20 emielsebastiaan: > <@jam_man:matrix.org> I submitted an official application already. I am just wondering while we wait to hear back. 

I sent you a DM on X.
2024-11-05 02:13 xlchen: https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-129-state-request
I don't really understand about the boundary node part. can we have some examples? also examples for each message request/response will be super helpful
2024-11-05 15:02 dave: > <@xlchen:matrix.org> https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-129-state-request
> I don't really understand about the boundary node part. can we have some examples? also examples for each message request/response will be super helpful

As an example, say the trie looks like this:

           a
       b       c
     d   e   f   g
    h i j k l m n o

And we get a query where the start key matches leaf i and the end key matches leaf k.

We would return the key/value pairs from i,j,k. We would also return a,b,d,i,e,k as boundary nodes. These boundary nodes cover the paths from the root (a) to the start and end keys (leaves i and k). Note that there is quite a bit of redundant information returned here; more than necessary to prove presence of i,j,k in the trie. This might be changed in the full protocol; it's defined this way to hopefully make the boundary proof easy to build and verify.

If we get a query where the start key is _not_ in the trie, it is a bit more complicated as the boundary nodes need to cover the path where this key _would_ be found, if it was in the trie (in order to prove absence). If we imagine, for example, the same query but with the start key changed so it is greater than i's key but would still be found at the location of i in the trie. In that case, we would only return the key/value pairs from j and k, but the returned boundary nodes would be the same (a,b,d,i,e,k).

  ‚Ü≥ 2024-11-05 20:31 xlchen: the boundary nodes is not length prefixed, so how am I suppose to know how many nodes are there?
  ‚Ü≥ 2024-11-05 20:32 xlchen: also can you confirm each node is 64 bytes data?
  ‚Ü≥ 2024-11-05 20:36 xlchen: I guess I will skip CE129 until we have some concrete test cases. it should only be used by light clients right? and maybe warp sync mode. otherwise I don't see why a fullnode need to make state request
  ‚Ü≥ 2024-11-05 21:35 dave: > <@xlchen:matrix.org> the boundary nodes is not length prefixed, so how am I suppose to know how many nodes are there?

The boundary nodes are sent in their own message, you can determine the number of nodes from the message length
  ‚Ü≥ 2024-11-05 21:36 dave: > <@xlchen:matrix.org> I guess I will skip CE129 until we have some concrete test cases. it should only be used by light clients right? and maybe warp sync mode. otherwise I don't see why a fullnode need to make state request

It will be used for warp sync, though finality proofs will also be needed for that which are not specified yet üòÖ
  ‚Ü≥ 2024-11-05 21:37 dave: Should be possible to get by without it for now
  ‚Ü≥ 2024-11-05 21:39 xlchen: we should have the proof format defined in GP if it is not already there. but JAMNP will be part if GP right? so that will happen eventually. will move this to bottom of my todo list for now
  ‚Ü≥ 2024-11-06 00:22 dave: > <@xlchen:matrix.org> we should have the proof format defined in GP if it is not already there. but JAMNP will be part if GP right? so that will happen eventually. will move this to bottom of my todo list for now

The final network protocol will be in the GP yeah. Don't think the simple version will ever be as it's just a stepping stone
  ‚Ü≥ 2024-11-06 00:25 dave: > <@jam_man:matrix.org> I‚Äôm just starting to look into this. So could someone help clarify some general questions about this ‚Äúcompetition‚Äù. Is the goal to build a fully functional prototype of the JAM protocol in  your selected language (Python), closely aligned with the Gray Paper? Each milestone‚Äîcovering state transitions, block importing, block production, PVM implementation, performance optimization, and security auditing‚Äîseems to reflect key sections of the Gray Paper, so I‚Äôm wondering if the intent is for us to create an end-to-end model of JAM‚Äôs core functionality in Python.

You should probably move this message to the main channel üòÖ
  ‚Ü≥ 2024-11-06 00:25 jam_man: Ya that‚Äôs probably a good call üòÖ
2024-11-05 15:03 dave: Example requests/responses for the various protocols will probably be covered by test vectors at some point, at least where this makes sense. These don't exist yet though.
2024-11-05 16:27 jaymansfield: Hello all. We have been silently coding away but are happy to finally share our first public update here. We are working on a Java implementation of JAM, temporary name is JavaJAM. 

Currently we have the following sets of test vectors passing: codec, safrole, disputes, recent history, trie and as of today PVM tests are also all passing now. 

Next priority is networking so we can start or join a testnet. Let's keep building! [edited]
2024-11-06 00:17 jam_man: 
2024-11-06 02:45 bmaas: JamZig has landed at the Valia Hotel, Bangkok. Milestone #1: find koffie! ‚òï [edited]
2024-11-06 12:28 sourabhniyogi: Does anyone have a Rust QUIC implementation demonstration showing the JAMSNP UP 0 handshake between Rust <> Rust?  

We can snowball a Go equivalent to match and show Rust <> Go (or whomever can contribute their own language), and I imagine everyone else can basically use this as a reference so JAMSNP connectivity issues are basically on par with FFIing into w3f's bandersnatch/ring-vrf+bls libraries (consistent with Rule 1).
  ‚Ü≥ 2024-11-06 12:35 celadari: We are also interested in seeing that, because the quic part is still a blurry for us
  ‚Ü≥ 2024-11-06 12:42 dave: I'd rather clarify the specification than provide an implementation, as this stuff will eventually need to go into the GP. Is there anything in particular that is unclear or in general it just needs fleshing out?
  ‚Ü≥ 2024-11-06 13:53 sourabhniyogi: Ok.  We can post a Go <> Go implementation (since we'd probably do Rust <> Rust badly in some way) and folks can check if it matches the spec.  
  ‚Ü≥ 2024-11-08 01:51 sourabhniyogi: https://github.com/jam-duna/jamtestnet/tree/main/jamnp/go
  ‚Ü≥ 2024-11-08 01:51 sourabhniyogi: has a tiny skeleton -- if there is a Rust one we could connect them together and see if they made the same correct choices.
  ‚Ü≥ 2024-11-11 18:52 tebdev: I suggest we have a discussion related to QUIC, one of the options I am researching wraps Rust for C++ but I think we should align on TLS library or not which seems to be a big dependency e,g, wolfSSL, LibreSSL, Boring OpenSSL, etc.
  ‚Ü≥ 2024-11-11 18:53 tebdev: The team has more Polkadot experience than I do so looking for guidance, opinion. [edited]
  ‚Ü≥ 2024-11-11 19:45 clearloop: > <@sourabhniyogi:matrix.org> has a tiny skeleton -- if there is a Rust one we could connect them together and see if they made the same correct choices.

Interesting, I'll start my rust implementation after devcon, imo a shared command line interface could be helpful for doing e2e tests with different clients
  ‚Ü≥ 2024-11-11 20:21 dave: > <@sourabhniyogi:matrix.org> has a tiny skeleton -- if there is a Rust one we could connect them together and see if they made the same correct choices.

Thanks, will try to connect this with our implementation this week
  ‚Ü≥ 2024-11-11 20:25 dave: > <@tebdev:matrix.org> I suggest we have a discussion related to QUIC, one of the options I am researching wraps Rust for C++ but I think we should align on TLS library or not which seems to be a big dependency e,g, wolfSSL, LibreSSL, Boring OpenSSL, etc.

IMO it would be preferable for implementations to use different TLS libraries to reduce the impact of vulnerabilities, possibly I'm misunderstanding
  ‚Ü≥ 2024-11-11 20:26 dave: Also to avoid accidentally depending on the details of a particular implementation
  ‚Ü≥ 2024-11-14 14:16 dave: > <@sourabhniyogi:matrix.org> https://github.com/jam-duna/jamtestnet/tree/main/jamnp/go

Not clear how I am supposed to run this? Looking through the implementation though I can see a few things that are not correct:

- Message size should be little-endian on the wire, as stated in the SNP doc.
- The block announcement protocol is supposed to be _persistent_ (hence the persistent in UP). In this repo it seems like it is opened for a single announcement and then closed again.
- The block announcement stream should be opened only by the peer which initiated the connection.
- The certificate's alternative name should be checked against its public key, see the SNP doc for details. The point of this is just to make things look more like the Web 2.0 case, which is what most QUIC libraries are designed to handle.
- Your handling of the connection<->public key association seems pretty sketchy, particularly considering that it is possible AFAIK to have multiple QUIC connections with the same IP:port endpoint.
  ‚Ü≥ 2024-11-14 18:00 sourabhniyogi: Stellar feedback‚Äî will fix the first 4 next week and research how to do the last one, thank you! 
  ‚Ü≥ 2024-11-14 18:03 dave: Fixing the last one _might_ be tricky. It's actually one of the main reasons polkajam uses Quinn instead of `s2n-quic`: with `s2n-quic` there seemed to be no easy way to access the certificate/public key used by the peer during the handshake.
  ‚Ü≥ 2024-11-14 18:05 dave: Looks like the peer certificate can be accessed in quic-go via `ConnectionState().TLS.PeerCertificates`
2024-11-06 12:29 sourabhniyogi: We have some guesses as to how Ed25519 public keys are mapped into validator indexes but aren't super sure that our guesses are right.  So, having this mapped out in a Rust <> Rust working demo would make everything crystal clear.  
2024-11-06 12:39 dave: > <@sourabhniyogi:matrix.org> We have some guesses as to how Ed25519 public keys are mapped into validator indexes but aren't super sure that our guesses are right.  So, having this mapped out in a Rust <> Rust working demo would make everything crystal clear.  

The index of a validator is simply its position in the validator key list in the state. Is this what you weren't sure about or something else?
2024-11-06 12:50 sourabhniyogi: > <@dave:parity.io> The index of a validator is simply its position in the validator key list in the state. Is this what you weren't sure about or something else?

By this I mean if some node X connects to another node Y, node Y has to figure out which validator index X in the state it is.  Both X and Y have some ed25519 pub key, which are used in the TLS handshake with self-signed certs as per https://github.com/zdave-parity/jam-np/blob/main/simple.md#encryption-and-handshake -- so both X and Y use their [genesis] state -- something like https://github.com/jam-duna/jamtestnet/blob/main/traces/safrole/genesis.json#L81-L118 which use develop -- to basically map the pub key from the cert into a validator index in that state.  

That's the first part, which gets all the basic niceties of TLS mapping into validator indexes out of the way

Then the second part is everything here down to the exact "Unique Persistent" part
https://github.com/zdave-parity/jam-np/blob/main/simple.md#up-0-block-announcement

where we can just have some dummy data to support the `Handshake` and `Announcement`, maybe like every 6 seconds.
2024-11-06 12:52 sourabhniyogi: We can post our Go <> Go but I don't want to spread the wrong answer if someone has a Rust <> Rust correct answer?
2024-11-06 12:54 charliewinston14: Are third party libraries allowed for the QUIC protocol? The rules only mention crypto related ones but not all languages have it built in yet and would be a massive undertaking to write from scratch.
2024-11-06 12:55 dakkk: image.png
2024-11-06 13:03 sourabhniyogi: > <@charliewinston14:matrix.org> Are third party libraries allowed for the QUIC protocol? The rules only mention crypto related ones but not all languages have it built in yet and would be a massive undertaking to write from scratch.

Definitely as per Rule 1 "Third-party libraries for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE), and networking (e.g. QUIC) are acceptable." 
2024-11-06 13:04 sourabhniyogi: Has anyone succeeded with FFIing into one, just curious?
2024-11-06 13:06 dave: FWIW we're using Quinn at the moment in PolkaJam (Rust)
2024-11-06 13:10 sourabhniyogi: Ok for Quinn is there some snippet of rust that if we add to
 https://github.com/quinn-rs/quinn/blob/main/quinn/examples/server.rs#L168
gets at the Ed25519 pub key correctly?

And covers the generation of the self-signed certs. [edited]
2024-11-06 13:17 dave: Once you have a `Connection` in Quinn you can call `handshake_data` to get at the peer's certificate (https://docs.rs/quinn/0.11.5/quinn/struct.Connection.html#method.handshake_data)
2024-11-06 13:28 dave: > <@dave:parity.io> Once you have a `Connection` in Quinn you can call `handshake_data` to get at the peer's certificate (https://docs.rs/quinn/0.11.5/quinn/struct.Connection.html#method.handshake_data)

Ah sorry the function is `peer_identity`, not `handshake_data`
2024-11-06 13:32 dave: You should also set custom certificate verifiers for `rustls` to check the requirements given in the SNP doc. The requirement that the "alternative name" be derived from the public key was intended to fit with APIs that allow you to specify an expected name when connecting. eg In Quinn, `Endpoint::connect` takes an IP address and an expected name (https://docs.rs/quinn/0.11.5/quinn/struct.Endpoint.html#method.connect)
2024-11-06 13:38 sourabhniyogi: Got it -- It is sufficient to check the pub key, and ignore checking that the ip address in the metadata matches, right?   A latent background question is: why do we need/want ip address data on-chain? [edited]
2024-11-06 13:39 dave: There is no need to verify IP address/port no
2024-11-06 13:39 dave: These are included on-chain so that all validators know how to connect to each other
2024-11-06 13:40 dave: In Polkadot there is a DHT for this, which has some advantages (eg IP/port can be changed at any time), but overall we decided it was not worth the extra complexity
2024-11-06 13:52 sourabhniyogi: Ok, how are validators expected to change their ip/port  -- isn't this a slow process?  is allowing dns into the mix a reasonable move for the ip part?   It sure seems too easy to firewall out the entire network.  Probably a rabbit hole discussion to be saved for another day!
2024-11-06 14:16 dave: A new validator set can be specified every epoch, with new addresses for all the validators in the set. New validator sets are queued, but epochs are only an hour each, so a transition to a new IP address should take at most a few hours. There is at least one wrinkle in this: exported segments are expected to be available for 28 days. The validators holding them may not be elected as validators again, and so may not get a chance to "announce" new addresses. In all honesty I'm not totally clear on what the incentives are for these validators to remain online and continue serving requests for the old exported data.
2024-11-06 14:17 dave: Not sure what you mean by "It sure seems too easy to firewall out the entire network"
2024-11-06 14:18 dave: Re allowing DNS, don't have a strong opinion on this, though it would be less simple :)
2024-11-06 17:30 xlchen: there is little needs to change ip address with ipv6
2024-11-06 17:31 xlchen: we are using msquic btw and it offers callback to perform custom cert validation 
2024-11-07 02:05 jaymansfield: I have a question relating to JAMNP. For the ephemeral encryption key for the DH key exchange, is this also Ed25519? Or does it use TLS 1.3 default sig algorithms? [edited]
2024-11-07 02:19 xlchen: our implementation just use the default
2024-11-07 08:55 dave: You can just use the default settings for this, IIRC there is some negotiation to pick an algorithm both sides support
2024-11-07 13:14 emielsebastiaan: > <@gav:polkadot.io> Do we have somewhere to congregate on the 9th/10th?

Did anyone share any new details for the 9th or 10th on any gathering of implementer teams? Lmk üôèüèª
2024-11-07 14:21 oliver.tale-yazdi: > <@emielsebastiaan:matrix.org> Did anyone share any new details for the 9th or 10th on any gathering of implementer teams? Lmk üôèüèª

i think this is the most up-to-date link https://polkadot.subsquare.io/referenda/1024
2024-11-08 01:54 sourabhniyogi: For the 9th/10th  whoever gets there tomorrow first can find a spot/room and announce that spot for JAM builders here?

For the 11th-16th I updated https://polkadot.subsquare.io/referenda/1024 with food arrangement details.  

Happy travels all [edited]
2024-11-08 10:54 ycc3741: Hi. I consider that I need some help. I'd sent the mail to your team and asking for whether or when our team can be on the JAM Prize client page. Look forward to your response, I appreciate your efforts. Thanks a lot.
2024-11-08 11:19 gav: > <@ycc3741:matrix.org> Hi. I consider that I need some help. I'd sent the mail to your team and asking for whether or when our team can be on the JAM Prize client page. Look forward to your response, I appreciate your efforts. Thanks a lot.

There is a link for getting in touch with the W3F prize team on the [W3F JAM Prize page](https://jam.web3.foundation/)
2024-11-08 11:20 gav: That link doesn't seem to mention 9-10. Is there any info on where and who will attend on the 9-10? [edited]
2024-11-08 17:00 olanod: Random thought, perhaps off-topic...I was very briefly checking [hyperlight](https://github.com/hyperlight-dev/hyperlight) and their "micro vms" concept, it looks interesting and familiar to what we see with WASM runtimes or PolkaVM. Assuming 99% of chain infrastructure runs on x86_64 linux, would it be reasonable to support chain infrastructure running sandboxed binaries of the same architecture as the host machines?("polkavm micro vms" should still be possible).
2024-11-08 17:19 gav: Firstly, PVM is already pretty close in ISA to x86_64, by design, so x86 code should not be too hard to express as PVM. The harder part is making the I/O work - CPUs enjoy a much greater memory/disk random access bandwidth than blockchains due to the need to ferry data and prove correctness to all nodes involved in verifying. Secondly, the really hard part for a trustless ISA is gas accounting. A lot more becomes possible with effective secure deterministic metering and hyperlight doesn‚Äôt make any efforts to support this afaict.  [edited]
2024-11-08 17:25 olanod: yeah I don't think metering is in their radar and might not be trivial to implement.
2024-11-09 04:46 ycc3741: > <@gav:polkadot.io> There is a link for getting in touch with the W3F prize team on the [W3F JAM Prize page](https://jam.web3.foundation/)

Thanks a lot. I'd sent the.
2024-11-09 04:46 ycc3741: I'd send the pr. 
2024-11-09 04:47 gav: Maybe it‚Äôs worth setting up a group for those who will be in Valia Hotel over the next days?
2024-11-09 04:47 gav: [@emielsebastiaan:matrix.org](https://matrix.to/#/@emielsebastiaan:matrix.org) [@sourabhniyogi:matrix.org](https://matrix.to/#/@sourabhniyogi:matrix.org)?
2024-11-09 04:50 boymaas: > <@gav:polkadot.io> Maybe it‚Äôs worth setting up a group for those who will be in Valia Hotel over the next days?

Great idea! Feel free to add me too.
2024-11-09 04:51 sourabhniyogi: > <@gav:polkadot.io> Maybe it‚Äôs worth setting up a group for those who will be in Valia Hotel over the next days?

Can you be at valia after sub0 on 11th (you have the last talk) or on 12th ? 
2024-11-09 04:57 gav: As I have previously said, I‚Äôll be in Thailand 9th and 10th only. 
  ‚Ü≥ 2024-11-09 05:33 0xjunha: In the Sub0 agenda, I see you are giving a speech on 11th at the main stage, will it be virtual?

https://agenda.sub0.gg/sub0-reset-2024/talk/XKWVPR/
2024-11-09 04:57 oliver.tale-yazdi: > <@gav:polkadot.io> Maybe it‚Äôs worth setting up a group for those who will be in Valia Hotel over the next days?

kianenigma: and me are also in the area
2024-11-09 04:57 oliver.tale-yazdi: Currently sub0
2024-11-09 05:07 emielsebastiaan: I am around (sub0) and available. Same for danicuki 
2024-11-09 05:17 gav: JAM0 chat: https://app.element.io/#/room/#jam0:polkadot.io
2024-11-09 06:01 gav: No -in person but I‚Äôll be leaving shortly afterwards. 9th and 10th are my only full days
2024-11-09 09:59 emielsebastiaan: We‚Äôll have a JAM meetup for JAM Implementers in private meeting room (Meeting Room II) with beamer at Valia Hotel from 19:00h - 22:00h tonight (Valia Hotel Bangkok, Sukhumvit 24).
We‚Äôll have plenty of pizza and drinks. ‚Ä®‚Ä®We can accommodate ~25 people.‚Ä®Agenda:
	1.	Team Introductions.‚Ä®We‚Äôd appreciate a 5-10 minute presentation about your team, reasons for implementing JAM, and some lessons learned.
	2.	Graypaper Questions and Answers
	3.	Planning, timelines, versions, milestones.
	4.	Suggestions for additional topics are welcome.
Please confirm your attendance.

One more important fact: Gavin will be joining.


2024-11-09 10:01 emielsebastiaan: Join chat to confirm attendance: https://app.element.io/#/room/#jam0:polkadot.io
2024-11-09 11:00 emielsebastiaan: I know it is a last minute call. But if you or your team is implementing JAM please join our little meetup. It is a great opportunity to get to know each other and converge on some common topics. 

We hope to see you in one hour. 
2024-11-09 11:20 emielsebastiaan: Meeting Room 2 can be found on the 18th floor and should be accessible by elevator. [edited]
2024-11-09 15:46 emielsebastiaan: ima_b848e0f.jpeg
2024-11-09 15:46 emielsebastiaan: ima_0087e61.jpeg
2024-11-09 15:46 emielsebastiaan: ima_d2fd7ea.jpeg
2024-11-09 15:46 emielsebastiaan: ima_d2c6157.jpeg
2024-11-09 15:46 emielsebastiaan: ima_4388d2e.jpeg
2024-11-09 15:46 emielsebastiaan: ima_ec8e5b7.jpeg
2024-11-09 15:47 emielsebastiaan: ima_24c082c.jpeg
2024-11-09 15:47 emielsebastiaan: ima_1bc1af5.jpeg
2024-11-09 15:47 emielsebastiaan: ima_c0934de.jpeg
2024-11-09 15:47 emielsebastiaan: ima_7755b40.jpeg
2024-11-09 15:47 emielsebastiaan: ima_5020b59.jpeg
2024-11-09 15:47 emielsebastiaan: ima_d1dbc71.jpeg
2024-11-09 15:47 emielsebastiaan: ima_9aeb50b.jpeg
2024-11-09 15:47 emielsebastiaan: ima_28c47bb.jpeg
2024-11-09 15:47 emielsebastiaan: ima_4601e36.jpeg
2024-11-09 15:48 emielsebastiaan: Lesson for next time: group picture. 

Thank you everyone for participating!!! üôèüèªüôèüèªüôèüèª
2024-11-09 15:49 emielsebastiaan: Does anyone have a picture of me on stage?
2024-11-09 15:53 emielsebastiaan: Apologies Kamil, I did not take a picture of you on stage. 
2024-11-09 15:55 emielsebastiaan: We hope to share recordings of presentations in due time. 
2024-11-10 14:28 clearloop: If it is still possible to join the public implementation )) I sent the form from the get in touch button and waited reply for months, just know it already started xd [edited]
2024-11-10 14:44 xlchen: there is no need to get anyone‚Äôs approval before you can start it 
2024-11-11 03:47 oliver.tale-yazdi: Hey i added a tutorial for certificate generation, just in case if someone needs a straight forward way to crosscheck: https://docs.jamcha.in/advanced/networking/Certificates  
Also please LMK if this seems wrong to you, will try to use this for networking soon with other teams
2024-11-11 05:47 danicuki: Video with the JAM Roadmap to 1.0

https://www.youtube.com/watch?v=Jq8XBs1wPhg
2024-11-11 08:44 danicuki: I didn't know, but looks like someone already thought about running Doom on a blockchain and build it for Cardano. https://x.com/inputoutputhk/status/1824496224764039678?s=46&t=uDWflhDt4F1i47bMUn3yKA

Does anyone can explain the differences on JAM compared to the Cardano solution?
2024-11-11 08:47 xlchen: a 5s look it is still transaction based, which is fundamentally different compare to JAM, which is transactionless. ie no need anyone to trigger the execution 
2024-11-11 09:12 oliver.tale-yazdi: > <@danicuki:matrix.org> I didn't know, but looks like someone already thought about running Doom on a blockchain and build it for Cardano. https://x.com/inputoutputhk/status/1824496224764039678?s=46&t=uDWflhDt4F1i47bMUn3yKA
> 
> Does anyone can explain the differences on JAM compared to the Cardano solution?

Jan had a demo about this last year already: https://github.com/koute/polkadoom, so not sure who got the idea from whom
2024-11-11 09:16 emielsebastiaan: ima_ed13495.jpeg
2024-11-11 09:16 emielsebastiaan: https://canitrundoom.org/
2024-11-11 09:18 bkchr: > <@xlchen:matrix.org> a 5s look it is still transaction based, which is fundamentally different compare to JAM, which is transactionless. ie no need anyone to trigger the execution

Yeah and they are just committing the frames to the chain, while with JAM Doom itself could on a core and you just send the inputs as transactions
2024-11-11 09:18 bkchr: Would actually be some funny game. Like these twitch games. Everybody controls the movement
2024-11-11 10:02 ycc3741: Hi I had sent the pr which is #56 and accepted by the bot. 
I wonder when the website will be update.
Thanks a lot. Also, today's event on youtube is awesome and I really appreciate your effort.
2024-11-11 18:26 danicuki: I have a conceptual question about JAM: does JAM offer any guarantee of privacy for users? Wouldn't be possible that the validators node owner have access to the hardware memory and could see everything that is being executed in their own node, unencrypted?  
2024-11-11 18:47 tebdev: Good question and observation danicuki ! I have had clients that chose Corda and Hyperledger for this reason and others rolled their own blockchain e.g. JP Chase. Also does the Validator have a transport confidentiality requirement that justifies use of TLS? That then leads us to key lifecycle questions. [edited]
2024-11-11 20:36 dave: TLS is primarily for peer authentication and ensuring data integrity. The privacy aspect is not particularly important though it does matter in some cases (e.g. Safrole tickets would not be anonymous if everyone could see where they came from)
2024-11-11 20:42 dave: Re privacy within JAM, everything is public so anyone can see what is being computed. It would presumably be possible to have private computation in a service using ZK stuff though
2024-11-11 20:49 tebdev: > <@dave:parity.io> TLS is primarily for peer authentication and ensuring data integrity. The privacy aspect is not particularly important though it does matter in some cases (e.g. Safrole tickets would not be anonymous if everyone could see where they came from)

Thank you for clarifying. If I read this right the secuirty requirements are 1) authentication 2) data integrity (transport versus payload(Tx, Extrensic) ? ). Can you help me understand risk of Safrole ticket confidentiality requirement?
2024-11-11 20:58 dave: One of the goals of Safrole is to keep the identity of the selected block authors secret up until the point they actually author their blocks, to prevent them being DoSed for example. Tickets themselves are anonymous due to the RingVRF magic, but it is also important that the way tickets are distributed does not reveal their author. This is achieved by first sending each generated ticket to a randomly selected "proxy" validator who then distributes the ticket more widely. Anyone who sees this ticket get sent to the proxy validator can infer who created it so the sending should be private. Of course the proxy validator could itself be compromised, this is hopefully rare!
2024-11-11 21:00 dave: > <@tebdev:matrix.org> Thank you for clarifying. If I read this right the secuirty requirements are 1) authentication 2) data integrity (transport versus payload(Tx, Extrensic) ? ). Can you help me understand risk of Safrole ticket confidentiality requirement?

Re security requirements, for the transport between validators we definitely need authentication and integrity, otherwise the security arguments for the protocols built on top will fall apart
2024-11-11 21:11 tebdev: Please accept my apology in advance if I am too direct, The prize is not my primary incentive. I am trying to convince my stakeholders that Polkadot and JAM is the future. I ask questions to defend my Polkadot lemma. Very interesting ... "things fall apart" ... So Validator requires Trust to enable Trustless transactions. Does this indicate that Polkadot will become a CA since a key pair at server level a dependency for mTLS? [edited]
2024-11-11 21:15 dave: I meant only that if a validator thinks it's talking to another validator but is actually talking to someone else then that is bad
2024-11-11 21:15 dave: Don't think this is anything special to JAM
2024-11-11 21:16 tebdev: Agreed, but it seems to be a foundational element If not there may be confusion in the craft or my observation.

2024-11-11 21:18 tebdev: Please excuse me being a Polkadot neophite, but for one server to trust another keys, there must be trusted third party in a brokered trust model ... Right ?
2024-11-11 21:46 dave: If you identify servers by name then yes, but we just identify them by their public key
2024-11-11 21:46 tebdev: a public key is an identity as in authentication ... Right
2024-11-11 21:48 tebdev: In laymen terms public key (ID), private key (password) ... figuratively speaking
2024-11-11 21:49 tebdev: Ok the Server (1) is first party Server (2) is second party and Polkadot is trusted third party issueing keys to registered agents ... Private CA like Apple
2024-11-11 21:50 tebdev: In my humble view Polkadot is a private CA with all the rights, privileges and risk there unto appertaining ... ;)
2024-11-11 21:52 tebdev: Passport or a coin (staking) is just a hurdle any CA can legislate but in the end it is the same. trusted third party issuing trust with keys.
2024-11-11 21:58 tebdev: This is my humble Polkadot lemma . I am open to "reductio ad absurdum" ;), encourage it, welcome it because security a team quality sport. [edited]
2024-11-11 22:10 dave: > <@tebdev:matrix.org> Ok the Server (1) is first party Server (2) is second party and Polkadot is trusted third party issueing keys to registered agents ... Private CA like Apple

No, validators generate their own keys. There is no trusted third party or central authority
2024-11-11 22:12 tebdev: OK, then validator creates own keys, server (1) and server (2) , which is reasonable, but what is mechanisms for them to trust each other ... JAM/Polkadot
2024-11-11 22:12 dave: Unless you consider the blessed chain that can set the validators to be a central authority, which I can see
2024-11-11 22:12 tebdev: Yes, I used term issue, but registration is another option for a CA
2024-11-11 22:13 tebdev: You still roll up to brokered trust model in the end, just semantics on who and what you call it.
2024-11-11 22:14 tebdev: Crypto chicken and egg... ;)
2024-11-11 22:15 tebdev: Google app store uses the CA registration versus Apple which is issuer ...
2024-11-11 22:15 tebdev: Both valid, but tradeoffs, 
2024-11-11 22:19 tebdev: Polkadot as a Certificate Authority:
Since Polkadot is issuing or registering keys for the servers, it qualifies as a certificate authority (CA) if these keys are used to establish mutual trust. The registration or issuance process is still central to Polkadot being considered a CA.
In set notation, the formal definition becomes:

2024-11-11 22:19 tebdev: 
2024-11-11 22:22 tebdev: image.png
2024-11-11 22:23 tebdev: If JAM/Polkadot will leave trust to the validators then OK, that is the law... If not then the judge is JAM/Polkadot
2024-11-11 22:33 tebdev: Net/Net, I need some help with this as foundational element to QUIC Key Life Cycle. 
2024-11-11 23:12 dave: > <@tebdev:matrix.org> sent an image.

Don't understand this sorry üòÖ
2024-11-11 23:26 dave: > <@tebdev:matrix.org> Net/Net, I need some help with this as foundational element to QUIC Key Life Cycle. 

Not sure what the question is exactly, sorry. You can argue that the blessed service is a central authority because it decides the next validator set. But assuming you trust the previously elected validator set, this service just behaves according to its code, which in practice will elect validators based on the staking decisions of Dot holders; there is no central authority.
2024-11-11 23:27 xlchen: I don‚Äôt really understand the question but there is some kind of chain of trust for validator keys. The root is genesis validators. And then via beefy/grandpa anyone can validate if a block is sealed by a current validator by proofs and exposed identity will be validator keys, which include ipv6 address in metadata
2024-11-11 23:27 tebdev: Sorry , early and multiplexing. Here is a better explanation. 
2024-11-11 23:28 xlchen: the only centralized part is the genesis, which is possible to find someways to generate it in decentralized way
2024-11-11 23:30 tebdev: PolkadotasCA.pdf
2024-11-11 23:33 tebdev: > <@dave:parity.io> Not sure what the question is exactly, sorry. You can argue that the blessed service is a central authority because it decides the next validator set. But assuming you trust the previously elected validator set, this service just behaves according to its code, which in practice will elect validators based on the staking decisions of Dot holders; there is no central authority.

Good point, but staking is a gate that Polkadot can up/down vote . If Validator approved how does the QUIC get a key it will trust. This goes back to your "fall down" comment to avoid a bad actor/imposter
2024-11-11 23:35 tebdev: Even if we have Governance and voting, the governance body = Polkadot
2024-11-11 23:35 tebdev: Or better said Polkadot stakers
2024-11-11 23:55 dave: To answer "If Validator approved how does the QUIC get a key it will trust": the blessed service provides the keys when specifying a new validator set
2024-11-11 23:59 tebdev: Ok , fair enough ... NO arguments from me, trying to walk it down to get my head around it, Blessed Service = (Some Polkadot Community) = (Distributed Authority) --> Issue keys (X.509, EC, Dual Key Pair) = Certificate. So would an entity issuing certificates with some rules or authority be a CA?. 
2024-11-12 00:19 dave: Not sure what you mean by (X.509, EC, Dual Key Pair) = Certificate. Each validator has 2 public keys at the moment: an Ed25519 public key and a "Bandersnatch" public key. These are the keys that are provided when the blessed service specifies a new validator set. The nodes generate their own certificates containing their Ed25519 key. This is done only to keep the TLS protocol happy. The certificates are self-signed but these signatures are not expected to be checked. FWIW I wouldn't say the authority "issues" keys but rather selects keys that have been previously generated by nodes.
2024-11-12 00:23 tebdev: 
2024-11-12 00:28 tebdev: Ok, corrected...  I was being figurative in speech to say a dual key pair of a mutually agreed type. I may have got ahead of myself with "Certificate." If I am validator and I can be slashed, I would want a trust chain for this key signed and sealed by whomever sent it to me e.g. a "Certificate" ... This could be a Tx Extrinsic signature or a self contained root chain like X.509. QUIC and TLS best practice is X.509 to handle numerous risk scenarios. 
2024-11-12 00:31 tebdev: This can also be genesis related as Bryan Chen | Laminar & Acala mentioned to establish a trust chain.
2024-11-12 00:32 tebdev: The validator would check public key to whatever trust chain before assuming trust of another validator?
2024-11-12 00:33 xlchen: what do you mean by check publicly key? they are read from onchain state which are checked
2024-11-12 00:34 tebdev: This delegates risk of bad key to governing body or genesis to mitigate validator risk
2024-11-12 00:34 xlchen: the risk of a few bad keys are minimal. that‚Äôs what PoS about (which is not part of GP)
2024-11-12 00:36 tebdev: Well, in all my security training we can 1) accept risk, 2) defer risk 3) mitigate risk ... Just need know which one is being asserted.
2024-11-12 00:36 tebdev: I am easy ;)
2024-11-12 00:37 tebdev: The flip side, I must be transparent to stakeholders when I explain. Then they chose to accept risk [edited]
2024-11-12 00:38 xlchen: GP implicitly covers the part of the maximum damage can be done by few bad keys
2024-11-12 00:38 xlchen: ie not possible to have bad reports to be finalized 
2024-11-12 00:40 tebdev: Fair enough, can you provide document. I am easy, but those that care will ask where did key come from and how can we trust it? If we just defer / accept risk , then that must be reveiwed for indemnification. 
2024-11-12 00:40 xlchen: the risks are mitigated 
2024-11-12 00:41 tebdev: OK, I am novice, help me understand
2024-11-12 00:41 xlchen: it is not possible for example to finalize a bad parachain block currently in polkadot 1.0. same for JAM
2024-11-12 00:42 tebdev: Hmm, I think we comparing apples to oranges... ;)
2024-11-12 00:44 xlchen: they are same. there are auditing process defined by GP to ensure bad reports will be identified and reported and having bad validators to be removed
2024-11-12 00:48 tebdev: I am only focused on QUIC server (1) <--> Server (2) TLS handshake now. Respectfully, I think what you referring to comes lager ... 
2024-11-12 00:49 xlchen: then the max damage is dos, which is nothing 
2024-11-12 00:50 xlchen: I am talking about max damage of a bad key
2024-11-12 00:50 xlchen: there is little damage can be done on network level
2024-11-12 00:52 xlchen: of course the node must implement the usual networking best practice. ie rate limiting, peer reputation, message sanitation etc
2024-11-12 00:54 xlchen: it will be bad for example if everyone is using openssl with another heartbleed bug. and that‚Äôs why we should use different libraries [edited]
2024-11-12 00:59 tebdev: Key management with X.509 is an industry best practice when using TLS even if QUIC(TLS) ., We can decide not to do that, but needs to be a decision at some level or maybe backlogged as issue to keep moving forward.
  ‚Ü≥ 2024-11-12 01:07 xlchen: if you can identify vulnerabilities of the current approach, just show it and I am sure the next version of the networking spec will be adjusted to fix it
2024-11-12 01:03 tebdev: > <@xlchen:matrix.org> it will be bad for example if everyone is using openssl with another heartbleed bug. and that‚Äôs why we should use different libraries

I agree, but think we should discuss use of different sources. I developed "Aerospace" and Crititical infrastructure code... commented deciding to do clean room and funding it was Nobel Prize level for unstoppable. We should seek unstoppable for the network too.
2024-11-12 01:05 sourabhniyogi: For those of you not in Bangkok, this is from this weekend's JAM0 meetup with Gav

 https://www.youtube.com/watch?v=Jq8XBs1wPhg
 https://x.com/colorfulnotion/status/1856135098929951219

Its more detailed than the sub0 talk of yesterday, so JAM implementers won't want to miss it!
2024-11-12 01:15 tebdev: To be clear, I have no dog in fight, I am following Sr. Polkadot guys.  I just want to know where dogs may fight to avoid it ;)
2024-11-12 01:17 tebdev: Maybe we agree QUIC keys are either issued or registered and tied to some authority to establish a trust chain and put in backlog as issue. ... I am flexible.
2024-11-12 01:19 xlchen: we are not going to make adjustments just because some people may have false understanding of security. we can provide more education content to explain why our approach is secure but if people insist on useless addition, well, I don‚Äôt know, I am not going to make my life harder because of that
2024-11-12 01:20 xlchen: there IS a chain of trust already 
2024-11-12 01:20 xlchen: it is not like people can become validators as they want
2024-11-12 01:21 dave: SNP uses certificates only because this is the path of least resistance: basically all QUIC libraries are designed for the Web 2.0 use case of a client connecting to a server via a name like google.com. In that case you need a certificate chain and trusted root to establish a link between google.com and a public key. In the case of JAM, we start with a public key so the certificate stuff is all somewhat pointless. It's just hoop jumping so that the protocol can be implemented without having to hack around with QUIC libraries too much. In a perfect world we would just use some noise protocol (http://www.noiseprotocol.org/) and there would be no certificates involved.
2024-11-12 01:21 tebdev: Fair enough. I did ask to help me understand as neophyte. I am too old to argue and to fat to fight. Also I am flexible and easy. I just ask for explanation so I can explain to others that rely on me. 
2024-11-12 01:22 tebdev: NO one asked you to change. I do not know where you got that. 
2024-11-12 01:22 tebdev: I hope this is safe place for open dialogue. 
2024-11-12 01:23 tebdev: Security = Quality, Quality = teamwork, Teamwork = open mind
2024-11-12 01:24 xlchen: > <@tebdev:matrix.org> Maybe we agree QUIC keys are either issued or registered and tied to some authority to establish a trust chain and put in backlog as issue. ... I am flexible.

this read like a change request? anyway, nothing personal. I don‚Äôt mind this kind of discussion. always happy to discuss things and I understand I maybe wrong as well
2024-11-12 01:24 tebdev: At the end it says "I am flexible" ;)
2024-11-12 01:26 tebdev: If you do not want something in backlog, I am OK. I just document and move on. I am truly easy...
2024-11-12 01:29 tebdev: I was asking for help to understand since I was not in the room when the design was developed. David was a good sport and made me think... this should be fun :)
2024-11-12 01:31 tebdev: No worries I am headed to Ethereum conference. I got people asking me about that one too. Maybe we catchup later with a beer. I have very open mind.
2024-11-12 03:49 danicuki: My initial question about security was exactly similar to Boy s condition: I am very happy to be building JAM. And can't keep this happyness within myself: I share what I am doing with others. People outside have many questions. I know how to answer most of them, but some are trickiest. 

That's why I ask here. We know some people are more specialists than me.  I am like Boy, kind of new to Polkadot. One idea would be to maybe include a FAQ section in the graypaper website or any other place might be convenient. 
2024-11-12 04:05 danicuki: If computation done in JAM is "public" - because hardware owner can read the memory - does this mean that some applications are not suitable for JAM, because of its design? Or am I missing something? [edited]
2024-11-12 06:54 emielsebastiaan: This is the point of having a public world computer. You can build private systems on a public infrastructure you cannot build a public system on a private infrastructure. 
2024-11-12 07:09 tebdev: World Computer  ... Indeed. Eth BT discussed that in keynote ... L1 = The Trust, L2 = The GPU ... Hmmm this sounds like Polkadot but with more validators 
2024-11-12 07:10 tebdev: hmmm [edited]
2024-11-12 13:21 olanod: Any word or place to discuss on the capabilities of the vm(during refine at least), i.e. what syscalls/host-functions would be available to guest programs? is it going to be very limited, fixed and jam specific or is it something that could evolve over time? I like the approach of WASI, after its MVP that provided basic std support(e.g IO with file descriptors), it's evolving into a flexible "component model" where interfaces are defined with the [WIT IDL](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) and based on the platform different bundles("worlds") are defined, interfaces can also include higher level capabilities like http clients or ML primitives(e.g. wasi-nn). Could we do something similar or better yet just use the same stuff? I imagine the Polkadot fellowship could be in charge of discussing via RFCs what goes in this "jam world" and jam implementers would be expected to support the agreed on capabilities.
2024-11-12 17:06 gav: JAM is a trustless supercomputer. this implies that it's a global singleton. whatever it does must be universally agreed. this is why we go to great pains to write a single formal specification that exactly describes correct behaviour in any possible circumstance. [edited]
2024-11-12 17:08 gav: if you can find a way to express an http client (or indeed any real-world I/O) in such a way, feel free to make a PR to the graypaper. [edited]
2024-11-12 17:09 gav: but i think you'll find it's a fool's mission.
2024-11-12 17:10 gav: (this is because the correct behaviour of an HTTP request is totally dependent on factors which cannot be universally agreed including network status, timing, server response, physical interface characteristics, ...) [edited]
2024-11-12 17:11 gav: without doing a comprehensive analysis i'd expect that the same is true for pretty much all useful sys calls.
2024-11-12 17:12 gav: there may be some which expose computation machinery which can be universally agreed upon to be available (e.g. a particular amount of "GPU gas"). this could _potentially_ be an in-core resource down the line. [edited]
2024-11-12 20:23 charliewinston14: Question about JAMNP. For the preferred initiator equation the last part has just (a < b) where a and b are ed25519 keys. What is meant by that comparison?
2024-11-12 21:08 alxmirap: hi, in my understanding, this equation is the XOR of 3 booleans, or equivalently 1-bit values. a and b are 32-byte arrays, but in essence they can be thought of as  very large numbers of the same size, so they can be sorted numerically. Then, a < b is literally their numerical comparison. 

Given that they are of the same domain, if they are both represented in, say, hex strings of the same size (as in, don't ignore leading 0s) then an alphabetical comparison should be equivalent to the numerical one.
2024-11-12 21:23 tebdev: > <@alxmirap:parity.io> hi, in my understanding, this equation is the XOR of 3 booleans, or equivalently 1-bit values. a and b are 32-byte arrays, but in essence they can be thought of as  very large numbers of the same size, so they can be sorted numerically. Then, a < b is literally their numerical comparison. 
> 
> Given that they are of the same domain, if they are both represented in, say, hex strings of the same size (as in, don't ignore leading 0s) then an alphabetical comparison should be equivalent to the numerical one.

agree with your statement, in C++ not a problem going from hex to int , If very large use Boost library ;)
2024-11-12 22:39 gav: > <@charliewinston14:matrix.org> Question about JAMNP. For the preferred initiator equation the last part has just (a < b) where a and b are ed25519 keys. What is meant by that comparison?

a and b are 32 byte quantities. They can be compared using a standard dictionary comparator. 
2024-11-12 22:55 tebdev: > <@gav:polkadot.io> a and b are 32 byte quantities. They can be compared using a standard dictionary comparator.

Agreed... good point. Using a "dictionary" more efficient std::lexicographical_compare, but depending on language including C++ can just be...  return hexStr1 < hexStr2, but do not want to speak for other languages.
2024-11-12 23:04 tebdev: > <@xlchen:matrix.org> this read like a change request? anyway, nothing personal. I don‚Äôt mind this kind of discussion. always happy to discuss things and I understand I maybe wrong as well

Please excuse, philosophically I agree this is better served as PR to JAM YP to avoid being disruptive. I am new to this project.
2024-11-13 05:59 haikoschol: At the JAM0 meeting yesterday we discussed what kind of dev tools we might want.

ltfschoen  just described how he is using TDD to implement Safrole, adding comments to the tests that reference the relevant part of the graypaper.

If those comments were in a specific format, a tool could identify changes to the graypaper that impact the behaviour those tests cover. Maybe the tool could use links to the fluffylabs reader (diffing HTML might be brittle though). Or it could use the LaTeX source.

Does that sound reasonable/useful to anyone?
2024-11-13 08:50 leonidas_m: Hello, given that passing the state-transition conformance tests is required for Milestone 1, do we need to fully implement the validator-core assignment logic as detailed in Section 11.3, or can we temporarily mock this for now (M1)?
2024-11-13 08:54 dakkk: > <@leonidas_m:matrix.org> Hello, given that passing the state-transition conformance tests is required for Milestone 1, do we need to fully implement the validator-core assignment logic as detailed in Section 11.3, or can we temporarily mock this for now (M1)?

g and g* are required for guarantees extrinsic validation, so you need to implement 11.3 in order to check the validity of a block
2024-11-13 17:12 tomusdrw: > <@haikoschol:matrix.org> At the JAM0 meeting yesterday we discussed what kind of dev tools we might want.
> 
> ltfschoen  just described how he is using TDD to implement Safrole, adding comments to the tests that reference the relevant part of the graypaper.
> 
> If those comments were in a specific format, a tool could identify changes to the graypaper that impact the behaviour those tests cover. Maybe the tool could use links to the fluffylabs reader (diffing HTML might be brittle though). Or it could use the LaTeX source.
> 
> Does that sound reasonable/useful to anyone?

We are using the links to the reader heavily in our code (duh!) and I think this kind of tool would make perfect sense.
I've passed that to the team and I think we can figure something out.

There is no need to parse HTML, because the reader link contains synctex blocks which point exactly to the latex source line that contains the selection. So it's just a matter of checking if that particular latex source line has been changed between versions.
  ‚Ü≥ 2024-11-14 01:21 sourabhniyogi: Wish you were here, you have a growing fan base -- I think one topic we want to know your thoughts on is what the import format for State should be 
 https://trie.fluffylabs.dev/ 
Option 1: https://github.com/jam-duna/jamtestnet/blob/main/traces/safrole/jam_duna/traces/373496_0.json
Option 2: 
https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-129-state-request

We would adjust Option 1 format to whatever you support today/tomorrow -- there are some details of lossiness in the service storage we are fretting over but there is no debate that with a little bit of work on your part to import some key-vals we can all benefit from a shared "state root" hasher and be like "what leaves do we differ on" so much faster!

  ‚Ü≥ 2024-11-14 09:06 tomusdrw: I think we can easily support both 31-bytes and 32-bytes input to the trie tool. We drop the last byte anyway right after the import. Let me prepare a PR for this.
  ‚Ü≥ 2024-11-15 00:28 sourabhniyogi: Eager to try it out and get your feedback on this, which I hope we can make as compatible as possible

https://hackmd.io/nk0Tr0iIQHmLm7WIXe_OoQ?both
2024-11-14 07:00 sourabhniyogi: Should CE 129 have 31-byte keys in the response or 32-byte keys in the response?

We believe it would be beneficial to have responses be *not* 31 bytes but instead 32 bytes, in order for a full range scan of CE129 (from 0x00...00 to 0xFF..FF) to have full 32-byte keys (and of course values) hashable into a comparable state root.   

Generating state roots with the 31 bytes, given the lossy service storage, is not possible -- but having 32 byte keys requires a tad more bookkeeping to match up with some UI like this https://trie.fluffylabs.dev/ 
  ‚Ü≥ 2024-11-14 13:04 dave: The response has 31-byte keys. This is explicitly stated in the SNP doc: `Key = [u8; 31] (First 31 bytes of key only)`
  ‚Ü≥ 2024-11-14 13:06 dave: The last byte of the key is ignored in the trie so I'm not sure including it makes sense
  ‚Ü≥ 2024-11-14 13:08 dave: You can do a full range scan and recompute the state root from the returned key/value pairs. Of course the idea is that you know the state root in advance and use it to verify the responses you receive
  ‚Ü≥ 2024-11-15 22:29 sourabhniyogi: Are we to compute state roots from 31 byte keys?  This detail escaped our attention ‚Ä¶ checking what we missed. 
  ‚Ü≥ 2024-11-26 04:18 sourabhniyogi: David Emett: Filed an issue / recommendation here [edited]
  ‚Ü≥ 2024-11-26 04:24 sourabhniyogi: https://github.com/zdave-parity/jam-np/issues/1 [edited]
2024-11-14 07:57 dakkk: There will be a video of the today JAM implementers meetup at Bangkok? 
2024-11-14 09:28 tomusdrw: > <@sourabhniyogi:matrix.org> Should CE 129 have 31-byte keys in the response or 32-byte keys in the response?
> 
> We believe it would be beneficial to have responses be *not* 31 bytes but instead 32 bytes, in order for a full range scan of CE129 (from 0x00...00 to 0xFF..FF) to have full 32-byte keys (and of course values) hashable into a comparable state root.   
> 
> Generating state roots with the 31 bytes, given the lossy service storage, is not possible -- but having 32 byte keys requires a tad more bookkeeping to match up with some UI like this https://trie.fluffylabs.dev/

IMHO it's better to just use `31-byte` for everything. I don't see a reason for this extra byte being useful at all.

Also I'd love to see the node hash truncated to 255bits everywhere to allow trie manipulation without recomputing the hash. If you merkelize everything from scratch, there is obviously no issue, but if you allow adding/removing nodes it's sometimes required to recompute the last bit in case the node moves from left to right branch.
2024-11-14 10:16 sourabhniyogi: > <@dakkk:matrix.org> There will be a video of the today JAM implementers meetup at Bangkok? 

We will have a second session on Friday at 11am and will share notes, but no recording :( 
2024-11-14 10:17 dakkk: got it (y) I'm a bit confused about those meetups, aren't a potential occasion of violating collusion rule? [edited]
2024-11-14 11:16 emielsebastiaan: Videos for the Saturday meetup have been published. We mostly got to know each other a bit better and got an opportunity to ask questions with Gavin present.
‚Ä®I was also present at the Tuesday meetup.‚Ä®I can assure you we did not discuss anything that violates (collusion) prize rules. That said, I am no longer in Bangkok now.
‚Ä®Discussion on Tuesday was mostly related to:‚Ä®‚Ä®1. Awareness of tooling that is already present and useful for everyone (e.g. fluffylabs)

2. Creating a list of things that would be useful besides the implementations (such as telemetry, explorer, cli flags, docker, RPC, other uis, etc)

3. Some coordination/scoping of M1, M2 priorities in order to have some form of cross-client testnet as initiated by Colorful Notion with useful phases to get implementer teams on board.

4. Discussion on having a (private) monthly call for implementers to further discuss on these topics.‚Ä®
It would be great if we can get notes out here on the chat. 1. To be transparent, 2. To follow up with actionable items. [edited]
2024-11-14 11:20 emielsebastiaan: Video‚Äôs Saturday: https://youtube.com/playlist?list=PLjGN96vX3BTKjLfBd5LimBuDuch-QfKPy&si=JyiUssgVrnaIdXqo

Scroll down to the end of the playlist. 
2024-11-14 11:37 emielsebastiaan: Notes by Oliver Tale-Yazdi - async and sourabhniyogi here: https://matrix.to/#/!KKOmuUpvYKPcniwOzw%3Amatrix.org/%24DL2Vsua2TFzSAZDzOYO4pH0A6Ud7cABS6C49vBZhx28
2024-11-14 17:32 prematurata: hey davxy , starting from the [padded ring commitment](https://github.com/davxy/jam-test-vectors/commit/2d71c3f76ac89aaf57abd892cc691841fa225c87) commit i am having issues in generating posterior_gamma_z. I've seen you changed all gamma_zs so I find it hard to pinpoint what changed at that point in time. Can you help out? 
2024-11-14 17:36 prematurata: > <@prematurata:matrix.org> hey davxy , starting from the [padded ring commitment](https://github.com/davxy/jam-test-vectors/commit/2d71c3f76ac89aaf57abd892cc691841fa225c87) commit i am having issues in generating posterior_gamma_z. I've seen you changed all gamma_zs so I find it hard to pinpoint what changed at that point in time. Can you help out?

ah i see ark-ec-vrfs also changed 2 months ago. Updating the underlying dependency fixed my issues. sorry for ping
2024-11-14 18:42 tomusdrw: 
2024-11-14 18:42 tomusdrw: > <@tomusdrw:matrix.org> We are using the links to the reader heavily in our code (duh!) and I think this kind of tool would make perfect sense.
> I've passed that to the team and I think we can figure something out.
> 
> There is no need to parse HTML, because the reader link contains synctex blocks which point exactly to the latex source line that contains the selection. So it's just a matter of checking if that particular latex source line has been changed between versions.

You ask, we provide: https://www.npmjs.com/package/@fluffylabs/links-check
2024-11-15 13:00 danicuki: Here is the video with JAM 1.0 detailed road map presented by Gav last week:

https://youtu.be/Jq8XBs1wPhg?si=8KvEZdAyeqeqaYP7
2024-11-15 19:20 sourabhniyogi: We would like to get systematic-ish access to the toaster to test V=1023 in mid-December after spinning up medium sized kubernetes cluster in Google Cloud of around V=384.  What do we do exactly? 
2024-11-15 20:09 gav: Wait until it‚Äôs built, for a start
2024-11-15 20:09 gav: mid-December is likely to be around the right timing though
2024-11-15 21:48 sourabhniyogi: Are there some smaller toaster configurations / parameters that could be appropriately be considered the Kusama JAM chain (and Paseo JAM chain) or are they going to be the same V? [edited]
2024-11-15 21:56 gav: I‚Äôd default to the same size unless there‚Äôs good reason to change it.  [edited]
2024-11-15 21:57 gav: As for the spec I‚Äôd have thought around 50% of the performance would be about right. 
2024-11-15 22:22 sourabhniyogi: I was thinking slightly more than V=341 for Paseo and slightly less than V=682 for Kusama (which could fit into the V=1023 toaster hardware) so as to grow like 1-2-3 but if that means teams spend time on appendix H variations it might not be worth it.  
2024-11-15 22:40 sourabhniyogi: In the big picture, is refine suitable for zk proof generation ? Are there any GPU resources per chance in this toaster we could use for some zk proof generation side use case? 
2024-11-16 08:44 gav: > <@sourabhniyogi:matrix.org> In the big picture, is refine suitable for zk proof generation ? Are there any GPU resources per chance in this toaster we could use for some zk proof generation side use case? 

No and it‚Äôd be dumb anyway. 
2024-11-16 08:45 gav: Refine is already trustless. 
2024-11-16 08:45 gav: ZK proof generation is verifiable. That‚Äôs the whole point of it. 
  ‚Ü≥ 2024-11-16 22:22 sourabhniyogi: Thanks for confirming that JAM should only be used to verify ZK proofs, and that the JAM Toaster has no role to play in being a ZK prover network itself.  How should JAM State integrate the results of ZK prover networks then, esp those powering rollups, in fulfilling its role as a rollup host?

Some underlying context, related to accumulate/integration:
https://github.com/gavofyork/graypaper/issues/134#issuecomment-2480827857


2024-11-16 15:18 ycc3741: Sorry, I would like to clarify whether we should mock the imported block to test the import functionality, or if there is any data already provided by Parity?
2024-11-16 16:04 davxy: Some vectors related to WP reporting STF (Section 11 - Part 2) are now available.
As always, your feedback is most welcome.

https://github.com/w3f/jamtestvectors/pull/20
2024-11-16 16:05 davxy: https://github.com/davxy/jam-test-vectors/blob/work-reports/reports/README.md
  ‚Ü≥ 2024-11-18 06:19 shwchg: is the entropy need to go into the state?
2024-11-16 22:27 gav: Rollups take time to get from sequencing through to fraud-detection-period. JAM gives certainty faster. This allows message/value transfers to happen almost instantaneously. JAM may or may not be competitive with ZK rollups. Difficult to tell since they‚Äôre currently vapourware. 
  ‚Ü≥ 2024-11-16 22:31 sourabhniyogi: Besides production-grade implementation, what would you need to see in "turn your ORU into ZKRU" prover networks like this OP Succinct
 https://github.com/succinctlabs/rsp
to not consider them vapourware?  
2024-11-16 22:33 gav: Just that. 
2024-11-16 22:34 gav: An actual, economically viable, production implementation which works with fully Turing complete computation on the level of a JAM core and doesn‚Äôt take several minutes to get from sequencing to finality.  [edited]
  ‚Ü≥ 2024-11-22 01:44 sourabhniyogi: Ok, I did some research on Succinct today and got some data on latency and ballpark costs =).  How much do you think a days worth of ZK proofs of finality (not proofs of validity, which was what I was doing in RFC #130) in the sense of
https://x.com/pepyakin/status/1857647576293716164
should cost per day to be "economically viable" for
(a) Ethereum
(b) Base
I got 32 blocks (a checkpoint's worth) of ZK proofs for (a) and at least for OP Stack and Arbitrum its easy to have similar estimates for that fraction of the rollup ecosystem. [edited]
  ‚Ü≥ 2024-11-22 12:35 gav: Ok so that‚Äôs $10m/year for ~25tps. All told, JAM should be able to handle around 1m tps. Equivalent cost for zk proofs alone (ignoring sequencing, finality and DA costs) would be maybe $400b/year. 

And (via ELVES), JAM gets secure validation of transactions in 12-18seconds, as opposed to zk, which takes 1 hour.  [edited]
  ‚Ü≥ 2024-11-22 13:01 sourabhniyogi: image.png
  ‚Ü≥ 2024-11-22 13:03 sourabhniyogi: https://explorer.succinct.xyz/proof/01jd8c8x6rermrft701efck1k3
  ‚Ü≥ 2024-11-22 13:04 sourabhniyogi: ZK proving a single ETH block in the public prover network takes 2-3 mins, like $0.16-0.32.  This is "noise" in the grand scheme of everything in present day.  The way they approach OP Stack (Base, Optimism, ..) is running private prover networks so latency is reduced.  You scale the private prover network based on how many "cycles" the prover needs.  To prove ETH needs ~ 25 Million cycles/sec, requiring a certain number  + kind of GPU to achieve (e.g. 50-100 GPUs of Nvidia L4s) [edited]
  ‚Ü≥ 2024-11-22 13:05 sourabhniyogi: The cost of a 32block checkpoint is $5-10.  You have to pay more to get latency down.
  ‚Ü≥ 2024-11-22 23:11 sourabhniyogi: For https://graypaper.fluffylabs.dev/#/911af30/3f8e003f8e00 $W_P$ = 12MB (the maximum size of a work package)  how did you choose this 12MB number?

I'm seeing that these "compressed" proofs are over 6MB 
https://gist.github.com/sourabhniyogi/c054965807711ff7ad62ff251edded9e
so it appears "Groth16" proofs are the primary proof (since PLONK takes 1.5mins)
https://docs.succinct.xyz/generating-proofs/proof-types.html#compressed
  ‚Ü≥ 2024-11-23 07:57 gav: > <@sourabhniyogi:matrix.org> For https://graypaper.fluffylabs.dev/#/911af30/3f8e003f8e00 $W_P$ = 12MB (the maximum size of a work package)  how did you choose this 12MB number?
> 
> I'm seeing that these "compressed" proofs are over 6MB 
> https://gist.github.com/sourabhniyogi/c054965807711ff7ad62ff251edded9e
> so it appears "Groth16" proofs are the primary proof (since PLONK takes 1.5mins)
> https://docs.succinct.xyz/generating-proofs/proof-types.html#compressed

12mb came from expected bandwidth implications on nodes. 
2024-11-16 22:46 sourabhniyogi: For "JAM may or may not be competitive with ZK rollups" why not take an approach of "If you can't beat them, JOIN them" (pun intended üòÖ , Join-Accumulate ZRKUs) by aiming to have the worlds ZKRU proofs  indexed in JAM DA along with all ORU proofs of validity for rollups that cant afford ZK prover networks.  It seems to be the winning approach?
2024-11-16 22:48 gav: Feel free to make whatever service you feel you can sell.  [edited]
  ‚Ü≥ 2024-11-18 00:56 sourabhniyogi: Do you believe the "JAM ecosystem" should cut across multiple Web3 ecosystems and aim for a not only a Polkadot JAM Chain but a { Ethereum, Bitcoin, Cardano, ... } JAM Chain with beefy finality proofs cutting across all of these JAM Chains?     Or should there be just ONE trustless JAM supercomputer?

I believe on this question of what we can sell with X JAM Chain is about 
(a) the technical problem (with elegance of "coprocessors") re beefy finality 
and
(b) the social problem of tribalism + branding (of "Polkadot Cloud" being the only place for JAM protocol vs X JAM Chain for X ecosystem for X = {Polkadot, Ethereum, Bitcoin, Cardano, X/DOGE ...}).  
If the JAM protocol wants us to do its bidding (instead of us wanting the JAM protocol to do our bidding) then how should JAM ecosystem participants vs DOT stakeholders reason about problems (a) vs (b).   Can you provide guidance on both problems? [edited]
  ‚Ü≥ 2024-11-18 10:38 gav: Well, in the context of the JAM Prize, which is in DOT and KSM, JAM is a protocol for use explicitly for the Polkadot and Kusama ecosystems.
  ‚Ü≥ 2024-11-18 10:38 gav: However, at the end of the day, JAM is a protocol and as such largely agnostic to where it is used.
  ‚Ü≥ 2024-11-18 10:40 gav: I don't see why Cardano would drop all their tech and move to a JAM protocol.
  ‚Ü≥ 2024-11-18 10:40 gav: Nor any other ecosystem.
  ‚Ü≥ 2024-11-18 10:41 gav: Polkadot does it because a) it's explicitly made to be compatible with what already exists and b) it already has a good amount of expertise on JAM within the ecosystem.
  ‚Ü≥ 2024-11-18 10:42 gav: I do think that JAM can potentially do a lot to close the gap between bridged-Ethereum and L2-Ethereum, which to a large extent is merely a psychological and branding gap. [edited]
  ‚Ü≥ 2024-11-18 10:44 gav: It's not a question of just "spinning up more JAM chains"
  ‚Ü≥ 2024-11-18 10:44 gav: There needs to be a validator base for each one, and thus for a trustless chain, there needs to be a staked token of high value for each one.
  ‚Ü≥ 2024-11-18 10:46 gav: You could launch "Sourabhinicoin" of course and launch an SourabhiniJAM on the back of it, but making the coin worth anything (and thus the network secure) would come down to token marketing, and if you're good at that then you probably don't need to bother becoming world experts in the Graypaper. [edited]
  ‚Ü≥ 2024-11-18 10:49 gav: In short I wouldn't be too keen to start thinking about launching your own instance of a JAM network.
  ‚Ü≥ 2024-11-18 10:51 gav: I'm not really sure what you're trying to say here, but overall I would advise that making services which are *useful to people* is (as always) the thing you should be focusing your efforts on (beyond creating JAM, of course).
  ‚Ü≥ 2024-11-18 10:52 gav: Launching a new instance of JAM does nothing for this; in fact it fragments the JAM-service-ecosystem and actually hampers all our efforts.
  ‚Ü≥ 2024-11-18 10:53 gav: If you think that the Ethereum service you suggested would be helpful to people (presumably those in the Ethereum ecosystem), then you should definitely launch it, and resell JAM Coretime adding (and extracting) value to it.
2024-11-17 18:29 rustybot: > <@prematurata:matrix.org> hey davxy , starting from the [padded ring commitment](https://github.com/davxy/jam-test-vectors/commit/2d71c3f76ac89aaf57abd892cc691841fa225c87) commit i am having issues in generating posterior_gamma_z. I've seen you changed all gamma_zs so I find it hard to pinpoint what changed at that point in time. Can you help out? 

@[prematurata | TSJam] 

https://github.com/davxy/jam-test-vectors/blob/safrole-ring-signatures-update/safrole/README.md#%EF%B8%8F-warning--%EF%B8%8F
2024-11-19 06:42 sourabhniyogi: Pictures from JAM0 are up on Polkadot forum:
 
https://forum.polkadot.network/t/jam0-jam-implementers-meetup-sub0-devcon-7-bangkok-nov-11-nov-16-2024/10866

If you enjoyed the event and want to do a similar event again in late Winter / early Spring 2025, please post something there, thank you all for making this a special week for everyone! [edited]
2024-11-19 06:53 sourabhniyogi: Please retweet https://x.com/colorfulnotion/status/1858765451071000716 =)
2024-11-19 16:04 danicuki: Useful PVM invocation dependency created by Luke | Jamixir  
2024-11-19 16:04 danicuki: 
2024-11-19 16:04 danicuki: image.png
2024-11-19 17:06 ycc3741: Pardon. Regarding Appendix D. In State Merklization, do we need to manually implement the serialization and encoding functions B and L ourselves, or are there available libraries for this?
  ‚Ü≥ 2024-11-19 18:21 luke_fishman: don't know what language you work in, it probably has a util to represent a decimal as a binary.
i don't see why you would need a library for that.


  ‚Ü≥ 2024-11-19 18:22 luke_fishman: anyways I think you're expected to implement it on your own
  ‚Ü≥ 2024-11-20 14:12 ycc3741: What I mean is, when I read a block, I will need to generate a new block, which would require a new H_r, right? In that case, wouldn't serialization and Merkle trees be necessary? Or did I misunderstand something?
  ‚Ü≥ 2024-11-20 14:40 ycc3741: Oh i see  what you mean
  ‚Ü≥ 2024-11-20 14:40 ycc3741: thanks a lot
2024-11-19 21:55 jaymansfield: > <@sourabhniyogi:matrix.org> Pictures from JAM0 are up on Polkadot forum:
>  
> https://forum.polkadot.network/t/jam0-jam-implementers-meetup-sub0-devcon-7-bangkok-nov-11-nov-16-2024/10866
> 
> If you enjoyed the event and want to do a similar event again in late Winter / early Spring 2025, please post something there, thank you all for making this a special week for everyone!

Wish we could have been apart of this!
2024-11-20 19:04 danicuki: Hi davxy, would you please explain what is this "entropy" in input? Shouldn't entropy be part of the pre_state? 

https://github.com/davxy/jam-test-vectors/blob/7dc0f5cee1552bd535a4cd76836b9d2a279fb878/reports/tiny/anchor_not_recent-1.json#L55
2024-11-20 19:16 greywolve: Isn't this because the entropy pool doesn't change, so it's just an input? [edited]
2024-11-20 20:17 danicuki: Actually I don't see why we can't simple use only pre-state and block as inputs. In the end, STF is just this: inputs are blocks and state. Would be much simpler than having another "input" which, in the end, must be transformed into some block and state to run the STF. 
2024-11-20 23:48 xlchen: can we please having the PRs in the jamtestvectors merged? it is not fun to try to run tests against with all those branches. it is not like we can't update the tests after they are merged
2024-11-21 06:58 rustybot: > <@danicuki:matrix.org> Actually I don't see why we can't simple use only pre-state and block as inputs. In the end, STF is just this: inputs are blocks and state. Would be much simpler than having another "input" which, in the end, must be transformed into some block and state to run the STF. 

Right. I'll move it to the state
2024-11-21 07:29 sourabhniyogi: A test vector in the codec with a full JSON + JAM-codec for state (C1-C15 _and_ some service account 42) with a precise state root (to get the 31 vs 32 byte key detail resolved) would be terrific -- I imagine it should follow this: https://graypaper.fluffylabs.dev/#/911af30/358101358101
2024-11-21 09:45 gav: > <@xlchen:matrix.org> can we please having the PRs in the jamtestvectors merged? it is not fun to try to run tests against with all those branches. it is not like we can't update the tests after they are merged

We're working on doing this now
2024-11-21 12:03 gav: JPEG image-46E2-99A7-AC-0.jpeg
2024-11-21 12:04 gav: JAM Toaster/Polkadot Palace internet uplink speed test. [edited]
2024-11-21 12:04 gav: Some other JAM Toaster pics...
2024-11-21 12:04 gav: JPEG image-4D01-A7E4-92-0.jpeg
2024-11-21 12:04 darkartistry: > <@gav:polkadot.io> sent an image.

How far apart were the machines 
2024-11-21 12:04 gav: JPEG image-498F-958B-74-0.jpeg
2024-11-21 12:05 gav: JPEG image-4EC7-BFE3-64-0.jpeg
2024-11-21 12:05 gav: > <@darkartistry:matrix.org> How far apart were the machines

This is internet uplink.
2024-11-21 12:05 gav: > <@gav:polkadot.io> sent an image.

Power distribution racks.
2024-11-21 12:05 gav: > <@gav:polkadot.io> sent an image.

Insulated panels for JAM Toaster enclosures.
2024-11-21 12:05 gav: > <@gav:polkadot.io> sent an image.

Installing the panels.
2024-11-21 12:06 darkartistry: What is the costs of maintaining this toaster ? 
2024-11-21 12:06 darkartistry: 100k per month ? Based on the uplink speed ‚Ä¶ 
2024-11-21 12:08 gav: Wouldn't know.
2024-11-21 12:08 gav: I don't think it's anything nearly as expensive as that though
2024-11-21 12:10 vinsystems: Amazing! ü§© 
2024-11-21 12:12 gav: Data_Center_video.mp4
2024-11-21 12:12 darkartistry: The monthly cost of a 1 Gbps (Gigabit per second) connection in data centers varies based on several factors, including geographic location, service provider, and specific service requirements. Here‚Äôs an overview:

Geographic Variations:
	‚Ä¢	North America and Europe: In these regions, transit costs are relatively low. For instance, a 1 Gbps connection might be priced around $10 per Mbps per month, totaling approximately $10,000 monthly. However, actual prices are often lower due to competition and peering agreements. Ôøº
	‚Ä¢	Asia: Transit pricing is significantly higher, approximately seven times that of North America and Europe. This means a 1 Gbps connection could cost around $70,000 per month. Peering arrangements can reduce this cost, but the effective price remains higher than in Western regions. Ôøº

Service Provider Examples:
	‚Ä¢	Dedicated Internet Access (DIA): For a 1 Gbps DIA circuit, prices can vary. A general guide suggests that any 500 Mbps+ DIA circuit priced under $1,000 per month is considered a solid deal, though this is typically outside data centers. Ôøº
	‚Ä¢	Colocation Services: Colocation providers often offer bandwidth as part of their packages. For example, some providers include 1 Gbps connections in their colocation plans, with overall monthly costs ranging from $79 for a single server to $599 for a full rack. These prices encompass space, power, and bandwidth. Ôøº

Additional Considerations:
	‚Ä¢	Peering vs. Transit: Engaging in peering agreements can significantly reduce bandwidth costs compared to purchasing transit from Tier 1 providers. The extent of peering varies by region and provider.
	‚Ä¢	Data Center Location: Data centers in regions with higher operational costs, such as Asia, may charge more for bandwidth. Conversely, facilities in areas with lower costs may offer more competitive pricing.
	‚Ä¢	Service Level Agreements (SLAs): Premium SLAs with guaranteed uptime and performance may increase costs.

In summary, while a 1 Gbps connection in data centers can range from under $1,000 to over $70,000 per month, the actual cost depends on various factors, including location, provider, and specific service requirements. It‚Äôs advisable to consult directly with data center providers to obtain accurate and tailored pricing.
2024-11-21 12:12 gav: And here's a simple 3d model of the final setup
2024-11-21 12:12 darkartistry: > <@darkartistry:matrix.org> The monthly cost of a 1 Gbps (Gigabit per second) connection in data centers varies based on several factors, including geographic location, service provider, and specific service requirements. Here‚Äôs an overview:
> 
> Geographic Variations:
> 	‚Ä¢	North America and Europe: In these regions, transit costs are relatively low. For instance, a 1 Gbps connection might be priced around $10 per Mbps per month, totaling approximately $10,000 monthly. However, actual prices are often lower due to competition and peering agreements. Ôøº
> 	‚Ä¢	Asia: Transit pricing is significantly higher, approximately seven times that of North America and Europe. This means a 1 Gbps connection could cost around $70,000 per month. Peering arrangements can reduce this cost, but the effective price remains higher than in Western regions. Ôøº
> 
> Service Provider Examples:
> 	‚Ä¢	Dedicated Internet Access (DIA): For a 1 Gbps DIA circuit, prices can vary. A general guide suggests that any 500 Mbps+ DIA circuit priced under $1,000 per month is considered a solid deal, though this is typically outside data centers. Ôøº
> 	‚Ä¢	Colocation Services: Colocation providers often offer bandwidth as part of their packages. For example, some providers include 1 Gbps connections in their colocation plans, with overall monthly costs ranging from $79 for a single server to $599 for a full rack. These prices encompass space, power, and bandwidth. Ôøº
> 
> Additional Considerations:
> 	‚Ä¢	Peering vs. Transit: Engaging in peering agreements can significantly reduce bandwidth costs compared to purchasing transit from Tier 1 providers. The extent of peering varies by region and provider.
> 	‚Ä¢	Data Center Location: Data centers in regions with higher operational costs, such as Asia, may charge more for bandwidth. Conversely, facilities in areas with lower costs may offer more competitive pricing.
> 	‚Ä¢	Service Level Agreements (SLAs): Premium SLAs with guaranteed uptime and performance may increase costs.
> 
> In summary, while a 1 Gbps connection in data centers can range from under $1,000 to over $70,000 per month, the actual cost depends on various factors, including location, provider, and specific service requirements. It‚Äôs advisable to consult directly with data center providers to obtain accurate and tailored pricing.

These were why I estimated 100k 
2024-11-21 12:13 gav: I'm not certain but I think it was more around 5k/mon
2024-11-21 12:14 gav: maybe quite a bit less
2024-11-21 12:14 darkartistry: Cooooool !!! 
2024-11-21 12:14 gav: but i know they had to lay a new fibre line so it took a while to get installed
2024-11-21 12:14 darkartistry: Nice I‚Äôll follow closely on the progress ! üôáüèª‚Äç‚ôÇÔ∏èüôáüèª‚Äç‚ôÇÔ∏èüôáüèª‚Äç‚ôÇÔ∏è
2024-11-21 12:16 vinsystems: Is in Portugal?
2024-11-21 12:18 gav: Yes - at the Polkadot Palace in Cascais
2024-11-21 12:19 gav: the existing pool is used as a giant heat sink for the toaster
2024-11-21 12:19 gav: So the toaster is located in an underground concrete "bunker" next to the pool's filtration system
2024-11-21 12:22 subotic: cool üòÄ good luck with the construction üçÄüçÄüçÄ I hope all goes smoothly.
2024-11-21 12:27 gav: me too:) aiming to have phase 1 complete EOY
2024-11-21 12:30 gav: that's 86 machines, each with 96 cores, simulating full JAM with 8 cores/node. it'll then be extended by 85 more machines (phase 2) so each node has 16 cores and we'll be quite close to the final node spec. [edited]
2024-11-21 12:34 gav: close enough, i expect, for effective modelling and experimentation. [edited]
2024-11-21 12:34 xlchen: is it possible to expose some heat sink somehow for it to be used as a real toaster
2024-11-21 12:35 gav: i'll ask :)
2024-11-21 14:44 danicuki: > <@gav:polkadot.io> Yes - at the Polkadot Palace in Cascais

What is the Polkadot Palace? Is it a space open to community? Can we make JAM0 there in March/2025?
2024-11-21 14:50 gav: Yes, JAM0 gatherings can probably take place there in due course. But it's currently under heavy redevelopment and is unlikely be usable before 2026.
2024-11-21 14:54 danicuki: Maybe we can make JAM0/March in a nearby hotel, close to Cascais, and have a tour to the datacenter. Would this be possible? I am already planning next JAM0, this is so exciting!
2024-11-21 15:44 subotic: > <@danicuki:matrix.org> Maybe we can make JAM0/March in a nearby hotel, close to Cascais, and have a tour to the datacenter. Would this be possible? I am already planning next JAM0, this is so exciting!

I would love that üëç
  ‚Ü≥ 2024-11-21 17:06 celadari: Me too üëå‚ú®
2024-11-21 17:00 gav: Definitely
2024-11-21 17:03 boymaas: Amazing! üòé It‚Äôs an honour to be part of this process so unique to our times. üöÄ‚ú®¬†
2024-11-21 17:08 dakkk: I made this tool in order to track graypaper equations inside jampy between different graypaper releases. If someone needs it, it is public: https://github.com/dakk/jambiato [edited]
2024-11-21 17:08 dakkk: image.png
2024-11-21 17:52 danicuki: > <@gav:polkadot.io> Definitely

Please share the dates you will be in town in March/25 so we setup things to have you with us during JAM0.
2024-11-22 04:43 rithy: I came late in the group. Which country is JAM0 planning to host?
2024-11-22 05:54 danicuki: > <@rithy:matrix.org> I came late in the group. Which country is JAM0 planning to host?

Next JAM0 will be in Portugal / March 2025
2024-11-22 06:17 rithy: Thank you for the information¬†
2024-11-22 12:37 gav: 
2024-11-22 13:05 danicuki: > <@rustybot:matrix.org> Right. I'll move it to the state

I propose something similar for "output" in test vectors. Why do we have this "output"? Why don't simple put every side effect of STF into post_state branch?

For exemple, here:

```
consume_authorization_once-1.json

            "reported": [
                {
                    "work_package_hash": "0x63c03371b9dad9f1c60473ec0326c970984e9c90c0b5ed90eba6ada471ba4d86",
                    "segment_tree_root": "0x5c9dca800c145685f052ce1ba343e2b66b4c333ee4c4ca3b29cb347b1009cb83"
                }
            ],
            "reporters": [
                "0x22351e22105a19aabb42589162ad7f1ea0df1c25cebf0e4a9fcd261301274862",
                "0x5c7f34a4bd4f2d04076a8c6f9060a0c8d2c6bdd082ceb3eda7df381cb260faff",
                "0x837ce344bc9defceb0d7de7e9e9925096768b7adb4dad932e532eb6551e0ea02"
            ]
```

would it be better to put these "output" into œÅ  on post_state?
  ‚Ü≥ 2024-11-22 20:32 celadari: - `reporters` should be output because they represent bold R in the graypaper

- now, `reported` => I wonder what part of the GP it represents ? If anyone knows ???
2024-11-22 13:08 danicuki: Generally speaking, test vectors should have only:
"input" => contain all extrinsic and header information
"pre_state" => all info related to previous state
"post_state"  => expected post_state will all relevant components change
"output" => only "error / error name" or "ok"
2024-11-22 15:23 ycc3741: Hi, I wonder wether we should sort the hash value by "Lexicographical Order".
2024-11-22 20:58 celadari: Hey guys, a few questions on the work report test vectors:

- in the state part of the .json (`"pre_state"` or `"post_state"`) we have fields `bytes` and `items` => what do they represent in the GP ? If I go to the chapter 9,service accounts, I see `s`, `p`, `l`, `c`, `b`, `g`, `m` but I don't see what fields they could represent. I guess I would have to parse/decode `bytes` and `items` to get `p`, `l`, `s` but I don't see how. I feel there is something I'm not seeing. Also there are 6 fields in the .json but the GP has 7 elements.
- I put here a question I put in a comment (just to centralize my questions): in the `"output"` field we have the field `"reported"` => what variable in the GP does it represent ? [edited]
2024-11-22 21:11 jaymansfield: > <@celadari:matrix.org> Hey guys, a few questions on the work report test vectors:
> 
> - in the state part of the .json (`"pre_state"` or `"post_state"`) we have fields `bytes` and `items` => what do they represent in the GP ? If I go to the chapter 9,service accounts, I see `s`, `p`, `l`, `c`, `b`, `g`, `m` but I don't see what fields they could represent. I guess I would have to parse/decode `bytes` and `items` to get `p`, `l`, `s` but I don't see how. I feel there is something I'm not seeing. Also there are 6 fields in the .json but the GP has 7 elements.
> - I put here a question I put in a comment (just to centralize my questions): in the `"output"` field we have the field `"reported"` => what variable in the GP does it represent ?

There is a definition of items/bytes at the start of section 9.3
  ‚Ü≥ 2024-11-22 21:24 celadari: I see, thank yoou for the answer.

Follow-up question: aren't they computed using equations at section 9.3 ? What I mean is => shouldn't we store them/consider them as state variables ?
2024-11-22 21:37 rick: Will the Safrole test vectors be updated to match the codec? Looks like it's just EpochMarks adding tickets-entropy, so nbd but it did trip up my tests. 
2024-11-23 17:31 danicuki: I have a doubt about work report test vectors, on services list. What are "bytes" and "items" fields are? Should'nt `s`: Storage dictionary (D‚ü®H ‚Üí Y‚ü©)  `p`: Preimage lookup dictionary (D‚ü®H ‚Üí Y‚ü©) and  `l`: Preimage lookup dictionary be provided as well?

2024-11-23 17:39 danicuki: Also on the same tests, I don't see slot or next_validators provided. Is it correct? Because when slot is not provided in previous state, there is a key rotation and since next_validators are also not provided, we come to a situation with empty validators set
2024-11-23 17:43 jaymansfield: > <@danicuki:matrix.org> I have a doubt about work report test vectors, on services list. What are "bytes" and "items" fields are? Should'nt `s`: Storage dictionary (D‚ü®H ‚Üí Y‚ü©)  `p`: Preimage lookup dictionary (D‚ü®H ‚Üí Y‚ü©) and  `l`: Preimage lookup dictionary be provided as well?
> 

There is a definition of items/bytes at the start of section 9.3
2024-11-23 17:44 jaymansfield: Slot # is provided in the input for the report vectors (it‚Äôs right above entropy) [edited]
2024-11-23 17:45 danicuki: > <@jaymansfield:matrix.org> Slot # is provided in the input for the report vectors (it‚Äôs right above entropy)

I assume slot in the input is the header slot. What about pre_state slot? 
2024-11-23 17:47 jaymansfield: > <@danicuki:matrix.org> I assume slot in the input is the header slot. What about pre_state slot? 

I think for pre state slot we just used the input slot subtracted by one
2024-11-23 17:48 danicuki: Why isn't this explicit in the test vectors? How could I guess this? [edited]
2024-11-23 17:56 jaymansfield: > <@danicuki:matrix.org> Why isn't this explicit in the test vectors? How could I guess this?

It might not really matter what value you use. The tests only really cover validating guarantees and updating state afterwards. I don‚Äôt think we did anything special for epoch updates in relation to it. 
2024-11-23 20:22 oliver.tale-yazdi: At JAM0 we talked briefly about how to construct the Dev account secret keys, I followed the approach of the test vectors now and updated the accounts here https://docs.jamcha.in/basics/dev-accounts  [edited]
2024-11-24 14:48 gav: signal-2024-11-22-170556_002.jpeg
2024-11-24 14:48 gav: signal-2024-11-22-171645_002.jpeg
2024-11-24 14:48 gav: signal-2024-11-22-174613_002.jpeg
2024-11-24 14:48 gav: signal-2024-11-22-174723_002.jpeg
2024-11-24 14:48 gav: A few more pics from the building of the Toaster
2024-11-24 14:49 gav: The first batch of racks has arrived. One of the enclosures is finished. And there's the copper power cable (it's very thick) and conduit. That's for the ~100kW power draw. Thankfully the Palace has a ~300kW power line so we're good for now. [edited]
2024-11-24 14:55 boymaas: Racks in, power set, lots of movement!‚Äîthis setup is getting ready to run some rock-solid, efficient Zig code. ‚ö°üöÄüòé
2024-11-24 15:36 emielsebastiaan: 1.21 Gigawatts Great Scott ‚ö°Ô∏è 
2024-11-24 17:45 prematurata: > <@boymaas:matrix.org> Racks in, power set, lots of movement!‚Äîthis setup is getting ready to run some rock-solid, efficient Zig code. ‚ö°üöÄüòé

Or some interpreted code like typescript :) 
2024-11-24 23:57 xlchen: I have published a docker image for Boka so that it can be used to test networking compatibility https://hackmd.io/HsBZpvxQSXOBMSu0Z3ciFA?view cc Oliver Tale-Yazdi - (back on 25th) 
2024-11-25 03:11 sourabhniyogi: Can someone suggest a better name for this ambiguous JSON attribute `tree_root`

https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/codec/data/work\_item.json#L8

like `segment_root_or_work_package_hash`  before we fall in love with `tree_root` ...

Origin of the concept is https://graypaper.fluffylabs.dev/#/911af30/19e30019e300 [edited]
2024-11-25 09:58 dakkk: davxy: regarding codec tests, is it correct to assume that data is valid? for instance, in the block test (https://github.com/w3f/jamtestvectors/blob/master/codec/data/block.json), should extrinsic_hash correspond to the computed hash of the given extrinsic?
2024-11-25 10:20 tomusdrw: AFAIR it was mentioned earlier that the codec test data is not valid semantically. It should be decoded successfully, but it doesn't necessarily make any sense in JAM context. [edited]
2024-11-25 10:21 dakkk: > <@tomusdrw:matrix.org> AFAIR it was mentioned earlier that the codec test data is not valid semantically. It should be decoded successfully, but it doesn't necessarily make any sense in JAM context.

ok my bad (y) thank you for re-clarifying it
2024-11-25 10:28 rustybot: @[dakkk | JamPy] https://github.com/w3f/jamtestvectors/tree/master/codec#semantic-correctness
2024-11-25 10:29 dakkk: > <@rustybot:matrix.org> @[dakkk | JamPy] https://github.com/w3f/jamtestvectors/tree/master/codec#semantic-correctness

yep, understood
2024-11-25 11:48 tomusdrw: I believe the `W_X` in `export` host call definition: https://graypaper.fluffylabs.dev/#/911af30/33ae0033b100 should rather be `W_M` (i.e. the maximal number of imported/exported items). The former doesn't seem to be defined anywhere. [edited]
2024-11-25 11:57 gav: > <@tomusdrw:matrix.org> I believe the `W_X` in `export` host call definition: https://graypaper.fluffylabs.dev/#/911af30/33ae0033b100 should rather be `W_M` (i.e. the maximal number of imported/exported items). The former doesn't seem to be defined anywhere.

https://github.com/gavofyork/graypaper/pull/150/commits/968dc94aec3e9cada4b177b44ef7320a16ecc434
2024-11-25 11:57 gav: Will be in 0.5.1
2024-11-25 19:12 piotrzwolinski: 
2024-11-25 19:14 piotrzwolinski: Hello JAM Community!

Over the past few weeks, the FluffyLabs team has been finalizing the first official release of the PVM Debugger (https://pvm.fluffylabs.dev). Alongside this, we‚Äôre preparing a proposal for retroactive funding from the Polkadot Treasury to support the development of this tool. We also plan to continue expanding its features in the near future.

We‚Äôve started a discussion about the planned Treasury proposal on Polkassembly: https://polkadot.polkassembly.io/post/2578 and would greatly appreciate your feedback. Please don‚Äôt hesitate to ask any questions or share your thoughts!
  ‚Ü≥ 2024-11-25 19:20 oliver.tale-yazdi: Could this be something for the Fellowship Treasury?  
It did not see many proposals yet, so I don't know, but it could be worth exploring.
  ‚Ü≥ 2024-11-25 19:45 dave: This is neat, not sure in practice how useful it will be for debugging large programs. I have some experience testing/debugging a processor implementation, which is a sort of similar problem to creating a PVM implementation. The most useful tool there was one which compared execution traces from the real processor and a reference implementation. Whether such a tool would be feasible or worthwhile for PVM I'm not sure.
  ‚Ü≥ 2024-11-26 09:30 tomusdrw: > <@oliver.tale-yazdi:parity.io> Could this be something for the Fellowship Treasury?  
> It did not see many proposals yet, so I don't know, but it could be worth exploring.

What would be a good place to figure out if it's actually a good idea? General treasury seems to be a more of a beaten track, but we are open for discussion.
  ‚Ü≥ 2024-11-26 09:32 tomusdrw: > <@dave:parity.io> This is neat, not sure in practice how useful it will be for debugging large programs. I have some experience testing/debugging a processor implementation, which is a sort of similar problem to creating a PVM implementation. The most useful tool there was one which compared execution traces from the real processor and a reference implementation. Whether such a tool would be feasible or worthwhile for PVM I'm not sure.

Yes, debugging large programs is yet to be figured out. The low hanging fruits that come to my mind (and we have them on our roadmap) are:
1. Supporting/folding basic blocks
2. Supporting debug symbols

We already support running two PVMs in parallel and stopping on the first difference. So comparing to reference implementation should be easy, figuring out why the code is not working correctly for given set of inputs (actually debugging the program in question) might need some extra work.
  ‚Ü≥ 2024-11-26 18:21 sourabhniyogi: As soon as polkatool + CoreChains (presumably a very very large service) has "eureka!" from PolkaJAM (in solving the same problem as the Polkadot Relay Chain does for a couple dozen blocks), every JAM implementer will be able to use this to support matching the same results, which probably will touch almost everything in Appendix A + B.  

However, its critical to have the scope include all the host functions to take a "PVM debugger" seriously, which means you kind of have to extend out to the "host" with a reasonably complex "X Context" \[accumulate\] and "(m,e)" \[refine\], extending to  imported segments, gas details, and probably a bunch of other host state.  Having a well defined interface (RPC + codec) between a JAM implementation _with host state_ and the PVM Debugger is a must, and hopefully only take a day to wire up.  I imagine you'd need to have a codec test vectors for this { XContext, m, e, i, ... } state to make this tractable + useful for the challenging cases?

If you have all that in scope, it would be wonderful. [edited]
  ‚Ü≥ 2024-11-27 17:04 tomusdrw: > <@sourabhniyogi:matrix.org> As soon as polkatool + CoreChains (presumably a very very large service) has "eureka!" from PolkaJAM (in solving the same problem as the Polkadot Relay Chain does for a couple dozen blocks), every JAM implementer will be able to use this to support matching the same results, which probably will touch almost everything in Appendix A + B.  
> 
> However, its critical to have the scope include all the host functions to take a "PVM debugger" seriously, which means you kind of have to extend out to the "host" with a reasonably complex "X Context" \[accumulate\] and "(m,e)" \[refine\], extending to  imported segments, gas details, and probably a bunch of other host state.  Having a well defined interface (RPC + codec) between a JAM implementation _with host state_ and the PVM Debugger is a must, and hopefully only take a day to wire up.  I imagine you'd need to have a codec test vectors for this { XContext, m, e, i, ... } state to make this tractable + useful for the challenging cases?
> 
> If you have all that in scope, it would be wonderful.

Indeed. So far we were trying to keep the tool as JAM-agnostic as possible, so it may help not only JAM-PVM but also for instance revive (Solidity to PVM compiler).

Next on our roadmap is to support more JAM-specific features (entry points), support host calls and have "mocked" JAM host calls implementation (for instance specialised UI where you can provide the segments to be available for `export` host call, etc).
Connecting to a running JAM node to invoke host calls is something worth considering as well, I will add that to our issue tracker.
2024-11-26 18:38 gav: Initial version of Parity JAM SDK is out, along with the Bootstrap Service: [Parity JAM SDK](https://hackmd.io/@polkadot/jamsdk)
2024-11-26 18:39 gav: It's not much right now and I've only tested it locally. But (if it works) it should be enough for anyone to build the Bootstrap service PVM code blob and (vaguely) see its Work Item ABI. [edited]
2024-11-26 18:39 gav: Rust coders should also be able to code and build their own services and authorizers.
2024-11-26 18:40 gav: The docs are a WiP, and I've thus far focussed only on basic Bootstrap service description. They should be improved in the coming days.
2024-11-26 18:41 gav: NOTE: There's no Github repo open yet, since we have a monorepo together with our node impl. So the code is currently available on crates.io only.
  ‚Ü≥ 2024-11-27 00:43 sourabhniyogi: Happily got through

```
jam-pvm-build ./jam-bootstrap-service
jam-pvm-build ./jam-null-authorizer
```

and put the .pvm and rust code here for us to take a look:
https://github.com/jam-duna/jamtestnet/tree/main/services/parity

0. Does Parity Rust JAM SDK completely phase out Jan's polkatool?
1. What is the recommended way to disassemble the `jam-pvm-build`- built PVM byte code ?

```
# cargo run -p polkatool disassemble --show-raw-bytes ~/go/src/github.com/jam-duna/jamtestnet/services/parity/jam-bootstrap-service.pvm
warning: /root/go/src/github.com/colorfulnotion/polkavm/Cargo.toml: unused manifest key: workspace.lints.rust.unexpected_cfgs.check-cfg
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/polkatool disassemble --show-raw-bytes ~/jam-duna/jamtestnet/services/parity/jam-bootstrap-service.pvm`
ERROR: failed to parse "/root/go/src/github.com/jam-duna/jamtestnet/services/parity/jam-bootstrap-service.pvm": failed to parse program blob: blob doesn't start with the expected magic bytes
```

2. Does the program start with the 5x4 = 20 bytes of jumps
https://github.com/jam-duna/jamtestnet/blob/main/services/jam-duna/bootstrap/bootstrap.txt#L10-L17
3. Can we build 32-bit vs 64-bit until the end of Jan/Feb/March with this?    How do we specify the 32 vs 64 target?
4. The 72K is surprisingly large, because it went for instructions in the payload with full generality üòÖ  --  Our first bootstrap code is ~200 bytes, hand built
https://github.com/jam-duna/jamtestnet/blob/main/services/jam-duna/bootstrap/bootstrap.txt#L8
We will try redoing it in this Parity SDK with a "barebones" mindset in a 32-bit or 64-bit way, but is the expectation that the bootstrap will actually be this big in the end?  Is there some code blob reuse _across services_ that is desired, e.g. for super common operations like hashing

5. Work Item ABI  -- earlier you said "Services are not smart contracts", but I'm glad you referred to it this way -- how would you see the end Bootstrap described in ABI form?
6. Any way to slip in some assembly code? [edited]
  ‚Ü≥ 2024-11-27 10:12 gav: I'm about to push 0.1.4 which adds support for building without logging and debug symbols. This takes Bootstrap down to 35k and NullAuth to ~8k.
  ‚Ü≥ 2024-11-27 10:13 gav: Can't do much more without a deeper analysis of code generation.
  ‚Ü≥ 2024-11-27 10:13 gav: ABI can probably just be specified similar to net protocol.
  ‚Ü≥ 2024-11-27 10:14 gav: It's on my list but haven't done it yet since it can be fairly easily derived from the Rust code.
  ‚Ü≥ 2024-11-27 10:14 gav: No easy way to insert assembly afaik, though Jan Bujak would know better
  ‚Ü≥ 2024-11-27 10:15 gav: 32-bit PVM isn't really supported going forward.
  ‚Ü≥ 2024-11-27 10:16 gav: The program code should begin with the appropriate jumps, but of course the `.pvm` output is the standard program format as detailed in GP-A.1, which doesn't begin with the PVM code. [edited]
  ‚Ü≥ 2024-11-27 10:18 gav: If you want to disassemble, you'll probably first want to write PVM program blob deconstructor to extract the PVM code. Then I guess you'll want to write a disassembler.
  ‚Ü≥ 2024-11-27 10:18 gav: This doesn't "completely phase out" anything. It's an early WiP, not a major product/service launch. [edited]
  ‚Ü≥ 2024-11-27 10:19 gav: Use whatever tooling you feel makes sense from what's out there. At present, this is provided on a "hope it's helpful" basis. Maybe that changes when it gets to 1.0. But until then, don't expect too much. [edited]
2024-11-27 04:28 xlchen: I plan to focus on the RPC part for Boka next and that includes the ability to generate RPC docs. Oliver Tale-Yazdi suggested to use https://github.com/ethereum/execution-apis / https://ethereum.github.io/execution-apis/api-documentation/ as the playground / documents for RPCs. Let me know what do you think 
  ‚Ü≥ 2024-11-27 08:46 sourabhniyogi: Here is my wish list of RPC methods 
https://github.com/jam-duna/jamtestnet/blob/main/RPC.md
and a protospec of using opentelemetry (in Go)
https://github.com/jam-duna/jamtestnet/blob/main/telemetry/go/otel.go
We have not reduced this to practice nor have we actually connected opentelemetry to prometheus (the way we have connected to Datadog + Google Cloud logging).  
  ‚Ü≥ 2024-11-27 09:01 sourabhniyogi: What is your wishlist?
  ‚Ü≥ 2024-11-27 09:25 dave: If we want all nodes to provide a "standard" set of RPC calls I think we should try to keep these calls easy to implement. So for example I wouldn't require a JSON encoding for any of the JAM structs but just use the JAM codec, which all nodes need to understand anyway. Any conversion to/from JSON can be handled by libraries on the client side.
  ‚Ü≥ 2024-11-27 09:37 dave: Re jam_getWorkPackageByHash this probably can't be usefully implemented as only the guarantors and auditors of a report ever have the corresponding WP data to hand and they will likely discard it once their duties are done (which should not take long)
  ‚Ü≥ 2024-11-27 10:17 xlchen: yeah we should start from simple ones and add more gradually. I will also define some namespaces for standard and non-standard implementations and everyone are free to implement any methods on the non-standard namespaces 
  ‚Ü≥ 2024-11-27 10:30 oliver.tale-yazdi: How would you then handle the non-standard Json versions? Appending a `Json` to the name?

It will probably help a lot for scripting to have these variants easily accessible without having to know about JAM codec [edited]
  ‚Ü≥ 2024-11-27 10:31 oliver.tale-yazdi: Or would it have its own namespace?
  ‚Ü≥ 2024-11-27 11:06 xlchen: we really should do the decoding in client side but otherwise we can have a convert rpc to convert between json and binary
  ‚Ü≥ 2024-11-28 12:15 olanod: Any chance nodes will offer other things beyond (websocket) JSON-RPC API? I'm thinking of a simpler http multipart/form-data + server sent events for small clients where avoiding encoding data to JSON to save some CPU cicles, bandwidth and size of the program would be nice if possible. Other transports like gRPC or similar would be interesting as well.
  ‚Ü≥ 2024-11-28 19:51 xlchen: gRPC is too complicated so I don‚Äôt think we can push it to have all implementation to implement. RESTful style is possible but it can‚Äôt have notifications 
  ‚Ü≥ 2024-11-29 09:16 olanod: That's why I mention SSE ;) they're simple and pair well with an HTTP API(that doesn't need to be too RESTy).

This combo besides being easier for embedded(an interest of mine) has the interesting side effect over websockets that can be intercepted in service workers, to have a simple DevX and avoid users installing extensions I have this experiment of a substrate client running in a (shared)WebWorker that processes HTTP requests that were intercepted by a service worker. To websites it looks like a normal http API
  ‚Ü≥ 2024-11-29 21:16 xlchen: one thing to keep in mind that general users and most devs does not need to have direct RPC access to jam chain. they only need light clients which should use the p2p protocol, not rpc 
2024-11-27 18:42 danicuki: 
2024-11-27 18:45 danicuki: Report test vectors seem to be using max gas GA = 1,000,000 - but GP sets to 100,000 - any particular reason for using a different number?

davxy  [edited]
2024-11-27 18:45 danicuki: Formula (11.29) ‚àÄw‚ààw‚à∂ ‚àë(rg)‚â§GA
2024-11-27 18:54 davxy: See discussion with [@dakkk:matrix.org](https://matrix.to/#/@dakkk:matrix.org) here https://github.com/w3f/jamtestvectors/pull/20
2024-11-27 18:55 davxy: I need to fix it 
2024-11-27 19:06 danicuki: > <@davxy:matrix.org> See discussion with [@dakkk:matrix.org](https://matrix.to/#/@dakkk:matrix.org) here https://github.com/w3f/jamtestvectors/pull/20

thanks for sharing. Solved another doubt I had  about "duplicates" / "out of order" cores
2024-11-27 19:21 danicuki: It would be REALLY REALLY helpful if vectors README had GP Formula Numbers / links for each condition being tested.

e.g.:

```
- [not_authorized](./tiny/not_authorized-1.json) üî¥
  - Target core without any authorizer.
```

I can't find out from this description what this test is all about. Sometimes the phrasing explanation is not accurate. A simple link to a formula would solve any doubt [edited]
2024-11-27 19:27 gav: JAM SDK API docs are slowly improving https://docs.rs/jam-pvm-common/0.1.5/jam_pvm_common/
2024-11-27 19:34 danicuki: davxy: what value are you using for rotation period (R) in test vectors? 
2024-11-27 22:32 danicuki: An interesting article that brings even more excitement to our JAM builders community: https://user.fm/files/v2-261b7914c204931fbf213d7d35307264/worldcomputer.pdf
2024-11-28 09:26 gav: > <@danicuki:matrix.org> An interesting article that brings even more excitement to our JAM builders community: https://user.fm/files/v2-261b7914c204931fbf213d7d35307264/worldcomputer.pdf

TBH I don't think it'll be a single "World Computer" any more.
2024-11-28 09:26 gav: At least as long as it is not totally free.
2024-11-28 09:27 gav: More likely, we'll see several weakly-compatible ("bridged") World Computer networks.
2024-11-28 09:27 gav: Kinda similar to the cloud services at present.
2024-11-28 09:28 gav: Each with their own tradeoffs in terms of reliability, scale, cohesion and peripheral services.
2024-11-28 09:28 gav: JAM as a protocol would be the architecture of the (first wave, anyway) of machines on the Polkadot "World Computer Network".
2024-11-28 09:30 gav: But the idea is for multiple JAMs to be placed in a sort of grid network, similar in approach to the Omniledger protocol. This seems like the only sensible option *at present* to scale more-or-less indefinitely. [edited]
2024-11-28 09:40 sourabhniyogi: As an old guy (so old I have seen a "Cray" and "Thinking Machines"), I really adore the shift to the words "trustless supercomputer" more than the "World Computer", where it matches 1 core = World Computer, N cores = Supercomputer. In a completely ordinary way, I think the term "SUPERcomputer" works on people well because of the superhero vs hero distinction that loosely maps onto your favorite word "Core", which ALSO works for everyday PC computer buyers.   Why not be consistent with this new "supercomputer" term for marketing reasons? [edited]
2024-11-28 09:44 sourabhniyogi: Polkadot JAM Chain is the world's first trustless SUPERCOMPUTER because ____
(a) it has more than one core!
(b) it is actually semi-coherent!
You get to decide the truthiness of (a)+(b) =)
2024-11-28 09:51 gav: I remember back in the old days (~y2k), pre-cloud, there was the concept of the "grid", basically a network of supercomputers with streamlined interconnects and access.
2024-11-28 09:53 gav: It seems unlikely to me that any fully-coherent system is going to scale indefinitely and economics being what they are, it seems unlikely that strict coherence will be paid for when it's not needed.
2024-11-28 09:54 gav: This all points to a multi network stable-state.
2024-11-28 09:55 gav: But probably with a range of interoperability/cohesion across the various (super)computers which make it up. [edited]
2024-11-28 09:55 gav: I don't really see crappy (trustful) bridges in this, except perhaps to connect low-quality low-resilience not-really-web3 networks.
2024-11-28 10:05 gav: But then probably we'll see a spectrum of connectivity; trustless light-client bridges, L1-L2 and other one-way full-node (ala Eth L2s and parachains), dual-way full-node, shared validators (ala Omnipool), weakly-coherent shared DA (ala JAM) and fully-coherent synchronous shared state (ala Eth L1).
2024-11-28 10:07 gav: We're already seeing a bit of this, but it's very much at the poles so far (incoherent or fully synch).
2024-11-28 10:11 gav: For the Polkadot Cloud Grid, we could almost certainly make a matrix of JAMs with a shared validator pool and light-client bridge interconnects (at the cost of a ~35% drop in cost of attack). This would be a basic Supercomputer Network. We can probably do better though, with a shared DA and maybe some built-in service migration or even Work Report and Transfer forwarding, so that Refine is spread around the network but Accumulation/OnTransfer still happens synch on a single "home JAM" of the service. [edited]
  ‚Ü≥ 2024-11-28 12:00 sourabhniyogi: The Polkadot Cloud Grid is an insanely great vision.  Concretely, I hope GP Sec 18 can incorporate the JAM-to-JAM process alongside the MMB nitty gritty, developed early between { Polkadot, Kusama, Paseo/Westend } JAM chain (maybe even in the Toaster!) or at least charted in Sec 20+ in a JAM 2.0 roadmap.

Apologies if this is too pushy ... but I believe there needs to be an equally insanely great vision for (homogenous) "Polkadot \[Asset\] Hubs" running across that grid, with clarity on how DOT can work across the grid.  I believe the poor messaging situation in OP's superchain can be easily attacked, but it seems to be a "if you can't beat them, join them" and we need a hijacking plan here.

This is too good of a vision to be locked inside this chat room -- can you get on like Unchained to share your vision
https://polkadot.polkassembly.io/treasury/576
with the broader Web3 masses? [edited]
  ‚Ü≥ 2024-11-28 12:37 gav: As I say, there's a few things to be solved with the idea of Work Report Forwarding to make Refine be scalable across the JAM Grid from a single service, but if those things can be solved (and I don't think it's unreasonable to expect they can be), then CorePlay (which is basically the logical successor to P(A)H/Plaza) could be scaled out across the JAM Grid. [edited]
  ‚Ü≥ 2024-11-28 12:38 gav: What I would aim to achieve with Grid scaling is JAM-style weak-coherency. Which is to say it'll never do the wrong thing regardless of where on the JAM Grid the Work Package is executed, but it might take much longer in some places than others (with the worst case being it takes so long as to time out completely). [edited]
  ‚Ü≥ 2024-11-28 12:44 gav: This would result CorePlay having existing JAM-style per-core synchronous composition for those transactors willing to pay for it, but with massively scalable (and therefore very cheap) asynchronous composition for everyone else. Since CorePlay would be continuations-based, high-quality primitives abound for minimising the pain of asynch programming. The main difference shouldn't be DevEx, but rather very particular functionality which strictly requires synchroneity ("Stop-The-World") in execution like flash-loans.
2024-11-28 10:12 gav: This would provide totally unprecedented levels of scale; an e.g. a 10x10x10 grid would give 1000x on the total compute throughput of JAM - so like ~1 quadrillion EVM-equiv gas/sec [edited]
2024-11-28 10:16 gav: There's still some stuff to be worked out, like preimage fetching/sharing across JAMs (possibly a simple cache model would do, or perhaps also an explicit fetch) and DA handoff as the partitioning changes (possibly just ephemeral connections across JAM validator partitions for segment-fetching). [edited]
2024-11-28 10:17 gav: But overall I see it as a pretty interesting next step once JAM is solid.
2024-11-28 10:19 gav: We should also keep our eyes on the progression of ZK stuff too. I think (and this is almost exclusively informed by the W3F research team) that it's too early to tell yet whether it'll become economically viable compared to ELVES, but if it does eventually come down in price enough to be a sensible option when we could potentially see a backward-compatible JAM-ZK on the cards in a few years.
2024-11-28 10:21 danicuki: davxy: are safrole test vectors already updated to GP 0.5? I see some of our tests failing after we upgraded our code to 0.5 specification
2024-11-28 10:22 emielsebastiaan: This made my day thx for sharing these insights once in a while. 
2024-11-28 10:24 davxy: > <@danicuki:matrix.org> davxy: are safrole test vectors already updated to GP 0.5? I see some of our tests failing after we upgraded our code to 0.5 specification

Which ones? And what is the actual failed condition? They should be aligned to 0.5
  ‚Ü≥ 2024-11-28 10:27 danicuki: I will double check on my side and get back to you if they still fail
  ‚Ü≥ 2024-11-28 14:50 rick: I raised this earlier, the EpochMarks added a field, TicketsEntropy, which isn't in the Safrole test vectors yet. 
  ‚Ü≥ 2024-11-28 14:51 rick: I *think* thats all I had to change. Hope this helps danicuki | Jamixir 
  ‚Ü≥ 2024-11-28 19:12 davxy: > <@rick:carback.us> I raised this earlier, the EpochMarks added a field, TicketsEntropy, which isn't in the Safrole test vectors yet. 

It is. I added it 3 days ago
  ‚Ü≥ 2024-11-28 20:28 rick: thanks davxy  i'll take a look üëçÔ∏è [edited]
2024-11-28 12:07 gav: Sure if you want to set it up
2024-11-28 12:32 davxy: Was 4 for both `tiny` and `full`.
I've just fixed it to be 10 for `full`.
The values are  NOW explicitly reported in the README [edited]
2024-11-28 19:13 davxy: https://github.com/w3f/jamtestvectors/pull/8/commits/df18b318433fda0cf0dd2b4aac29abce09f0b15a
2024-11-28 20:43 davxy: Could this be the breaking change? https://github.com/w3f/jamtestvectors/pull/8/commits/aeb976ff3eed8afed4dda53286f7cb2af5b81ebd

Specifically, post-offenders have been moved to the "state". Please refer to the ASN.1 schema for further details.

I followed the recommendation to include in the "input" struct only the elements found within the block (I.e. header items and extrinsics). When a pre-execution state item is "posterior" it is explicitly specified in the ASN.1 schema.
 
Always keep an eye on the schema. [edited]
2024-11-28 20:50 davxy: ^ posterior with respect to some other subsystem STF (in this case, it is the "disputes" subsystem that advances the offenders' list). Thus, it is assumed that the subsystem has already been executed to obtain psi_o'.


2024-11-28 23:26 danicuki: About the work report vectors: why the post_state doesn't include the core report component - with all its fields? Shouldn't be better than using an "output" in the json? @davxy 
2024-11-29 06:38 xlchen: Trying to use OpenRPC tools for JAM RPC spec work. It is kind of working: https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/open-web3-stack/jam-rpc-spec/refs/heads/master/openrpc.json

The spec defs is generated by our Swift code from our RPC implementation so those methods are what we have implemented currently, not what I wanted to propose
2024-11-29 06:40 xlchen: I created a repo here but not sure if it should just be part of some other repos https://github.com/open-web3-stack/jam-rpc-spec?tab=readme-ov-file
2024-11-29 06:43 xlchen: I plan to create the actual spec proposal (in Swift code) and update the openrpc spec file next week
2024-11-29 06:46 xlchen: open-rpc have client and server generator which I didn't try, but the docs generated don't work for me https://github.com/open-rpc/generator 
2024-11-29 14:32 nathanccxv: I recently finished reading Jam's GrayPaper and am preparing to develop its implementation. Is it too late for that? Is there any time limit? gav 
2024-11-29 15:09 gav: There‚Äôs no time limit, though of course the prize pool is limited and it‚Äôs FCFS :)
2024-11-29 15:26 nathanccxv: Thank you for your clarification. According to the 'Gav's Unofficial JAM Prize Notes' document, up to five implementations per language set can receive rewards. 2500k/(100k*5 milestones) = 5. Is this understanding correct?
2024-11-29 16:30 dakkk: > <@nathanccxv:matrix.org> I recently finished reading Jam's GrayPaper and am preparing to develop its implementation. Is it too late for that? Is there any time limit? gav

if may I ask, which language are you going to use?
  ‚Ü≥ 2024-11-29 16:58 nathanccxv: I'm not entirely sure yet, but I'm more proficient in Go and Python, so I might go with Go.
  ‚Ü≥ 2024-11-29 16:58 dakkk: GOod choice üëçÔ∏è
2024-11-29 16:32 gav: Well, this assumes each of those 5 implementations get to M5 before any others get to M1. [edited]
  ‚Ü≥ 2024-11-30 12:43 clearloop: Curious about will PolkaJam take one of the slots in set B üòÇ


2024-11-29 21:50 tomusdrw: > <@gav:polkadot.io> Well, this assumes each of those 5 implementations get to M5 before any others get to M1.

Hmm, I guess that creates a risk of having no incentives to go up to M5 for some of the "heavily occupied" language sets depending on the timing of when it will be possible to submit implementations for acceptance, doesn't it? But AFAIR I saw in the repo, that there is not going to be milestone deliveries before GP 1.0, right? 
2024-11-29 22:27 gav: Indeed
2024-11-29 22:33 sourabhniyogi: I'm putting together a "importblocks" fuzz tester and would like to know which state elements would be changed by blocks in "M1 Import blocks" milestone from
https://graypaper.fluffylabs.dev/#/293bf5a/348e00348e00
in different testing modes to match the goals of M1 vs M2 vs M3 as well as which extrinsics.  I think we should have a super precise answer for M1 Import Blocks now?

My guess is:

- "M1 Import blocks" will have blocks that change the state of:

    - C(4), C(6), C(7), C(8), C(9), C(10), C(11), C(13), C(15)
    - all service storage (Œ¥, a\_s, a\_p, a\_l)
    - extrinsics E\_{T,G,A,P}

... implying these will happen later:

- M2/M3: C(1), C(2), C(3), C(5), C(12), C(14), E\_D

Can someone clarify what M1 Import Blocks state changes should cover?

This has implications as to what teams should focus on finishing in what order.   I remember earlier comments that M1 doesn't even need PVM implementation, which is at odds with the above guess.

This is important for the design+implementation of a fuzz tester that only generates blocks suitable for each milestone / mode, with a parameter like "mode" that is like
M1: "fallback" (no extrinsics), "safrole" (only ticket extrinsics), "assurances" (all but dispute extrinsics and no prereqs)
M2: "orderedaccumulation" (adjusting C(14), including prereqs), "authorization" (adjusting C(1)+C(2)), "recenthistory" (C(3)), "blessed" (adjusting C(5), C(12)), "basichostfunctions" (most common host functions)
M3: "finalization" (everything in C(1)-C(15) except disputes), "disputes" (everything, including dispute extrinsics), "conformance" (every single host function) [edited]
2024-11-29 23:05 charliewinston14: Anyone else having difficulty verifying the beefy_root's in the report vectors? Just wondering if it's my issue or if its an issue with the vectors themselves?
  ‚Ü≥ 2024-11-30 07:00 sourabhniyogi: Note that MMRs will be replaced with MMBs soon so it might not be worth sweating too much about this.
  ‚Ü≥ 2024-11-30 07:04 dakkk: I'm having issue too 
  ‚Ü≥ 2024-11-30 17:45 danicuki: I have the same issue also. Can't match beefy_root - davxy  maybe you are using a different Hash algorithm than specified? Or something else related to encode_mmr function - I tried different combinations here but none of them matched the vector 
  ‚Ü≥ 2024-11-30 18:43 davxy: > <@danicuki:matrix.org> I have the same issue also. Can't match beefy_root - davxy  maybe you are using a different Hash algorithm than specified? Or something else related to encode_mmr function - I tried different combinations here but none of them matched the vector 

You are referring to the 'reports' vectors, correct? 
  ‚Ü≥ 2024-12-01 14:32 danicuki: > <@davxy:matrix.org> You are referring to the 'reports' vectors, correct?

yes
  ‚Ü≥ 2024-12-02 11:05 davxy: Given an MMR, i.e. a sequence of hashes where some items may be null. How do you produce the beefy root?
  ‚Ü≥ 2024-12-02 11:06 davxy: I.e. what equation, from the GP, you're using?
  ‚Ü≥ 2024-12-02 11:19 danicuki: E.9 - E(‚Üï[¬øx ‚à£ x <‚àí b])
  ‚Ü≥ 2024-12-02 11:20 danicuki: This is EM
  ‚Ü≥ 2024-12-02 11:20 dakkk: in 11.32 the beefy_root of the context of the work reports should be equal to the keccak of the encoded_mmr (E.9) of the history element matching the context anchor.


  ‚Ü≥ 2024-12-02 11:20 danicuki: Exactly
  ‚Ü≥ 2024-12-02 11:20 danicuki: this is what we are doing
  ‚Ü≥ 2024-12-02 11:21 dakkk: I know, I was answering davxy
  ‚Ü≥ 2024-12-02 11:21 dakkk: maybe the issue is the sorting of b; b can contain null values, how should we sort them?
  ‚Ü≥ 2024-12-02 11:21 danicuki: HK(EM(yb))
  ‚Ü≥ 2024-12-02 11:22 danicuki: ```Elixir
Hash.keccak_256(Codec.Encoder.encode_mmr(y.accumulated_result_mmr))
```
  ‚Ü≥ 2024-12-02 11:23 danicuki: we don't sort them. Just take them as they are
  ‚Ü≥ 2024-12-02 11:23 danicuki: there is nowhere in the GP specified that they should be sorted
  ‚Ü≥ 2024-12-02 11:23 danicuki: as long as I remember
  ‚Ü≥ 2024-12-02 11:23 davxy: I guess we have an inconsistency in our impl. Probably we need to fix it 
  ‚Ü≥ 2024-12-02 11:26 dakkk: > <@danicuki:matrix.org> there is nowhere in the GP specified that they should be sorted

you're right, I made confusion with another thing
  ‚Ü≥ 2024-12-02 11:26 dakkk: anyway danicuki | Jamixir what is your result? mine is 0x233440078b657c8f7c8fa7316a13f002da38a5ed38f33e616dd0e02505d7995f
  ‚Ü≥ 2024-12-02 11:34 danicuki: what vector?
  ‚Ü≥ 2024-12-03 18:07 danicuki: > <@davxy:matrix.org> I guess we have an inconsistency in our impl. Probably we need to fix it 

Please let us know when you release it so we can test against it again. 
2024-11-30 06:07 ksc85pwpj5: davxy:  Excuse me, may I kindly ask if there are currently any test vectors available for shuffle, or if anyone else has any results related to shuffle?
  ‚Ü≥ 2024-11-30 06:48 sourabhniyogi: https://github.com/w3f/jamtestvectors/pull/17
  ‚Ü≥ 2024-11-30 06:48 sourabhniyogi: We were able to pass it along with a couple of others. [edited]
  ‚Ü≥ 2024-11-30 06:51 sourabhniyogi: The ${\cal F}$ in F.3 here: 
https://graypaper.fluffylabs.dev/#/911af30/39a30239a302
probably should have a subscript to distinguish it from the ${\cal F}$ in F.1 
2024-11-30 06:41 dakkk: 
2024-11-30 06:42 dakkk: 
2024-11-30 07:04 rustybot: 
2024-11-30 07:04 davxy: > <@sourabhniyogi:matrix.org> I'm putting together a "importblocks" fuzz tester and would like to know which state elements would be changed by blocks in "M1 Import blocks" milestone from
> https://graypaper.fluffylabs.dev/#/293bf5a/348e00348e00
> in different testing modes to match the goals of M1 vs M2 vs M3 as well as which extrinsics.  I think we should have a super precise answer for M1 Import Blocks now?
> 
> My guess is:
> 
> - "M1 Import blocks" will have blocks that change the state of:
> 
>     - C(4), C(6), C(7), C(8), C(9), C(10), C(11), C(13), C(15)
>     - all service storage (Œ¥, a\_s, a\_p, a\_l)
>     - extrinsics E\_{T,G,A,P}
> 
> ... implying these will happen later:
> 
> - M2/M3: C(1), C(2), C(3), C(5), C(12), C(14), E\_D
> 
> Can someone clarify what M1 Import Blocks state changes should cover?
> 
> This has implications as to what teams should focus on finishing in what order.   I remember earlier comments that M1 doesn't even need PVM implementation, which is at odds with the above guess.
> 
> This is important for the design+implementation of a fuzz tester that only generates blocks suitable for each milestone / mode, with a parameter like "mode" that is like
> M1: "fallback" (no extrinsics), "safrole" (only ticket extrinsics), "assurances" (all but dispute extrinsics and no prereqs)
> M2: "orderedaccumulation" (adjusting C(14), including prereqs), "authorization" (adjusting C(1)+C(2)), "recenthistory" (C(3)), "blessed" (adjusting C(5), C(12)), "basichostfunctions" (most common host functions)
> M3: "finalization" (everything in C(1)-C(15) except disputes), "disputes" (everything, including dispute extrinsics), "conformance" (every single host function)

https://github.com/w3f/jamtestvectors/issues/21
2024-11-30 07:55 davxy: It seems your tool aligns somewhat with the conformance testing tool for M1. I encourage the sharing of relevant ideas and discussions within the GitHub issue, as people (me included) may occasionally miss messages in the chat 


2024-11-30 08:07 prematurata: > <@davxy:matrix.org> https://github.com/w3f/jamtestvectors/issues/21

hey davxy thanks for this. I previously used your `polkajam-vectors` branch but i noticed that compared to the upstream repository gamma_z is computed differently (my findings were that a different version of ark repo was used.) caan you share some insights on which of the 2 provide the "correct" gamma_z computation?
2024-11-30 10:51 davxy: I checked the value of `gamma_z` and is the same in both the upstream PR and my fork.
Obviously if for upstream you mean the master branch, yes. This is different. At this point master is quite outdated.
I suggest you to work with the changes in the PR or using my fork, that I try to keep updated WRT the open PRs we have upstream.

I report the **current** values here:

### Tiny

"gamma\_z": "0xa949a60ad754d683d398a0fb674a9bbe525ca26b0b0b9c8d79f210291b40d286d9886a9747a4587d497f2700baee229ca72c54ad652e03e74f35f075d0189a40d41e5ee65703beb5d7ae8394da07aecf9056b98c61156714fd1d9982367bee2992e630ae2b14e758ab0960e372172203f4c9a41777dadd529971d7ab9d23ab29fe0e9c85ec450505dde7f5ac038274cf",

### Full

"gamma\_z": "0x96fcd017ddd980b1847422ee6d9c7619e71d1a17acfbb9c572feec917cf3c12f5a87d33f249b5ecf2639859bf3eb2795841d5317144feab07f6e7d0add7a8b3591b9c913ea56198c53a0894f040d7f1392c790755b97a6167e0ca9978421e6b596c1b168e2dcc743f9eadda76c041db42d39f27a58418f88c0ea67656a224934e12b5dfc8f0f460a95c2d467fa41907b", [edited]
2024-11-30 10:51 davxy: You can check for the ark-ec-vrfs revision currently used here: https://github.com/davxy/jam-test-vectors/tree/polkajam-vectors/safrole#%EF%B8%8F-warning--%EF%B8%8F
2024-11-30 10:58 davxy: Following suggestions from some other team members, the `tiny` configuration now uses a maximum tickets per validator of 3 (compared to 2 for the `full` configuration). This adjustment ensures that epoch slots can be filled with tickets from a supermajority of honest nodes (5 out of 6 validators). This change aligns the vectors to the proposed testing values outlined here: https://docs.jamcha.in/basics/chain-spec/Tiny.
  ‚Ü≥ 2024-11-30 21:08 sourabhniyogi: image.png
  ‚Ü≥ 2024-11-30 21:08 sourabhniyogi: https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=615049643#gid=615049643
  ‚Ü≥ 2024-11-30 21:10 sourabhniyogi: Do you have suggestions on how to have larger configurations than "tiny"?  Above is my starting point for some chain specs, in expectation that the JAM Toaster will support teams having { small => 2x large } configs 100% on their own and then { 2, 3, 4 } teams can assemble into a { xlarge, 2xlarge, 3xlarge } config in 2025. 
  ‚Ü≥ 2024-12-01 14:25 sourabhniyogi: For `R` (rotation) https://github.com/JamBrains/jam-docs/issues/5 

what is the logic of having R=4 in `tiny` instead of R=10?

Do you have recommendations for other chain specs 

https://docs.jamcha.in/basics/chain-spec/small
https://docs.jamcha.in/basics/chain-spec/medium
https://docs.jamcha.in/basics/chain-spec/large
... [edited]
2024-11-30 11:47 sourabhniyogi: > <@davxy:matrix.org> It seems your tool aligns somewhat with the conformance testing tool for M1. I encourage the sharing of relevant ideas and discussions within the GitHub issue, as people (me included) may occasionally miss messages in the chat

https://github.com/w3f/jamtestvectors/issues/21#issuecomment-2508934671
2024-11-30 12:28 tomusdrw: > <@gav:polkadot.io> JAM SDK API docs are slowly improving https://docs.rs/jam-pvm-common/0.1.5/jam_pvm_common/

I'm playing around with the SDK and have some `.pvm` files compiled. It seems to me that there is one extra byte between "read-only data" `o` and `E_4(codeLength)`. Normally there should be `w` there, but length of `w` is set to 0. Am I missing something, or might this be a bug?
  ‚Ü≥ 2024-11-30 14:57 tomusdrw: Hmm, is it actually based on GP 0.5.0 or some other version? I'm trying to:

1. Read it as SPI (need to alter the `|w|` to 1 byte to make it valid (i.e. skip one byte between `o` and `|c|`)
2. Disassemble the instructions. For bootstrap service I see 3 `JUMP(5)` at the beginning which looks like pre-0.5 instruction numbers, but in `0.5.` JUMP is `40`? [edited]
  ‚Ü≥ 2024-11-30 15:31 tomusdrw: FWIW: it seems that the instruction set is the current `master` branch of `polkavm`, which looks kind of like in between `GP-0.4.5` and `GP-0.5.0`, so `0.4.5 + 64-bit stuff`
  ‚Ü≥ 2024-12-01 11:18 jan: Yes, sorry, this isn't yet fully updated with the GP. I'll update it sometime this week.
  ‚Ü≥ 2024-12-01 11:21 jan: Our current linker emits 64-bit code but still with the old opcode numbers, and the JAM blob builder still needs its header adjusted.
2024-11-30 13:47 gav: We won‚Äôt
  ‚Ü≥ 2024-12-01 20:50 sourabhniyogi: Ok!  Some advice on how to organize this would be appreciated

https://docs.jamcha.in/testing/import-blocks#modes
2024-11-30 14:59 gav: Would need to check with [@jan:parity.io](https://matrix.to/#/@jan:parity.io)
2024-11-30 15:50 gav: Yeah it‚Äôs possible @jan didn‚Äôt yet update it. 
2024-11-30 16:02 subotic: I have an open PR with the updated opcodes. Jan wants to wait with merging.
2024-11-30 16:04 subotic: > <@subotic:matrix.org> I have an open PR with the updated opcodes. Jan wants to wait with merging.

The reason is that there are smart contracts on Westend, which would otherwise break.
2024-11-30 16:14 subotic: > <@subotic:matrix.org> The reason is that there are smart contracts on Westend, which would otherwise break.

Furthermore, there are additional opcodes coming with the ZBB extension, and there might be another round of opcode reshuffling. This is what I have understood anyway. Jan is the authority, though.
2024-11-30 16:50 tomusdrw: Yeah, no worries. I was just trying to figure out if it's possible to import the service code into [PVM disassembler](https://pvm.fluffylabs.dev). I think I do understand where we are at, so it's fine and I can wait for full GP-0.5.0 migration.
2024-12-01 11:55 jan: So we've recently switched to a 64-bit PVM in the GP. I haven't got the updated the test vectors ready yet (I will have them ready soon-ish), but in case some of you are already looking to update your PVM implementations to 64-bit here are some tips to make this process easier:

- *The* major change introduced with the 64-bit PVM is that the registers are now 64-bit, and in case of the most of the instructions their behavior stays essentially exactly the same, except they operate on 64-bit values instead of on 32-bit values now.
- The instruction encoding is unchanged. Those instructions which previously took at most a 32-bit immediate value (like e.g. `and_imm`) now still can have at most a 32-bit *physical* immediate, *however* the immediate value is now sign extended to full 64-bit before being used.
- There's only a *single* instruction which takes a 64-bit immediate that is actually *physically* encoded in the code stream as 64-bit (`load_imm_64`)
- There are a couple of instructions where there exists both a 64-bit variant and a 32-bit variant. (e.g. `add_32` and `add_64`) The `_32` variants work like the old 32-bit instruction from 0.4 - they ignore the upper 32-bits of the registers and use only the lower bits, but their result is *always* sign extended to full 64-bits when written to the destination register.
- The address space is still 32-bit and memory accesses ignore the upper 32-bits of registers.

If any of you have trouble updating your PVMs or have any questions regarding PVM then, as always, feel free to ping me and I'll be happy to help.
  ‚Ü≥ 2024-12-01 14:50 sourabhniyogi: Thank you so much for summarizing what we should do next!

We have been using polkatool to build a few test services in 32-bit =) and are trying out building the same with the Parity Rust SDK.  Is polkatool going to be 64-bit soon or is it 64-bit already under certain flag / conditions or 64-bit already?

We could not tell exactly
https://github.com/paritytech/polkavm/commits/master/



  ‚Ü≥ 2024-12-01 16:19 jan: `polkatool` and PolkaVM supports both 32-bit and 64-bit simultaneously; no extra flags are needed. It picks the appropriate target based on which RISC-V target you used to compile your code.
  ‚Ü≥ 2024-12-01 19:18 sourabhniyogi: 1. It appears mul\_upper\_s\_s\_imm + mul\_upper\_u\_u\_imm existed in 0.4.5 but disappeared in 0.5.0 -- is this intentional?
2. GP keeps a lot of 32-bit instructions alongside 64-bit instructions, creating a lot of "twins", which I tabulated in two columns here "32-bit twin" and "64-bit twin"
https://docs.google.com/spreadsheets/d/1R7syeL7GYq4KH2B3Zh03v3CAFnK1iNNF0J4c2r-vKWw/edit?gid=1743195954#gid=1743195954
Is there a way to eliminate the 32-bit ones in favor of 64-bit?  After all, the R = Reduced and we appear to have a bit of instruction bloat -- If this to support 32-bit and 64-bit simultaneously in GP/polkadot/JAM Rust SDK/..., may I suggest we cut out the 32-bit support by a certain date to make everyone's life easier, the sooner the better?
3. In A.5.10 -- why is there not store\_ind\_i8, store\_ind\_i16, store\_ind\_i32, store\_ind\_i64, load\_ind\_i64, load_i64 [edited]
  ‚Ü≥ 2024-12-01 20:06 sourabhniyogi: Filed issue https://github.com/gavofyork/graypaper/issues/158 and thanks for responding =) [edited]
2024-12-01 17:19 danicuki: What is the difference between 
tickets_per_validator: 3 and  max_tickets_per_extrinsic: 3
in tiny vectors specification?
Aren't the the same thing?

https://docs.jamcha.in/basics/chain-spec/tiny
  ‚Ü≥ 2024-12-01 17:45 oliver.tale-yazdi: there is some short explanation here https://docs.jamcha.in/basics/chain-spec

Ticket per validator is [N](https://graypaper.fluffylabs.dev/#/911af30/3f67003f6900), and max_tickets_pre_extrinsic is [K](https://graypaper.fluffylabs.dev/#/911af30/3f61003f6300)
  ‚Ü≥ 2024-12-01 17:46 oliver.tale-yazdi: I will add some GP reader links to the explanation, basically the first one is the number of ticket entries each validator can do into the contest, and the second one is just to limit the size of the extrinsic
  ‚Ü≥ 2024-12-01 17:47 oliver.tale-yazdi: there can be at most 18 tickets in tiny, with at worst 15 in the honest majority case. But the Ticket extrinsic will only carry at most 3 per block [edited]
  ‚Ü≥ 2024-12-04 08:16 danicuki: with max_tickets_pre_extrinsic = 3, safrole tiny vectors fail. Should tiny be set to 16 also? or vectors should be changed?
  ‚Ü≥ 2024-12-04 09:48 oliver.tale-yazdi: right, my node was missing this. Looks indeed like two tiny vectors fail [edited]
  ‚Ü≥ 2024-12-04 12:44 davxy: > <@danicuki:matrix.org> with max_tickets_pre_extrinsic = 3, safrole tiny vectors fail. Should tiny be set to 16 also? or vectors should be changed?

Our tiny node has a max tickets per extrinsics = 16 (same as full). Why 3?
  ‚Ü≥ 2024-12-04 15:55 davxy: > <@oliver.tale-yazdi:parity.io> right, my node was missing this. Looks indeed like two tiny vectors fail

Fixed
  ‚Ü≥ 2024-12-05 07:39 danicuki: > <@davxy:matrix.org> > <@danicuki:matrix.org> with max_tickets_pre_extrinsic = 3, safrole tiny vectors fail. Should tiny be set to 16 also? or vectors should be changed?
> 
> Our tiny node has a max tickets per extrinsics = 16 (same as full). Why 3?

In the definition of tiny here is 3: https://docs.jamcha.in/basics/chain-spec/tiny
2024-12-01 18:58 sourabhniyogi: I tabulated the 0.4.5 opcode => 0.5.0 opcode updates here
https://docs.google.com/spreadsheets/d/1R7syeL7GYq4KH2B3Zh03v3CAFnK1iNNF0J4c2r-vKWw/edit?gid=1743195954#gid=1743195954

If you think the sheet is wrong, just update the sheet and point out what you changed.
2024-12-01 19:18 jaymansfield: > <@sourabhniyogi:matrix.org> I tabulated the 0.4.5 opcode => 0.5.0 opcode updates here
> https://docs.google.com/spreadsheets/d/1R7syeL7GYq4KH2B3Zh03v3CAFnK1iNNF0J4c2r-vKWw/edit?gid=1743195954#gid=1743195954
> 
> If you think the sheet is wrong, just update the sheet and point out what you changed.

Thank you for this!
2024-12-02 12:02 danicuki: davxy: How do you setup the initial value for authorizer queue (œÜ) for work report vectors? They are not supposed to be empty. Formula 8.2 adds œÜ[c][Ht] to authorizer pool, but in vectors they are not being added.
2024-12-02 12:13 danicuki: What are "offenders" state field in the work report vectors? Are they part of the psi state field? If so, please, use the same convention you used on disputes vectors. Please, be consistent with test vectors, regarding to json field names, use the same convention on all vectors, otherwise we get crazy ‚úåÔ∏è   [edited]
2024-12-02 12:36 rustybot: The asn.1 syntax is clear about it
2024-12-02 12:37 davxy: https://github.com/davxy/jam-test-vectors/blob/work-reports/reports/reports.asn
2024-12-02 12:48 danicuki: Thanks for the clarification. the .asn helps a lot. My suggestion is more about using the same names / structure for the same field in different test vectors. e.g.: why not use the same naming convention that you were already using in safrole and disputes vectors (psi, rho, tau, kappa, etc)? 
2024-12-02 12:55 davxy: I believe that reading the ASN.1 syntax file is more than enough to eliminate any ambiguity. Regarding the state, I‚Äôm open to renaming it if it helps. However, at the time of writing, I felt that `offenders` was a clearer choice compared to `psi_o_prime`. :-) [edited]
2024-12-02 13:34 rick: Hard agree +1 to `offenders` over `psi_o_prime`, you've already got defs in the GP which make that link to the asn spec name. 
2024-12-02 14:04 danicuki: > <@davxy:matrix.org> I believe that reading the ASN.1 syntax file is more than enough to eliminate any ambiguity. Regarding the state, I‚Äôm open to renaming it if it helps. However, at the time of writing, I felt that `offenders` was a clearer choice compared to `psi_o_double_dagger`. :-) 
> 
> 

My suggestions is to use offenders, but ender psi branch:

Psi: {
 offenders: [...]
 other_psi_fields...
}

This is how it is in disputes vectors, which for me makes much more sense. Offenders under the main state branch seems odd, as state doesn't have an "offenders" component. 
2024-12-02 14:30 davxy: I understand your perspective. However, the state in question is not the "main" state. Only the relevant portions of the state required to advance the STF of a particular subsystem are included. 

In cases of "disputes" vectors, the entire œà is necessary, while "reports" STF requires only œà‚Çí. I don't think that including items that are not strictly needed is beneficial, which is why for example, I have not included other state items here. 

I recognize that this approach is based on personal preference. However, since there is no formal specification for how to write vectors, I believe it is more efficient to exclude elements not required by the subsystem's STF. 

If anyone wishes to draft a mini-specification for writing vectors, I encourage you to open an issue on GitHub to address these considerations. Of course, I will eventually adapt my approach to the issue outcome. [edited]
  ‚Ü≥ 2024-12-02 14:58 danicuki: Thanks for the conversation. For elements that are not needed, you don't need to include. In this case, you would just put:‚Ä®Psi: {‚Ä®offenders: []‚Ä®}
You keep the consistency among different test vectors, while excluding unneeded elements.
I agree that these are not formally specified. What I am trying to propose here is something that helps teams to be more efficient when dealing with vectors. [edited]
2024-12-02 15:41 sourabhniyogi: Strongly prefer long Developer-friendly English attribute names in JSON over short greek letters from GP to reduce cognitive load.   Its best to have a single benevolent dictator have good consistent taste than have any inconsistency in this.   The style is roughly in place already, lets not change it!

For STF test vectors:

- raw k,v values in JSON with a little bit of metadata for service storage sufficient to derive the key and know its type will be best.
- having a comprehensive dump of raw k,v values for the "pre\_state" is necessary, ideally coupled with this metadata;
- for the post\_state, its a debate as to whether to have a comprehensive dump of k,v state along with this metadata.  Its easier to read/write but a tad harder to spot the differences without writing a little diff code.
- Having the post state root is desirable but not strictly necessary.
- Having a JAM codec version of an STF test vector might be useful or unnecessary.  But, in general, the W3F test vectors being in both JSON + JAM Codec shuts down unnecessary debates effectively.  In all cases, having W3F be the benevolent dictator is very useful so we don't have engineers bickering over formats. [edited]
2024-12-02 17:13 oliver.tale-yazdi: > <@davxy:matrix.org> I believe that reading the ASN.1 syntax file is more than enough to eliminate any ambiguity. Regarding the state, I‚Äôm open to renaming it if it helps. However, at the time of writing, I felt that `offenders` was a clearer choice compared to `psi_o_prime`. :-)

IMHO any naming is fine. I only write these things once into a translation map and never think about them again.
2024-12-02 20:48 danicuki: I had a doubt about the assurance bitfield interpretation in vectors:

I see in vectors we have values from 0x01 to 0x03, which would be:
\[0, 1\], \[1, 0\] and \[1, 1\]

My question is: what is the correct position for cores? Do we use the least significant bit order or the most significant? In other words, 
if bitstring is 0x01 for example, core\[0\] is 1 and core\[1\] is 0? Or the opposite?

Having some issues with af[c] with the presented bitfields [edited]
  ‚Ü≥ 2024-12-03 01:47 jaymansfield: I have both the tiny and full vectors passing now. Here is how I converted them: 0x01 = 10000000
0x03 = 11000000
  ‚Ü≥ 2024-12-03 01:48 jaymansfield: For the full vectors, convert each pair separately and make sure to pad each to 8 digits. [edited]
2024-12-02 21:01 jaymansfield: We have these vectors passing now in our implementation. For bitfield 0x01, the vectors seem to expect core[0]=1 core[1]=0, and 0x02 to be core[0]=0 core[1]=1. Had the opposite originally and had to reverse the binary we generated for it to pass. [edited]
2024-12-03 03:22 xlchen: Here is my RPC proposal draft: https://github.com/open-web3-stack/jam-rpc-spec pretty much copying the Substrate RPC with some minor tweaks
2024-12-03 04:28 amritj: In graypaper here https://graypaper.fluffylabs.dev/#/911af30/19e30019e600

It is mentioned that import spec could contain both segment root and work package hash and to distinguish between them the work package hash value are tagged 


But here according to jam official codec it is just a hash: 

https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/jam-types-asn/jam-types.asn#L121

So, how do we identify, if hash is tagged or not i.e. is it a segment root or work package hash?


 [edited]
  ‚Ü≥ 2025-01-05 06:50 luke_fishman: Amrit Jain: any news on this? how you tell them apart? i am wondering the same
  ‚Ü≥ 2025-01-07 04:58 amritj: https://graypaper.fluffylabs.dev/#/911af30/368602368602
2024-12-03 08:53 davxy: > <@amritj:matrix.org> In graypaper here https://graypaper.fluffylabs.dev/#/911af30/19e30019e600
> 
> It is mentioned that import spec could contain both segment root and work package hash and to distinguish between them the work package hash value are tagged 
> 
> 
> But here according to jam official codec it is just a hash: 
> 
> https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/jam-types-asn/jam-types.asn#L121
> 
> So, how do we identify, if hash is tagged or not i.e. is it a segment root or work package hash?

Ty for reporting, I'll fix it.

2024-12-03 09:01 davxy: @room If you are using GitHub, please report any issues related to test vectors directly [here](https://github.com/w3f/jamtestvectors/issues). I may overlook or forget about some messages shared in the chat. This request does not pertain to trivial questions but rather to issues you are confident you have identified. Ty
  ‚Ü≥ 2024-12-06 01:10 sourabhniyogi: Added https://github.com/w3f/jamtestvectors/issues/26
2024-12-03 14:13 danicuki: I've been posting many questions related to test vectors here in this chat. Do you believe it is a good idea to have another room just for test vectors related questions, so we don't spam the main chat with these messages?
  ‚Ü≥ 2024-12-03 14:48 rick: I think it's fine, there's not that much activity and people are generally good about threading the topics. 
2024-12-03 14:50 danicuki: for no_assurances_with_stale_report-1 vector, how can the cores[0] report be nullified on the next state if there are no assurances in the block (thus no new report available)? I am referring to Formulas 11.15 and 11.16 - am I missing something?
2024-12-03 18:18 jam_man: Question about starting an implementation. 

Is there any guide(s) to follow, or is the idea that we use only the gray paper as a guideline for how to create the implementation? 
2024-12-03 18:24 jam_man: More specifically. Is the idea that we read and interpret the gray paper and turn the core ideas into functional code.

Specifically making sure we hit the milestones from the web3 rules page.  [edited]
2024-12-03 18:52 danicuki: > <@jam_man:matrix.org> Question about starting an implementation. 
> 
> Is there any guide(s) to follow, or is the idea that we use only the gray paper as a guideline for how to create the implementation?

We all started like this: read the paper, start writing code. You will get surprised about how much you can do. I've presented a workshop last month that might give you some ideas: https://www.youtube.com/watch?v=8UT2akmxu4I
2024-12-03 18:53 jam_man: > <@danicuki:matrix.org> We all started like this: read the paper, start writing code. You will get surprised about how much you can do. I've presented a workshop last month that might give you some ideas: https://www.youtube.com/watch?v=8UT2akmxu4I

Awesome I will take a look at this. Thank you 
2024-12-03 20:09 sourabhniyogi: I tabulated the W3F Test Vectors concerning "block validation" errors (safrole, reports, assurances, disputes)  here:

https://docs.google.com/spreadsheets/d/1yizEboIB28AP1fZXVfcm7kI5CtKd12TepsUcTDV1auo/edit?gid=2118274177#gid=2118274177

I assembled this to address a "importblocks" implementation:
https://docs.jamcha.in/testing/import-blocks
but this may help others develop systematic error treatment (in response to the above, and thus pass M1 Import Blocks).  

If you see fixes or want to add 0.5.x links to GP sections, just update the sheet! [edited]
2024-12-04 03:32 luke_jamixir: [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org) any plans to add to safrole  vectors with proper header seal and vrf signatures?
That would be very useful 
2024-12-04 03:37 amritj: Question:

The segments are erasure-coded and distributed to the validators. Each validator receives a single shard out of the 1,023 shards, determined by their validator index. Therefore, the shard index of the shard they receive equals to their validator index.

According to the JAMNP protocol, to fetch data from the assurers, we need to provide each assurer with the shard index we require from them.

The exported segments are expected to remain available for 28 days. During this period, it is assumed that more than 341 validators will remain consistent. However, there is still a significant likelihood that validator indexes may change during this time due to the addition or removal of validators.

Given this, should we also maintain a record of the validator keys associated with each shard index? This would allow us to identify which validator holds a specific shard, regardless of changes in their validator index.

Finally, is the assumption that more than 341 validators will remain unchanged for 28 days accurate? [edited]
  ‚Ü≥ 2024-12-04 03:39 sourabhniyogi: Join Gray Paper room for these great questions -- Recently a similar question was asked --  There is no mechanism to "hand over" import DA data to new validators. Thus far the assumption is that it doesn‚Äôt matter. (Ie churn will be sufficiently small)
  ‚Ü≥ 2024-12-04 03:40 sourabhniyogi: Conclusion is likely that there no need to keep the validator key associated with the shard index.  But you can if you want =)
  ‚Ü≥ 2024-12-04 03:46 amritj: Gotcha, so we assume most of the validators will remain the same.

But the validator indexes can still change.


For example, in the test vectors validator at index 0 in archive and active validator set is different

https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/safrole/tiny/enact-epoch-change-with-no-tickets-4.json#L17

https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/safrole/tiny/enact-epoch-change-with-no-tickets-4.json#L55  [edited]
  ‚Ü≥ 2024-12-04 03:47 amritj: And yeah I am already in the Graypaper room will try to post these questions there from now on, I assumed this was related to JAMNP too so I posted it here [edited]
  ‚Ü≥ 2024-12-04 09:57 dave: Yes, you need to remember historical validator sets to know who to request shards from. You may also want to remember the availability bitfield for each package so you know which validators claimed to have their data
  ‚Ü≥ 2024-12-04 13:57 amritj: Gotcha, and in the case of a new validator added to the network, is there any mechanism to distribute this table to him? Otherwise he won't be able to compute work results
  ‚Ü≥ 2024-12-04 14:34 dave: Ah good question. New validators will need to fetch the last ~28 days of block history anyway to build the SR->ER mapping. I believe this map can be built using _only_ the blocks, without requiring any state to be fetched. Unfortunately as-is I don't think the old validator sets can be determined just by looking at the blocks, as I don't think the epoch marker in the header includes all the necessary information. Seems like it might be a good idea to change this, but maybe there is a different way to make it work. We certainly won't require full state history to be kept for 28 days. [edited]
  ‚Ü≥ 2024-12-04 17:50 amritj: We can also use DA system to store this type of data, it will allow to easily distribute and hand over data required by new validators [edited]
  ‚Ü≥ 2024-12-04 17:55 amritj: Yeah, but the question remains the same in our case ‚Äì we still need to know which validator has which shard, it doesn't solve anything üòÖ
  ‚Ü≥ 2024-12-04 17:55 dave: There is possibly a chicken-egg problem there? Separately, given that all validators need this data anyway, I'm not sure about erasure coding it.
  ‚Ü≥ 2024-12-04 19:34 amritj: If from the current validator set we know the validators that are active during the epoch the work package was executed, we can just send them the erasure root and ask them the shard they have and they will share the shard with it's index and ofcourse justification data so we can verify it.

And about knowing which validators were active during our work package epoch, I think we can store a status component like we do in preimages in the validator metadata which somehow tell us the epoch indexes the validator was active   


2024-12-04 03:50 clearloop: May I ask if the example in https://github.com/davxy/bandersnatch-vrfs-spec is outdated? both the latest on main and  @8c82722 could not be compiled [edited]
2024-12-04 04:23 luke_jamixir: > <@clearloop:matrix.org> May I ask if the example in https://github.com/davxy/bandersnatch-vrfs-spec is outdated? both the latest on main and  @8c82722 could not be compiled


Try to update the ark-ec-vrfs dependency to revision:¬†e491b41
  ‚Ü≥ 2024-12-04 04:31 clearloop: @8c82722 maches @e491b41, I'll try again about it anyway, thanks! [edited]
2024-12-04 04:37 luke_jamixir: Indeed, does not compile 
2024-12-04 04:44 clearloop: seems caused by ring-proof is broken via the update of w3f/fflonk
2024-12-04 04:50 clearloop: Screenshot 2024-12-04 at 11.49.25.png
2024-12-04 04:50 clearloop: okay yesterday...

in case anybody meet the same problem while playing around with it, you can add this patch to your local testing repo instead of updating the whole dependency chain

```
[patch."https://github.com/w3f/fflonk"]
fflonk = { git = "https://github.com/clearloop/fflonk", rev = "1e854f35e9a65d08b11a86291405cdc95baa0a35" }
``` [edited]
2024-12-04 07:42 davxy: mmm... I know. The problem is that these crypto backends are not yet published on crates.io. And stuff may break.
I'm going to anchor the ring-proof we're using to the previous fflonk revision.

2024-12-04 08:51 davxy: should be fixed. New reference ark-ec-vrfs rev: d90e180
2024-12-04 13:26 davxy: A smaller value for tiny makes sense BTW. I think we can change it 
2024-12-04 15:53 davxy: That will eventually be included in the vectors used to verify the block header. Safrole vectors are responsible for validating the Safrole STF.
2024-12-05 11:21 luke_fishman: Thank you, and apologize if I'm being pushy, but do you have a rough ETA for that? we in Jamxiir would really like to get some validations that we are signing/verifying correctly.

  ‚Ü≥ 2024-12-05 13:50 oliver.tale-yazdi: You can just publish some signatures yourselves and ask other teams to cross-check?  
We could also define a JSON rpc function check it cross-client [edited]
2024-12-05 14:56 danicuki: > <@danicuki:matrix.org> for no_assurances_with_stale_report-1 vector, how can the cores[0] report be nullified on the next state if there are no assurances in the block (thus no new report available)? I am referring to Formulas 11.15 and 11.16 - am I missing something?

davxy afk: can you help with this issue? 
2024-12-05 15:09 danicuki: Also, from what I noticed, vectors are considering a report staled when Ht = œÅ‚Ä†[c]t + U, but the GP formula says:

af [c] ‚áí œÅ‚Ä†[c] ‚â† ‚àÖ‚àßHt ‚â§ œÅ‚Ä†[c]t + U 

(or vectors are using a value of U different then 5)
2024-12-05 15:29 danicuki:  https://www.youtube.com/watch?v=9EcjWd-O4jI - Blockcowboy  nostalgic reference
2024-12-05 15:46 davxy: > <@danicuki:matrix.org> Also, from what I noticed, vectors are considering a report staled when Ht = œÅ‚Ä†[c]t + U, but the GP formula says:
> 
> af [c] ‚áí œÅ‚Ä†[c] ‚â† ‚àÖ‚àßHt ‚â§ œÅ‚Ä†[c]t + U 
> 
> (or vectors are using a value of U different then 5)

Yeah looks like GP prescribes lazy deletion of stale reports. I asked [@gav:polkadot.io](https://matrix.to/#/@gav:polkadot.io) for confirmation.
Also I was considering a report stale if  H_t >= ... . Looks like should be H_t > ... instead. Probably I need to fix these assurances vectors. 
2024-12-05 22:08 danicuki: davxy afk: I just saw the new statistics vectors. Why do you use kappa_prime in the pre_state? shouldn't it simply be 
{
pre_state: { kappa: {}} 
post_state: { kappa: {}} 
}

kappa_prime in the pre_state seems very odd, and kappa_prime in the post_state seems redundant, as everything in post_state is prime :-)
2024-12-06 19:24 rustybot: I think we already discussed about this. Not sure if with you or someone else. 
- "input" is stuff found in the block: extrinsic and header
- "state" are the relevant bits found in the global state relevant to push forward the STF.

Said that,
- some of these state bits may be "prime", "dagger" or double dagger (see asn.1 for semantics)
- some of these bits are changed by the STF, while some others not. 

This may result in data redundancy. But otherwise I had to introduce a different struct for posterior state. I found this easier. [edited]
2024-12-07 11:18 olanod: Hello, don't know if it's of interest or too soon ... while y'all work hard on JAM implementations I'm getting interested in looking a bit higher up the stack(services) also following my interest of lower level embedded Rust(specially riscv). I've been toying around with a simple embedded/virtual OS that allows writing simple ink-like apps that can run on a riscv microcontroller(also linux, web and of course I also checked building against the pvm target ;)). I think I get now how to port this to run as a JAM service but the random idea I came to ask is to see if there would be interest in a **"pocket JAM"**, I'll buy this [dev kit](https://de.aliexpress.com/item/1005005128298189.html?spm=a2g0o.productlist.main.11.8183CxLGCxLGyZ&algo_pvid=7b0defc5-548f-44e6-96ac-ba5cd46302c2&algo_exp_id=7b0defc5-548f-44e6-96ac-ba5cd46302c2-5&pdp_npi=4%40dis%21EUR%2145.50%2126.39%21%21%2146.97%2127.24%21%402103917f17335688657033211e7482%2112000031770778647%21sea%21DE%210%21ABX&curPageLogUid=3yHiDQ0GYa4J&utparam-url=scene%3Asearch%7Cquery_from%3A) to experiment porting the os, it's interesting that has 3 different risc-v core including one rv64gcv and a rv32emc, I feel it would have enough juice to run a light client.
2024-12-07 21:46 gav: > <@davxy:matrix.org> Yeah looks like GP prescribes lazy deletion of stale reports. I asked [@gav:polkadot.io](https://matrix.to/#/@gav:polkadot.io) for confirmation.
> Also I was considering a report stale if  H_t >= ... . Looks like should be H_t > ... instead. Probably I need to fix these assurances vectors.

Reports are now actively removed on expiration: https://github.com/gavofyork/graypaper/pull/160/commits/3e99734afc3770b145539f20b1cfa2939bbecd80
2024-12-08 11:09 sourabhniyogi: Looking closely at the shape of [CE134: Work-package sharing](https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-134-work-package-sharing) and [CE135: Work-report distribution](https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-135-work-report-distribution) it appears that there continues to be an expectation that a guarantor has at most ~2 seconds to do its work eg "The third guarantor should be given a reasonable amount of time (e.g. two seconds) to produce an additional signature before the guaranteed work-report is distrubuted."   Is the max gas allotted to refine going to be matched to this ~2s expectation?

How does JAM's refine gas limit compare to the gas/weight available in a single block of Polkadot (Asset) Hub with revive-pallet? [edited]
2024-12-08 11:25 gav: There's no need to wait until the WR is computed before distributing the WP.
2024-12-08 11:26 gav: You just need to check the authorisation is reasonable.
2024-12-08 11:26 gav: And there's no need to synchronise with the block production.
2024-12-08 11:26 gav: The anchor block can be (IIRC) up to 8 blocks from the head of the chain at time of reporting. [edited]
2024-12-08 11:27 gav: JAM's gas limit is designed such that the WP should be able to be fetched and execute easily within the 6 seconds, the provisional gas limit is tuned to 5 seconds. [edited]
2024-12-08 11:41 sourabhniyogi: For both polkatool (usable to build contracts with refine-pallet, now on [Westend Hub](https://contracts.polkadot.io/tutorial/rust)) and the JAM Rust SDK, there is this idea that arbitrary Rust code can be put into contracts and JAM Services.  But in practice, in both cases, it appears there is a pretty serious "no\_std" requirement ... that makes it hard to put Rust packages using `std` into PolkaVM Contracts or JAM Services.  They quickly hit this "error\[E0463\]: can't find crate for `std`"!  This leaves us reaching out for a host function and a 'ecalli ___` as a "cheat code" to avoid rewriting the underlying dependencies on std packages, and thus get a revive-pallet based contract and/or JAM Service.  

Is there some trick that can be employed to overcome the no\_std limitation? [edited]
2024-12-08 11:44 gav: No. It‚Äôs there by design. This is consensus code. 
2024-12-08 11:44 gav: You get trustless bare metal. Not Windows.  [edited]
2024-12-08 12:14 sourabhniyogi: Its amazing how quickly the "you can run Doom with PolkaVM!" for the cameramen devolves into "how does info! work" üòÖ

How should non-Rust JAM implementations interface with Rust JAM SDK `info!` calls like [these](https://github.com/jam-duna/jamtestnet/blob/main/services/parity/jam-bootstrap-service/src/main.rs#L59) -- not talking about Windows here, just like printing stuff with caveman debugging -- is there a way? [edited]
2024-12-08 13:41 gav: Yeah - there‚Äôs an additional (unofficial) host call provided by polkajam which the logging system uses if enabled. [edited]
2024-12-08 13:42 gav: You can derive the details from the code in `jam-pvm-common` crate quite easily. Here's the relevant snippet:
2024-12-08 13:42 gav: ```
	#[polkavm_import(index = 100)]
	pub fn log(
		level: u64,
		target_ptr: *const u8,
		target_len: u64,
		text_ptr: *const u8,
		text_len: u64,
	);
```
2024-12-08 13:43 gav: So that takes 5 registers
2024-12-08 13:44 gav: The first is the log level, 0...5 which gives the severity of the item [edited]
2024-12-08 13:45 gav: then two UTF-8 strings passed as the usual offset/length combinations, the first for the subsystem name and the second for the message.
2024-12-08 13:45 gav: The subsystem name can by the null ptr, in which case it is in a "global" context without a specific subsystem.
2024-12-08 13:46 gav: I can copy/paste this into a JAM-community document.
2024-12-08 13:47 gav: Happy to consider other such unofficial host-calls if they make sense, though beware they'd only be for testing/debugging unless detailed in the GP.
2024-12-08 13:49 gav: There should be nothing which introduces non-determinism into the PVM, which basically means they have to be pure functions that could possibly have some useful side-effects (as long as they're transparent from the perspective of the GP).
  ‚Ü≥ 2024-12-08 16:24 sourabhniyogi: Looking at `pallet-revive`
 
https://docs.rs/pallet-revive/latest/pallet_revive/trait.SyscallDoc.html#tymethod.ecdsa_to_eth_address

I would suggest literally the following:

ecdsa_recover
ecdsa_to_eth_address
hash_blake2_128
hash_blake2_256
hash_keccak_256
hash_sha2_256
sr25519_verify

Skeptical these should be interpreted PVM byte code, but putting that nag aside, having a whole host of them in bootstrap code and a idiomatic way of accessing them with invoke or similar seems justified.   It seems wild for everyone to have their own versions of these in their own service code, but this will lead to some nice performance tests a side effect.  

For pedantic reasons hope you will consider: 
block_number, code_hash, now, minimum_balance
own_code_hash [invoke?]
and for parity: 
xcm_execute, xcm_send [??]
depending on how transfer and xcm are related.

"info!" and debug_message could be massaged together.

All of this is deterministic but the first group has a lot of opinionated stuff on what is a worthy crypto primitive between edwards, bls and bandersnatch signature verification to consider.

Generally, from [this](https://contracts.polkadot.io/tutorial/rust/) we want JAM Service builders and Polkadot Hub contract builders to have minimal friction between {Rust, ...} code built with the JAM SDK vs revive, even though the former is meant for rollups and the latter is for end users.   
  ‚Ü≥ 2024-12-08 17:30 gav: I'd be very careful before adding this stuff to JAM at the lowest level. Once added it must be supported as a protocol component forever. Inevitably it's heavily opinionated.
  ‚Ü≥ 2024-12-08 17:31 gav: PVM is fast, and unless there's a great, ecosystem-wide need for it to be faster at doing specifically this stuff then it's just not worth dirtying the protocol with.
  ‚Ü≥ 2024-12-08 17:32 gav: It's not too difficult to add pure host-calls down the line since they can be polyfilled with PVM implementations, averting the need for a messy hard-fork. All that is really needed is for implementations to recognise the new host-call and charge the right gas. [edited]
  ‚Ü≥ 2024-12-08 17:32 gav: However, removing them is a big pain since you need to increase the gas-prices which services utilizing them are paying. [edited]
  ‚Ü≥ 2024-12-08 17:35 gav: These "precompiles" make a bit more sense in a smart contract environment where execution is slow and the domains can be pretty specific. [edited]
  ‚Ü≥ 2024-12-08 17:35 gav: > xcm\_execute, xcm\_send

These make no sense. XCM has nothing to do with JAM. [edited]
  ‚Ü≥ 2024-12-08 17:37 gav: > block_number

This is contained as part of the refinement-context
  ‚Ü≥ 2024-12-08 17:37 gav: > code_hash

This is part of the service info.
  ‚Ü≥ 2024-12-08 17:38 gav: > now

This is the block number.
  ‚Ü≥ 2024-12-08 17:38 gav: > minimum_balance

This is part of the service info
  ‚Ü≥ 2024-12-08 17:39 gav: > own_code_hash

This is part of the service info.
  ‚Ü≥ 2024-12-08 23:32 sourabhniyogi: Ok, hope JAM { Rust, ... } SDKs will get these out of the contexts/service info/...  into similar if not identical abstractions.  No specific request, thank you!

For "XCM has nothing to do with JAM", I had thought JAM's transfer memos and XCM/XCMP would be directly connected -- surely for Polkadot rollups but potentially also non-Polkadot rollups.  You must mean something much more particular here -- is it  "the content of the message [XCM] has nothing to do with messaging service [XCMP]" or something else? [edited]
  ‚Ü≥ 2024-12-09 02:08 xlchen: XCM/XCMP are implemented on top of JAM but JAM shouldn't be aware of XCM/XCMP. for example, we can't require every services to support XCM
  ‚Ü≥ 2024-12-09 11:33 sourabhniyogi: Brilliant =)  Got it.
  ‚Ü≥ 2024-12-09 18:02 sourabhniyogi: > <@gav:polkadot.io> It's not too difficult to add pure host-calls down the line since they can be polyfilled with PVM implementations, averting the need for a messy hard-fork. All that is really needed is for implementations to recognise the new host-call and charge the right gas.

Understood about not adding these at the lowest level within the JAM protocol.
```
ecdsa_recover=101
ecdsa_to_eth_address=102
hash_blake2_128=103
hash_blake2_256=104
hash_keccak_256=105
hash_sha2_256=106
sr25519_verify=107
```
but what about
(a) for performance testing interpreted PVM implementations  ala/within JIP-1 101..107 -- we'd compare calling the "native" unofficial host implementation against a PVM implementation against whatever Westend Hub does in { clock time, gas } -- its apples to apples 
(b) for abstractions within the JAM (Rust) SDK that simply call some bootstrap "polyfilled" PVM code.
These are not JAM protocol additions forever etched in but abstractions and measurements.
  ‚Ü≥ 2024-12-10 08:02 olanod: About non-determinism,  I was wondering about the feasibility of introducing yet another step between authentication and refinement, a "data sourcing" stage run by a single node, this step similar to an off-chain worker can access the network to fetch/load resources that are loaded into the DA and can be used during refinement. I suppose loading data into the DA layer can be done independently by the light client but some clients might be very light and won't even have the memory to hold and upload the resources they want for refinement.
  ‚Ü≥ 2024-12-10 08:04 xlchen: GP (at current status) is really only for validator nodes. if for example your parachain/light client/collator node need to do extra step, sure no one is going to stop you
  ‚Ü≥ 2024-12-10 08:17 olanod: Can't Polkadot validators do off-chain workers? I was thinking of a set up without the equivalent of a parachain with collators, for sure we would do that if there's no other option but if I understand correctly there will be services like CoreJAM where a light client directly connected to said validators could call a function of a JAM service? that service could have sourced data at an earlier stage.
  ‚Ü≥ 2024-12-10 08:20 xlchen: I don't 100% get your requirement but data of a work package can come from 3 places: the work package itself, DA via a segment root, or preimage store via a hash.
  ‚Ü≥ 2024-12-10 12:10 gav: Polkadot Relay chain validators are not meant to be using generally programmable off-chain workers. They‚Äôre application level things. Jam is ‚ÄúOS‚Äù level. [edited]
2024-12-08 18:08 gav: > <@gav:polkadot.io> I can copy/paste this into a JAM-community document.

https://hackmd.io/@polkadot/jip1
  ‚Ü≥ 2024-12-08 21:25 sourabhniyogi: Permissions need granting.
  ‚Ü≥ 2024-12-09 09:53 prematurata: yeah can't access it 
2024-12-09 06:34 weigen: Hello, I have a question about work package, is a work package limited to a maximum of four segment roots?
2024-12-09 11:28 gav: > <@weigen:matrix.org> Hello, I have a question about work package, is a work package limited to a maximum of four segment roots?

No
  ‚Ü≥ 2024-12-09 11:41 weigen: I thought a work package have mostly four work items and each work item only has one segment root
  ‚Ü≥ 2024-12-09 12:34 gav: There can be four work items, each work item has no individual limit on imports and exports. Each import requires either a segment root or a work package hash to define it (along with an index). There can be a maximum of 2048 imports. [edited]
  ‚Ü≥ 2024-12-09 12:34 gav: The ensuing work report as a whole has a single segment root. This root commits to all of the exports of all work items. [edited]
  ‚Ü≥ 2024-12-09 13:36 weigen: Thanks, I got it!
  ‚Ü≥ 2024-12-10 09:59 weigen: Hi, I'm a little confused after reading the paged proof part.Can I confirm that I understand it correctly?

Focusing on the work package export part, work items will export segments, and these segments will form a Merkle Tree with a constant depth. The Merkle Root of this tree will become the segment root in the work report.
Paged-proofs function will page the Merkle Tree built by the export segments, and each page will have 64 segments. Each segment will have a Merkle Proof (paged-proof) to the subtree root (tree of each page). The paged-proofs function will output the leaves (hashes of each segment), and each segment's Merkle Proof to the subtree root.

Is this understanding correct?
 [edited]
  ‚Ü≥ 2024-12-10 11:21 gav: See my message in the main chat
2024-12-09 11:56 oliver.tale-yazdi: doc is private
2024-12-09 12:08 amritj: In CE 144 Audit announcement of JAMNP, how can we verify the announcement of no show auditors without the full list of reports they announced to audit?

https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-144-audit-announcement [edited]
  ‚Ü≥ 2024-12-09 12:37 dave: Not sure I understand the question. Do you mean when an announcement is made claiming some no-shows, how these no-shows can be proved/verified?
  ‚Ü≥ 2024-12-09 12:48 amritj: Yes, we pass a list of no-show auditors for every WR we intend to audit after tranche 0

The no-show data contain validator index and their audit announcement, so we can verify that the auditor really announced if they will audit the WR.

https://github.com/zdave-parity/jam-np/blob/5d374b53578cdd93646e3ee19e2b19ea132317b8/simple.md?plain=1#L656

But to verify the announcement, we need the original message that contains the full list of reports the no-show auditor announced

https://graypaper.fluffylabs.dev/#/5b732de/1d7e011d7e01

So, my question was how to retrieve the report list and verify the no-show auditor announcement [edited]
  ‚Ü≥ 2024-12-09 12:51 dave: Everything needed to verify the no-shows should be included
  ‚Ü≥ 2024-12-09 12:53 amritj: Yeah, but the full list of the no-show auditor work reports, is not included in the spec, and that I believe is required to verify the no-show announcement
  ‚Ü≥ 2024-12-09 12:53 dave: FWIW you can just verify the signatures of the no-show announcements
  ‚Ü≥ 2024-12-09 12:55 dave: > <@amritj:matrix.org> Yeah, but the full list of the no-show auditor work reports, is not included in the spec, and that I believe is required to verify the no-show announcement

Maybe I am misunderstanding but they are included here? `Announcement = len++[Core Index ++ Work-Report Hash] ++ Ed25519 Signature`
  ‚Ü≥ 2024-12-09 12:56 amritj: Aah, I got confused by the definition of announcement in the graypaper and thought only announcement signature was included
2024-12-09 18:55 gav: (a) could be done trivially without the trouble of defining a multi client standard host function to implement. 
(b) I see little point of this other than for code deduplication. In that case if it‚Äôs a serious issue we should allow for code-importing in a more sensible way. 
2024-12-10 00:40 celadari: Hi, I would like to ask some help debugging signatures in work report tests.

In `tiny/multiple_reports-1.json` (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/reports/tiny/multiple_reports-1.json), our signatures are failing. **Could someone with a passing test vector share the following in HexString please ?**
- The encoding of the first workReport
- The hash of that encoding

I post the full workReport definition in the thread to keep this message brief in the main chat.
Thanks!
  ‚Ü≥ 2024-12-10 00:41 celadari: the report
```json
{
                "report": {
                    "package_spec": {
                        "hash": "0x63c03371b9dad9f1c60473ec0326c970984e9c90c0b5ed90eba6ada471ba4d86",
                        "length": 12345,
                        "erasure_root": "0x9fc7e637969aef1a95dfb560a914cf5161a76498db3aa19df131cea199ed6e44",
                        "exports_root": "0x5c9dca800c145685f052ce1ba343e2b66b4c333ee4c4ca3b29cb347b1009cb83",
                        "exports_count": 3
                    },
                    "context": {
                        "anchor": "0x39cb518983b02695034b3b92cb31a7334e1a2ec3ef7dbfa32c68e4e8444363f1",
                        "state_root": "0xd8c577816b629241676502d0461e4eae42a375461314d64484f35f4228da23d6",
                        "beefy_root": "0x71c150347dc035847d5944c864a2d3ed0fa410341b2ffbfdeeaa1c9d6aa9cacd",
                        "lookup_anchor": "0x16bda47e5a68daf53c39ddee8af4ecaced7e87f3f0ac9da5a6f4f9e41350d319",
                        "lookup_anchor_slot": 6,
                        "prerequisites": []
                    },
                    "core_index": 0,
                    "authorizer_hash": "0x9a3a97d1950356ef6d3c20acb5ab6699be454b1498ecd513bdc6d849497e42eb",
                    "auth_output": "0x",
                    "segment_root_lookup": [],
                    "results": [
                        {
                            "service_id": 42,
                            "code_hash": "0x6470fd21983eae8d706f1edd5e2dc5afe095980f8fb7bd4ebfd33550d8730246",
                            "payload_hash": "0x3cf2d09da453bbdd6b68d8a1acd5f15ba23ba46d4ff087592b3d319432500a50",
                            "accumulate_gas": 10000,
                            "result": {
                                "ok": "0x64756d6d792d726573756c74"
                            }
                        }
                    ]
                },
                "slot": 14,
                "signatures": [
                    {
                        "validator_index": 1,
                        "signature": "0xeef064e3973b71fa4b0ce0c69c6799cc9b0e1887a894a93559a4c3a3848f039df82de95c70218588134ac51c2a329936ec54bc320b4c97c5f29f46acd1f4860e"
                    },
                    {
                        "validator_index": 4,
                        "signature": "0x68e84d7253380e8beb1fb71a54a8a0a805c06ea756da74d79bcbf5b811306cea560f27abaca175f6908ab54e4acc7bb919ab87ac616e7df106d3b043b71bac04"
                    },
                    {
                        "validator_index": 5,
                        "signature": "0x2c369533280dcd2fbdc2efeaf9dd0e042363ad14a4dee64a0f539def799f488912c85743132c5966bf5f9e65ec4d13cda5281fbbbe0c705a22e00424c858bf0b"
                    }
                ]
            },
```
  ‚Ü≥ 2024-12-10 08:26 danicuki: Do you fall into error? If so, which one?
  ‚Ü≥ 2024-12-10 11:44 celadari: image.png
  ‚Ü≥ 2024-12-10 11:44 celadari: At the moment, what is failing is equation (11.27) - GP version 0.5.2 Screenshot of the equation failing
  ‚Ü≥ 2024-12-10 11:56 celadari: At the moment, for:

- encoding of this workReport we get `0x63c03371b9dad9f1c60473ec0326c970984e9c90c0b5ed90eba6ada471ba4d86393000009fc7e637969aef1a95dfb560a914cf5161a76498db3aa19df131cea199ed6e445c9dca800c145685f052ce1ba343e2b66b4c333ee4c4ca3b29cb347b1009cb83030039cb518983b02695034b3b92cb31a7334e1a2ec3ef7dbfa32c68e4e8444363f1d8c577816b629241676502d0461e4eae42a375461314d64484f35f4228da23d671c150347dc035847d5944c864a2d3ed0fa410341b2ffbfdeeaa1c9d6aa9cacd16bda47e5a68daf53c39ddee8af4ecaced7e87f3f0ac9da5a6f4f9e41350d319060000000000009a3a97d1950356ef6d3c20acb5ab6699be454b1498ecd513bdc6d849497e42eb0000012a0000006470fd21983eae8d706f1edd5e2dc5afe095980f8fb7bd4ebfd33550d87302463cf2d09da453bbdd6b68d8a1acd5f15ba23ba46d4ff087592b3d319432500a501027000000000000001a3078363437353664366437393264373236353733373536633734`
- hash of this workReport we get `0xba11d7c078f0f4a259bae20f2d6633613c9fdf10ca7c554b7aceec94ee71847a`

- I tested all signatures with all public keysboth in current validators and previous validators.

- I'm suspecting something is off with my workReport object.
**Can you tell me what you get in hex format on your side please booth for encoding of the work report and the hash ?** [edited]
  ‚Ü≥ 2024-12-10 13:54 celadari: NEVER MIND üôÉ
error was on my side as I was parsing the test vector.

ALL GOOD NOW
2024-12-10 11:02 gav: IMG_3845.jpeg
2024-12-10 11:03 gav: Here‚Äôs a simple diagram of it. 
2024-12-10 11:04 gav: So the first proof page would be formed as p0 with h1 h2,3 and h4,7
2024-12-10 11:04 gav: The second would be p1 h0 h2,3 h4,7 
2024-12-10 11:05 gav: The fifth would be p4 h0,3 h5 h6,7
2024-12-10 11:05 gav: And so on. 
2024-12-10 11:06 gav: Each page is made up of 64 segments, each hashed with the proper prefix. This is then appended with the subtree path proof (ie the complementary nodes) from the segment root‚Äôs first child down to the root of the subtree holding the 64 segments of the page.   [edited]
2024-12-10 11:09 gav: This is enough information to form a proof of inclusion for any segment in the page given the segment root commitment. 
2024-12-10 13:26 weigen: Thanks for the clear explanation!
2024-12-10 18:12 danicuki: davxy afk:  What value are you using for G_A on the high_work_report_gas-1 test? This tests seems to be over the total gas, but no error expected in the vector. The sum in work results is 10_000_000, much above the 100_000 limit (or you are using another value for G_A). 
2024-12-10 18:37 jaymansfield: > <@danicuki:matrix.org> davxy afk:  What value are you using for G_A on the high_work_report_gas-1 test? This tests seems to be over the total gas, but no error expected in the vector. The sum in work results is 10_000_000, much above the 100_000 limit (or you are using another value for G_A). 

This might help: https://github.com/w3f/jamtestvectors/pull/20#issuecomment-2526203035
2024-12-10 19:57 celadari: Regarding work report guarantees test vectors (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/codec/data/guarantees\_extrinsic.json) => is it normal that `alpha` gets updated ? (field `"auth_pools"` is not the same in pre_state and post_state)

I ask this because I know `alpha` should be updated using `phi'` and `E_G` but it should be done after accumulation, more precisely after computing `phi'` ? [edited]
2024-12-11 00:33 celadari: I'm gonna put here a few questions I have regarding work report guarantees test vectors (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/codec/data/guarantees_extrinsic.json)
2024-12-11 00:35 celadari: - I think there might be an issue with file `full/consume_authorization_once-1.json` because test vector passes if I don't sort the hashes when computing super peak but fails if I do. However, if I refer to the GP 0.5.2 - equation (E.10) => hashes should be sorted to compute super peak
2024-12-11 00:38 celadari: I'm actually gonna post them on the github PR, might be the right place for it [edited]
2024-12-11 08:48 danicuki: I don't see anywhere in the formula that the elements should be "sorted". They need to be "consumed" in the order they are served , but not sorted [edited]
  ‚Ü≥ 2024-12-11 11:49 celadari: My bad, lack of sleep made my interpret the screenshot
as sorting them but it just means keep the same order as b
  ‚Ü≥ 2024-12-11 11:49 celadari: Capture d‚Äô√©cran du 2024-12-11 13-39-59.png
2024-12-11 08:50 dakkk: I answered 4 of 5 on gh
  ‚Ü≥ 2024-12-11 11:48 celadari: Thank you very much Davide.

Your namesake also replied and made some commits.

- I just have a doubt regarding `\nu` and `\xi` which I replied on github

  ‚Ü≥ 2024-12-11 11:58 dakkk: \nu is a \theta; btw I replied there
  ‚Ü≥ 2024-12-11 13:21 celadari: Indeed, good to know, maybe we can suggest the "standard theta" for the GP....
  ‚Ü≥ 2024-12-11 16:30 dakkk: 20241211_173025_5869733150355889156.jpg
  ‚Ü≥ 2024-12-11 16:30 dakkk: this is on my desk üòÇ [edited]
  ‚Ü≥ 2024-12-12 08:29 danicuki: > <@dakkk:matrix.org> sent an image.

Oh God! I should have this when I started to read the GP 6 months ago. 
2024-12-11 11:10 clearloop: may I ask about the progress of erasure\_coding, saw there is still a lot of TODOs in the implementation that generates the testvectors, shall we push the testvectors together or it's enough for our current stage? [edited]
2024-12-12 08:24 danicuki: About the test vectors, I would suggest to include in the post_state only the fields that are supposed to be tested. Including fields with incorrect post transition value can create confusion for us. Or explicit post somewhere else that these values should not be checked. [edited]
2024-12-12 12:50 davxy: > <@danicuki:matrix.org> About the test vectors, I would suggest to include in the post_state only the fields that are supposed to be tested. Including fields with incorrect post transition value can create confusion for us. Or explicit post somewhere else that these values should not be checked.

What do you mean with:

> include in the post_state only the fields that are supposed to be tested.

And

> Including fields with incorrect post transition value can create confusion for us. 

?
  ‚Ü≥ 2024-12-12 12:57 danicuki: Eg: in reports vectors, there are block history in pre and post state. We need to use the pre state info to transition the reports. But block history itself in post state are not changing, so there is no need to add them to post state

  ‚Ü≥ 2024-12-12 12:58 danicuki: As an implementar my assumptions Wil always be:‚Ä®Take everything from pre state, apply block, and compare my resulting full post state with the vector post state. If something differs, I did something wrong.  [edited]
  ‚Ü≥ 2024-12-12 13:00 danicuki: If some field is excluded from the post state, I become aware that I don't have to match any value for this specific field on post state. 
  ‚Ü≥ 2024-12-12 15:55 sourabhniyogi: We prefer the opposite end of this, where the pre state and post-state are exhaustive.  Its less code for all of us -- everyone can write their own difference check if they need one. [edited]
  ‚Ü≥ 2024-12-12 16:11 sourabhniyogi: The existing STF vectors have been massively beneficial for educational purposes, along with English descriptions.  

But for large scale testing, a state_transitions format (pre_state [with state_root], block, post_state [with state_root]) (in both JSON + JAM Codec form) would likely be better across all STF test vectors: 

https://github.com/jam-duna/jamtestnet/blob/main/safrole/state_transitions/407402_000.json

Is it possible to cover both needs?

  ‚Ü≥ 2024-12-12 17:55 celadari: From our perspective, having the same fields in both pre_state and post_state is the preferred option because:

- It simplifies implementation by requiring only one parser instead of two.

- It allows us to easily verify that fields expected to remain unchanged are indeed unaltered.
  ‚Ü≥ 2024-12-12 18:29 danicuki: > <@celadari:matrix.org> From our perspective, having the same fields in both pre_state and post_state is the preferred option because:
> 
> - It simplifies implementation by requiring only one parser instead of two.
> 
> - It allows us to easily verify that fields expected to remain unchanged are indeed unaltered.

How can you differentiate these two cases when a field remais the same in post state:

case (a): the STF should not change the value
case (b): the transition for that particular field is not being executed in that particular test vector

About parser, you don't need to create two parsers. If a field is missing, your parser simply ignore all inexistent fields
  ‚Ü≥ 2024-12-12 18:31 danicuki: sourabhniyogi:  I completely agree that if we had all complete fields in all pre and post state would be better. The point is that sometimes these fields are there in the post state, but with values that actually not correct if we execute the full transition.  [edited]
  ‚Ü≥ 2024-12-12 18:33 danicuki: What remains confusing to me is:
"what parts of the full STF should I run for each vector". This is not clear at all. The GP specification doesn't have a distinction between running one or other parts of the state. All state components are always changed according to pre state and block.  [edited]
  ‚Ü≥ 2024-12-12 18:36 celadari: If you go to chapter 4, part 4.2.1 *State Transition dependency Graph* it becomes clearer
  ‚Ü≥ 2024-12-12 18:37 danicuki: The dependency graph doesn't say you should "ignore" some transitions [edited]
  ‚Ü≥ 2024-12-12 18:39 celadari: What do you mean by "ignore" ?

The dependency graph says that only these state components should be used as input and only those are modified as output.

If one state component is in the input but not the ouput it means the stf doesn't change it
  ‚Ü≥ 2024-12-12 18:51 danicuki: Ok. Thanks. I will try to use the dependency graph as a guide. 
  ‚Ü≥ 2024-12-12 18:52 danicuki: I thinking we are talking about the same thing but in a different language :-D
2024-12-12 12:53 davxy: For the first statement I imagine you meant having a different struct for the posterior state? 
2024-12-12 12:54 danicuki: > <@davxy:matrix.org> For the first statement I imagine you meant having a different struct for the posterior state? 

No. Same structure
2024-12-12 12:55 davxy: So now it is even less clear. Can you elaborate? 
2024-12-12 15:00 tvvkk7: Hi, I would like to confirm the result of work report/work returned from PVM invocation. The result of the work report will be "ok" , "panic" or "oog" as in jamtestvectors ? 
The result codes of innver PVM invocation such as HALT=0  is for PVM itself ?  [edited]
2024-12-12 16:04 ycc3741: 
2024-12-12 16:08 ycc3741: davxy afk: When I used the validator from your "jam-test-vectors" library , the following error occurred. I suspect that something might be wrong: [edited]
2024-12-12 16:08 ycc3741: Ëû¢ÂπïÊì∑ÂèñÁï´Èù¢ 2024-12-13 000742.png
2024-12-12 17:34 davxy: > <@ycc3741:matrix.org> davxy afk: When I used the validator from your "jam-test-vectors" library , the following error occurred. I suspect that something might be wrong:

Are you using this fork? https://github.com/davxy/asn1tools/
2024-12-12 17:54 celadari: We believe it would be helpful to have a `miscellaneous` field that is not used for comparing `expected_post_state` and `pre_state`, but instead provides intermediary state values. This would make it easier to identify which parts failed when test vectors fail.

For example, in the case of work reports, the miscellaneous field could include guarantor assignments and previous guarantor assignments. This way, if someone encounters a failing test vector, they could check whether the issue is related to these assignments or something else.

**What is everyone opinion on that ?** [edited]
2024-12-12 18:09 sourabhniyogi: To make our own debugging life easier and to help teams compare state with others we are extending our representation of serialized (k,v) state from just

```
            [
                "0x00fe00ff00ff00ff4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b",
                "0x00000000000000000020009b0000000000808628110000002810000000281c000000287333073200140a0400fffe00000000330b24330732008b11f8711014070000fffe0000000076782033090020330a0010330b0030330c00400a09140b00e0fdfe00000000480b70b704140904e0fdfe00000000330804330a04140700e0fdfe000000000a038d77208e772078108b110832003307320021842a80540a2011110550024802282915",
            ],

            [
                "0xff00000000000000000000000000000000000000000000000000000000000000",
                "0xee4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b4bb7c7f85f60ba102700000000000064000000000000006400000000000000fb0000000000000002000000",
            ]

            [
                "0x7fc1b2006200c10015b4b5bb2060104268e1155884d8b5ab2aad3c12475c7e95",
                "0x01cfaf4b00",
            ]
```

to (k, v, type, k\_and\_v\_metadata)

```
            [
                "0x00fe00ff00ff00ff4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b",
                "0x00000000000000000020009b0000000000808628110000002810000000281c000000287333073200140a0400fffe00000000330b24330732008b11f8711014070000fffe0000000076782033090020330a0010330b0030330c00400a09140b00e0fdfe00000000480b70b704140904e0fdfe00000000330804330a04140700e0fdfe000000000a038d77208e772078108b110832003307320021842a80540a2011110550024802282915",
                "account_preimage",
                "s=0|h=0xee4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b4bb7c7f85f60ba|plen=170"
            ],

            [
                "0xff00000000000000000000000000000000000000000000000000000000000000",
                "0xee4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b4bb7c7f85f60ba102700000000000064000000000000006400000000000000fb0000000000000002000000",
                "service_account",
                "s=0|b=10000 g=100 m=100 l=251 i=2|clen=32"
            ]

            [
                "0x7fc1b2006200c10015b4b5bb2060104268e1155884d8b5ab2aad3c12475c7e95",
                "0x01cfaf4b00",
                "account_lookup",
                "s=3244470911|h=0xc4254ce54e9166133e4b84446c88bbce6d31324bbac003e7c72d39b4918a8d02 l=193 t=[4960207]|tlen=1"
            ]
```

This is valuable not merely because {s, h, ... } is "lossy" going into k, but because we can quickly reason about (really, grep for) keys, values over many states quickly.   This makes it easy for us to settle debates within our team quickly and others if we all post something similar.  Having 2 extra values in the k,v serialization is simpler than putting it in more verbose pre-serialized state representation.  We're not super wedded to any specific metadata format for the 4 service k,v - but prefer non-JSON to have simple "cut" work rather than complex json attribute extraction (so, as you can see above, |-separated, space separated, then =-separated).  What do you think about this? [edited]
  ‚Ü≥ 2024-12-12 18:26 celadari: I don't have any format preference on my side.
Only thing I would say is not to break (as much as possible) current test vectors parsers
  ‚Ü≥ 2024-12-12 18:36 sourabhniyogi: Since there aren't any test vectors outputting (k,v,type,k_and_v_metadata) yet, this should be easy.  With a 3rd and 4th value being optional except for debugging purposes, we could also have w3f test vectors be of length 2 for compactness and the 3rd and 4th optional values purely for informal debugging, similar to info! = 100  
  ‚Ü≥ 2024-12-12 18:44 sourabhniyogi: We'll post basically the above early next week as an update of these:
https://github.com/jam-duna/jamtestnet/blob/main/assurances/state\_transitions/407413\_003.json
but hope to pass the reports (with new beefy root etc) and get our 64-bit life in order, amongst signature fixes and so many other things -- fast moving targets! [edited]
2024-12-12 18:49 ycc3741: I am using this: https://github.com/w3f/jamtestvectors [edited]
2024-12-12 19:52 davxy: > <@ycc3741:matrix.org> I am using this: https://github.com/w3f/jamtestvectors

No, what I mean is that the validate.py script relies on the asn1tools Python package. You need to use the version I shared with you, as it includes some modifications compared to the upstream version.

2024-12-12 20:11 davxy: My 2 cents regarding the test vectors format discussion. As the conversation seems to be getting somewhat scattered, I suggest moving it to a dedicated GitHub issue. Personally, (of course) I believe that the current one is the best format for the moment, but that's just my opinion. Naturally, **everyone has an opinion** and this can get fuzzy fast, especially in a chat. However, I'm not sure how effective it is in this context.

I plan to finalize the collection of vectors for the different STFs using current format, as we are quite close to covering the full on-chain requirements. If we find a better format later, a switch can certainly be considered. Of course, anyone is free to propose independent vectors in other formats, as Jam Duna is already doing (although would be more beneficial to remain aligned. And that is the main purpose of the GH issue) [edited]
  ‚Ü≥ 2024-12-12 22:08 danicuki: You are doing great work with the vectors! Please, don't take any of my suggestions as complains or requirements. I trust 100% on your final judgements in doing the best for JAM implementors. And yes, any further suggestion, github issue. 
  ‚Ü≥ 2024-12-12 23:30 boymaas: Personally, I appreciate the current format, as I don‚Äôt see any advantage in changing it. Any change would involve trade-offs. The current setup works well and feels intuitive. I don‚Äôt have any suggestions for improvement that would justify the effort required (for us) to adapt to a new format.
  ‚Ü≥ 2024-12-13 05:52 clearloop: imo the current test vectors format are good enough for unit tests (test implementations separately)

apart from the unit tests, clients may need other format for integration tests ( mb for rpc or p2p ), however, even though **new formats**, I believe wrapping the current test vectors' format is the best choice for efficiency > <
2024-12-12 20:22 sourabhniyogi: > <@davxy:matrix.org> My 2 cents regarding the test vectors format discussion. As the conversation seems to be getting somewhat scattered, I suggest moving it to a dedicated GitHub issue. Personally, (of course) I believe that the current one is the best format for the moment, but that's just my opinion. Naturally, **everyone has an opinion** and this can get fuzzy fast, especially in a chat. However, I'm not sure how effective it is in this context.
> 
> I plan to finalize the collection of vectors for the different STFs using current format, as we are quite close to covering the full on-chain requirements. If we find a better format later, a switch can certainly be considered. Of course, anyone is free to propose independent vectors in other formats, as Jam Duna is already doing (although would be more beneficial to remain aligned. And that is the main purpose of the GH issue)

Awesome - which issue?  https://github.com/w3f/jamtestvectors/issues 
2024-12-13 09:03 dakkk: a new one
2024-12-13 10:55 danicuki: Good morning all!
I have doubt about a safrole vector "enact-epoch-change-with-padding-1"

My gamma\_z (epoch root) is not matching the vector's - may be something related with the zeroed offender key. From what I understood, we should zero the offender key before calculating the ring commitment root. This zero is a 32 zero bytes. Did anyone could make this vector pass?

gamma\_k (b):

```
["aa2b95f7572875b0d0f186552ae745ba8222fc0b5bd456554bfe51c68938f8bc",
"0000000000000000000000000000000000000000000000000000000000000000",
"5e465beb01dbafe160ce8216047f2155dd0569f058afd52dcea601025a8d161d",
"1ecc3686b60ee3b84b6c7d321d70d5c06e9dac63a4d0a79d731b17c0d04d030d",
"3d5e5a51aab2b048f8686ecd79712a80e3265a114cc73f14bdb2a59233fb66d0",
"7f6190116d118d643a98878e294ccf62b509e214299931aad8ff9764181a4e33"]
```
my gamma_z (doesn't match the vector):

```
81eaf0953ed7474a81fa5445616a141c4c1f54ebd3cd8bda932bf612fc7fa41a90ce8db077f4bc5a3f71336e98a57ea8a6385289d15586c18ff7f8f5661a00bb783afe07938431c77d8cccc3585612cf3461f987e01dadfec7aefbc2aa3bb31a92e630ae2b14e758ab0960e372172203f4c9a41777dadd529971d7ab9d23ab29fe0e9c85ec450505dde7f5ac038274cf
``` [edited]
2024-12-13 10:57 dakkk: you should use the bandersnatch padding point 
2024-12-13 10:58 danicuki: > <@dakkk:matrix.org> you should use the bandersnatch padding point

What is padding point? I am not aware of this? ü§î
  ‚Ü≥ 2024-12-13 11:08 danicuki: dakkk | JamPy: is this the padding point you are referring to?

‚Ä¢ Padding point in Twisted Edwards form:
‚ñ°x =26690044630372444677440308098946018389016038587388751811165279176488605875833
‚ñ°y =569559155228528470326092120674498621727733902430463954153034712442147510565
‚Äì Compressed: 0xf5399e03f2121ff4c5d33386cdc66d56a6c5132b739f753442f7bda6c7698c03
  ‚Ü≥ 2024-12-13 11:10 dakkk: idk, but when a key is invalid you should replace it with the padding point
  ‚Ü≥ 2024-12-13 11:11 danicuki: what is the padding point value?
  ‚Ü≥ 2024-12-13 11:11 dakkk: it depends on the ring size, it is not a fixed value
  ‚Ü≥ 2024-12-13 12:13 davxy: This is the padding value:

```
[Ring Padding]
X: 23942223917106120326220291257397678561637131227432899006603244452561725937075
Y: 1605027200774560580022502723165578671697794116420567297367317898913080293877
Compressed: 0xf5399e03f2121ff4c5d33386cdc66d56a6c5132b739f753442f7bda6c7698c03
```

Sorry but the one in the spec was outdated.
Now you can see the value by running the example here: 
https://github.com/davxy/bandersnatch-vrfs-spec/blob/c6288ddea8770eb81dc70b01c97b0a54fb595090/assets/example/src/main.rs#L228-L234
  ‚Ü≥ 2024-12-13 12:13 davxy: Also the spec has been updated with the new value
  ‚Ü≥ 2024-12-13 12:33 davxy: Generally, in JAM you keep Bandersnatch public keys in compressed form (i.e. 32 bytes). 
Not all 32 bytes variants represent valid points in the Bandersnatch curve. 
If you fail to deserialize it then you need to resort to the padding point. [edited]
  ‚Ü≥ 2024-12-13 12:38 davxy: E.g. the [0; 32]  array (i.e. 32 zero bytes) doesn't deserialize to a valid point.
  ‚Ü≥ 2025-03-03 16:20 decentration: regarding this situation, where it is not an offender but the key cannot be decompressed. Do we just make it a padding point, but still continue to include it in the set?

in this specfic situation, in [safrole/tiny/enact-epoch-change-with-padding-1.json](https://github.com/davxy/jam-test-vectors/blob/469018009df0e8fa7e34b105f448e6ab2db60fe3/safrole/tiny/enact-epoch-change-with-padding-1.json)

the key:

```
                "bandersnatch": "0x1ecc3686b60ee3b84b6c7d321d70d5c06e9dac63a4d0a79d731b17c0d04d030d",

```

does not seem able to be decompressed, using `ark-ec-vrfs`. [edited]
  ‚Ü≥ 2025-03-05 11:11 decentration: ah yes the updated padding points in this thread. 

 [edited]
2024-12-13 10:59 dakkk: checkhe note at the end of apx G
2024-12-13 12:30 ycc3741: Thanks a lot
2024-12-14 15:33 ycc3741: davxy afk: Hi I wonder whether we should use [this one](https://github.com/davxy/ark-ec-vrfs) or [this one](https://github.com/w3f/ring-vrf/tree/master) for singature and verification if using the vector you provide to test. [edited]
2024-12-15 01:29 jam_man: Has phase one already been submitted by teams? 
2024-12-15 06:19 davxy: https://github.com/davxy/bandersnatch-vrfs-spec [edited]
2024-12-15 07:17 clearloop: hi there! anybody feel weird about the tests cases (tiny) related to formula 11.23 (11. reporting)?

```
// formula 11.23
let (e, k) = (tau' - R) / E == (tau' / E) ? (eta'2, kappa'): (eta'3, lambda')
```

most of the test cases (tiny) are using `tau=14` in both guarantee & reports, however, `tau=14` meets the case using (`eta'3`, lambda') instead of the `eta'2` pair while the current tiny test cases are expecting the eta'2 pair to be used [edited]
2024-12-15 10:50 prematurata: AFK now but check README. `R` is different for `tiny`
2024-12-15 10:57 clearloop: yes but still...

```
let (e, k) = if (14 - 4) / 12 == 14 / 12 ? (eta_2, kappa): (eta_3, lambda)
               = if 0 == 1  ? (eta_2, kappa): (eta_3, lambda)
               = (eta_3, lambda)
```

I can pass all test vectors via ignoring `/E` but I know it is not correct ))) and if I stick to this formula over 10 test cases will get bad signature xd
2024-12-15 10:58 prematurata: will get back in afew and can check if you want.... can you name one specific test?
2024-12-15 11:00 clearloop: yes! for example https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/reports/tiny/many_dependencies-1.json
2024-12-15 14:27 prematurata: 'm using p\_eta3 as well and test is passing [edited]
  ‚Ü≥ 2024-12-15 14:28 clearloop: hmm, I'll re-check my implementation later, mb sth is wrong in my code
  ‚Ü≥ 2024-12-15 14:29 prematurata: let me know if i can help
  ‚Ü≥ 2024-12-15 15:39 clearloop: I still believe my implementation is correct ü´† will get back to this problem after finishing other stuffs
  ‚Ü≥ 2025-02-05 13:49 decentration: i see in `many\_dependencies-1.json`, that `input.slot` and `input.guarantees\[0\].slot` are both `14`, which could produce a false positive [edited]
2024-12-16 11:14 prematurata: davxy afk: can you tell me which lib you using to sign/verify bandersnatch?
  ‚Ü≥ 2024-12-16 11:40 clearloop: I believe you're looking for https://github.com/davxy/ark-ec-vrfs
  ‚Ü≥ 2024-12-16 12:08 prematurata: I am using that but only for ring related stuff
  ‚Ü≥ 2024-12-16 12:09 prematurata: Didn't see any routines to perform "standard" signatures 
  ‚Ü≥ 2024-12-16 12:45 prematurata: ok nevermind :)
2024-12-16 19:00 ycc3741: davxy afk: I want to use the w3f [Rust library](https://github.com/davxy/ark-ec-vrfs/tree/d90e1800d571f32163e6f7b5d956d065668c899f), but we‚Äôre implementing our project in Go. We‚Äôre wondering if it‚Äôs acceptable to write a Rust file to encapsulate your Rust functionality, then compile it for FFI so that we can use it in Go. What I mean is: would doing this be acceptable according to the rules, or would it violate any regulations about which implementation languages are allowed?
2024-12-16 19:25 davxy: acceptable (see rule 1 https://jam.web3.foundation/rules ) [edited]
  ‚Ü≥ 2024-12-17 04:52 clearloop: Thought we need to implement the erasure-coding as well ))
2024-12-16 19:29 ycc3741: Thanks a lot [edited]
2024-12-17 18:37 davxy: I've opened an issue to gather opinions regarding the detection of duplicate packages in the "reports" STF vectors.
https://github.com/davxy/jam-test-vectors/issues/7
2024-12-17 18:38 davxy: Mostly to properly address https://github.com/w3f/jamtestvectors/pull/28#issuecomment-2535457582
2024-12-17 18:39 davxy: Please leave your feedback directly in the GH issue. Thank you.
2024-12-17 20:03 prematurata: heads up for anyone who relied on the PR 14 to implement trie https://github.com/w3f/jamtestvectors/pull/14#issuecomment-2549423040. Although as stated in the comment the implementation makes more sense than what has been written in the Graypaper, I believe that PR is out of spec.

Also considering several implementors said they aligned with the PR provided vectors (which again is not in spec of gp) made me appreciate even more the clean room implementation rule. In this specific case the implementation was provided along with the vectors which I'd say should be discouraged.

2024-12-18 15:15 fbranciard: Hi, I have 3 questions about Core Play vision and services compositions:

1- I wonder if, in a sense, it will look like CRDT (Conflict-Free Replicated Data Type) world state. Or it will not be at this level but rather at a low level like several VMs: (start, stop, resume, VM state) with ability to communicate together through exposed APIs.

2- Another question: is Solid (from Tim Berners-Lee), separation of concerns - data, app, identity - will be a guideline in the design of Core Play?

3- Last question: I envision here https://forum.nextgraph.org/#narrow/stream/3-devs/topic/ISCC.20metadata.20on.20Document/near/776 that Jam could be a notary anchor for a Document-based system, is that correct?

2024-12-18 21:19 gav: CorePlay idea is based around actors whose memory exist within DA, but are committed to on-chain. Async and sync interaction patterns are possible via message queuing and typical async programming techniques, as well as co-scheduling. To the outside world (like developers and blockchain inspectors) it‚Äôll look a lot like a regular smart contract environment except that the contracts are actually actors and execute perpetually. I‚Äôm not knowledgable about these of TBL‚Äôs musings but given his other work cannot imagine they‚Äôre especially relevant.  [edited]
2024-12-18 21:22 gav: The forum post you link isn‚Äôt especially helpful but from what I can tell it is a DAG project without any definitive global state. JAM has global state albeit with a slightly weakened coherence compared to fully synch systems so I couldn‚Äôt imagine the architecture is comparable. 
2024-12-18 21:23 gav: CRDT has no relevance to CorePlay. 
2024-12-18 21:54 fbranciard: Thanks for the explanation, looking forward to see jam services.
2024-12-19 11:13 subotic: A heads up for those that are waiting for the 64-bit PVM test vectors. Here is my PR: https://github.com/paritytech/polkavm/pull/238 adding 64-bit test cases. Jan still needs to do the review, so no guarantees that everything is correct. Since Jan is now on his well deserved holiday break, it will be some time until this gets merge. If you have any questions or problems, don't hesitate to ask.
  ‚Ü≥ 2024-12-19 11:15 subotic: To generate the test cases, go into the `tools/spectool` directory and run `cargo run generate`
  ‚Ü≥ 2024-12-19 13:20 clearloop: btw I remember the opcode set are changed as well after 0.5.0, the exist PVM test vectors were generated with 0.4.x's opcodes XD spent a lot of time on detecting why my parser could not parse the test vectors correctly while working on it [edited]
  ‚Ü≥ 2024-12-19 15:54 prematurata: thanks for saving me the time and headache :)
  ‚Ü≥ 2024-12-19 19:06 sourabhniyogi: Wow you totally rock!
  ‚Ü≥ 2024-12-19 20:12 sourabhniyogi: May I suggest a new PR just like this going into w3f/jamtestvectors repo  but based your 64-bit update

https://github.com/w3f/jamtestvectors/pull/3/files

We can check it and report our findings in that new PR?  Thank you for this! [edited]
  ‚Ü≥ 2024-12-19 20:21 tomusdrw: https://github.com/FluffyLabs/jamtestvectors/pull/5 We've generated a bunch of 64-bit test vectors based on Ivan's PR last week. If there weren't any significant updates since then these should be valid.

Obviously, "official ones" would be good to have, but I'm sure they will come at the right time.  [edited]
  ‚Ü≥ 2024-12-19 20:22 sourabhniyogi: Spectacular!  Thank you as well!
  ‚Ü≥ 2024-12-20 13:27 sourabhniyogi: Not 100% sure but tomusdrw Ivan Subotic  here are a couple of dozen opcodes that need coverage:
```
LOAD_IMM_64 = 20 // 0x14
LOAD_I32 = 57    // 0x39
LOAD_U64 = 58    // 0x3a
STORE_IMM_IND_U64 = 73 // 0x49
STORE_IND_U64 = 113 // 0x71
LOAD_IND_I32 = 119  // 0x77
LOAD_IND_U64 = 120  // 0x78
CMOV_NZ_IMM = 138   // 0x8a
ADD_IMM_64 = 139 // 0x8b
SHLO_L_IMM_64 = 141 // 0x8d
SHLO_R_IMM_64 = 142 // 0x8e
DIV_U_64 = 183	// 0xb7
DIV_S_64 = 184	// 0xb8
REM_U_64 = 185	// 0xb9
REM_S_64 = 186	// 0xba
SHLO_L_64 = 187	// 0xbb
SHLO_R_64 = 188	// 0xbc
SHAR_R_64 = 189	// 0xbd
MUL_UPPER_S_S = 193 // 0xc1
MUL_UPPER_U_U = 194 // 0xc2
MUL_UPPER_S_U = 195 // 0xc3
CMOV_NZ = 199   // 0xc7
```

We were happy to learn that polkatool covered 64-bit smoothly and had to implement some of the new 64-bit only ones to repeat.  Also, we got to 96% coverage within a day (like 5-6 outstanding cases).  We'll sweat through the last 6 next week and report back hopefully.

  ‚Ü≥ 2024-12-20 15:19 tomusdrw: The PR just updates the spectool/assembly so it's only the existing examples, but re-generated for new opcodes. Indeed it's not covering some of the new stuff.
2024-12-19 19:01 sourabhniyogi: It appears that this MMB ref was NAYed to oblivion --   https://polkadot.polkassembly.io/referenda/1317 
What does this mean for our MMB vs MMR implementation / Beefy life?   
2024-12-19 19:17 gav: > <@sourabhniyogi:matrix.org> It appears that this MMB ref was NAYed to oblivion --   https://polkadot.polkassembly.io/referenda/1317 
> What does this mean for our MMB vs MMR implementation / Beefy life?   

Nothing.
  ‚Ü≥ 2024-12-19 19:22 sourabhniyogi: At least for now, does this imply 0.5.2's  E.2 is effectively done or should teams expect a new MMB spec to replace/augment E.2?  

It wasn't that big a deal to do E.10 here:
 https://graypaper.fluffylabs.dev/#/5b732de/39be0139be01
2024-12-19 19:27 gav: ‚ÄúAt least for now‚Äù everything is ‚Äúeffectively done‚Äù except what is on milestone 5.  [edited]
2024-12-20 05:17 sourabhniyogi: What is the expected plan for Grandpa Messages https://spec.polkadot.network/chap-networking#sect-msg-grandpa ?  
  ‚Ü≥ 2024-12-20 11:47 dave: Grandpa messages will probably be quite similar to those used by Polkadot today. We're working on this now, though I don't have an ETA for an SNP update.
2024-12-20 05:20 clearloop: May I ask if there is test data like a sequence of blocks ( from genesis ) for testing block importing? [edited]
  ‚Ü≥ 2024-12-21 03:11 sourabhniyogi: We are sharing this:
https://github.com/jam-duna/jamtestnet?tab=readme-ov-file#import-blocks
(4 sets of blocks)

Its not official but we hope you will tell us why its not perfect so we can fix it -- we have improved 10 things in it already and hope others may post something similar!
  ‚Ü≥ 2024-12-21 13:09 clearloop: we're about to author empty blocks directly now (for writing the tests of importing blocks XD), it would be interesting to see if we can verify each others' blocks! will share a docker of our binary and related docs here as well next week!
  ‚Ü≥ 2024-12-21 16:03 sourabhniyogi: Terrific!  See if you can conform to this
https://docs.jamcha.in/testing/import-blocks
for mode={fallback, safrole, assurances, ...} [we are aiming for this as well]

Note that "tiny" is:
V	6
C	2
N	3
E	12
Y	10
K	3
R	4
O	2
Q	6
as per this:

https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=615049643#gid=615049643


  ‚Ü≥ 2024-12-21 16:53 clearloop: My implementation currently just supports `tiny` since I have a handwrite jamcodec, don't want to reach the edge cases if don't have to atm üòÇ

excited about testing with other teams in the next weeks!
2024-12-20 22:24 rgekfd3e: What are the improvements in dApp UX design when using JAM instead of an EVM dApp?
  ‚Ü≥ 2024-12-21 13:35 clearloop: I don't think UX improvement could be considered in the virtual machine level, some companies promoting their new layer2s with supporting EIPs not approved in ETH mainnet is because they can't improve the UX but they want people think they are working on it (so they give people something looks convinced while people will never read one line detail of them), if they can do it, they build better DApps directly in their centralized services instead of centralizing a copy of ETH

imo the end of UX of DApps is storing users' secret keys in projects' centralized service ))
2024-12-21 13:59 gav: > <@rgekfd3e:decred.org> What are the improvements in dApp UX design when using JAM instead of an EVM dApp?

JAM is far more general a platform than EVM and doesn‚Äôt put any limitations on user-interaction directly. All of the stuff that Ethereum is trying to work around due to design limitations in its transaction model don‚Äôt apply to JAM (or, indeed, to Polkadot). 
  ‚Ü≥ 2024-12-21 19:59 sourabhniyogi: Will every day users interact with Coreplay?  
How is Coreplay related to revive vs frontier vs normal substrate pallets?
How can non-Polkadot rollups (e.g. OP Stack)  interact with Coreplay?
Is there a writeup/lecture on Coreplay?  The only thing we know of is:
https://github.com/polkadot-fellows/RFCs/blob/gav-coreplay/0000-template.md
but I imagine with Section 12 "effectively done" (??) its possible to go next level on this?
2024-12-21 16:25 wind.sixwings: signing_context_example.png
2024-12-21 16:25 wind.sixwings: When reading the GP ch6, I saw that (6.18) ~ (6.20) defined 3 Signing Contexts. I would like to ask whether these 3 Signing Contexts need to be defined by the implementation team themselves or are there other official sources of definition?

Another question raised by team members during the discussion is whether Signing Contexts are constant in most cases? Or will it be modified under certain circumstances?
  ‚Ü≥ 2024-12-21 16:56 clearloop: they are just constants, see `Appendix I.4.4`

```
# the singing context is "jam_entropy"
X_E = $jam_entropy 
```

you can verify them with the test vectors [edited]
  ‚Ü≥ 2024-12-21 17:31 wind.sixwings: So a piece of text starting with $ can be understood as a constant string. I understand, thank you.
2024-12-21 20:25 gav: Define everyday users. Define interact.
  ‚Ü≥ 2024-12-21 22:24 sourabhniyogi:  I'll give it my best shot ... üòÖ

‚ÄúEveryday users‚Äù are individuals who engage with dApps by signing transactions/extrinsics/messages using a wallet solely under their control, typically resulting in state changes to one or more chains.

To ‚Äúinteract‚Äù with one or more smart contracts (revive contract with Coreplay powers TBD) means to invoke a method they expose in order to effect those changes.

With Polkadot Hub pallet-revive deployed in 2025, everyday users will interact with revive-compiled smart contracts, yay!    There is a direct vs indirect qualification added on whether everyday users interact with JAM.   Users interact _directly_ with Polkadot Hub in that their signed extrinsics make it onto Polkadot Hub (revive or not) -- for revive, they could, if they chose, look at the material they are signing, go check out the methods in a verified revive contract and see how Solidity code map into storage changes in some Solidity contract interfaces on Etherscan PolkaVM block explorer.   But through these same interactions everyday users will _indirectly_ interact with JAM, through the JAM CoreChains service validating workpackages containing segments related to these signed extrinsics; but users will have absolutely no idea how JAM machinery works to do that -- its cognitively impenetrable except for the fellows.  This is how the "JAM services are not for everyday users _directly_" is accurate, how the "there are no transactions on JAM" makes sense, even though the bits of workpackages are _about_ them.  Did I get that right?

If Coreplay is both a JAM Service and an upgrade of pallet-revive, it would be great to have some comprehensible revision to the above ending up with "everyday users DIRECTLY interact with JAM through Coreplay/revive" that harnesses the INSANE amount of trustless supercomputing power available.  No idea what that means for the "Cloud vs Hub" vocab, and I don't want it to delay 1.0 ratification üòÖ.  But avoiding hard forks with xyz on integration/co-scheduling in prep for this supremely high impact 2.0 on the roadmap is critical?  
2024-12-21 20:28 gav: Coreplay might reasonably be an upgrade path from pallet revive. The rest of Polkadot could interact with it synchronously via co-scheduling and co-integration, or asynchronously in the usual way via XCM. Non Polkadot systems could interact using a bridge. Coreplay is an idea at present; there is no writeup or lecture.  
2024-12-21 23:10 gav: It‚Äôs not exactly an upgrade for pallet-revive but it might provide an upgrade path for whatever systems are using it. We‚Äôll have to see. 
2024-12-21 23:11 gav: Taken at your definitions then yes it would be interacted with by everyday users.  [edited]
  ‚Ü≥ 2024-12-22 15:50 sourabhniyogi: Super exciting, can't wait to see all this happen!   I'll bet I'm not the only one who would like to see a lot of investment _beyond_ the JAM Prize into CorePlay, CoreVMs, JAM Services that make JAM something that everyday users can interact with.  But your relatively rare (and honestly, grinchy, to senior people anyway) vote/comment on 1317 brought a few questions to mind.   

Questions:
1. How should JAM services, tooling, and related innovations (minor or major) be supported outside the JAM Prize between OpenGov, the fellowship funds and outside capital?   Is there some ideal allocation between these sources (of capital) and sinks (talent doing xyz innovations) that you could articulate?   

2. Does a JAM-centric collective separate from the Fellowship make sense? Or does a 2025 revision to the 1.0/Substrate-centric fellowship charter to cover JAM + JAM Services (CoreChains/CorePlay/CoreVM), PolkaVM/revive/polkatool/JAM SDK, related tools to name last 18-24 months innovations make sense instead?  

3. Latent questions related to Rule 12:  What does it mean to be a fellow who knows JAM super well but knows nothing about Substrate?  What does it mean to be a fellow who knows Substrate super well but knows nothing about JAM?  

4. Can you provide guidance on how better decision making / resource allocation to JAM/CoreXYZ/PolkaVM innovation and support should come from the general public in OpenGov especially given that the knowledge required to reason about these things is either so new (say, JAM SDK) or requires a lot of expertise (say, the effort/innovation level in MMB over MMR)?  

I believe your guidance on these types of questions generally would be valuable for everyone who want to plot a course beyond JAM implementation life for next year and beyond.
2024-12-21 23:11 gav: However I think those definitions are not especially helpful as they are so broad. 
2024-12-21 23:13 gav: That transactions get signed in a dapp is about as relevant as the fact that a TCP packet gets authored when fetching a webpage. We don‚Äôt say that people ‚Äúsend TCP packets‚Äù though.  [edited]
2024-12-22 20:33 gav: 2. As I already answered in the fellowship call a few days ago, no. 
2024-12-22 20:34 gav: 3. Not much. There are already fellows who are experts in one area and not others. 
2024-12-22 20:35 gav: 4. I don‚Äôt see all that much need for JAM development from the ‚Äúgeneral public‚Äù. It‚Äôs a complex protocol not Roblox. 
2024-12-22 20:36 gav: 1. I‚Äôve no idea beyond the obvious ‚Äúbuild it and they will come‚Äù mantra. Support of Polkadot is no different to support of JAM, since JAM will become Polkadot. Thus you may as well ask that question in the Polkadot forum but with ‚ÄúJAM‚Äù exchanged for ‚ÄúPolkadot‚Äù. No.  [edited]
2024-12-22 20:41 gav: Finally [@sourabhniyogi:matrix.org](https://matrix.to/#/@sourabhniyogi:matrix.org), please do not treat this room as a perpetual Gavin AMA. If you have something to contribute to the conversation, contribute it. If you wish to start a new topic do so. But quizzing me on non-technical, *financial* strategy is totally unacceptable and goes against the CoC. I‚Äôve already warned you of this.  [edited]
2024-12-22 20:42 gav: I thought I had already made this clear to you. Apparently not. Consider this a final warning. [edited]
  ‚Ü≥ 2024-12-23 00:58 sourabhniyogi: Apologies for all the questions, and thank you for being so accessible this year. It‚Äôs been a delight, but I can see I‚Äôve tried your patience. I‚Äôll take a break and contain my enthusiasm. Happy holidays!
2024-12-23 13:36 clearloop: as we can see in the jam-types spec, https://github.com/w3f/jamtestvectors/blob/master/jam-types-asn/jam-types.asn#L32, the bls public key has `144 bytes`, if I'm not mistaken, `bls\_12\_381` has `96 bytes` or `48 bytes` (compressed) in the public key, that this 144 bytes could be the combined version of the compressed and the uncompressed versions? if so, shall we place the compressed version ahead of the uncompressed version since it could be more frequently used? [edited]
2024-12-23 15:57 davxy: copy/paste of an old reply given in the GP chan some time ago:

The public key for the scheme consists of two public elements, each corresponding to one of the two groups used by BLS for pairing: G1 and G2. Specifically, it is represented as (g1 * sk, g2 * sk), where g1 is the generator of G1 and g2 is the generator of G2. Each point in G1 is compressed into 48 bytes, while each point in G2 is compressed into 96 bytes. This scheme allows both fast verification of aggregate signatures and (pairing less) single signature verification. The full scheme is detailed in this paper: https://eprint.iacr.org/2022/1611 and is implemented by this library: https://github.com/w3f/bls. [edited]
2024-12-25 15:37 jaymansfield: Merry Christmas everyone! As we refine and accumulate memories this season, let‚Äôs celebrate connection, innovation, and a unified vision for the future!
2024-12-25 16:29 terryhung: Hi davxy afk , 
Merry Christmas!

I want to test the data in bandersnatch_ed_sha512_ell2_ring.json via ring_vrf_verify flow.


I‚Äôd like to understand how to construct the `ring` from this data and how the Verifier should output `ring_pks_com`.

Here is the related issue I opened: https://github.com/davxy/ark-ec-vrfs/issues/39

thanks!
2024-12-26 17:17 tvvkk7: Ëû¢ÂπïÊì∑ÂèñÁï´Èù¢ 2024-12-27 011630.png
2024-12-26 17:17 tvvkk7: Hello, 

I have a problem with deserialization while implementing Eq. 6.26. I used the deserialization of Equation C.5 with l=4 to compute the result, but got different result with the testvectors. Am I using the wrong deserialization and which term of deserialization should I use? 
2024-12-27 01:55 luke_jamixir: > <@tvvkk7:matrix.org> Hello, 
> 
> I have a problem with deserialization while implementing Eq. 6.26. I used the deserialization of Equation C.5 with l=4 to compute the result, but got different result with the testvectors. Am I using the wrong deserialization and which term of deserialization should I use? 

We also used to have problems there and it turned out to be a problem with our H4(blake hash 4 bytes)
We also deserialize using l=4 so that's likely not your issue 
2024-12-27 04:00 tvvkk7: Got it!  Thanks
2025-01-01 12:03 0xjunha: Hey guys we're in JAM COMMON ERA!
2025-01-01 20:29 tvvkk7: Hello, I have a problem on slot key sequence(Eq. 6.24) and the fallback mode happens. In the condition, gamma\_s' will be updated by the F function. I got the same result using testvectors of W3F, but got different result using test data of jam-duna. I use eta\_2 in [epoch 425523\_011](https://github.com/jam-duna/jamtestnet/blob/main/fallback/state_snapshots/425523_011.json) (prior slot key sequence). I use gamma\_s' in [425523\_000](https://github.com/jam-duna/jamtestnet/blob/main/fallback/state_snapshots/425524_000.json) (posterior key slot sequence).
According to Eq. 6.24, in the first slot, gamma\_s' will be updated using eta\_1. The other slots wii be gamma\_s' = gamma\_s if e' = e. So, the result should be gamma\_s' is finally updated using eta\_1.
Is my understanding incorrect ? [edited]
2025-01-02 02:23 shwchg: the files in state_snapshots is the post_state after applying the corresponding block. If you would like to use it as the pre_state for the next block, you should use eta_0
2025-01-02 10:11 tvvkk7: Thanks a lot 
2025-01-03 09:33 vinsystems: Will JAM be able to support distributed validator technology?
2025-01-03 10:47 gav: Define "distributed validator technology"
2025-01-03 10:48 clearloop: hmm, interesting, in my implementation, the validator could be local and remote, however, I think this kind of stuff is not proper for the current stage since we need to make the network work first XD [edited]
2025-01-03 11:12 vinsystems: Basically I mean the same (or similar) approach used in Ethereum, which spreads out key management across multiple parties to reduce single points of failure.  [edited]
2025-01-03 11:46 gav: JAM makes no great requirements on how validators manage/store their secret keys, only that they provide an IPv6 endpoint and set of relevant public keys. [edited]
2025-01-03 11:47 gav: If you want to give a better definition than "will it be like Ethereum?", I'm happy to offer a more detailed commentary.
2025-01-04 04:36 jakechen: Hello, we are encountering an issue with header serialization. When the test data we use does not include epoch_mark and tickets_mark, we can correctly serialize the header data and compute the parent header hash for the next time slot using BLAKE2b-256. However, when the test data includes either epoch_mark or tickets_mark, the hash we calculate does not match the test data.
In addition to handling the discriminator encoding (Eq. C.9), does the serialization of epoch_mark and tickets_mark require any additional processing for the array data, such as epoch_mark.validators? 
We are troubleshooting using the test data files [425530_000.json](https://github.com/jam-duna/jamtestnet/blob/main/safrole/blocks/425530_000.json) and [425530_001.json](https://github.com/jam-duna/jamtestnet/blob/main/safrole/blocks/425530_001.json).
2025-01-05 11:20 gav: > <@amritj:matrix.org> In graypaper here https://graypaper.fluffylabs.dev/#/911af30/19e30019e600
> 
> It is mentioned that import spec could contain both segment root and work package hash and to distinguish between them the work package hash value are tagged 
> 
> 
> But here according to jam official codec it is just a hash: 
> 
> https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/jam-types-asn/jam-types.asn#L121
> 
> So, how do we identify, if hash is tagged or not i.e. is it a segment root or work package hash?
> 
> 
> 

There‚Äôs a proper encoding given in C.29
2025-01-05 14:58 tvvkk7: Hello, I wold like to make sure whether the condition will happen if the report is good, but the work report hash is not in the fault. As gray paper defines [good reports should be in the fault](https://graypaper.fluffylabs.dev/#/6e1c0cd/12fb0212fb02) If any good report is not in fault, do we need to take any measure like append the work report hash to fault ? [edited]
2025-01-05 14:59 tvvkk7: 
2025-01-05 18:00 gilescope: C.6 Are there any test vectors for the length encoding? Is number 12 really encoded as 0x30 as some test vectors suggest? Sorry for asking but something's not quite right and I'm soaking up a lot of time on C.6.
2025-01-06 07:15 gav: > <@tvvkk7:matrix.org> Hello, I wold like to know whether the condition will happen if the report is good, but the work report hash is not in the fault.(Eq. 10.13)  If this happens, do we need to take any measure like append the work report hash to fault ?

Best to provide a link with the gray paper reader. 
2025-01-06 07:16 gav: > <@gilescope:matrix.org> C.6 Are there any test vectors for the length encoding? Is number 12 really encoded as 0x30 as some test vectors suggest? Sorry for asking but something's not quite right and I'm soaking up a lot of time on C.6.

Which test vectors imply that?
2025-01-06 10:10 gilescope: > <@gav:polkadot.io> Which test vectors imply that?

https://github.com/w3f/jamtestvectors/blob/dc20cbce7d855974aa64301a4d952e22f277010f/safrole/tiny/skip-epoch-tail-1.json#L169 - the gamma_a is a variable length and is 12 long according to the json for the pre_state. But the byte is 0x30 when I look at the hex immediately before `11da6d1f761ddf9bdb4c9d6e5303ebd41f61858d0a5647a1a7bfe089bf921be9` in the corresponding scale file.
2025-01-06 10:26 gav: That's probably an old test vector: 0x30 is a SCALE Compact integer encoding for 12.
2025-01-06 10:28 gav: Best to use the vectors in https://github.com/w3f/jamtestvectors/pull/28
2025-01-06 10:30 xlchen: .scale is using the old/non-gp scale codec. you should reference .bin files
2025-01-06 11:29 piotrzwolinski: 
2025-01-06 11:30 piotrzwolinski: Hello JAMmers!

At Fluffy Labs, we build tools like the [Gray Paper Reader](https://graypaper.fluffylabs.dev/) and [PVM Debugger](https://pvm.fluffylabs.dev/) to support JAM development, and we‚Äôd love your feedback! üôå

üëâ Anonymous feedback: https://docs.google.com/forms/d/e/1FAIpQLSducTy9dgPd0FG0QyWH-QKuolf1Sfp8I8kI2vdkKghuu82JoA/viewform
üëâ Non-anonymous testimonial: https://docs.google.com/forms/d/e/1FAIpQLSfP2Yf0cfcb5vtaNzqJb40i-H5_gVxeTpWCLactlSmPMydxiQ/viewform

Thank you for helping us improve and support the JAM community! üöÄ
  ‚Ü≥ 2025-01-08 09:29 clearloop: Thanks for your awesome work! both of the two tools are playing important roles in our development! [edited]
2025-01-06 11:33 tvvkk7: Thanks, got it!
2025-01-08 04:19 clw0908: Hello, I have a question regarding the **codec** part in **jamtestvector**:  

I‚Äôm wondering whether the **"extrinsic_hash"** in **block.json** is calculated using [**GP-0.5.3 equations 5.4, 5.5, and 5.6**](https://graypaper.fluffylabs.dev/#/6e1c0cd/0cc6000cf200), or if it is still calculated using the older version of the function. Since the calculation method hasn't been modified for a long time, I‚Äôd like to confirm.  

[The commit that added block.json](https://github.com/w3f/jamtestvectors/commit/7a96598b7ad7d079288a0043b0240894c9a33864#diff-81e841f65f02445b042e5186d09d489695ef99a0408535e28b72ea60b2961e61) was made on **September 18, 2024**. Since then, there have been no further modifications to **"extrinsic_hash"**.  
2025-01-08 09:17 tomusdrw: > <@clw0908:matrix.org> Hello, I have a question regarding the **codec** part in **jamtestvector**:  
> 
> I‚Äôm wondering whether the **"extrinsic_hash"** in **block.json** is calculated using [**GP-0.5.3 equations 5.4, 5.5, and 5.6**](https://graypaper.fluffylabs.dev/#/6e1c0cd/0cc6000cf200), or if it is still calculated using the older version of the function. Since the calculation method hasn't been modified for a long time, I‚Äôd like to confirm.  
> 
> [The commit that added block.json](https://github.com/w3f/jamtestvectors/commit/7a96598b7ad7d079288a0043b0240894c9a33864#diff-81e841f65f02445b042e5186d09d489695ef99a0408535e28b72ea60b2961e61) was made on **September 18, 2024**. Since then, there have been no further modifications to **"extrinsic_hash"**.  

It doesn't really matter. The codec test vectors are not meant to be semantically correct. They are just testing if you can decode the data given some schema.
2025-01-08 16:08 gav: I think it'd be good to request treasury support for 2 or 3 deliberately-produced JAM (services and authorizer) SDKs, aside from the SDK produced by Parity.

The best way I see this of happening is to ask teams who have passed M1 to submit proposals for an SDK framework, giving code examples for the sort of thing their SDK would allow to write. I would then get some initial treasury funding of ~$100k, possibly just from the Fellowship Treasury. From the proposals, we could fund up to 10 teams ~$10k each to make initial prototypes of their proposals and 2 or 3 of the most promising prototypes could be further developed into proper SDKs. [edited]
2025-01-08 16:09 gav: Is there any interest from teams close to M1 to put forward such a proposal and build a prototype?
2025-01-08 17:37 jaymansfield: ima_2c6a278.png
  ‚Ü≥ 2025-01-08 18:21 clearloop: congratulations! 

btw may I ask are you queuing empty blocks or also have the transaction pool implementations as well XD
2025-01-08 17:38 jaymansfield: Happy to share a glimpse of JavaJAM‚Äôs first testnet utilizing QUIC messaging. Still a lot of tweaks to go but feels good to get to this stage.
2025-01-08 18:11 clearloop: Hi there, we just introduced a simple general testvectors runner, please feel free to try it out!

```
cargo install specjam
specjam dummy
```

https://github.com/spacejam-network/specjam [edited]
2025-01-08 21:09 gav: > <@jaymansfield:matrix.org> Happy to share a glimpse of JavaJAM‚Äôs first testnet utilizing QUIC messaging. Still a lot of tweaks to go but feels good to get to this stage.

Could you repost with a link someone other than here? Media inclusion doesn‚Äôt seem to work for me at all:(
2025-01-08 21:46 jaymansfield: > <@gav:polkadot.io> Could you repost with a link someone other than here? Media inclusion doesn‚Äôt seem to work for me at all:(

Realizing now I probably should have made it a video, but you can find the same screenshot here: https://x.com/javajamio/status/1877069057372881158?s=46&t=WteYIn3tg7gE1pCvJh1G2Q
2025-01-13 19:02 tvvkk7: Hello, I have a question about serialization.  We have to check the data types of the serialization target to choose which kind of the serialization we should use, is that right ?
All the int types should be serialized using [equation C.5](https://graypaper.fluffylabs.dev/#/579bd12/360102360102).
And only the up-down arrow serialization uses [equation C.6](https://graypaper.fluffylabs.dev/#/579bd12/365602365602) ? [edited]
2025-01-13 19:42 gav: Yes that‚Äôs right. We might see C.6 used a bit more in other parts of the protocol as time goes on but for now your reading is correct.  [edited]
2025-01-13 20:03 ycc3741: thanks a lot. We've been a bit confused for a while.
2025-01-14 17:41 yu2c: Hello, does anyone know how to join [this call](https://x.com/danicuki/status/1879180907636232527) ?
I couldn't find any public invite information
2025-01-14 17:44 dakkk: good question
2025-01-14 17:52 rustybot: > <@yu2c:matrix.org> Hello, does anyone know how to join [this call](https://x.com/danicuki/status/1879180907636232527) ?
> I couldn't find any public invite information

How was this call organized? Is there another channel dedicated to JAM that I am not aware of? I completely missed it 


2025-01-14 17:55 ycc3741: We have no idea, either.
2025-01-14 17:55 jaymansfield: Also was not aware of any meetup [edited]
2025-01-14 18:01 rustybot: It seems plenty of teams were in the loop about this meetup (https://x.com/danicuki/status/1879210677216379008?t=VCKJxGk4SEqM1uRGC0IFcA&s=19). So either I've been living under a rock, or there's a communication channel that some of us aren't privy to


2025-01-14 18:42 prematurata: I didn't know as well 
2025-01-14 18:51 oliver.tale-yazdi: It was in the JAM0 channel since it is not really canonical "Jam", just among implementors: https://matrix.to/#/!KKOmuUpvYKPcniwOzw:matrix.org?via=matrix.org&via=parity.io  
(not sure if you need an invite)
2025-01-14 19:08 yuchun: Could you invite me? thanks [edited]
2025-01-14 19:41 danicuki: The JAM0 channel was created during the Bangkok gathering. Nothing there is private, just we didn't wanted to spam the main JAM chat with conferences and meetups organization details. The meeting video will be shared with all implementors. Anyone is welcome to join.

About the twitter thread in particular, fill free to send me your blurb and X handle, and I add it to the thread.
2025-01-14 19:43 danicuki: Summary of the Meeting Outcomes:

1/ üíº Meeting Frequency: We agreed on holding monthly meetings to synchronize our efforts and tackle obstacles together. This will ensure that everyone stays updated on progress and challenges.

2/ üé• Recording Sessions: The team discussed recording our calls for transparency and sharing knowledge. These recordings will be made available privately and potentially shared publicly for broader community engagement.

3/ üóìÔ∏è Upcoming Meetup: A second JAM0 meetup is being planned in Lisbon, likely around May, coinciding with Ethereum Lisbon. This event will focus on collaboration and knowledge sharing among JAM implementers. Waiting for gav availability to define dates.

4/ üõ†Ô∏è Community Test Vectors: We emphasized the importance of developing community test vectors to streamline our testing processes. This will help ensure compatibility and foster collaboration among different implementations.

5/ üìà Milestones Discussion: Teams shared progress on their individual milestones, with special attention on the transition from the first milestone to the more complex second milestone, which involves networking and consensus mechanisms.

6/ üåç Networking Implementation: There‚Äôs a strong interest in collaborating on networking implementations across teams, ensuring that different JAM clients can communicate effectively.

7/ ü§ù Overall, the meeting reinforced our commitment to collaboration, transparency, and continuous improvement within the JAM community. Together, we aim to drive innovation and success in our projects!
2025-01-15 02:51 jay_ztc: Can someone invite me to the JAM0 channel please? Thanks!
2025-01-15 11:21 gav: I've seen a couple of proposals for JAM node RPCs:
- https://docs.jamcha.in/basics/rpc
- https://github.com/open-web3-stack/jam-rpc-spec?tab=readme-ov-file
2025-01-15 11:22 gav: The first thing I'd like to say is _Death to RPCs_! ü´£
2025-01-15 11:22 gav: In general, all JAM interaction should happen, as with `smoldot`, through an in-process (light) node. [edited]
2025-01-15 11:23 gav: However, I accept it's probably helpful to have some sort of RPC defined either for local interactions or development/debugging.
2025-01-15 11:23 gav: So, a slight critique of these two.
2025-01-15 11:24 gav: The first suffers from `jam_getServiceStorage` and, probably, `jam_getState`.
2025-01-15 11:24 gav: The `jam_getServiceStorage` RPC call, and probably the other also, are not generally implementable. [edited]
2025-01-15 11:26 gav: The protocol doesn't track inserted keys; the node would have to. This requires specialised logic and a potentially very large shadow database and removes the possibility of light-client implementations and fast-syncing. Given that block-execution will likely take a very large portion of the 6 second block time, full-syncing a chain of any significance is going to be practically impossible, doubly so if you're also having to retain a database of all inserted keys as well as everything else. [edited]
2025-01-15 11:27 gav: Otherwise the first proposal looks pretty sensible.
2025-01-15 11:29 gav: The second proposal has typos (never a good sign) and is not especially clear in meaning. In particular, `state_getKeys` and `state_getStorage` are not 100% clear on the meaning of the term "keys". If the meaning is the key as it appears in the JAM chain Merkle tree, then the calls are fine and make sense. If the meaning is the key as appearing in the `read`/`write` host-calls, then not. [edited]
  ‚Ü≥ 2025-01-15 20:31 xlchen: sorry about the typos. you might be the first reviewer of it. it is the merkle key, not the original key
  ‚Ü≥ 2025-01-15 20:31 xlchen: the idea is to expose the db directly for debugging purpose
  ‚Ü≥ 2025-01-15 20:33 xlchen: it is designed for node developers and node operators, not for end users/dapps, which as you suggested should use light clients not rpc
2025-01-15 13:36 danicuki: JAM Community Call #1 video is live: https://www.youtube.com/watch?v=ghjvdHzA1P0

2025-01-15 21:26 tomusdrw: Are there any estimates when `jam-sdk` supporting `0.5.4` opcodes will be released? Or maybe there is any way to contribute to make this happen? :)
2025-01-15 21:26 gav: Tomorrow. 
2025-01-15 21:26 gav: Actually‚Ä¶
2025-01-15 21:27 gav: Are they not already in place in the latest release from a few days ago?
2025-01-15 21:27 gav: If not then I guess it‚Äôll depend on [@jan:parity.io](https://matrix.to/#/@jan:parity.io)
2025-01-15 21:33 tomusdrw: let me double check, but afaict last release was 7 days ago and last time I checked it was producing pre-0.5.4 opcodes
2025-01-15 21:40 tomusdrw: yeah, `jam-pvm-build=0.1.9` seems to be producing a bunch of jumps initially and then a bunch of `113` instructions which used to be `STORE_IND_U64` and now is invalid.
2025-01-16 05:41 jan: We will cut a release today.
2025-01-16 10:07 danicuki: 
  ‚Ü≥ 2025-01-16 10:07 clearloop: cat input?
  ‚Ü≥ 2025-01-16 10:07 boymaas: qwer(ty)?
  ‚Ü≥ 2025-01-16 10:41 danicuki: cat input
2025-01-16 11:33 gav: polkajam-sdk v0.1.12 is released on crates.io https://docs.rs/jam-pvm-common/latest/jam\_pvm\_common/index.html [edited]
2025-01-17 18:48 danicuki: I've created an open source repo with some JAM media assets. It might be helpful to use on presentations, social media posts, etc. Contributions are welcome: https://github.com/jamixir/jam-media
2025-01-17 19:14 jaymansfield: > <@danicuki:matrix.org> I've created an open source repo with some JAM media assets. It might be helpful to use on presentations, social media posts, etc. Contributions are welcome: https://github.com/jamixir/jam-media

Thanks for this. Definitely useful.
2025-01-19 17:41 celadari: Hi everyone,

I have a question regarding the Safrole test vectors. Looking at this commit:
üîó [Commit 2d71c3f](https://github.com/davxy/jam-test-vectors/commit/2d71c3f76ac89aaf57abd892cc691841fa225c87)

I noticed that the ring root values were changed, even for test vectors without offenders.

‚ùì Can someone clarify what changed at that point in the computation of the ring root?

At the moment, we are using the following code (this part is from primitives, so I can share it here in the thread)
  ‚Ü≥ 2025-01-19 17:42 celadari: ```rust
let ring_size = public_keys.len();
    let ring_ctx = ring_context(ring_size, pcs_params_file_path)?;
    let padding_point = Public::from(ring_ctx.padding_point());

    let mut keys: Vec<Public<BandersnatchSha512Ell2>> = Vec::new();
    for key in public_keys {
        let mut cursor = Cursor::new(&key);
        let pub_key = Public::<BandersnatchSha512Ell2>::deserialize_compressed(&mut cursor)
            .unwrap_or_else(|_| padding_point);
        keys.push(pub_key);
    }


    let pts: Vec<_> = keys.iter().map(|pk| pk.0).collect();
    let verifier_key = ring_ctx.verifier_key(&pts);
    let commitment = verifier_key.commitment();

    let mut buf = Vec::new();
    commitment
        .serialize_compressed(&mut buf)
        .map_err(|_| VRFResult::SerializationError)?;

    Ok(buf)
```
  ‚Ü≥ 2025-01-19 17:51 vinsystems: Maybe [this](https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/safrole/README.md?plain=1#L23)
  ‚Ü≥ 2025-01-19 18:03 celadari: > <@vinsystems:matrix.org> Maybe [this](https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/safrole/README.md?plain=1#L23)

This is the version of ark-ec-vrfs but what changed because my code uses ark-ec-vrfs and even updating the dependency didn't do it ü•≤
  ‚Ü≥ 2025-01-19 18:17 vinsystems: Also changed [this](https://github.com/davxy/bandersnatch-vrfs-spec/blob/bdd1f4b7ccbad9227dc28c72660d438cf00b1b33/assets/example/src/main.rs#L38) data file 
  ‚Ü≥ 2025-01-19 18:42 celadari: I took the one in Davide's repo jamtestvectors but I'm gonna try tomorrow the one in this repo you pointed out
  ‚Ü≥ 2025-01-19 19:58 celadari: > <@vinsystems:matrix.org> Also changed [this](https://github.com/davxy/bandersnatch-vrfs-spec/blob/bdd1f4b7ccbad9227dc28c72660d438cf00b1b33/assets/example/src/main.rs#L38) data file 

What is the code you use to generate ring root commitment ?
  ‚Ü≥ 2025-01-20 07:56 vinsystems: ```
let ring_set: Vec<Public> = bandersnatch_keys;
let verifier = Verifier::new(ring_set);
verifier.commitment.serialize_compressed(&mut proof[..]).unwrap();
return proof;
```
  ‚Ü≥ 2025-01-21 07:13 celadari: - In my case, Verifier has only method `verify`

can you tell what is your import please for Verifier ?

- Also, shouldn't you also handle padding (array of 0 is not a valid bandersnatch curve point) ?
  ‚Ü≥ 2025-01-21 07:30 vinsystems: Im importing the bandersnatch-vrfs-spec example, the commitment method is [here](https://github.com/davxy/bandersnatch-vrfs-spec/blob/main/assets/example/src/main.rs#L120-L126)

Yes Im also handling padding and it's in the "ring\_set" vector of the above pseudocode. [edited]
  ‚Ü≥ 2025-01-21 14:00 celadari: So far that's also how we do ü§î

- do you do like this to generate the keys ?

```rust
let padding_point = Public::from(ring_ctx.padding_point());

let mut keys: Vec<Public<BandersnatchSha512Ell2>> = Vec::new();
for key in public_keys {
        let mut cursor = Cursor::new(&key);
        let pub_key = Public::<BandersnatchSha512Ell2>::deserialize_compressed(&mut cursor)
            .unwrap_or_else(|_| padding_point);
        keys.push(pub_key);
}
``` [edited]
  ‚Ü≥ 2025-01-21 20:28 vinsystems: It's something like (I didn't test it): 

```
let padding_point = Public::from(ring_ctx.padding_point());
let public_keys: [u8; 32] = bandersnatch_keys;
let mut ring_set: Vec<Public> = Vec::new();

for key in public_keys.iter() {
        let point = Public::deserialize_compressed(key)
            .unwrap_or_else(|_| padding_point);
        ring_set.push(point);
}
let verifier = Verifier::new(ring_set);
...
```


  ‚Ü≥ 2025-01-22 09:37 davxy: > <@celadari:matrix.org> So far that's also how we do ü§î
> 
> - do you do like this to generate the keys ?
> 
> ```rust
> let padding_point = Public::from(ring_ctx.padding_point());
> 
> let mut keys: Vec<Public<BandersnatchSha512Ell2>> = Vec::new();
> for key in public_keys {
>         let mut cursor = Cursor::new(&key);
>         let pub_key = Public::<BandersnatchSha512Ell2>::deserialize_compressed(&mut cursor)
>             .unwrap_or_else(|_| padding_point);
>         keys.push(pub_key);
> }
> ```

IIRC in that test you need to use the padding point twice: once for an invalid key and once for a key in the offenders list (which is zeroed out, so it becomes invalid as well). Are you using padding for both of these? IIUC you get a different ring commitment?

  ‚Ü≥ 2025-02-15 16:12 heyitsstanoagain: hi davxy I think the OP's concern (and mine too) was about unrelated test cases. E.g. I was struggling with `safrole/tiny/publish-tickets-no-mark-9.json` and only now saw that its posterior gamma\_z changed from `0x95f3...` to `0xb375...` in the mentioned commit (`2d71c3f`) I think there are no offenders in this case but something in the computation of the ring commitment has changed. [edited]
2025-01-19 19:10 danicuki: Some people noticed that the Polkadot logo used for JAM/Polkadot mix is an old version of Polkadot logo. gav Should we update it using the new one?
2025-01-19 19:12 piotrzwolinski: Hi!

We have finalized the first "official release" of the Gray Paper Reader (https://graypaper.fluffylabs.dev), which most of you probably know.

We believe this tool will serve as a living documentation resource even beyond the JAM Contest, supporting ongoing development and understanding of JAM.

To keep the Reader freely available and open-source, we‚Äôre **submitting a proposal for retroactive funding** to the Polkadot Treasury.

We‚Äôve started a discussion on Polkassembly to share details about the proposal and gather feedback: https://polkadot.polkassembly.io/post/2722. Your thoughts and questions are welcome!
2025-01-19 19:15 boymaas: Great work! ‚ù§Ô∏è I‚Äôve been using it with pleasure much appreciated.
2025-01-20 22:19 decentration: can i confirm which hashing algorithm we are using for mmr peak hashes? im assuming sha2-256 by default.

2025-01-20 22:20 dave: MMR uses Keccak, most other things use Blake2b
2025-01-22 15:48 charliewinston14: Having some difficulty finding an erasure coding library that could adhere to the GP specs. Was previously using a branch of paritytech's erasure-coding repo (branch: cheme/test_vecs) but the PR has been closed as it was non conforment.  What library are the other teams using for this?
2025-01-22 17:28 decentration: for M1, are there any conformance test vectors that we don't need to do until M2, in the davxy/jam-test-vectors repo?

or shall we pass every (tiny) test from within assurances, authorizations, disputes, history, preimages, reports, safrole, statistics...? [edited]
2025-01-22 17:38 dakkk: Take a look on this issue: https://github.com/w3f/jamtestvectors/issues/21 

I have doubt about erasure coding, since I'm not sure it is required for M1 [edited]
2025-01-22 18:01 gav: Edit: M2 is focussed on block authoring whereas M1 on block execution. The erasure coding, for example, will not be needed for M1 as it is not used in block execution.  [edited]
2025-01-22 18:03 dakkk: From what I see on the website (https://jam.web3.foundation/), M2 is focused on block authoring, 3 and 4 are focused on performances
2025-01-23 08:41 gav: > <@dakkk:matrix.org> From what I see on the website (https://jam.web3.foundation/), M2 is focused on block authoring, 3 and 4 are focused on performances

Yes indeed. Most test vectors will end up being useful for M1 but some are not relevant (such as erasure coding). In any case the actual conformance tests will be done privately and using a random fuzzer by the W3F to avoid the possibility of teams gaming their implementations to any blind spots in the published vectors. 
2025-01-23 08:43 gav: The test vectors are there as an aid only. Don‚Äôt rely on them to tell you what you should and should not implement for M1 or M2. There is no short-cut to total comprehension of the Gray Paper.  [edited]
2025-01-23 08:44 xlchen: is the confirmation test fuzzer going to be open sourced? so that we don‚Äôt need to invest too much time to integrate other fuzzers
2025-01-23 08:50 gav: The interface will be. 
2025-01-23 08:51 gav: But probably not the block-generation aspects. 
2025-01-23 08:51 gav: That would defeat the purpose. 
2025-01-23 08:58 xlchen: ok so it will be more or less the acm contest style? we submit, get some vague error message if failed, and repeat until pass?
2025-01-23 09:07 gav: Well, given that the W3F's throughput is not infinite, teams relying on this "grind" strategy will likely not get anywhere fast.
2025-01-23 09:08 gav: For failed entries we will try to add a test vector to the public repository demonstrating how the candidate failed (by giving what it should have done). This may not always be possible, but we'll do our best. [edited]
2025-01-24 12:05 jan: I have just updated the PVM test vectors here; grab them fresh from the oven here: https://github.com/w3f/jamtestvectors/pull/3

This is the biggest update yet; changes:
   * The tests now target 64-bit PVM, in alignment with GP 0.5.4. (Thanks to Ivan Subotic for helping out with these!)
   * The `trap` exit status is now called `panic` to align with the GP.
   * Added new exit status: `page-fault`; tests which previously panicked when accessing unpaged memory now generate page faults.
   * Added 106 new tests from the RISC-V test suite transpiled into PVM.

All of the tests starting with `riscv_` are ported from an external RISC-V test suite, hence they're named based on which original RISC-V instructions they were testing. I've just transpiled them to PVM (since PVM is derived from RISC-V) and left them mostly unmodified.

As always, please do let me know if there are any issues with these test vectors.
2025-01-24 12:06 boymaas: Nice! Thank you Jan Bujak 
2025-01-24 23:07 jaymansfield: > <@jan:parity.io> I have just updated the PVM test vectors here; grab them fresh from the oven here: https://github.com/w3f/jamtestvectors/pull/3
> 
> This is the biggest update yet; changes:
>    * The tests now target 64-bit PVM, in alignment with GP 0.5.4. (Thanks to Ivan Subotic for helping out with these!)
>    * The `trap` exit status is now called `panic` to align with the GP.
>    * Added new exit status: `page-fault`; tests which previously panicked when accessing unpaged memory now generate page faults.
>    * Added 106 new tests from the RISC-V test suite transpiled into PVM.
> 
> All of the tests starting with `riscv_` are ported from an external RISC-V test suite, hence they're named based on which original RISC-V instructions they were testing. I've just transpiled them to PVM (since PVM is derived from RISC-V) and left them mostly unmodified.
> 
> As always, please do let me know if there are any issues with these test vectors.

Are the instruction codes for the risc-v tests aligned with the GP?
2025-01-25 09:25 gav: Given the above message, I‚Äôd say the answer is ‚Äúyes‚Äù
2025-01-25 12:13 luke_fishman: question about  import segments:
as a guarantor i receive a work package that includes a sequence of imported data segments

I need to import and reconstruct them, by fetching 342 shards.

looking here(https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-139140-segment-shard-request)

i see that in order to fetch a shard, i need to use the erasure root

is this a mistake in the hackamd document?
should it be fetched using the segment-root?


  ‚Ü≥ 2025-01-26 11:55 dave: Not a mistake. You need to maintain a segment-root to erasure root mapping
  ‚Ü≥ 2025-01-26 14:17 luke_fishman: is the current GP version considered complete in regards to DA specs? or is there more to come?
i find it hard to follow / understand what mapping are needed to be maintained

2025-01-26 13:42 decentration: 
2025-01-26 14:18 gav: It should be unambiguous already.
2025-01-26 14:19 gav: It won‚Äôt be as nearly as easy as M1‚Äôs block-execution logic because it isn‚Äôt a simple closed-form spec, but more of a constraint-optimisation problem. 
2025-01-26 14:20 gav: That‚Äôs just the reality of block authoring as opposed to block execution. 
2025-01-26 15:57 luke_jamixir: OK, maybe it's a silly or too open ended questions, but could you shed some light please on 

1.Why is the justification for a import segment is either a segment root hash OR a work package hash
2. Why is erasure root used to fetch segments and not the segment root? 
3.being given a wp from a builder, what is the process to find its erasure root? (seems that in order to know erasure root I need to know the imports and in order to do that I need to know the erasure root) [edited]
  ‚Ü≥ 2025-01-26 17:15 dave: 1. To allow importing of recently exported segments where the builder only knows the hash of the exporting WP (not its segment root)
  ‚Ü≥ 2025-01-26 17:16 dave: 2. Because the validators providing the segment shards can verify/prove to the erasure root but not the segment root
  ‚Ü≥ 2025-01-26 17:21 dave: 3. Build bundle and exported segments, erasure code both, calculate the root from the shards as per the GP. For importing a segment you need the erasure root of the WP that exported it, not the root of the WP that is importing it, so there is no circularity there
2025-01-26 18:14 luke_jamixir: So the WP that exported it, do I get it's erasure root from the corrodponding WR (on chain, accumulated already) or? 
2025-01-26 18:54 dave: Yes, you will need to get it from the WR. The assumption is that nodes will maintain a database mapping SR to ER, which they will do by monitoring WRs that are included on chain
  ‚Ü≥ 2025-05-22 11:43 dvladco: Do we also need to keep a mapping of work-report hash to segment-root? in case the import segment is referenced by work-report hash? Also to me it looks like these dictionaries are part of the state, is there a plan to add this in the state, or is this a minor implementation detail?
2025-01-26 19:33 tomusdrw: FYI: I've built a web app to encode/decode JAM objects: https://papi.fluffylabs.dev it's a fork of an amazing papi-console, so most of the credit should go there - I just plugged in the JAM codec. Hope you'll find it useful. [edited]
2025-01-27 00:51 luke_jamixir: > <@dave:parity.io> Yes, you will need to get it from the WR. The assumption is that nodes will maintain a database mapping SR to ER, which they will do by monitoring WRs that are included on chain

Thank you [@dave:parity.io](https://matrix.to/#/@dave:parity.io) 
2025-01-27 08:59 gav: Just a friendly reminder on clean-room requirements: don‚Äôt look at other implementation‚Äôs code (and that includes PolkaVM). Doing this will compromise you and your implementation. It‚Äôs not hard to see where code is copy-pasted (and use of the world‚Äôs most powerful plagiarism device, AI, is no different).

The rules are clear: if you submit a code base with content determined to come from anywhere other than official specs, you‚Äôll likely be disqualified. 
2025-01-27 10:18 jan: To expand on what Gav wrote, in the context of PolkaVM (since that's a major piece of Parity's node implementation that is already open source and people may be tempted to look at) this should be obvious but let me explicitly state it - copying _any_ of these is not acceptable according to the rules (this list is _not_ exhaustive; these are just examples):

- PVM program blob deserialization
- instruction parsing
- interpreter implementation of what each instruction does
- exact interpreter architecture
- machine code which the recompiler generates for each instruction
- outer PVM memory map builder

It's better to err on the side of caution and not look at PolkaVM at all, but there are some thing I would find acceptable to look at/copy/contribute to as long as it's declared up front that you've looked at these things (note that this is not "official" and I'm only speaking in a purely personal capacity here, but I will defend anyone who does any of these):

- human readable disassembly pseudo code syntax (that is, the way instructions are printed out as seen in the TESTCASES.md in my PVM test vectors; there's no official way to disassemble PVM programs besides what they're named in the GP, but feel free to copy my pseudo code syntax if you like it),
- bindings to native Linux APIs (`polkavm-linux-raw` crate) and x86/AMD64 assembler (`polkavm-assembler` crate) - these are just general purpose libraries that only coincidentally live in the PolkaVM repository for convenience; the goal here is for people to become experts in the JAM protocol, and not become experts in how to write high performance x86 assemblers (which you need for a very fast recompiler, but by itself is not specific to the JAM protocol),
- high level API as shown on https://docs.rs/polkavm (this is just an interface, not an implementation; even PolkaVM's API was/is partially based on `wasmtime`'s API),
- high level techniques for implementing a fast parser or a recompiler, since it's unrealistic to expect 34 independent teams to rediscover these from scratch, especially since those are useful/used when implementing _any_ VM, not just PVM (but I emphasize the _high level_ part - just copying PolkaVM's code here is not acceptable; if there's interest eventually I'll host a workshop where I'll explain some of these independent of any particular implementation),
- the toolchain to build PVM programs (`polkavm-linker` crate, `polkavm-derive`, `polkatool`, etc.) - this takes care of translating RISC-V code to PVM; this runs offline and is not part of the GP,
- the format of the `.polkavm` blob - the on-disk format of what the toolchain emits by default; this is not part of the GP and will never be (note that this only applies to the parts of the blob that are specific to the `.polkavm` blob and are _not_ specced by the GP!),
- the format of the debug info inside of `.polkavm` blob (is not and will never be specced by the GP; this is needed to be able to debug PVM programs and it's useful for production-level VMs to support some form of debug info)

In general please use some common sense, and when in doubt please first ask. [edited]
2025-01-27 13:20 luke_fishman: > if there's interest eventually I'll host a workshop where I'll explain some of these independent of any particular implementation


just stating my interest. i would be very happy to join any workshop you may host on the topic
2025-01-27 13:21 boymaas: Good point Luke | Jamixir Would be very happy as well!
2025-01-27 17:10 yu2c: Hello, I have a question about PVM implementation. Since we chose a non-Rust language to implement the JAM protocol, I feel that using a higher-level language makes PVM implementation more challenging.
Are there any language restrictions for PVM implementation?
2025-01-27 17:11 dakkk: what do you mean with "language restrictions"?
2025-01-27 17:24 yu2c: If we choose Golang to implement the JAM protocol, does that mean our PVM implementation is also restricted to Golang? Or we can implement our PVM by Rust?
2025-01-27 17:58 gav: You are free to mix-and-match languages from the same language set. 
2025-01-27 18:01 gav: Things get complicated with mixed-language implementations from two (or more) different language sets. For this, the Fellowship and W3F will evaluate the footprint of each language in the implementation and a fractional prize may be taken from the according sets. This fraction will be *entirely* at the judges discretion.  [edited]
2025-01-27 18:02 gav: To avoid being at the mercy of such an arbitrary decision I‚Äôd suggest teams stick to a single language set. 
2025-01-27 18:19 yu2c: Clearly understood! But I have another question: 
if I use Rust for some low-level implementation of the PVM and construct the PVM's high-level part in Golang by leveraging FFI (Foreign Function Interface) from Rust to Go, would this operation potentially go beyond the single language set?

Let me broaden the question: for third-party libraries (e.g., VRF, erasure coding, ...) allowed under the JAM Prize rules, would using FFI to bridge two language sets also go beyond the single language restriction?

2025-01-27 18:36 yu2c: I understand your answer regarding FFI [here](https://matrix.to/#/!wBOJlzaOULZOALhaRh:polkadot.io/$ZjjyqHc0IAYY1QxedjEaHj_ZCJ5s02NpPbZ7am8PGUM?via=polkadot.io&via=matrix.org&via=parity.io), but I‚Äôd like to focus on the issue of language sets: would using FFI between two different language sets be considered mixed-language set implementation under the rules?


2025-01-27 18:49 gav: Language is unimportant and irrelevant for the third-party utility libraries for those portions of the logic not covered by the prize (crypto, erasure-coding, networking, ...). [edited]
2025-01-27 18:50 gav: Language only matters for that code written and submitted against the JAM Prize (commonly known as a "JAM Implementation"). [edited]
2025-01-27 18:52 gav: > if I use Rust for some low-level implementation of the PVM and construct the PVM's high-level part in Golang by leveraging FFI (Foreign Function Interface) from Rust to Go, would this operation potentially go beyond the single language set?

Yes. It would most certainly and very obviously go beyond a single language set: your implementation is using two languages! [edited]
2025-01-27 18:59 yu2c: Got it, thanks for the clarification!
2025-01-27 19:58 tomusdrw: Correct me if my take on this is wrong, but my understanding is that the interpreter preformance is pretty irrelevant anyway, since to reach anywhere near the rust implementation (for m3/m4) it will require some transpilation of PVM code to native code (compilation).
I have a pretty limited knowledge on this, but afaict compilation involves: a) bringing in something that can turn assembler into native code (most likely llvm) and just producing native code for the hardware you are running on. For languages with runtimes it will require FFI anyway and the language-of-choice can only orchestrate that process.
  ‚Ü≥ 2025-01-27 20:00 jan: You don't really want to use LLVM. Any implementation which uses LLVM would definitely not pass any of the performance tiers because JAM *requires* linear time O(n) recompilation (otherwise security of the network breaks) which LLVM cannot do.
  ‚Ü≥ 2025-01-27 20:13 jan: So there are essentially two major parts to a PVM recompiler VM implementation:

1) recompiler which will turn PVM into native machine code - technically can be done in *any* language, but will be too slow in some languages if we target performance anywhere close to what PolkaVM has; for some non-systems languages you might be able to pull it off if you use non-idiomatic code and carefully write it for performance, for some languages (Python, Ruby, etc.) it's most likely completely impossible without using another language (maybe you could pull it off with some "Python -> C" runtime/translator/whatever, but I'm not familiar with this space so I can't tell)

2) interacting with low level OS APIs to "load" and run that code and manage the VM state (using hardware for detecting page faults, etc.); this for the most part will need at least some FFI, because the required APIs are very low level and a lot of languages can't do this natively
2025-01-28 03:48 clearloop: curious about if it is possible to hit m3 with an interpreter [edited]
2025-01-28 03:50 gav: > <@clearloop:matrix.org> curious about if it is possible to hit m3 with an interpreter

Highly unlikely. 
2025-01-28 07:05 dakkk: Anyway there are various techniques to improve performance even on interpreted languages; for instance, for me using python I can rewrite critical sections of jampy using cython (which is python code translated to C and compiled)
2025-01-28 08:54 jan: Take a look at benchmarks here:

https://github.com/paritytech/polkavm/blob/master/BENCHMARKS.md#oneshot-execution-for-pinky

Compare "PolkaVM (64-bit, recompiler)" vs "PolkaVM (64-bit, interpreter)". My interpreter can still be optimized, but even if you look at state of art optimized-to-the-bone interpreters (e.g. wasm3) there's still an order of magnitude performance difference vs the recompiler.

So essentially I expect the M3 performance threshold will most likely be on the level of "a working but not necessarily optimal recompiler with okay compilation speed" and M4 to be "an optimized recompiler with high recompilation speed".
2025-01-28 18:03 sourabhniyogi: The "JAM requires linear time O(n) recompilation" has been an non-explicit (but deepseekly awesome) requirement it appears, for M3 -- check?  Can you explain what teams would be expected to do to achieve this O(n) linear compilation time, and how we could get started on this process in the next 2 months?

It would appear that once we go through the above transformation, the bulk of our [Appendix A](https://graypaper.fluffylabs.dev/#/579bd12)  PVM implementations are then expendable training wheels, save the infamous [`ecalli`](https://graypaper.fluffylabs.dev/#/579bd12/25b90025b900) (and thus as tomusdrw says, anyone's interpreter performance is in fact _irrelevant_), check?  If this is correct, we should like to understand how this ecalli / host function call process works in a post-recompilation era, soon? [edited]
  ‚Ü≥ 2025-01-29 06:52 jan: > Can you explain what teams would be expected to do to achieve this O(n) linear compilation time

I'm not really sure what there is to explain here as it should be pretty much self explanatory. The process of turning PVM into a native machine code needs to take O(n) time, that is the formula `recompilation_time = a * size_of_program + constant` must hold.

> how we could get started on this process in the next 2 months?

Write a recompiler which turns PVM bytecode into machine code in a single pass (that is, you don't go over the bytecode multiple times; you generate machine code as you read it), then write a VM that can load it and execute it.

> It would appear that once we go through the above transformation, the bulk of our Appendix A PVM implementations are then expendable training wheels

No, you want to write an interpreter first simply because recompilers are so much harder to debug. If you have a correct interpreter you can then easily crosscheck your recompiler against it. Even I wouldn't write a recompiler right off the bat and first make an interpreter.

>  If this is correct, we should like to understand how this ecalli / host function call process works in a post-recompilation era, soon?

Sorry, I don't understand this question at all. There's nothing special about ecalli nor about calling host functions?
2025-01-28 19:15 gav: > as tomusdrw says, anyone's interpreter performance is in fact irrelevant

Almost certainly correct.
2025-01-28 19:17 gav: Jan Bujak is already planning on giving talks about how to achieve a high performance O(n) recompiler. Any team interested in delivering M3 or M4 would be well-advised to pay *very* close attention.
2025-01-28 19:18 gav: It won't just be about the recompiler though. Much performance will come with optimised databases, Merklisation and networking behaviour. M4's performance tests (which have yet to be written) will be stringent.
2025-01-28 19:19 gav: M3 is intended to be somewhat less stringent but still requiring a recompiler and sensible implementations for all of the above. Obviously, some languages will need to be less optimised than others in order to get to M3.
2025-01-28 23:03 decentration: do you mean don't use AI as a tool for plagiarism, or that AI is itself plagiarism?

it is a very clear rule not to look at anything related to JAM implementation except for the GP, these two channels, the JAM videos and the conformance tests.

But what is now less clear are AI tools use. i thought it was clear when you mentioned that AI should not be used to plagiarise someone else's work, in [June 2024](vector://vector/webapp/#/room/!wBOJlzaOULZOALhaRh:polkadot.io/$aA1-kjwr08g74hQ46SpIIBajbxSFsZl_hg5RfRcWvpQ), this makes sense and is an understandable concern, hence why commits must show a timestamped path of one's own coding journey.

But it has never been mentioned that it cannot be used at all. Can you confirm? Because the "Explain" button in the Fluffy Labs GP reader, signals that it can be used, but as an obvious caveat not to be used as a tool to rearticulate someone else's work. [edited]
2025-01-28 23:16 jimboj21: Hello, I have a question regarding the MMR super peak function (GP E.10). I thought I have an understanding of how this works, but am not getting the correct output on the reporting vectors test case for this.

Lets say the input to the function is: [a, b, nil, c]
I would expect the following behavior for this example:
- empty removed, giving [a, b, c]
- msg = $peak + a + b
- msg2 = $peak + H(msg) + c
- super_peak = H(msg2)
  
Does this seem like the correct flow (i reduced the details in the example, but can elaborate on steps if needed)? I'm not understanding where I am off in my logic here but like I said I am not outputting the correct value (unless its a bug elsewhere). 

Any input is appreciated, thanks!
  ‚Ü≥ 2025-01-29 08:29 dave: This was changed in the GP recently, not sure the test vectors have been updated yet
  ‚Ü≥ 2025-01-29 08:33 dave: See https://github.com/gavofyork/graypaper/commit/f9e72d79698077a2d21075f6d5555250a7c498b8
  ‚Ü≥ 2025-01-29 08:36 prematurata: On my side they don't look like the tests have reflected the recent changes
  ‚Ü≥ 2025-01-29 15:09 jimboj21: oh my gosh this is totally it! I was so confused, reminder to self to be careful with versions üòÖ Thanks for help here
  ‚Ü≥ 2025-02-08 21:40 decentration: this is helpful thread, thanks. so to pass conformance test use "node" instead of "peak" as prefix. 
  ‚Ü≥ 2025-02-09 15:23 decentration: > <@rustybot:matrix.org> Vectors were regenerated to use "peak". Have you tried to pull the last rev?

oh no i didnt, ty üëç
2025-01-29 00:33 gav: > <@decentration:matrix.org> do you mean don't use AI as a tool for plagiarism, or that AI is itself plagiarism?
> 
> it is a very clear rule not to look at anything related to JAM implementation except for the GP, these two channels, the JAM videos and the conformance tests.
> 
> But what is now less clear are AI tools use. i thought it was clear when you mentioned that AI should not be used to plagiarise someone else's work, in [June 2024](vector://vector/webapp/#/room/!wBOJlzaOULZOALhaRh:polkadot.io/$aA1-kjwr08g74hQ46SpIIBajbxSFsZl_hg5RfRcWvpQ), this makes sense and is an understandable concern, hence why commits must show a timestamped path of one's own coding journey.
> 
> But it has never been mentioned that it cannot be used at all. Can you confirm? Because the "Explain" button in the Fluffy Labs GP reader, signals that it can be used, but as an obvious caveat not to be used as a tool to rearticulate someone else's work.

It is a slightly impetuous and controversial remark but my point was that current AI tools *are* fundamentally plagiaristic. 
2025-01-29 00:34 gav: Generally they are shallow reformulation of the work of others and usually devoid of original material.
2025-01-29 00:36 gav: We can‚Äôt really enforce the non-use of AI more than we can enforce not looking at, say, stackexchange. But if we see obvious similarities in two code bases we will assume at least one is plagiaristic. 
2025-01-29 00:37 gav: So beware of this if using ChatGPT to write your algorithms for you. 
2025-01-29 05:05 stanleyli: Hello everyone,

I just created a PR to jamtestvector, providing test vectors generated based on the definitions from the Gray Paper.
https://github.com/w3f/jamtestvectors/pull/35

I hope those interested can give them a try, and I look forward to contributing to the community
2025-01-29 07:49 dakkk: 
2025-01-29 07:50 dakkk: We talked about it in this channel in September, if I remember correctly
2025-02-03 11:08 emielsebastiaan: I found an error in testvectors for the `rem_s_64` instruction: 
https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2630619549
2025-02-03 12:35 decentration: do we have a tiny const for `L` (re: 11.34)? In GP (I.4) Values it's:

```
L = 14, 400: The maximum age in timeslots of the lookup anchor.
``` [edited]
2025-02-03 12:47 oliver.tale-yazdi: I dont think there was a value proposed for this yet, otherwise i will add it to https://docs.jamcha.in/basics/chain-spec/tiny  
We can probably calculate backwards from the toaster full spec (modulo any contraints)?
  ‚Ü≥ 2025-02-03 12:58 decentration: ah ok thanks for these docs, i think for now i can infer it from the `report_before_last_rotation` test vector
  ‚Ü≥ 2025-02-03 13:12 decentration: oh no, actually `rotation_period` = 4 is what i need for that test vector.

i just need to floor(22/4) - floor(6/4) = 4, which is greater than 1 rotation.

but for `L`, I will just use a small reasonable number, i will go with 60. [edited]
  ‚Ü≥ 2025-02-03 19:12 sourabhniyogi: If you feel industrious, consider `L` (`max_age_in_timeslots` (?)) for other networks from tiny to full ?

https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=615049643#gid=615049643


As you can see, since most of us can't afford a JAM Toaster but can afford a few hours of `small` to `large`, or non-stop `tiny` to `small`, the simple-minded approach taken thus far is to have the same constants for `tiny` through `large` as `tiny`, and the same constants for xlarge through `full` as `full`.  If anyone has a better idea, just go for it!
2025-02-03 18:11 gav: IMG_4368.jpeg
2025-02-03 18:11 gav: IMG_4367.jpeg
2025-02-03 18:11 gav: IMG_4366.jpeg
2025-02-03 18:12 gav: IMG_4365.jpeg
2025-02-03 18:12 gav: IMG_4364.jpeg
2025-02-03 18:12 gav: IMG_4363.jpeg
2025-02-03 18:12 gav: IMG_4362.jpeg
2025-02-03 18:12 gav: IMG_4361.jpeg
2025-02-03 18:12 gav: IMG_4360.jpeg
2025-02-03 18:13 gav: Some new pics on the latest state of the Toaster.
2025-02-03 18:13 gav: We now have around half of the machines delivered for phase 1 (41 of them), and should have the remaining 45 in the next 2-3 weeks. [edited]
2025-02-03 18:13 gav: The first 6 are being configured now in a temporary server room, the others will be installed and configured in the dedicated space once that's ready. 
2025-02-03 18:14 gav: They've been installing some serious heat ducts to make sure that the jacuzzi gets toasty.
2025-02-03 18:18 gav: Once phase 1 is built out and going strong we can start to think about phase two, which will see an additional 85 machines for a total of 171 machines. That will take us to our goal of 16 AMD TR cores, each with 1MB L2 cache, for each of the 1023 nodes. [edited]
2025-02-04 20:09 decentration: > <@gav:polkadot.io> They've been installing some serious heat ducts to make sure that the jacuzzi gets toasty.

nice use case üëå
2025-02-05 13:54 decentration: Do we need to enforce a particular order for the Set of Ed25519 keys, Reporters (R)? 

from gp 11.26 i believe we don't, but just checking if we need it to go beyond and conform to the order of test vector exactly. e.g. r[eports_with_dependencies-1.json](https://github.com/davxy/jam-test-vectors/blob/553ba30d80d39f892fbd74806ba21152e01bd8a5/reports/tiny/reports_with_dependencies-1.json#L337)
2025-02-05 14:09 gav: Do you have a GP link?
2025-02-05 14:10 decentration: https://graypaper.fluffylabs.dev/#/4bb8fd2/15b80015b800

i ordered from ascending validator\_index but seems test vector is slightly different [edited]
2025-02-05 14:15 gav: 11.26 only provides constraints for the items.
2025-02-05 14:16 gav: 11.25 constrains the ordering of the items.
2025-02-05 14:16 gav: (by `v`).
2025-02-05 14:26 decentration: ok ty, yes i'm ordering by v \[0,1,2,3,4,5\] but seems test vector is doing something different, i.e. \[1,0,4,5,3,2\] in reports\_with\_dependendencies-1.json, will [pr in the repo](https://github.com/davxy/jam-test-vectors/issues/15).  [edited]
  ‚Ü≥ 2025-02-05 15:11 decentration: ok i see now test vectors are ordered lexicographically and not by validator index, so i will go with that approach, ty. 
2025-02-06 13:23 clearloop: curious how many teams are now following jamnp? when will there be a stable spec for the network (p2p) implementation? will there be an official transaction sender client for testing & debugging? [edited]
  ‚Ü≥ 2025-02-06 13:53 dave: JAM-SNP is stable modulo bugs, so I assume you mean the full protocol? Don't know the answer to that. For now you should just implement SNP. The conformance testing suite will almost certainly contain networking tests. This does not exist yet though so don't really have details.
  ‚Ü≥ 2025-02-06 14:29 clearloop: I'm not pretty sure about some components of JAM-SNP so I was hoping those uncertain stuffs are not 100% required that I can hack or trim them üòÇ 
  ‚Ü≥ 2025-02-06 16:06 gav: JAM-NP is scheduled to be added as an appendix in the 0.7/0.8 series. We'll need a decent amount of Toaster-experimentation to gain some confidence that the network protocol is capable of delivering the sort of performance we need. [edited]
2025-02-07 14:45 ycc3741: Does implementing BLS Signatures require a PoPs version, or is a non-PoPs version sufficient?
2025-02-07 14:45 ycc3741: Refer to https://eprint.iacr.org/2022/1611.pdf.
2025-02-07 16:09 wind.sixwings: Is there a bls signature length defined in GP? We need to ensure that the bls signature length is consistent
2025-02-08 23:22 rustybot: > <@decentration:matrix.org> this is helpful thread, thanks. so to pass conformance test use "node" instead of "peak" as prefix. 

Vectors were regenerated to use "peak". Have you tried to pull the last rev?
2025-02-10 11:38 sourabhniyogi: Here is our open source implementation of erasure coding in Go ([Appendix H](https://graypaper.fluffylabs.dev/#/5f542d7/3c11003c1100)) with a matching [erasure coding test vector](https://github.com/w3f/jamtestvectors/pull/35):
 https://github.com/jam-duna/jamtestnet/tree/main/erasurecoding
We would love others providing bug reports on this -- once its believed to be compliant by 2+ teams, we imagine other language implementations can match.

2025-02-10 19:10 lucy_coulden: Attended the first JAM Tour session at Cambridge University which was cracking!
I have a couple of questions‚Ä¶
- how do people apply to be involved as a builder?
- I believe there are 35 official teams. Is there a list of these teams and where they are based? We are doing a big push in the US and exploring a physical footprint which may be called a JAM space and where people could go to build and be together with others in the Polkadot ecosystem.
  ‚Ü≥ 2025-02-10 20:06 jay_ztc: It's worth calling out there is a strict clean room requirement for validator implementations, love this as a long pole idea for post M5 
  ‚Ü≥ 2025-02-11 01:25 lucy_coulden: Noted and thanks Jay ‚ò∫Ô∏è
  ‚Ü≥ 2025-02-11 14:32 philip.poloczek: You can always start a team as well. There is no limit of participating teams or "officially" approved teams. The list just includes teams which made it public they formed and started working on JAM. :) [edited]
  ‚Ü≥ 2025-02-11 14:33 philip.poloczek: Not all of them might be ending up implementing all milestones or even one. It's quite the challenge after all, so everything is still up for grabs! :)
  ‚Ü≥ 2025-02-11 14:57 jay_ztc: "Artificial limit of teams"?
  ‚Ü≥ 2025-02-11 16:00 philip.poloczek: Meant to write "no artificial limiting of teams", updated my message üëçÔ∏è
2025-02-10 19:12 xlchen: you can find registered teams here https://graypaper.com/clients/
2025-02-10 21:32 ascriv: +1 for jam hacker spaces post m5 
2025-02-10 21:56 sourabhniyogi: image.png
2025-02-10 21:56 sourabhniyogi: Some JAM implementers are getting together in a "JAM0 Meetup #2" call in the next 24 hours.  If you are implementing JAM, please add this to your calendar and DM me (@sourabhniyogi) and I'll you to the "JAM0" Element channel where a meeting link will be dropped.


2025-02-10 21:59 jaymansfield: > <@sourabhniyogi:matrix.org> Some JAM implementers are getting together in a "JAM0 Meetup #2" call in the next 24 hours.  If you are implementing JAM, please add this to your calendar and DM me (@sourabhniyogi) and I'll you to the "JAM0" Element channel where a meeting link will be dropped.
> 
> 

Looking forward to meeting the other teams tomorrow!
2025-02-11 01:25 lucy_coulden: Thanks Bryan! Is there anything that lists where in the world the teams are based? [edited]
  ‚Ü≥ 2025-02-11 14:31 philip.poloczek: Hey Lucy, what's so interesting about the location is the contact not enough? This is often very rough as the teams just formed and not yet put a custom website up or anything which could inform about the teams location.
2025-02-11 01:27 lucy_coulden: 
2025-02-11 04:41 xlchen: I am not aware of any public list with team location. Some of the teams are remote / global also.
2025-02-11 12:25 alice_und_bob: can services pull in memory pages from other services?

I am asking because I wonder how separated different applications in JAM are across the service boundary. E.g. can a corechains chain's logic be based on the state of a coreplay agent? [edited]
  ‚Ü≥ 2025-02-11 13:26 bkchr: Jam doesn't know the concept of memory pages. But yeah, you can put multiple items of different services into one `WorkPackage`
  ‚Ü≥ 2025-02-11 13:52 alice_und_bob: thanks basti.

who then knows about the memory pages? is it an optional additional service? does JAM not know about the DDL?
  ‚Ü≥ 2025-02-11 13:52 bkchr: DDL?
  ‚Ü≥ 2025-02-11 13:53 alice_und_bob: distributed data lake
  ‚Ü≥ 2025-02-11 13:53 bkchr: Yes there will be a service that handles these memory pages etc 
  ‚Ü≥ 2025-02-11 13:53 bkchr: You mean the da layer? [edited]
  ‚Ü≥ 2025-02-11 13:53 gav: Yes - D3L (decentralised, distributed, data lake) is what I'm calling JAM's DA [edited]
  ‚Ü≥ 2025-02-11 13:54 alice_und_bob: I see. So JAM is like a microkernel that is completely stateless and then D3L is a service that listens to the outputs of cores and keeps it available for 28 days? [edited]
  ‚Ü≥ 2025-02-11 13:54 gav: JAM is more like the virtual hardware.
  ‚Ü≥ 2025-02-11 13:54 gav: And e.g. CorePlay would be more akin to the OS kernel which sits atop that.
  ‚Ü≥ 2025-02-11 13:55 gav: And actors in CorePlay would be the software running on the OS.
  ‚Ü≥ 2025-02-11 13:55 gav: the D3L has no concept of services. Once data it in there it's not associated with any service and thus any service may read it.
  ‚Ü≥ 2025-02-11 13:56 gav: It is temporary and immutable, which means once data is added it cannot be altered and it only lasts for a limited period of time in there (28 days) before it must be re-added. [edited]
  ‚Ü≥ 2025-02-11 13:56 alice_und_bob: and D3L as a service... who is it governed by? Is it immutable except for hardforks or is it under the control of an on-chain governance mechanism?
  ‚Ü≥ 2025-02-11 13:57 gav: Some services probably won't make much use of it since they will need to have data in some other domain-specific format (e.g. the parachains service will use Substrate's Merkle structure).
  ‚Ü≥ 2025-02-11 13:58 gav: JAM has no on-chain governance. [edited]
  ‚Ü≥ 2025-02-11 13:58 gav: It's immutable.
  ‚Ü≥ 2025-02-11 13:58 gav: It could host on-chain governance schemes of course, but they would be powerless to do anything to JAM's internal state beyond its own corner. [edited]
  ‚Ü≥ 2025-02-11 13:59 alice_und_bob: hm, Basti refers to it as a service. As in "JAM service"?
  ‚Ü≥ 2025-02-11 13:59 gav: Oh - it's not a service like that.
  ‚Ü≥ 2025-02-11 13:59 gav: Call it a feature if you like.
  ‚Ü≥ 2025-02-11 13:59 alice_und_bob: ah, so more low level. 
  ‚Ü≥ 2025-02-11 13:59 gav: Yes
  ‚Ü≥ 2025-02-11 14:01 alice_und_bob: so in theory I could co-sequence a corechain and a coreplay actor?
  ‚Ü≥ 2025-02-11 14:01 gav: Yes.
  ‚Ü≥ 2025-02-11 14:02 gav: Services' on-chain (fully synchronous and coherent) state may be read directly and more or less synchronously by other services during accumulate. They may also be read and written by the owning service during accumulate. But services cannot synchronously interact in accumulate.
  ‚Ü≥ 2025-02-11 14:02 alice_und_bob: lovely
  ‚Ü≥ 2025-02-11 14:02 alice_und_bob: thx a lot!
  ‚Ü≥ 2025-02-11 14:04 alice_und_bob: oh but so services could only compose synchronously if they have a trust-relationship?
  ‚Ü≥ 2025-02-11 14:05 gav: It makes little sense to do synchronous composition without trust. 
  ‚Ü≥ 2025-02-11 14:06 gav: You pretty much need to be able to trust that they'd do the thing you expect if you're going to interact (directly) at all. [edited]
  ‚Ü≥ 2025-02-11 14:07 gav: For synchronous composition, you need two things: 1. to establish, in Refine, some causally-entangled effects. [edited]
  ‚Ü≥ 2025-02-11 14:08 gav: 2. To enact those effects within Accumulate if and only if you're certain that the counter-party will, at some point, do the same. I call this the Integration Gate. [edited]
  ‚Ü≥ 2025-02-11 14:10 gav: Generally I'd expect that causality to be established by co-scheduling within the same Work Package, since this way you're more certain that they'll both get to the Integration Gate. It also means that both Refines have access to exactly the same information. [edited]
  ‚Ü≥ 2025-02-11 14:11 gav: It could be done over multiple Work Packages, but then you'd need to extra logic to help establish what effect the Integration Gate should really be gating for (e.g. point 1 above). [edited]
  ‚Ü≥ 2025-02-11 14:12 gav: Point 2 will likely be done through each services send the other a `transfer` message establishing that they will certainly integrate their part of the entangled effects once they receive the same message from the other side.
  ‚Ü≥ 2025-02-11 14:13 gav: A simple way of identifying the entangled effects would be the hash of the work-package, which would easily fit inside the 64 bytes of the transfer memo. [edited]
  ‚Ü≥ 2025-02-11 14:13 alice_und_bob: hm, and intuitively I would say it would create too much complexity to consider this for now
  ‚Ü≥ 2025-02-11 14:14 alice_und_bob: does this have any impact on how we look at XCMP? or is XCMP constrained to corechains?
  ‚Ü≥ 2025-02-11 14:14 gav: Well it's inherently buildable on top of what we have, and I'll probably try to write a simple service which shows it in action.
  ‚Ü≥ 2025-02-11 14:15 gav: Unclear as yet. There's a few possibilities.
  ‚Ü≥ 2025-02-11 14:15 gav: XCMP could be dropped and Hyperbridge used instead.
  ‚Ü≥ 2025-02-11 14:16 gav: Or we could expand XCMP to a JAM-wide service and make it be able to deliver messages not just into the parachains service but also into CorePlay and whatever else. [edited]
  ‚Ü≥ 2025-02-11 14:17 gav: Or we could keep it scoped as-is and potentially introduce another message-passing system specifically for inter-service messaging if it sufficiently desired.
  ‚Ü≥ 2025-02-11 14:17 gav: For short, expensive messages, we could also keep HRMP as a backup option.
2025-02-11 14:27 danicuki: JAM Call link: https://meet.google.com/edd-nixn-mps?authuser=0 . Starts in 10  minutes
2025-02-11 15:24 alice_und_bob: so to summarize this conversation, JAM is a type 1 hypervisor
2025-02-11 15:26 gav: In some sense, but it would be a bit of an odd comparison as it's not clear what the hardware on which this hypervisor runs is. [edited]
2025-02-11 15:28 gav: I think the analogy of stating that JAM is a (virtual) machine is superior, but I suppose it's reasonable to suggest that it includes elements of not only the low-level "computer" but also some functionality associated with more OS/hypervisor-level software. [edited]
2025-02-11 15:54 danicuki: Here is the link for subscription to the JAM Experience event in May. Please, subscribe only if you have high chance of coming. As it will be a free event and we need to plan foods and drinks according to number of people. 

https://lu.ma/ob0n7pdy

This link is only for JAM teams. I will create another event for the JAM Party. 
  ‚Ü≥ 2025-02-11 16:14 jay_ztc: Hi Daniel, thanks for helping organize this event! Our team isn't registered, but planning on having two in attendance. Will continue to keep tabs on event updates in the JAM0 channel. Thanks! [edited]
  ‚Ü≥ 2025-02-11 17:57 danicuki: > <@jay_ztc:matrix.org> Hi Daniel, thanks for helping organize this event! Our team isn't registered, but planning on having two in attendance. Will continue to keep tabs on event updates in the JAM0 channel. Thanks!

What is your team name? I will add it to the list. 
  ‚Ü≥ 2025-02-11 18:03 jay_ztc: Thanks! "ZTC" 
  ‚Ü≥ 2025-02-11 19:00 danicuki: > <@jay_ztc:matrix.org> Thanks! "ZTC" 

Added. You can register now! ü§ó
  ‚Ü≥ 2025-02-11 19:00 danicuki: I took the list from the official gray paper website. I suggest to open a PR to add your team there. 
  ‚Ü≥ 2025-02-11 20:01 danicuki: Please share your team / personal Twitter so I can mention on posts eventually
  ‚Ü≥ 2025-02-11 20:53 jay_ztc: Not on socials, appreciate the thought tho
2025-02-11 19:21 danicuki: For those coming to "JAM Experience" in Cascais, I highly recommend to stay a couple more days and attend to ETHLisbon. We are planning a Polkadot / JAM booth there and will probably have some funding for a Hackathon prize  for JAMers. Subscribe here:

https://lu.ma/ETH-Lisbon-2025
2025-02-11 20:05 danicuki: Today's call Highlights and video: https://x.com/danicuki/status/1889402796723609833
2025-02-12 06:15 clearloop: May I ask if the transaction pool is totally open to implement or there is sort of spec WIP?
2025-02-12 10:47 decentration: could someone confirm with me what permutation they produced in this [issue](https://github.com/davxy/jam-test-vectors/issues/18)? i cannot seem to verify the validators assignment to cores. Though i was able to pass the [w3f/jamtestvectors/shuffle](https://github.com/w3f/jamtestvectors/tree/master/shuffle) test...

https://github.com/davxy/jam-test-vectors/issues/18 [edited]
2025-02-12 15:10 gav: > <@clearloop:matrix.org> May I ask if the transaction pool is totally open to implement or there is sort of spec WIP?

There is no transaction pool. 
  ‚Ü≥ 2025-02-12 15:25 clearloop: hmm, if so, how do we pack the extrinsics to blocks )) for example the maximum number of tickets can be submitted in a single extrinsic is 16, what if my node received 20 extrinsics, then I need to sort them and get the first 16 which have better scores, if there are references from GP for this part?

also, on receiving extrinsics from other nodes, we may need to fast validate the upcoming extrinsics otherwise the node hardly can author blocks successfully once there are invalid & outdated extrinsics, besides, on waiting for finalization, we can preprocess the future extrinsics based on the predicted longest chain's state [edited]
  ‚Ü≥ 2025-02-12 15:59 oliver.tale-yazdi: Are you implying that ticket extrinsics have something to do with transactions?  
Ticket extrinsics are to acquire an authoring slot, has nothing to do with TX
  ‚Ü≥ 2025-02-12 16:00 clearloop: oh yeah I mean sort of extrinsic pool in memory comparing with db transactions, just sth handling the pending extrinsics, I have a problem about how to fast validate them before packing them into blocks & simulate state transaction, so if there is a spec for this stuff, it would save my ass [edited]
2025-02-12 15:29 dave: It looks like you are permuting the wrong thing. Please read the GP formulas that you linked carefully. The input to the permutation should look like [0, 0, 0, 1, 1, 1] for the tiny configuration.
  ‚Ü≥ 2025-02-13 10:16 decentration: ok yes i was thrown by the fisher yates shuffle passing tests, i will shuffle by cores and not validator indices, ty 
2025-02-12 15:50 gav: B5B82264-C7ED-45C8-9076-D503D932B2ED.png
2025-02-12 15:50 gav: First JAM toaster server room getting deployment. 
2025-02-12 15:51 gav: The journey is arduous 
2025-02-12 15:51 gav: 300kW of power: on. 
2025-02-12 16:03 gav: There is not a spec for this - it is largely strategy since validators get rewarded for building blocks with full and correct extrinsic data. 
2025-02-12 16:04 gav: Note that there is a limited amount of extrinsic slots and all slots are limited in terms of what they can host. So it‚Äôs less about building a pool (where we would assume some degree of fungibility). 
2025-02-12 16:05 gav: In general you‚Äôll just keep *all* reasonable extrinsic data you receive from other validators as long as it could help you build a block. 
2025-02-12 16:06 gav: There will be a sensible block-building deadline, at which point you‚Äôll use whatever extrinsic data you know about. 
2025-02-12 17:49 decentration: oh yes gotcha [edited]
2025-02-13 00:51 sourabhniyogi: For pragmatic strategy choices where GP is silent, would it be useful for JAM implementers to make these strategy choices /  parameters adjustable for users and make our (maybe singular or maybe default) choices explicit amongst ourselves?

We are aware of a dozen pragmatic strategy choices we made (e.g. when and how often to send tickets, who to ask for D3L data in what order, whether to request/verify proofs when, etc.) but maybe there are 2 dozen others that we aren't aware that we made but also could justify "strategy" specified in client implementation.  Potentially having non-GP strategy default choices could be useful, so that nodes don't receive more tickets + requests + ...  than they actually need to from other implementations.  We could add a "strategy" component to docs.jamcha.in to make these 1-3 dozen strategy choices explicit and make it clear what it means to not only have a GP-compliant implementation but a "friendly" implementation (vs overly aggressive or overly conservative \[or lazy and maybe actually non-compliant \]). [edited]
2025-02-13 00:54 xlchen: I think it will be useful to define what is considered as "bad behaivour" (e.g. sending too much requests at once) so we can all avoid doing it. The nodes that is doing the bad behaviour should get detected and banned by other peers.
2025-02-13 12:46 hanayukii: For formula (A.16) https://graypaper.fluffylabs.dev/#/5f542d7/24e30224e302
under case a = 0  the formula would be -> x / (2^-1) * (2^64 -1) and seems weird, do I understand something wrong?
2025-02-13 13:55 alice_und_bob: is the JAM Bootstrap service mentioned here ( https://hackmd.io/@polkadot/jamsdk ) the thing that Gavin referred to as CoreBoot?
2025-02-13 15:45 sourabhniyogi: yes
2025-02-13 16:25 gav: > <@hanayukii:matrix.org> For formula (A.16) https://graypaper.fluffylabs.dev/#/5f542d7/24e30224e302
> under case a = 0  the formula would be -> x / (2^-1) * (2^64 -1) and seems weird, do I understand something wrong?

No - x is always zero and since the term is multiplied by it, the result is always zero which is what we want. 
2025-02-13 16:30 gav: > For pragmatic strategy choices where GP is silent, would it be useful for JAM implementers to make these strategy choices /  parameters adjustable for users and make our (maybe singular or maybe default) choices explicit amongst ourselves?

Most important aspects of strategy (e.g. extrinsic population, selection of WPs to guarantee) should be pretty straightforward to reason about optimal behaviour. We will likely, in due course, document strategies which we feel are sensible, and behaviour which we feel is crucial to deliver. I would invite teams to document their own approaches for discussion.
2025-02-13 16:32 gav: Network protocol should, and ultimately will, document "polite" behaviour. Technically this, like all network behaviour is not about "correctness" but rather an attempt to make a mutually-beneficial connection.
2025-02-13 16:33 gav: Politeness is defined as conventionally acceptable behaviour.
2025-02-13 16:34 gav: Like all strategy, nodes are of course free to be more restrictive or permissive, but it can be very helpful to have a clear convention.
2025-02-13 19:25 harshitc286: Hello GM gm
2025-02-13 19:29 harshitc286: 1000869038.jpg
2025-02-13 19:31 harshitc286: > <@harshitc286:matrix.org> sent an image.

From IITB, JAM Tour by, 
Dr. Gavin Wood
Amazing Event! 
2025-02-14 15:27 emielsebastiaan: Gavin, 

In this new Parity blog (https://www.parity.io/blog/JAM-experience) the JAM Grid is mentioned. 

This Parity blog references an article explaining JAM Grid (by Permanence DAO: https://permanencedao.medium.com/jam-and-the-jam-grid-the-subsequent-phases-of-the-polkadot-cloud-a79f416e5ec5).

This referenced article seems to suggest that JAM Grid will have a shared security (by DOT).

1. Could you shed some light on this?
2. Do you envision JAMs in JAM Grid to have a shared security?
3. And if so, how would this (on a high level) be achieved technically?
2025-02-14 15:33 gav: This is still under ideation and there are still unsolved questions. However, the main strategy is to draw all JAMs‚Äô validators from the same set, partitioning it randomly on each epoch.  [edited]
2025-02-14 15:33 gav: With enough validators, this can be shown to keep the majority of the security. 
2025-02-14 15:35 gav: Eg two JAMs would have a single staking system which elected 2046 validators. Every epoch the two JAMs‚Äô entropy would be combined to partition those validators randomly into two sets of 1023 and those validators would take over validating on their corresponding network. 
2025-02-14 15:35 gav: Communication would be achieved between JAMs via the usual bilateral bridging. 
2025-02-14 15:36 gav: Our bridge design is light enough and there‚Äôs enough processing power and data bandwidth that we can realistically afford to bridge every pair of JAM instances. 
2025-02-14 15:37 gav: The overall security in this model sits at 20% (rather than 33% as at present), which would lower the Nakamoto coefficient by around 40%. Not ideal, but Polkadot would remain well within its current practical security bracket.  [edited]
2025-02-14 15:38 gav: This model scales very well. 
2025-02-14 15:39 gav: Even with 1000 JAMs and thus 1023,000 validators, we‚Äôd still enjoy a somewhat similar level of both security and coherence.  [edited]
2025-02-14 15:40 gav: Exactly how similar is an open question. 
2025-02-14 15:41 gav: It is conceivable that a single service could be made to scale elastically over not simply one JAM‚Äôs worth of cores but many.  [edited]
2025-02-14 15:41 emielsebastiaan: Thanks great!! This gives me something to ponder about. 
2025-02-15 11:34 davxy: sourabhniyogi: We'd like to try importing Jamduna vectors. Would it be possible to provide the genesis files from this link (https://github.com/jam-duna/jamtestnet/tree/main/chainspecs/rawkv) in binary format as well?
2025-02-15 14:46 obnty: Hello implementers, if any of you are in town at the same time as the JAM tour is happening in HK, Taipei, Beijing, Shanghai, Hangzhou, Shenzhen, please let me or milaswords know. (already in touch with JAM DUNA and New JAMneration team based in Taipei)
  ‚Ü≥ 2025-02-15 14:55 0xjunha: I'll be in HK and Shanghai (team RJAM)
2025-02-15 16:11 davxy: See also: https://github.com/jam-duna/jamtestnet/issues/71
2025-02-15 20:24 sourabhniyogi: Absolutely, will do!
  ‚Ü≥ 2025-02-16 11:58 sourabhniyogi: Is [this](https://github.com/jam-duna/jamtestnet/blob/main/chainspecs/rawkv/README.md) what you had in mind?

If not, it might be easiest if you added a single array of kv codec example [here](https://github.com/w3f/jamtestvectors/tree/master/codec/data) that matched [this](https://github.com/jam-duna/jamtestnet/blob/main/chainspecs/rawkv/genesis-tiny.json) -- then we would publish json codec state\_snapshots like [this](https://github.com/jam-duna/jamtestnet/blob/main/data/safrole/state_snapshots/5_000.bin) in the same way?

Can discuss [here](https://github.com/davxy/jam-test-vectors/issues/22#issuecomment-2661399256) instead as you see fit! [edited]
2025-02-16 19:00 davxy: As we begin testing each other's block import vectors, it might be worth establishing clearer "standards" for these vectors to help collaboration.

I think that the format adopted by [jamduna](https://github.com/jam-duna/jamtestnet/blob/main/data/safrole/state_transitions) is quite practical (and is similar to the approach taken by [javajam](https://github.com/javajamio/javajam-trace/tree/main/state_transitions)).

Furthermore, could we explore defining community-wide values for the genesis header? For additional context, see these related issues:  
- https://github.com/jam-duna/jamtestnet/issues/71  
- https://github.com/javajamio/javajam-trace/issues/2  

It might also be beneficial to document the testing genesis header and import format outcome details here: https://docs.jamcha.in/
2025-02-17 00:26 xlchen: How are we going to deal DA/erasure coding related parameters regards to small size testnets? Are we still keep the same WG=4104 and still coded it into 1023 shards but just require each validators to hold multiple shards?
2025-02-17 10:21 danicuki: I created a spreadsheet to track which teams imported blocks from each other. Feel free to edit with your own team data:

https://docs.google.com/spreadsheets/d/1JVt_1daKJWslCaP9hfggKQSN4aGuV_le0XkKcsrjXDc/edit?gid=0#gid=0
2025-02-17 12:00 gav: We‚Äôll want to keep segment size the same so yeah, increasing the number of shards stored makes most sense.  [edited]
2025-02-17 13:44 dave: For the "tiny" testnet we have 2052-byte segment shards rather than 12-byte segment shards. This results in the same 4104-byte segment size (2052\*2 = 12\*342) [edited]
2025-02-17 13:46 dave: EC produces 1 shard per validator, so 6 shards on the tiny testnet
2025-02-17 16:11 clearloop: process goes faster these days ü´† still struggling with refactoring the network part though ( was implemented with libp2p XD )
2025-02-17 16:50 alice_und_bob: MEV-related question: what determines accumulation order of core work results?
2025-02-17 18:01 davxy: Proposal for a genesis header for block import interoperability testing:

https://github.com/JamBrains/jam-docs/pull/13

I'm mostly trying to achieve "consensus" on these values to make testing easier for everyone. Please feel free to share your thoughts directly on the GH issue
2025-02-17 18:03 davxy: FWIW these are the values currently used by jamduna and polkajam for testing [edited]
2025-02-17 21:03 oliver.tale-yazdi: LGTM, hash also verifies. will merge tomorrow if no objections until then
2025-02-17 23:04 gav: > <@alice_und_bob:matrix.org> MEV-related question: what determines accumulation order of core work results?

The service. 
  ‚Ü≥ 2025-02-17 23:47 alice_und_bob: My understanding is that you can have work items from different services in one work package. 

Maybe a better way to phrase my question: how is the order determined in which work packages are processed?
  ‚Ü≥ 2025-02-18 01:40 gav: > <@alice_und_bob:matrix.org> My understanding is that you can have work items from different services in one work package. 
> 
> Maybe a better way to phrase my question: how is the order determined in which work packages are processed?

Work packages can declare a prerequisite work package. This will be enforced for accumulate ordering. Other than that, there are no ordering guarantees between WPs. Within the same WP, you get a guarantee that the different work items will execute contemporaneously. But if they are different services, they will execute independently; transfers are asynchronous and state-reads outside of the service which is executing are fixed at the state from when execution began. 
  ‚Ü≥ 2025-02-20 04:00 alice_und_bob: hm, so who decides on the ordering of the processing of work packages (or the resulting accumulations) in cases where there is no path-dependence constraining it?
  ‚Ü≥ 2025-02-20 05:37 xlchen: for parachains, we still going to have collators and it will still be collators to determine the tx order
  ‚Ü≥ 2025-02-20 05:39 xlchen: we might have super collator that is responsible for multiple parachains for sync crosschain interactions and in that case, there will be some cross chain MEV 
  ‚Ü≥ 2025-02-20 05:56 gav: > <@alice_und_bob:matrix.org> hm, so who decides on the ordering of the processing of work packages (or the resulting accumulations) in cases where there is no path-dependence constraining it?

Refine is asynchronous, stateless and really has no order. 
  ‚Ü≥ 2025-05-05 16:09 alice_und_bob: hey, coming back to this question. 

I try to understand who eventually determines to order of WP accumulation.

Let's say WPs don't define a pre-requisite other WP, is the order then determined in the accumulate stage from the leader?
  ‚Ü≥ 2025-05-05 20:08 gav: It‚Äôs determined by the service‚Äôs Accumulate logic. From JAM‚Äôs perspective there is no order. Because it doesn‚Äôt impose any kind of sequence or loop like transactive systems.  [edited]
  ‚Ü≥ 2025-05-06 08:18 alice_und_bob: so let's say there is a bunch of refined workitems/workresults that reach the service's accumulate logic with no defined order.

Is the accumulate stage eventually executed by the leader? Is it the leader who would pick an order if it is not otherwise given? [edited]
2025-02-17 23:46 sourabhniyogi: Does anyone have a  polkatool or JAM Rust SDK built "null authorizer" which matches https://x.com/the_seraya/status/1891521159209824381 that we can basically standardize on amongst ourselves
  ‚Ü≥ 2025-02-17 23:50 dave: See https://crates.io/crates/jam-null-authorizer, though I'm not sure if the build is reproducible or not, so not sure if you will get the same hash every time
  ‚Ü≥ 2025-02-18 00:04 sourabhniyogi: The latest "0.1.12" looks to have not changed in the last couple of months, thank you!  https://github.com/jam-duna/jamtestnet/blob/main/services/parity/jam-null-authorizer/src/main.rs
Will try with this again and attempt a polkatool equivalent to reduce byte count.. [edited]
  ‚Ü≥ 2025-02-18 01:26 sourabhniyogi: Did you put this null authorizer in the genesis state (alongside the bootstrap service)?  Seems natural to do so... actually, is technically there any alternative? [edited]
  ‚Ü≥ 2025-02-18 01:41 gav: Yes and no there is probably no alternative.  [edited]
2025-02-20 04:01 alice_und_bob: It's not very precise, but I am going to use this graphic today to explain the relation of Apps, Services, Work Packages and Cores today
2025-02-20 04:01 alice_und_bob: 2025-02-20 - Winning the Scalability Wars - Hack Seasons Side Event @ Consensus HK.png
2025-02-20 05:58 gav: There are a few factors regarding the order that inter-service accumulation happens for two different WPs if they don‚Äôt have any stated dependency. No one actor controls this. 
2025-02-20 06:02 gav: It depends on the guarantors, the builder at the time of reporting and the builder at the time of assurance. Builders have no direct control over ordering but they could hypothetically disregard a report or assurance-set at some cost to themselves which could (for the builder at report time) delay the WP compared to other WPs being reported at the time. 
2025-02-20 06:03 gav: Builders at assurance time don‚Äôt get the same ability - the best they can do is prevent any new WPs from becoming available and thus accumulating. 
2025-02-20 06:04 gav: > <@alice_und_bob:matrix.org> It's not very precise, but I am going to use this graphic today to explain the relation of Apps, Services, Work Packages and Cores today

Unfortunately pictures are totally broken on element/matrix right now. Is there a link?
2025-02-20 06:05 gav: It‚Äôs worth remembering that services themselves are asynchronous with regards to each other, limiting the possibility of inter-service race conditions. 
2025-02-20 06:09 mister_cole: I see the image fine. Can you see it when I post it?

2025-02-20 06:09 mister_cole: image.png
2025-02-20 06:12 gav: > <@mister_cole:matrix.org> I see the image fine. Can you see it when I post it?
> 

Nope
2025-02-20 06:13 gav: I‚Äôm on Element X which might not help. [@erin:parity.io](https://matrix.to/#/@erin:parity.io)told me there were widespread difficulties with images recently. 
  ‚Ü≥ 2025-02-20 17:29 erin: i can take another look, perhaps they've fixed something else by now [edited]
2025-02-20 17:23 dvdplas: Polkadot wiki says: "JAM will provide synchronous composability across heterogeneous services, enabling new kinds of interoperability." [edited]
2025-02-21 14:03 gav: I didn't write the wiki; someone should probably clarify it. [edited]
2025-02-21 14:04 gav: JAM certainly makes it *easier* to provide synchronous composability across services, but it does not directly offer it as a feature.
2025-02-21 14:12 dvdplas: Alright, thanks for clarifying
2025-02-21 14:12 dvdplas: Created an issue on the wiki
2025-02-21 14:16 bill: I'll ping the tech ed team to clarify ASAP. Thanks for filing an issue.
2025-02-21 14:21 decentration: 
2025-02-21 17:52 danicuki: Hey Jammers, I have bad news for us: unfortunately our JAM Experience in Cascais proposal was rejected by the events bounties committee. If you have any idea of how we can get funded, please raise your hand! I attach for your appreciation the event proposal, as well the event bounties feedback. 
  ‚Ü≥ 2025-02-21 17:52 danicuki: JAM Experience Portugal.pdf
  ‚Ü≥ 2025-02-21 17:52 danicuki: ```
Hi Daniel,  Thank you for submitting your proposal, unfortunately it has been rejected. While we think that organising events which either support the implementers or wider reach of the technology, we are of the opinion that the budget and format of the event are not fitting. Regardless, we would still like to encourage you and even assist if necessary with planning a different type of event. 

Please find our reasons for rejection below: 

1. The Events Bounty is generally not in favour of standalone large events, as it is difficult to promote them and grow an audience. The location you choose would have also been proven difficult to attract further guests on the second day. 
2. We don‚Äôt see why you would be preparing devs for ETH Lisbon in a location outside of Lisbon, especially if the conference is centered around JAM. 
3. For this amount of attendees, the approximate agenda cost of the event is too high. 
4. It is expected that proponents use the attached budget sheet separately from the document so we can properly keep track of all entries. Every line item should be in USD, as well as the final price.  
5. We are not sure what ‚Äúlook and feel‚Äù entailed in the budget sheet. 
6. There is a full production team included in the budget, but it is not clear what the purposes of their roles are. Additionally, Adlib did not do the JAM Tour, nor the Grey Paper tour, this is done by Pala Labs and they are currently on the tour with Gavin. 
7. This event feels like multiple things: connecting implementers, sharing knowledge about JAM and preparing folks for ETH Lisbon. These are each an undertaking of their own, so we would propose organising only one of these formats. Additionally, aren't there around 30 teams of implementers // cca 100 people? The events bounty would not fund all these travel costs. 
8. We know that the Palace is currently under construction and don‚Äôt know when it would be open for people to come and actually go there. 
9. If you would like assistance from us on how to format your event we would be happy to help. 
``` [edited]
  ‚Ü≥ 2025-02-21 17:54 danicuki: If you also have any idea of how I can improve the proposal, I am also open to collaboration

  ‚Ü≥ 2025-02-21 17:54 danicuki: We need to act quick, otherwise the event will be cancelled. [edited]
  ‚Ü≥ 2025-02-21 17:56 emielsebastiaan: I tend to agree. Focus on JAM implementers coordination. Do not focus on Ethereum event and audience. 
  ‚Ü≥ 2025-02-21 17:57 emielsebastiaan: Scale down and focus on what is important. Palace visit would be nice, but not an absolute necessity. 
  ‚Ü≥ 2025-02-21 18:02 danicuki: they use "head count" as a metric of success. This is the problem. We are just 30-40 

I was trying to do something more holistic 
  ‚Ü≥ 2025-02-21 18:17 danicuki: But maybe Emiel are right. I was trying to hit two rabbits with one stone and in the end missed both. I will re-structure in a more modest format
  ‚Ü≥ 2025-02-21 19:41 gav: > <@emielsebastiaan:matrix.org> Scale down and focus on what is important. Palace visit would be nice, but not an absolute necessity. 

Palace visit should be no problem at all. Just wont be an especially long stay. 
  ‚Ü≥ 2025-02-22 00:32 sourabhniyogi: Suggestion is do this for May 7+8 for \< 10K EUR

- Meeting room, 2 days + coffee breaks + dinner - Venue ‚Ç¨6,863.00
- Celebration Dinner Day 1 Food & Drinks ‚Ç¨1,476.00
- Transportation to Toaster (40 pax) Ext Travel ‚Ç¨645.00

What else do you really really need over than the above.

The JAM0 in Bangkok was ~ $11-12K (sponsored by us) for ~5 days --  the above gets us 2 days for a similar price, and probably JAM teams can meet on the 6th or the 9th on their own to connect implementations.  I'd like to believe we can to real tiny=>small stuff and have a Toaster summer plan by the end of this.

I've been amazed at how much we can quickly accomplish asynchronously with github given GP clarity, but I'm sure I'm not the only one who believes that its in part because we've met each other IRL that we are able to accomplish this.  So lets be sure to make this happen.

If it doesn't happen (sad!) [and also probably if it does], we can host a week at the end of the summer here in San Mateo California, though I imagine the total cost to all of you non-US people is way higher than just doing this type of event again in Europe. [edited]
  ‚Ü≥ 2025-02-22 11:51 danicuki: Thanks all for the feedback. We will make it happen!! Will submit a less ambitious proposal soon. 
  ‚Ü≥ 2025-02-24 09:25 danicuki: I just submitted a new proposal do the events bounty with a $18k budget. This is the budget breakdown spreadsheet. 

https://docs.google.com/spreadsheets/d/1GnWLxHMl9cj7lA3RkZMbqhH8XnVpN4nV81Xao95n\_m4/edit?usp=sharing [edited]
2025-02-21 17:54 danicuki: 
2025-02-22 00:57 gav: For Lisbon, parity office can be used. 
2025-02-22 00:58 gav: This is big enough for 50 people to work from easily and maybe up to 100 with a little creativity. 
2025-02-22 00:58 gav: Once the palace is completed then none of this will be a problem ofc:))
2025-02-22 11:55 danicuki: > <@gav:polkadot.io> This is big enough for 50 people to work from easily and maybe up to 100 with a little creativity. 

Great! Let‚Äôs do there then. I will coordinate with the office manager. 
2025-02-22 11:57 danicuki: Already started to create songs for the GP 1.0 JAM Party Playlist üéâ . https://suno.com/song/44ed243a-232a-4ed6-be05-34becd213b4e [edited]
2025-02-22 16:32 davxy: danicuki | Jamixir: , I noticed [here](https://docs.google.com/spreadsheets/d/1JVt_1daKJWslCaP9hfggKQSN4aGuV_le0XkKcsrjXDc/edit?gid=0#gid=0) that Jamixir provides test vectors. Are these vectors the same as the ones listed in this repository: https://github.com/jamixir/jamtestnet? If not, how do they differ from the ones provided by JamDuna? [edited]
2025-02-22 16:39 dakkk: > <@davxy:matrix.org> danicuki | Jamixir: , I noticed [here](https://docs.google.com/spreadsheets/d/1JVt_1daKJWslCaP9hfggKQSN4aGuV_le0XkKcsrjXDc/edit?gid=0#gid=0) that Jamixir provides test vectors. Are these vectors the same as the ones listed in this repository: https://github.com/jamixir/jamtestnet? If so, how do they differ from the ones provided by JamDuna?

You should use the branch called "jamixir"
2025-02-22 20:45 junger0x: Hi, it's J√ºnger from Taiko, a based rollup on Ethereum. I want to analyse JAM for Ethereum perspective for potential new designs. what are the best sources other than the whitepaper?
2025-02-22 20:46 gav: There is no white paper - just the graypaper:)
2025-02-22 20:46 junger0x: Yeah, you're right üòÜ
2025-02-22 20:46 gav: But that is really the best and only proper source 
2025-02-22 20:47 gav: I‚Äôve done some talks on it and the one I consider the best (Taipei last week) will be published in the next day or two. For a basic introduction to its premise this would be a good start. 
2025-02-22 20:48 gav: There are some overviews that people have written; you can find many of these linked on graypaper.com [edited]
2025-02-22 20:48 gav: But they‚Äôre not always up to date, complete or even correct. 
2025-02-22 20:49 gav: The graypaper is the definitive resource for doing any kind of rational analysis. 
2025-02-22 20:52 junger0x: Let me get my hands dirty with greypaper then. Thanks for the answers Gavin. 
2025-02-22 20:53 gav: Have fun!:)
2025-02-23 15:01 oliver.tale-yazdi: https://x.com/jam\_brains/status/1893662855334965306  

We went ahead with this idea from sourabhniyogi on adding an RPC for STF validation [edited]
2025-02-23 15:02 oliver.tale-yazdi: Let us know how helpful this is with validating your STF vectors. Currently our validation logic is probably too lenient, so some invalid blocks will import, but no valid block should be rejected. [edited]
2025-02-24 10:45 danicuki: We are still working to setup for the JAM Experience May/25 event in Lisbon. I would ask you please to subscribe [here](https://lu.ma/ob0n7pdy) if you plan to come. This is very **important**, so we can plan better with the approximate number of people.

As suggested by gav , we will make the event at the Parity's office in Lisbon, less complex and more affordable. [edited]
2025-02-25 14:57 danicuki: Trying to understand the flow of information from end-user to blockchain state in JAM, I created this "step-by-step" doc. I am still not 100% sure it is accurate, so any feedback is very welcome:

https://hackmd.io/@w_7Gu9yjR4q8dsYR89m4OA/ryIwYLj5kl
  ‚Ü≥ 2025-02-25 14:59 dvdplas: Amazing!
  ‚Ü≥ 2025-02-25 16:26 vinsystems: Interesting article Daniel üëå after reading it I have a (maybe very basic) question: What kind of nodes running different software interact with Jam? My understanding is:

Guarantors: nodes running "Jam".
Validators: nodes running "validator software".
Auditors: nodes running "auditor software".
Data Lake: Nodes running "data lake software" [edited]
  ‚Ü≥ 2025-02-25 16:34 danicuki: I believe JAM is the amalgamation of all these roles. Most JAM implementers are creating nodes capable of running all this node roles in the same box. I don't know if it will be economically interesting for anyone run only partially
  ‚Ü≥ 2025-02-26 14:12 olanod: Thanks for the write up! As a service implementer that might not go through the details of the gray paper it helps to understand the different flows at a higher level. 
So Guarantors are the ones running the whole refine/accumulate pipeline in the code of the service the work package is referencing? or just refine ? it says guarantors run computation off-chain so no accumulate? sorry if it's stupid but I'm still trying to understand different concepts and draw a parallel with what I thought I understood from the refine/accumulate process. Is the off-chain code run by a Guarantor receiving a work package run only once? or does it need to be deterministic to be re-executed by other Guarantors or other actors?
  ‚Ü≥ 2025-02-26 14:49 gav: > <@olanod:virto.community> Thanks for the write up! As a service implementer that might not go through the details of the gray paper it helps to understand the different flows at a higher level. 
> So Guarantors are the ones running the whole refine/accumulate pipeline in the code of the service the work package is referencing? or just refine ? it says guarantors run computation off-chain so no accumulate? sorry if it's stupid but I'm still trying to understand different concepts and draw a parallel with what I thought I understood from the refine/accumulate process. Is the off-chain code run by a Guarantor receiving a work package run only once? or does it need to be deterministic to be re-executed by other Guarantors or other actors?

These are protocol-level distinctions. They are not service-provider-level distinctions. Validators must have the capability of being a block author, guarantor, assurer and auditor. They must not be separated. 
  ‚Ü≥ 2025-02-26 15:53 danicuki: The off-chain (refine) code is executed by 2 other validators (3 in total: remember off-chain code runs only on cores and each core has 3 validators). 
  ‚Ü≥ 2025-02-26 16:30 danicuki: correcting: ~32 validators, including auditors: https://matrix.to/#/!wBOJlzaOULZOALhaRh:polkadot.io/$NZiNFgDQ172zoOlcyvrAZ4zyj1OW4DeDVfkV7UUOvDI?via=polkadot.io&via=matrix.org&via=parity.io
  ‚Ü≥ 2025-02-26 17:32 dave: I've made some comments. There seems to be some confusion as to how WP execution is verified. Not sure if there is a good summary of this anywhere.
  ‚Ü≥ 2025-02-26 18:44 danicuki: thank you so much! Will apply some corrections based on your comments.


2025-02-25 15:02 ascriv: Only going if there are jam themed snacks 
  ‚Ü≥ 2025-02-25 15:03 danicuki: good idea! Let's make it a reality
2025-02-26 12:44 gav: It certainly shouldn‚Äôt be - if it is then it‚Äôs a protocol flaw. 
2025-02-26 15:59 gav: Actually executed by an average of about 32 validators. 
2025-02-26 16:00 gav: Between guaranteeing and auditing. 
2025-02-26 16:16 danicuki: Does auditing run full execution? I understood that auditors perform a more selective verification rather than executing the full computation of every work package
2025-02-26 16:20 dave: Guaranteeing and auditing do almost the same work, in particular they "fully execute" the refine function
2025-02-26 16:22 dave: One difference between the two is that guarantors fetch imported segments from DA directly, whereas auditors fetch these as part of the work-package "bundle"
2025-02-26 16:23 dave: And obviously guarantors receive the work-package and extrinsic data from builders or other guarantors on the same assignment, whereas auditors fetch this data from DA (though in the full network protocol there will likely be a "fast path" for fetching this data from the guarantors)
2025-02-26 18:42 jay_ztc: Does it make sense to enforce static branch/jmp target validations during program initialization? Or should we assemble & execute regardless?
  ‚Ü≥ 2025-02-26 18:45 jay_ztc: I'm leaning on the side of stricter program initialization validations, assuming most pvm compilers will protect against generating this sort of flawed bytecode. Curious to hear the groups thoughts. [edited]
  ‚Ü≥ 2025-02-26 18:51 jay_ztc: better not to "burn" the gas executing the valid parts of a program that we know has some invalid instructions that might be triggered? [edited]
  ‚Ü≥ 2025-02-26 20:50 xlchen: I think it is unnecessary. people shouldn‚Äôt upload bad program at first place and if they did, well, why save cost for them with trade off of more overhead for everyone else?
  ‚Ü≥ 2025-02-26 21:38 jay_ztc: I'm not sure it would be more overhead actually... If anything, I imagine it would be less overhead to validate at assemble-time. Validate once at assemble-time vs every time the instruction is called right?
  ‚Ü≥ 2025-02-26 21:39 dave: As long as behaviour is as specified in the GP it doesn't really matter how you implement it. Of course there will be minimum performance requirements, but if you think you can implement optimisations to go faster than this then great
  ‚Ü≥ 2025-02-26 21:44 jay_ztc: Throwing panic/error at assemble-time would be a different result than running the buggy bytecode right? I'm assuming the consensus would be different between these two approaches. Gas deducted comes to top of mind.
  ‚Ü≥ 2025-02-26 21:48 dave: Sure, that just means you can't throw an error at assembly time. It doesn't mean you can't optimise the generated assembly according to this static analysis, for example omitting a runtime check if you have checked at assembly time.
  ‚Ü≥ 2025-02-26 21:50 dave: If you think the specification in the GP should be changed, then feel free to make your case in the Gray Paper channel
  ‚Ü≥ 2025-02-26 21:51 jay_ztc: good point, I think the original question still stands though
  ‚Ü≥ 2025-02-26 21:52 jay_ztc: Yep, good callout. Was thinking I'd get peoples thoughts here first, since this isn't explicitly addressed in the GP.
  ‚Ü≥ 2025-02-26 21:53 dave: The GP in general won't say how something should be implemented, it just defines the observable behaviour
  ‚Ü≥ 2025-02-26 21:53 dave: Are you saying the observable behaviour is not completely specified in some case?
  ‚Ü≥ 2025-02-26 21:59 jay_ztc: this is what I'm looking to gather thoughts on. GP can be discussed in the GP channel separately
  ‚Ü≥ 2025-02-27 05:12 gav: I think you might get a better response if you put forward a concrete proposal for change to the GP together with an argument for it. [edited]
  ‚Ü≥ 2025-02-27 07:24 jan: That's not how it works. A proper recompiler (and a well written non-naive interpreter) won't "validate every time the instruction is called"; it recompiles a piece of code once, and that's it.

There are roughly two strategies you can have:

1) Recompile the whole program ahead of time.
2) Recompile parts of the program just-in-time as they're executed.

Whether you reject programs with "invalid" bytecode (whichever way you define "invalid") has absolutely no bearing on whether you can do (1), but it prevents you from being able to do (2).

So while we're planning to essentially assume (1) in our gas cost model so far I've designed it so that the implementation has the flexibility to implement (2) and still be compliant (such an execution mode could be useful in certain cases, e.g. you have a huge program blob and you want to only execute a tiny chunk of it), and this means that you cannot require an O(n) pass to validate the program.
  ‚Ü≥ 2025-02-27 07:56 jay_ztc: Thanks for sharing your thoughts in such a detailed response Jan Bujak . The design background provides great clarity as well. I had in mind something similar to the 2nd approach, but combined with jmp table validations that could be done using the bitmask- lighter weight than parsing out the whole program up front. But I missed that the invalid target resolutions could be done as part of the JIT design as well. I'm leaning towards the opinion of leaving this flexibility as-is in the spec given your points, especially since this type of program bug should be something caught in the process of compiling into pvm bytecode anyways. [edited]
  ‚Ü≥ 2025-02-27 19:24 jay_ztc: Jan Bujak: are you accepting PRs to your pvm testvec repo? I modified a few of the existing branch/jmp vectors to create new tests for these edge cases that aren't currently covered by the suite. [edited]
2025-02-26 22:42 sourabhniyogi: https://github.com/jam-duna/jamtestnet/actions/runs/13554662679

Super spiffy!  Hope we can get more matrix endpoints soon
https://github.com/jam-duna/jamtestnet/blob/main/.github/workflows/deploy.yaml#L14-L17
2025-02-27 08:10 gav: > <@danicuki:matrix.org> Trying to understand the flow of information from end-user to blockchain state in JAM, I created this "step-by-step" doc. I am still not 100% sure it is accurate, so any feedback is very welcome:
> 
> https://hackmd.io/@w_7Gu9yjR4q8dsYR89m4OA/ryIwYLj5kl

Good that you're trying to get the word out and whatnot. I left some comments.
2025-02-28 10:23 clearloop: ima_90c7a16.jpeg
2025-02-28 10:24 clearloop: Jam Tour Live in Shanghai üé∂
2025-02-28 12:24 sourabhniyogi: https://github.com/jam-duna/jamtestnet/pull/109

is a first attempt at dumping out at the shape of some test vectors.  We need to get alignment on a erasure coding scheme that works for "tiny" V=6 network (and then "small" V=24) outside of Appendix H full V=1023 -- it would be awesome to get everyone's ideas on what is actually truly necessary to have multi-team tiny vs small testnet this Spring.
  ‚Ü≥ 2025-02-28 15:47 dave: Re the erasure coding scheme for "tiny": In PolkaJam segments are the same size with V=6 as with V=1023 (4104 bytes). With V=6 each segment is split into _2_ shards of 2052 bytes (vs 342 shards of 12 bytes with V=1023). Erasure coding produces an additional 4 shards, giving 6 total (one per validator). [edited]
  ‚Ü≥ 2025-02-28 16:55 sourabhniyogi: thank you ‚Äî is it reasonable to post a sample 4104 original and the 6 total so we can put it back together with the same parity ffi ?  If not we will do it based on your hint, we do enjoy the exercise.   
  ‚Ü≥ 2025-02-28 21:27 mkchung: https://graypaper.fluffylabs.dev/#/5f542d7/1b4c011b5701 

So in tiny setting matching shards of 2052 bytes, the C_6 here should be C_1026, correct? To generalize this, I think C_6 should perhaps be replaced with C_W_P? 
  ‚Ü≥ 2025-02-28 21:43 dave: Yes, I think I agree with both
  ‚Ü≥ 2025-02-28 21:48 dave: Though the definitions of C and C_k in the GP also assume V=1023 and need adjusting appropriately for the tiny config
  ‚Ü≥ 2025-02-28 23:13 sourabhniyogi: image.png
  ‚Ü≥ 2025-02-28 23:15 sourabhniyogi: Are all these 8 configurations reasonable looking ?
  ‚Ü≥ 2025-02-28 23:19 dave: Looks plausible to me. I think the main thing we need is that the size of a segment is the same across all configs, and obviously that total # shards = # validators
  ‚Ü≥ 2025-02-28 23:36 sourabhniyogi: https://github.com/jam-duna/jamtestnet/issues/112
2025-02-28 13:27 danicuki: Hey Jammers, we just published a PVM workshop we recorded yesterday:

https://x.com/luke_fishman/status/1895409726898467236

PS: Everyone is welcome to publish videos in the JAM Community Youtube Channel: 
https://www.youtube.com/@PolkadotJAM
2025-02-28 15:08 jay_ztc: Is there a scenario where a validator might accept tickets as part of stage1 jamnp distribution, but selectively drop peer tickets in favor of their own? Would a rewards/cooling mechanic based on the "tickets submitted" activity stat come into play here? 
  ‚Ü≥ 2025-02-28 15:11 dave: Do you mean Safrole tickets? There is possibly scope for this happening, but each validator can only produce 2 tickets per epoch, and the VRF output must be "good enough" to be included in the accumulator, so not sure this scope is very large
  ‚Ü≥ 2025-02-28 15:14 jay_ztc: yep, was wondering if it might be a possible scenario for validator to drop any (or some percent of) peer tickets that have higher priority than their own [edited]
  ‚Ü≥ 2025-02-28 15:16 dave: They could plausibly include the lowest value tickets possible, but at some point some other validator will probably include the higher value tickets so not sure it ultimately makes much difference
  ‚Ü≥ 2025-02-28 15:28 dave: In the case where not enough tickets are accumulated, author selection falls back to a round-robin thing. This limits how much you can gain by censoring tickets
  ‚Ü≥ 2025-02-28 15:30 jay_ztc: good callout on the fallback, yep. Probably some game theory equilibrium formula that's of relevance here... Doesn't sound like a big concern at present though. Thanks for sharing your thoughts.
  ‚Ü≥ 2025-02-28 15:37 dave: With 600-slot epochs, there could be an equilibrium where only 300 validators author blocks, and they refuse to include tickets for any other validators. Don't know if this is a legitimate concern or not
  ‚Ü≥ 2025-02-28 15:38 dave: 300 is obviously a lot, but it's less than 1/3, which is the maximum number of byzantine validators for many other bits of JAM [edited]
  ‚Ü≥ 2025-02-28 15:41 dave: There also wouldn't be any real way of punishing this behaviour, outside of some governance thing
  ‚Ü≥ 2025-02-28 15:48 jay_ztc: Sounds like a good use-case for a "flexible-simulated-local-test-net"; accelerate the protocol and spin up a mock test net to race through epochs as quick as possible and see if particular equilibriums are reached. Maybe a number of test nets in parallel and the results are aggregated/joined/interpreted in some way.Just thinking off top of head here... 
  ‚Ü≥ 2025-02-28 15:48 jay_ztc: Probably some others here who have thought a bit about this already, in the context of the toaster 
  ‚Ü≥ 2025-02-28 15:49 prasad-kumkar: maybe we could multiply the tickets by eta1' before scoring? to bring even more randomness
  ‚Ü≥ 2025-02-28 15:49 dave: Well this equilibrium will only happen with byzantine validators, which aren't including all the tickets they receive
  ‚Ü≥ 2025-02-28 15:51 dave: In general only including your own tickets would be a bad strategy as this would reduce your reward
  ‚Ü≥ 2025-02-28 15:52 dave: It's only a "good" strategy if you are colluding with many other validators to ensure you always get to author 2 blocks per epoch
  ‚Ü≥ 2025-02-28 15:58 dave: My point being this kind of equilibrium will _never_ occur in a testnet where we're only running honest validators
  ‚Ü≥ 2025-02-28 16:00 jay_ztc: Yes. Worth calling out that is a pretty big assumption in that statement though-> as far as parity between testnet and "real world"
  ‚Ü≥ 2025-02-28 16:02 jay_ztc: hence, my thoughts went to not a "true testnet with many parties", but rather a the "flexible-simulated-local-test-net" where behavior/equilibriums can be tested and reached quicker- given the input is "node configurations across validators" type of thing. Probably not putting it into text as cleanly as possible here...
2025-02-28 16:02 gav: Even if 341 validators colluded and censored and didn‚Äôt include any tickets at all, that would only leave an expected 200 blocks per epoch without tickets. Even if those 200 tickets all fell in the first 500 blocks where tickets can be submitted, it leaves 300 normal blocks. With 8 tickets able to be introduced per block, there‚Äôs plenty enough room (8*300) for all the other legit validators to include all 600 winning tickets. 
2025-02-28 16:03 gav: There‚Äôs plenty of slack here. 
2025-02-28 16:05 dave: The point was if you are in a situation where there are 300 validators each producing 2 blocks in an epoch, they can just collude to include only their tickets for the next epoch, so no other validator ever gets a chance to author a block. Of course it might be practically impossible to get into this situation to start with
2025-02-28 16:06 gav: Statistically speaking that wouldn‚Äôt happen.  [edited]
2025-02-28 16:06 gav: Ever. 
2025-02-28 16:08 gav: The chance of there being only 300 block producing validators in an epoch is small enough. The chance of them happening to be the same 300 colluding out of the 1023 total is something magnificently small like (300/1023)^300 [edited]
2025-02-28 16:10 gav: It‚Äôs probably not quite that small (combinatorics being what it is) but I expect it‚Äôs vanishingly small regardless 
2025-02-28 16:11 gav: And if you control literally every block in an epoch you could also block audits too. 
2025-02-28 16:11 gav: So you‚Äôd have a lot more to worry about. 
2025-02-28 16:11 dave: You probably don't need to start with only 300 dishonest validators authoring, the dishonest validators could eg just fork to exclude blocks authored by other validators. Maybe even then it's unlikely you could get a foothold, dunno
2025-02-28 16:12 gav: You‚Äôd need to control over half of the slots. 
2025-02-28 16:12 gav: Again, vanishingly small. 
2025-02-28 16:13 gav: I expect the paper on Sassafras has this better modelled though. 
2025-02-28 16:14 gav: Davide at the foundation can probably give a link for anyone interested 
2025-02-28 17:07 danicuki: Updates about the JAM Experience event in Portugal üáµüáπ:

We‚Äôve got approved budget for a modest event üí•üéâ. It will happen at Parity‚Äôs office, with a closing party open to broad crypto community. 

The budget we have is for 40 pax, so if you plan to come, register asap here: https://lu.ma/ob0n7pdy

Dates: 6th and 7th May 

ETHLisbon is right after, 9-10th. Would be a plus to have you all there too, jamming along the hackathon. Subscriptions here: https://lu.ma/ETH-Lisbon-2025?tk=xlyRJ9

  ‚Ü≥ 2025-03-04 16:48 p1sar: On luma, it says the JAM event is 7-8 
  ‚Ü≥ 2025-03-07 14:13 danicuki: Yes, it was wrong. I fixed it now.
2025-03-01 02:27 sourabhniyogi: Adjusted https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m\_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=723798716#gid=723798716 based on the idea that all 8 configurations from tiny to full should have the same W\_G=4104 and be basically "corevm" friendly -- if anyone has wishes on what they should instead please share your thoughts! [edited]
2025-03-01 15:53 tushar_kumar: can we know the approx date for milestone submissions?? 
2025-03-01 15:59 ascriv: Latest info as of a week ago ish is that v1.0 of the gp is estimate at end of Q3 of this year, but with a decent error margin
2025-03-01 15:59 ascriv: Milestone 1 submissions won‚Äôt be accepted until 1.0
2025-03-01 16:03 tushar_kumar: 
2025-03-01 16:07 tushar_kumar: thanks for reply, do you know from where can i be aware of latest updates on jam [edited]
2025-03-01 16:08 tushar_kumar: as you said Q3, its much time for v1.0
2025-03-01 16:08 ascriv: AFAIK the single source of truth is the gray paper and secondarily gav/ the gray paper chat
2025-03-01 16:09 tushar_kumar: thanks!
2025-03-01 16:19 tushar_kumar: wait, in the jam experience event description, its says the launch of GP v.1.0.https://lu.ma/ob0n7pdy. 

check it
2025-03-01 16:25 ascriv: Latest estimate is by end of Q3. But will depend a lot on the outcome of Toaster and initial service development. 
2025-03-01 16:26 ascriv: ^quote from gav in the gray paper channel. Either they moved it up a lot since that message, or the jam experience event description is wrong, or I‚Äôm otherwise mistaken 
2025-03-01 16:27 tushar_kumar: can i get the link for gray paper channel
2025-03-01 16:30 dakkk: https://matrix.to/#/!ddsEwXlCWnreEGuqXZ:polkadot.io?via=matrix.org&via=parity.io&via=web3.foundation
2025-03-01 16:55 tushar_kumar: gav: will be great if you can clarify.
2025-03-01 19:06 danicuki: To avoid speculation, we removed GP1.0 from the JAM Experience Event description. Off-course we would love to have 1.0 ready by then, but this is just a wish. With 1.0 or not, the event will be awesome. Everybody is working hard, and milestone estimations don't help to accelerate things.
2025-03-02 04:27 gav: > <@danicuki:matrix.org> To avoid speculation, we removed GP1.0 from the JAM Experience Event description. Off-course we would love to have 1.0 ready by then, but this is just a wish. With 1.0 or not, the event will be awesome. Everybody is working hard, and milestone estimations don't help to accelerate things.

Indeed they do not.
2025-03-02 05:03 gav: I was going to prepare an implementors' update for JAMXP, but I may as well give the gist here.

The conditions for 0.9 are that we credibly expect to be able to run the Polkadot-compatible parachains service _and_ CorePlay at a speed which our best modelling implies. This is an art and not a science - don't forget JAM is bleeding edge tech - so it will depend on the outcome of empirical experiments/analysis with the Toaster. I'd say this will probably (P>0.5) happen by EOQ3. The GP will need to be audited; this I expect (P>0.5) to take around 3 months and not to throw up too many issues. We may be able to audit implementations at the same time to shorten the TTL.

Regarding M1 submissions, my feeling is to get to 0.7 or 0.8, probably calling it in mid-April, and then open submissions for M1. Any milestone submission should be made for the most recent GP release at the time, this obviously includes submissions by teams who have already submitted for milestones on older GP versions.

Finally, I expect to introduce two additional paths for implementors to go down beyond the initial 5 milestones of the "validating node":

- Non-PVM-recompiler validating node: This implementation allows teams who do not wish to build a recompiler to shortcut to M5 and thus become viable network validator nodes. Basically such teams would be able to integrate with any PVM recompiler of their choice through FFI or native linking. This would come at the cost of only being able to claim **HALF** of each milestone prize as well as accordingly less of some other benefits. Such teams would have the possibility of eventually resubmitting M4 and M5 with their own recompiling PVM impl to claim the rest of the prizes/benefits.
- Light-client implementations; these would retain M1 (dumb full node) but their own M2-M5 milestones each worth half of the regular prize, giving overall rewards at 60% of the regular recompiling, validating full-node. Milestones 2, 3 and 4 would be based on resource usage over time (CPU, storage, memory and networking) as well as synchronisation time from zero, partial synchronisation time and time to service a random basket of requests. No recompiler would be needed and resource usage expectations would likely be in line with Smoldot. [edited]
2025-03-02 05:06 gav: None of this is decided yet and in particular we may need an incentive structure to avoid too many people switching to light-clients or getting too many low-power light-client implementations, but I do believe JAM will need a solid light-client community to be successful.
2025-03-03 01:04 ascriv: Is there a recording somewhere of gav‚Äôs taipei jam tour talk?
2025-03-03 01:29 obnty: It will be published today if there's no network issue. There has been a delay as the video crew has been in China after Taipei (we had to use mobile network with a vpn).
2025-03-04 01:13 xlchen: where can I find the jam tour recordings? if they are not yet uploaded, where will it be uploaded to?
2025-03-04 02:12 wabkebab: Jam implementors, technologists and Web3 enthusiasts, here you can find one of the videos of the JAM Tour, filmed during the lecture at Taipei University. More content coming! [edited]
2025-03-04 02:12 wabkebab: https://www.youtube.com/watch?v=aTS4yjFsJd0
2025-03-04 12:11 ultracoconut: Hello guys what do you think about the idea of ‚Äã‚Äãa Jam OS similar to Eliza OS but for smart contracts and services?ü§î
2025-03-04 13:18 gav: Maybe it could use JAM/CorePlay directly. 
2025-03-04 17:39 jaymansfield: If any other JAM teams are interested in erasure coding vectors I've published a few. There are just 4 right now which cover JAM's basic requirements. It includes encoding a work package at both the tiny and full chain specs, and encoding a segment at both tiny and full chain specs. Once at least one other team can confirm they are working correctly I will generate a bunch more to have a larger suite. https://github.com/javajamio/javajam-trace/tree/main/erasure_coding
2025-03-05 14:57 davxy: STF test vectors updated to GP 0.6.3 
https://github.com/davxy/jam-test-vectors
2025-03-05 18:10 davxy: A couple of test vectors for single segment erasure coding.

https://github.com/davxy/jam-test-vectors/pull/28
2025-03-06 07:37 gav: Phase 1 is about 70% complete..
2025-03-06 07:37 gav: signal-2025-03-05-042811_002.mp4
2025-03-06 07:38 gav: image.png
2025-03-06 17:18 sourabhniyogi: Is it reasonable to have the package versioning details eg https://docs.rs/reed-solomon-simd/3.0.1/reed_solomon_simd/ and a snippet of the test vector process generation at least for this 4104 tiny case -- with Rule 1, similar to bls + bandersnatch FFIing into w3f libraries, most implementers will likely do FFI into the exact package version.  This erasure coding test vector would then stand as a check of correct FFI behavior rather than some kind of interpretation of GP Appendix H problem to solve.
  ‚Ü≥ 2025-03-06 23:59 dave: We're working on EC test vectors, they'll be posted here when they're ready
  ‚Ü≥ 2025-03-07 16:55 sourabhniyogi: That's awesome, in the meantime here is a start consistent with the W_G = 4104 choice
https://github.com/jam-duna/jamtestnet/tree/main/erasurecoding
It doesn't have transformations like in Appendix H though so it is desirable to see actual Rust code for the transformation and an explanation of why it is actually necessary in non-full chain specs to actually include the transformation
  ‚Ü≥ 2025-03-07 18:31 greywolve: The test vectors above don't seem to include the Appendix H transforms, looks like it's purely testing the C function that does the actual encoding.

They might be using some sort of pre-transform before encoding that isn't mentioned in the GP and that forms part of C for SIMD purposes. Version 3.0.1 of reed-solomon-simd does [this](https://github.com/AndersTrier/reed-solomon-simd/blob/74f48e20636f80c43d0e8884ff7a87669bfd8be6/src/engine/shards.rs#L36-L73) to handle smaller shards. Maybe there's another way to do that which is why we aren't matching the recovery shards.
2025-03-07 13:47 danicuki: Here are some updates for the JAM Experience event

- The dates will be **6th-7th** May (it was wrongly configured in lu.ma
- The JAM Toaster visit will be in one of these two days
- The event will be at Parity's office - R. Serpa Pinto 12, 1200-443 Lisboa, Portugal
- Full schedule yet to be defined, probably in the next couple of weeks.
- We already have 35 confirmed jammers. If you didn't register yourself, hurry up, there are only 10 places left: https://lu.ma/ob0n7pdy
- If you registered and won't be able to come, please release your place for someone else
- We will create a separate luma event for the closing Party - if you are registered in the main 2 days event, you **don't need** to registry for the party.
- The party is open for all crypto community, so you can share the [party link](https://lu.ma/6monb9f9) with anyone might be interested in JAM.
- ETH Lisbon is 9th-11th - Registry here: https://ethlisbon.org/ for an extra couple of days together [edited]
2025-03-08 08:10 gav: I think it would be no bad thing if anyone well-familiar with JAM's internals happened to have a speaking slot at an event ETH Lisbon
2025-03-08 14:30 clearloop: May I ask has any team tested that how many non-ticket sealed blocks could be produced generally in tiny testnet?

I found that I have to author blocks on `forks` first otherwise the chain will never get finalized (tickets have distributed in nodes' own forks which won't get finalized), while maintaining the state of fork may increase the complexity of state management significantly

or, have to produce ticket sealed blocks only and this is obvious incorrect according to the graypaper since it hardly can maintain the 6-secs timeslot of block production [edited]
2025-03-08 14:53 ycc3741: I would like to ask if there is a specific required version for PKCS.
  ‚Ü≥ 2025-03-08 15:04 clearloop: I believe pkcs#8 will be chosen since it's stable with ed25519
  ‚Ü≥ 2025-03-08 17:37 ycc3741: cool. so does our team.
2025-03-08 17:38 ycc3741: Also, just curious‚ÄîI watched the Jam Tour in China and wanted to ask if there‚Äôs an estimated timeline for the release of coreVM, or if there‚Äôs a place where I can find more details or advanced information?
2025-03-09 12:27 danicuki: > <@gav:polkadot.io> I think it would be no bad thing if anyone well-familiar with JAM's internals happened to have a speaking slot at an event ETH Lisbon

Some of us can fill this form with talk proposal:

https://airtable.com/appTaYsacDkPPrePJ/pagd1QKEO2r3i2idK/form

We can also ask for budget to events bounty to sponsor ETHLisbon as Polkadot. I can‚Äôt do it myself because I already asked money for the JAMXP event. 
2025-03-10 10:49 dvdplas: Does that mean that one core can only run one service per block?
2025-03-10 10:54 dvdplas: As for synchronous interaction between parachains in one core, how are they co-located? Can there be synchronous interaction for more than 2 "interactions" (apologies, don't know what the correct terminology for this is), in other words chain x interacts with chain y and responds back to chain x (i.e. three "interactions")
  ‚Ü≥ 2025-03-10 10:56 dvdplas: And how will this look like from the parachains' perspective, how can they ensure their work is scheduled to the same core in the same block (to have synchronous interaction)? [edited]
  ‚Ü≥ 2025-03-10 10:57 bkchr: Such a block would need to be build by a collator that can build for both chains X & Y 
  ‚Ü≥ 2025-03-10 10:58 dvdplas: Something like that doesn't exist / we haven't seen as of now in Polkadot right? [edited]
  ‚Ü≥ 2025-03-10 11:01 bkchr: Yes we don't have done this yet in Polkadot 
  ‚Ü≥ 2025-03-10 11:02 dvdplas: Do those work items, submitted by this collator, include anything that co-locates those work items or are they submitted in a way that ensures the work items are executed after each other?
  ‚Ü≥ 2025-03-10 11:02 bkchr: None of this code exists yet :) 
  ‚Ü≥ 2025-03-10 11:03 bkchr: Also parachains are quite heavy in their functionality, so if they get co-located is a little bit questionable 
  ‚Ü≥ 2025-03-10 11:04 dvdplas: And I assume that xcmp is necessary?

In other words, it is impossible to implement this on Polkadot right now?
  ‚Ü≥ 2025-03-10 11:04 bkchr: Also AFAIK this is not really planned to develop this feature for parachains. Everyone could for sure, but will probably not be a top feature 
  ‚Ü≥ 2025-03-10 11:04 bkchr: To implement what? Co-scheduling? 
  ‚Ü≥ 2025-03-10 11:05 dvdplas: Yes, because with hrmp you need it to be processed through the relay
  ‚Ü≥ 2025-03-10 11:07 dvdplas: I don't understand, is this not one of the big selling  points? Having synchronous composability between chains?
  ‚Ü≥ 2025-03-10 11:08 dvdplas: > Also AFAIK this is not really planned to develop this feature for parachains

For what is it planned if I may ask?
  ‚Ü≥ 2025-03-10 11:09 bkchr: If you don't send messages or receive messages you could probably build something like this right now already. 
  ‚Ü≥ 2025-03-10 11:09 bkchr: CorePlay. I mean JAM will provide this feature for any service 
  ‚Ü≥ 2025-03-10 11:10 dvdplas: Yes but using what cross chain message protocol ? [edited]
  ‚Ü≥ 2025-03-10 11:12 bkchr: I mean all of that is quite hypothetical 
  ‚Ü≥ 2025-03-10 11:20 dvdplas: Is CorePlay going to be a service or a feature of JAM?

And will it provide synchronous interaction between services or work items of the same service (in one core)? [edited]
  ‚Ü≥ 2025-03-10 11:20 bkchr: It will be a service 
  ‚Ü≥ 2025-03-10 11:20 bkchr: JAM will come with no batteries included :D 
  ‚Ü≥ 2025-03-10 11:54 dvdplas: And will it provide synchronous interaction between work items of multiple services or work items of the same service (in one core)? 

This comes back to my first question I guess, can one JAM core only run one type of service per block? [edited]
  ‚Ü≥ 2025-03-11 07:17 xlchen: each work package can have up to 4 work item, and the work items can be different services
2025-03-10 16:08 danicuki: Screenshot 2025-03-10 at 13.08.11.png
2025-03-10 16:09 danicuki: These are ETHLisbon Sponsorship packages: https://encodeclub.notion.site/ETHLisbon-2025-1436c123e77d801bbf02e2b9dce2b43d

What do you guys think about having a Polkadot / JAM booth? 
2025-03-10 16:18 jay_ztc: Has documentation been released yet about the specific scope for M1 conformance? I'm curious what layer the testing will be at- since DA systems are out of scope for M1. Are there any specific APIs we should be conformant with, to make M1 acceptance testing across many implementations more streamlined?
2025-03-10 19:28 philipdisarro: Hello all, thanks for the invitation. I just want to clarify a few things. First off, I am a big fan of the enshrined-rollup centric architecture, I think monolithic scaling is a dead-end and a honeypot for centralized chains. I think JAM is an incredible innovation on the forefront of modular scalability (scalability without compromising L1 decentralization), and I think L1s as DA layers with minimal computation capacity (mainly for validating rollup state-commitments and fault proof resolution). That said, is JAM not what I am describing above? A state-of-the-art DA layer with a coherent data-sharing solution that addresses DA fragmentation. 

From my perspective, the goal is not to have all logic ran natively with the full security of the L1, it is to instead achieve scalability via enshrined rollups (in some sense equivalent to sharding) with fault proofs to inherit the full security of the L1 under the 1 honest live actor assumption. It is a mechanism for horizonal scalability. [edited]
  ‚Ü≥ 2025-03-10 19:37 bkchr: But JAM is not using fault proofs
  ‚Ü≥ 2025-03-10 19:37 bkchr: It re-executes the candidates 
  ‚Ü≥ 2025-03-10 19:55 philipdisarro: AFAIK, it re-executes the candidates with a subset of L1 validators (enshrined-rollup). The only way to inherit the full base layer security is by raising an issue (ie. fault proof).  [edited]
  ‚Ü≥ 2025-03-10 19:57 bkchr: https://x.com/jeffburdges/status/1898690774704771498?s=19 did you read this answer? 
  ‚Ü≥ 2025-03-10 20:04 philipdisarro: Yes, and again from what I understand JAM is still a base layer for enshrined rollups. I don't argue against the degree to which those enshrined rollups inherit the base layer security. ELVES seems like a very sane design for rollups, with a very high degree of security inheritance, but at the end of the day there is still an objective difference in security between execution in a rollup and execution directly on the base layer with the security of the entire validator set. The difference in that security with respect to the enshrined rollups is a separate matter entirely, but it does exist.
  ‚Ü≥ 2025-03-10 20:06 philipdisarro: IE ELVES & JAM are an improvement upon other rollup-centric architectures, and the post you have referenced explicitly mentions:

> ELVES could be described as a twisted non-zk cut n choose roll up, which some shorten to pessimistic roll up.

Which again, furthers my understanding that indeed Doom executed on a rollup and not on the base layer. I don't dispute the degree to which the rollup inherits the base layer security, but it doesn't objectively inherit the full security of L1 validation. [edited]
  ‚Ü≥ 2025-03-10 20:08 bkchr: It is more likely that you get hit by meteoroid, but we still don't assume that you already got hit :) You are saying because there is a chance that is smaller than getting hit by a meteoroid, the security is less than just running it as part of the state transition function of JAM.  
  ‚Ü≥ 2025-03-10 20:11 philipdisarro: Indeed, it is. There is a difference in security. I don't argue that the difference is large, and relative to the scalability that is achieved I don't argue that this is not a sensible choice, but at the end of the day, the computation is still executing on a rollup and settling to the L1 right? 

As stated: 
>ELVES could be described as a twisted non-zk cut n choose roll up, which some shorten to pessimistic roll up.

It is even described as a rollup. I don't disagree that the rollup inherits maximal security from the L1, but that don't mean it isn't a rollup.
  ‚Ü≥ 2025-03-10 20:12 philipdisarro: Strictly speaking, from my perspective it is correct to say that Doom executed on a rollup. 
  ‚Ü≥ 2025-03-10 20:13 philipdisarro: That rollup inherits maximal security from the L1, and probabilistically equivalent security, but this is not the same as executing natively on the L1.
  ‚Ü≥ 2025-03-10 20:16 philipdisarro: Originally, the only reason I even began this discussion is because someone posted:
https://x.com/csaint02/status/1897864223382011954

and then went on to claim that Hydra Doom does not count because it was executed in a L2, and that on Polkadot it was executed on the base layer. 
  ‚Ü≥ 2025-03-10 20:17 philipdisarro: To me this is an unfair claim. At the end of the day, both Hydra Doom and Doom on Polkadot executed in L2s, it is just that with JAM the degree to which the L2 inherits the L1 security is much higher. 
  ‚Ü≥ 2025-03-10 20:19 bkchr: Reading into Hydra, only the results are returned back to the main chain
  ‚Ü≥ 2025-03-10 20:19 bkchr: The operations in between are not checked 
  ‚Ü≥ 2025-03-10 20:19 bkchr: https://hydra.family/head-protocol/ at least from what I can read here 
  ‚Ü≥ 2025-03-10 20:21 philipdisarro: Agreed, but Hydra is a state channel, not a rollup, the goal of a state channel is for participants of the channel to inherit the full security of the L1 (because the computation is entirely irrelevant for non-participants). That means if you played in the Hydra Doom tournament (ie. were a participant in the Hydra Head) you have equivalent security guarantees of the L1.
  ‚Ü≥ 2025-03-10 20:21 bkchr: > By providing more efficient means of processing transactions off-chain for a set of users
  ‚Ü≥ 2025-03-10 20:22 bkchr: > That means if you played in the Hydra Doom tournament (ie. were a participant in the Hydra Head) you have equivalent security guarantees of the L1.

This contradicts the beginning of your message
  ‚Ü≥ 2025-03-10 20:22 bkchr: How do you get the L1 security guarantess
  ‚Ü≥ 2025-03-10 20:22 philipdisarro: If 10 people bet $100 on a Doom game, and the game is executed in a Hydra head where all ten are participants in the channel, then the game has the full security of the L1, because a participant would never willingly defraud themselves. 
  ‚Ü≥ 2025-03-10 20:23 bkchr: If the Hydra head just does the computation off chain? 
  ‚Ü≥ 2025-03-10 20:23 philipdisarro: https://iohk.io/en/research/library/papers/hydra-fast-isomorphic-state-channels/
  ‚Ü≥ 2025-03-10 20:24 philipdisarro: Hydra requires unanimous consensus amongst participants, so as a participant you will never willingly defraud yourself. 
  ‚Ü≥ 2025-03-10 20:26 philipdisarro: I agree that enshrined-rollups are a more general purpose scaling solution, and that for adversarial cases the fact that it doesn't require unanimous consensus amongst participants is obviously a massive strength. I'm not arguing that Hydra is better in any way. I am just arguing that both Hydra, and JAM's enshrined rollups are indeed L2s. [edited]
  ‚Ü≥ 2025-03-10 20:27 philipdisarro: Personally, I think JAM's enshrined rollups are much better L2s for 99% of task domains, but still they are both L2s. [edited]
  ‚Ü≥ 2025-03-10 20:30 bkchr: As I skimmed the paper it also requires that parties report to the main chain if someone closed a head on a wrong state. 
  ‚Ü≥ 2025-03-10 20:32 bkchr: Also this tweet said:

> Cardano recorded DOOM stats on chain

> Polkadot ran the entire MFing game on chain

Which is correct, even from what you said above. (on chain doesn't mean that the on chain was JAM itself and it is more the L2) 
  ‚Ü≥ 2025-03-10 20:32 bkchr: But every L2 transition is checked by the JAM validators 
  ‚Ü≥ 2025-03-10 20:33 bkchr: With the very very very very.... small likelihood that you paid enough validators to cheat 
  ‚Ü≥ 2025-03-10 20:33 bkchr: We can agree on that both run on L2's (Cardano + Jam), but each with very different security guarantees. 
  ‚Ü≥ 2025-03-10 20:34 philipdisarro: Closed a head on a previous state*

You cannot close a head on an invalid state because to initiate a close you need to provide the state snapshot that is unanimously signed by all participants, it's just that the snapshot you provided might not be the most recent snapshot, and in that case others can begin a complaint processes which allows them to provide a more recent state (and the most recent state at the end of this process is considered canonical). 
  ‚Ü≥ 2025-03-10 20:34 philipdisarro: Yes, that's the only thing I wanted to clarify.
  ‚Ü≥ 2025-03-10 20:35 philipdisarro: Thank you for your time. I think JAM is a novel of engineering and a clear advancement in horizontal scalability in the blockchain domain as a whole.
  ‚Ü≥ 2025-03-10 20:36 bkchr: Yeah maybe you did not like the future output and just stopped at some state. Generally sounds to me like you could build some exploits around it
  ‚Ü≥ 2025-03-10 20:36 bkchr: Or I buy my croissant 
  ‚Ü≥ 2025-03-10 20:36 bkchr: And then pretend this never happened  [edited]
  ‚Ü≥ 2025-03-10 20:36 erin: > <@philipdisarro:matrix.org> Yes, that's the only thing I wanted to clarify.

state channels are sooooooo far away from rollups though, and even further away from parachains, and even further away from JAM running DOOM on CoreVM. But sure.
  ‚Ü≥ 2025-03-10 20:37 erin: If you want to be pedantically correct yes, but if you want to be intellectually honest for the people you are speaking to then realistically no.
  ‚Ü≥ 2025-03-10 20:38 philipdisarro: Right, but that's the purpose of the L1 resolution phase, if you attempt to do so, any of the other participants will just provide the most recent signature. 
  ‚Ü≥ 2025-03-10 20:39 philipdisarro: Again, I am not arguing that Hydra is some amazing general purpose technology. It is a different scaling solution with its own set of tradeoffs, specifically tailored to maximal scalability between non-adversarial participants (ie. B2B micro-payments)
  ‚Ü≥ 2025-03-10 20:39 bkchr: I would just dos you until this phase is over :D 
  ‚Ü≥ 2025-03-10 20:42 philipdisarro: I didn't design Hydra haha, I don't even particularly like the design of Hydra, personally I think the versatility of rollups intending to directly inherit maximal L1 security is a much better approach (which is why my firm is building a rollup stack on Cardano). [edited]
  ‚Ü≥ 2025-03-10 20:43 bkchr: You can always come and build some rollup stack on Jam :) 
  ‚Ü≥ 2025-03-10 20:43 philipdisarro: My only point is that the Doom was not executed directly on the L1, it was executed on a rollup that settles to the L1 and inherits maximal security of the L1.
  ‚Ü≥ 2025-03-10 20:44 jam_man: Philip DiSarro:  could you explain how exactly Hydra Heads Ran Doom? Because from my understanding the game logic was not actually run in the heads themselves? 
  ‚Ü≥ 2025-03-10 20:44 bkchr: "Settles" sounds so innocent and leaves room for a lot of interpretation.
  ‚Ü≥ 2025-03-10 20:44 philipdisarro: I might take you up on this after we finish the stack on Cardano. Eventually the goal is to have settlement layer be modular so it can be swapped for JAM or EthDA or Celestia or whatever else.
  ‚Ü≥ 2025-03-10 20:45 philipdisarro: > Doom was not executed directly on the L1, it was executed on an enshrined rollup that inherits maximal security of the L1.\*

That better? [edited]
  ‚Ü≥ 2025-03-10 20:52 jam_man: So are yo you still sticking to this statement, because I would really love to know if I was wrong in my initial assessment that Hydra Heads did not actually run DOOM. They only verified game states. 

https://x.com/phil_uplc/status/1898142394345787428?s=46
  ‚Ü≥ 2025-03-10 21:01 philipdisarro: Run the game in what sense? Cardano validators are not actors, they simply validate. On Cardano, a chess dApp for instance, takes the move (and the transaction inputs, outputs etc) as inputs, and returns true if the move is legal (and the resulting state is stored in a UTxO), or false if the move is illegal (and the transaction fails). 

In the case of Doom, the game state is stored in UTxOs, and when the player interacts with the game they are sending a transaction to replace that UTxO with a new updated game state and validating that the transition is honest. This ensures that if you play Hydra Doom as a participant, if you are hit by a bullet, it with reflect that in the game state UTxOs, and if you attempt to cheat by violating any of the game rules you will be unable to because your transaction would be rejected (and your character / health etc, will remain where it was prior to the transaction)  [edited]
  ‚Ü≥ 2025-03-10 21:03 philipdisarro: Do you mean like execute the graphics engine onchain? In that case, no, the graphics rendering is not considered, it was only game logic and state that is executed in the Hydra head\*.  This ensured that if you play a hydra doom tournament, none of the participants can cheat, all players must obey the game rules (cannot do more damage than they are supposed to, cannot no-clip, cannot move faster or jump higher than the game logic allows, cannot avoid taking damage when they are supposed to, and so forth). [edited]
  ‚Ü≥ 2025-03-10 21:07 jam_man: So you retract the statement that 

‚ÄúCardano also ran Doom, the entire 
game, on Hydra, an L2‚Äù
  ‚Ü≥ 2025-03-10 21:07 jam_man: Because you spent 2 days making this claim to me and eveyone else 
  ‚Ü≥ 2025-03-10 21:11 philipdisarro: I stated that once in the OP, from there almost everything I said was regarding the definition of native execution vs L2s. 

Did Polkadot run Doom entirely on a rollup? As in the graphics engine rendering state was done entirely inside the rollup? How is the output rendered? If two players move, is it immediately reflected to both players? How is no-clipping / cheating handled?  [edited]
  ‚Ü≥ 2025-03-10 21:21 philipdisarro: From what I gather the goal was different, the goal of Hydra Doom was to allow a multiplayer hydra tournament where the blockchain was used to ensure the integrity of the multiplayer tournament (all game logic is obeyed, and cheating is prevented).

From what I gather, JAM Doom was a compilation of Doom to Polkadot execution bytecode without modification? So for instance no-clips / cheating in general was not considered, as the goal was not about ensuring integrity, instead it was about showcasing the computation and bandwidth capacity of JAM services / enshrined rollups.
  ‚Ü≥ 2025-03-10 21:24 jam_man: from my understanding yes, all aspects of the game were run directly on JAM cores (or "enshrined rollups" as you keep calling them). where the game logic was split onto two parallel cores. where both cores were both processing the doom executable, and there was another process running monitoring the JAM chain and the JAM DA, this process was feeding frames out of the DA and displaying them in real-time. 
  ‚Ü≥ 2025-03-10 21:29 philipdisarro: If this is the case, I am happy to write a revised statement on that, as in that case, JAM Doom directly executed the transpiled binary unmodified, where-as Hydra Doom reimplemented the game logic in smart contracts that validated the integrity of game state progression to ensure the security of the multiplayer tournament.
  ‚Ü≥ 2025-03-10 21:31 philipdisarro: That's a very impressive showcase of bandwidth / computational capacity indeed.
  ‚Ü≥ 2025-03-10 21:33 jam_man: I would love to have some other developers back up my conceptual understanding of this. But I am 95% sure that this is how it worked. for now i can point you to this video covering it https://x.com/pala_labs/status/1898040116528238780?s=46
  ‚Ü≥ 2025-03-10 21:34 erin: > <@jam_man:matrix.org> from my understanding yes, all aspects of the game were run directly on JAM cores (or "enshrined rollups" as you keep calling them). where the game logic was split onto two parallel cores. where both cores were both processing the doom executable, and there was another process running monitoring the JAM chain and the JAM DA, this process was feeding frames out of the DA and displaying them in real-time. 

JAM services are different than rollups; they do not have to adhere to the properties of a blockchain. Polkadot parachains are only one such possible way to inherit this security, and thus services are something else entirely - they can be more generic than just running rollups as we know them.
  ‚Ü≥ 2025-03-10 21:43 erin: And you can run 20-30 DOOMs per core (currently). This is a single core. No splitting was done. [edited]
  ‚Ü≥ 2025-03-10 21:45 oliver.tale-yazdi: Is the logic in those channels a generic WASM blob or is it only a predefined set of games?  

  ‚Ü≥ 2025-03-10 21:52 sourabhniyogi: Philip DiSarro: Its really awesome that you took the time!   In the end, we should go back to "show us the JAM service code" ethos to replace the "If this is the case..." -- with JAM it is now obvious many of us will be able to do this with simpler (but less titillating) demos of JAM's CoreVM/CorePlay services involving tiny code bases where experienced people can understand what is going on in less than a couple of minutes rather than take everyone elses word for it =).  
  ‚Ü≥ 2025-03-10 21:59 philipdisarro: The smart contract logic was implemented by hand, not transpiled, because the Doom multiplayer code itself does not prevent no-clipping / speed hacks / most forms of cheating. The Doom smart contracts used in Hydra took the game logic and implemented it into smart contracts which ensured the correctness of game state progression (player & NPC & bullet location / velocity / direction, health, items etc).  [edited]
  ‚Ü≥ 2025-03-10 22:02 philipdisarro: Also cheating aside, it wouldn't be possible to transpile, because there is no WASM to PlutusCore compilation pipeline. 
  ‚Ü≥ 2025-03-10 22:03 philipdisarro: I believe they are currently working on a RISC-V compilation pipeline, so once that is released it may be. 
  ‚Ü≥ 2025-03-10 22:04 xlchen: One of the key takeaway of the demo is that JAM is capable to run arbitrary program. Specifically the one not build for blockchains. This is not the case for all existing blockchain platforms.
  ‚Ü≥ 2025-03-10 22:08 philipdisarro: Yes, that's what I gather, the goals were quite different. JAM Doom is not designed to showcase the use of blockchain to ensure the integrity of the game, it was used to illustrate the ability to run arbitrary WASM programs on the blockchain, and to show-case the capacity and bandwidth of Polkadot services. Doom itself would still be vulnerable to the same exploits that the WASM is, but that's beside the point because the goal had nothing to do with Doom in the first place. 
  ‚Ü≥ 2025-03-10 22:09 erin: > <@philipdisarro:matrix.org> Yes, that's what I gather, the goals were quite different. JAM Doom is not designed to showcase the use of blockchain to ensure the integrity of the game, it was used to illustrate the ability to run arbitrary WASM programs on the blockchain, and to show-case the capacity and bandwidth of Polkadot services. Doom itself would still be vulnerable to the same exploits that the WASM is, but that's beside the point because the goal had nothing to do with Doom in the first place. 

JAM does not use WASM.
  ‚Ü≥ 2025-03-10 22:09 xlchen: Yes (except WASM wasn't used, it is PVM / RISC-V)
  ‚Ü≥ 2025-03-10 22:09 philipdisarro: It compiles the WASM to RISC-V to Polkadot VM right?
  ‚Ü≥ 2025-03-10 22:09 philipdisarro: Or was the native implementation used in RISC-V?
  ‚Ü≥ 2025-03-10 22:10 erin: > <@philipdisarro:matrix.org> It compiles the WASM to RISC-V to Polkadot VM right?

It compiles C directly to RISC-V.
  ‚Ü≥ 2025-03-10 22:10 xlchen: the source code is compiled to RISC-V and then transcoded to PVM bytecode
  ‚Ü≥ 2025-03-10 22:11 philipdisarro: Ah so C to RISC-V to PVM, not WASM. I didn't know there was a RISC-V backend to C that's cool.
  ‚Ü≥ 2025-03-10 22:13 erin: You can target C and Rust directly to PVM which is most of the point. Polkadot has been running WASM for years :). The entire idea is you can compile a program which can be targeted to RISC-V and run it directly (yes directly) on JAM.
  ‚Ü≥ 2025-03-10 22:16 erin: Perhaps we have different pedantic opinions on what "directly" means, but JAM is not a strictly L1/L2 defined system, it is a secret third thing in the current understanding of how blockchain systems work.
  ‚Ü≥ 2025-03-10 22:16 philipdisarro: directly* as in on an enshrined rollup right, executed by a subset of validators (equivalent to  a shard in sharded networks), not by the L1 validator set unless you "raise an issue" which is an optimistic fault proof type security mechanism right?
  ‚Ü≥ 2025-03-10 22:18 philipdisarro: Or can you just pay more to directly run it with the full base layer validator set?
  ‚Ü≥ 2025-03-10 22:19 xlchen: it is somewhat correct but for most existing optimistic fault proof system, there is no guarantee someone will check it. we have an audit system and with proof that the result will be checked
  ‚Ü≥ 2025-03-10 22:19 emilkietzman: > <@philipdisarro:matrix.org> Ah so C to RISC-V to PVM, not WASM. I didn't know there was a RISC-V backend to C that's cool.

I wrote a thread on this today, there are more languages available

https://x.com/emilkietzman/status/1899048987237224711?s=46
  ‚Ü≥ 2025-03-10 22:19 xlchen: it is possible (but that lose the points)
  ‚Ü≥ 2025-03-10 22:19 erin: > <@philipdisarro:matrix.org> directly* as in on an enshrined rollup right, executed by a subset of validators (equivalent to  a shard in sharded networks), not by the L1 validator set unless you "raise an issue" which is an optimistic fault proof type security mechanism right?

It is not optimistic nor is it fault proof based. It is checked every single state transition and this is how finality is reached so quickly on polkadot vs Ethereum. As for the execution, it depends on the service; the service running DOOM here is CoreVM, which is different than polkadot and how polkadot runs parachains.
  ‚Ü≥ 2025-03-10 22:21 philipdisarro: It is still a form of fault proofs right? Someone "raises an issue" claiming that there was fault with the result confirmed by the subset of validators that re-executed the rollup state-commitment, and once an issue is raised, the full security of the L1 consensus is invoked (all validators) to re-execute the state commitment and determine the correct result? [edited]
  ‚Ü≥ 2025-03-10 22:22 philipdisarro: The result will be checked by whom? The subset of validators that re-execute it or the entire L1 validator set, or just a proof that one honest live party checked it? 
  ‚Ü≥ 2025-03-10 22:23 philipdisarro: Is the assigned subset of validators responsible for raising an issue or is it open to all validators in the base layer (even those not assigned in the re-execution subset)?
  ‚Ü≥ 2025-03-10 22:23 erin: A group of randomized validators (rotated frequently) checks the STF directly and if it doesn't match, it raises a dispute, which is further checked by all other validators. This is how polkadot works today. Perhaps people more close to JAM protocol implementation can chime in here. [edited]
  ‚Ü≥ 2025-03-10 22:23 erin: The rotation is also random.
  ‚Ü≥ 2025-03-10 22:24 xlchen: assume > 1/3 honest validators, a random set of validators will be selected to audit incore executions
  ‚Ü≥ 2025-03-10 22:25 philipdisarro: So the subset needs to come to consensus to raise an issue or any validator in that subset can raise an issue?
  ‚Ü≥ 2025-03-10 22:25 xlchen: with right parameters, we can calculated that the chance of missing proof check
  ‚Ü≥ 2025-03-10 22:25 philipdisarro: Also are we assuming 1/3 honest validators total or 1/3 honest validators in most random subsets of size N?  [edited]
  ‚Ü≥ 2025-03-10 22:26 philipdisarro: Probabilistically if 33% of total validators are honest, you might randomly have chosen a subset where only 30% of validators are honest will that subset still be able to raise an issue? 
  ‚Ü≥ 2025-03-10 22:26 xlchen: it is a 2 stage thing. there is 1023 validators, 3 validators per core. for anything goes to the chain, it needs 2 signatures for the out of the 3 random selected one. and then another ~30 random validators will be selected to do audit
  ‚Ü≥ 2025-03-10 22:27 xlchen: I didn't do the math but here is a paper showing it is secure. let me see if I can find it
  ‚Ü≥ 2025-03-10 22:28 philipdisarro: So, a single validator cannot raise an issue? It needs to be done via consensus of the subset of randomly selected validators assigned for the audit?
  ‚Ü≥ 2025-03-10 22:28 xlchen: I think it is this one https://eprint.iacr.org/2024/961
  ‚Ü≥ 2025-03-10 22:29 xlchen: I think any single validator can raise issue, but a random set of validators are required to do the check and submit a statement that they did the check
  ‚Ü≥ 2025-03-10 22:30 xlchen: if a work is not required/incentivized, then we can only assume it won't be done (which is the issue of many existing optimistic system) [edited]
  ‚Ü≥ 2025-03-10 22:32 philipdisarro: That's great then, so the assumption is only 1 honest validator in the randomly selected subset.
  ‚Ü≥ 2025-03-10 22:35 xlchen: in order to perform an attack, all 3 validators in the core must be malicious (or 2 malicious and last one down due to DDOS or some other attack). And then the auditors are still going to identify the bad work report and slash it [edited]
  ‚Ü≥ 2025-03-10 22:40 dave: > <@xlchen:matrix.org> in order to perform an attack, all 3 validators in the core must be malicious (or 2 malicious and last one down due to DDOS or some other attack). And then the auditors are still going to identify the bad work report and slash it

This isn't really true; 2 need to be malicious, they can simply not send anything to the third. Though as you say the security comes from auditing anyway
  ‚Ü≥ 2025-03-10 22:45 bkchr: > <@bkchr:parity.io> https://x.com/jeffburdges/status/1898690774704771498?s=19 did you read this answer? 

We are turning in cycles 
  ‚Ü≥ 2025-03-10 22:47 philipdisarro: That seems incorrect, if the elves paper is to be believed it does not assume 2/3 honesty (at-least for correctness) it assumes at-least 1 honest party in the fixed size audit committee.
  ‚Ü≥ 2025-03-10 22:47 philipdisarro: Because if one auditor determines fault, they raise a dispute.
  ‚Ü≥ 2025-03-10 22:50 philipdisarro: IE. the same extremely valuable, "secure under the assumption of at-least one live honest actor monitoring the state" assumption of optimistic rollups, except improved with the notion that now there is an incentive scheme for "honest live actors" and that it actually forces at-least N actors (audit committee size) to review the state and made a claim (so if at-least 1 of N of those is honest then security is guaranteed).
  ‚Ü≥ 2025-03-10 22:52 philipdisarro: From that I see though, it appears that only those randomly elected in the subcommittee are able to make a claim (a validator that was not elected in the audit committee or a random third party cannot initiate a dispute). I'm sure it could be extended to allow non-auditors to initiate a dispute, and it was just designed like that for simplicity. 
  ‚Ü≥ 2025-03-10 22:53 dave: > <@dave:parity.io> This isn't really true; 2 need to be malicious, they can simply not send anything to the third. Though as you say the security comes from auditing anyway

If you're referring to this then I wasn't talking about the auditing process but the guaranteeing process by which things-to-be-audited are introduced. For auditing yes you need only one of the randomly selected parties to be honest
  ‚Ü≥ 2025-03-10 22:55 dave: Moreover the random set cannot be determined in advance, so as an attacker you can't wait until the slim odds are in your favour
  ‚Ü≥ 2025-03-10 23:02 dave: > <@philipdisarro:matrix.org> From that I see though, it appears that only those randomly elected in the subcommittee are able to make a claim (a validator that was not elected in the audit committee or a random third party cannot initiate a dispute). I'm sure it could be extended to allow non-auditors to initiate a dispute, and it was just designed like that for simplicity. 

In JAM it is possible for any validator to initiate a dispute. So plausibly if you had spare processing power as a validator you could use it to check reports that you haven't actually been assigned. I expect you wouldn't receive any compensation for this so not sure it would be a great idea
  ‚Ü≥ 2025-03-10 23:04 philipdisarro: I see. The solution in other rollup-centric ecosystems is that the publisher of a state commitment must be bonded (ie. have slashable value locked) and if a third party (not even necessarily validator) decides to review state commitments of a given rollup and detects fraud and submits a successful fraud proof then the publisher of that state commitment has their bond slashed and the party who successfully submitted the fault proof receives a portion of it as a reward.
  ‚Ü≥ 2025-03-10 23:05 philipdisarro: I guess in the above case, you could reward the validator (with spare compute who decided to review the incoming state commitment associated with a rollup that they were particularly interested in) with a portion of the bond only if fraud indeed did occur and the audit committee did not report it (very low chance).
  ‚Ü≥ 2025-03-10 23:07 philipdisarro: A lot of the time though, third parties (non-validators) will likely be reviewing the state commitments of a given rollup anyway for a myriad of reasons (ie. they are an indexer, or web-based blockchain explorer, or dApp, or otherwise running any service that depends on monitoring the state of that rollup).
  ‚Ü≥ 2025-03-10 23:09 dave: In JAM validators are both the "publishers of state commitments" _and_ the parties responsible for reviewing these. When acting as publishers we call them guarantors and when acting as reviewers we call them auditors, but they are the same actors. Validators in practice will be slashable, for misbehaviour in either role
  ‚Ü≥ 2025-03-10 23:10 dave: I say "in practice" because slashing is not really part of JAM itself but will be managed by a service running on JAM
  ‚Ü≥ 2025-03-11 10:51 gav: Well, the point that Elves brings is bounded security.
  ‚Ü≥ 2025-03-11 10:55 gav: Because there only needs to be one honest auditor to raise a dispute, because the fork-choice and finality subsystems are explicitly tied into the disputes mechanism, and because Elves is able to properly reason about the chances that each and every work-report of a block (roll-up state-delta commitment) has been audited by at least one such validator, we are able to reach a statistical certainty (within economic bounds, as with all crypto-economic systems) over the correctness of any given block's state-transition fast and ensure that any finalised chain contains only correct state-changes. And we can do this without forcing all validators to compute everything. [edited]
  ‚Ü≥ 2025-03-11 10:58 gav: "Fast" here means generally within 10 seconds after the work was initially done. [edited]
  ‚Ü≥ 2025-03-11 11:00 gav: As Dave says, this only works because it's all happening within a closed network of validators whose behaviour we can reason about and thus can actually model these probabilities correctly.
  ‚Ü≥ 2025-03-11 11:09 gav: > From my perspective, the goal is not to have all logic ran natively with the full security of the L1

This very much depends on what is meant by "full security". I would argue there's not really a useful way of reasoning about this. The security of an L1, any L1, is not insurmountable. Like all crypto-economic systems, the best we can do is measure _the cost_ of breaking it. And there are multiple ways to break a system (censorship, stalling, reversion, invalid state transition, to name just four). The costs of breaking each of these are typically different and change between L1s and over the course of time of an L1. So the concept of inheriting any particular aspect of any particular L1's security guarantees at any particular time is pretty much meaningless. [edited]
  ‚Ü≥ 2025-03-11 11:09 gav: What is meaningful is to be able to state the actual cost of breaking a system, in what way, and with what assumptions.
  ‚Ü≥ 2025-03-11 11:17 gav: In any case, Elves is specifically designed not only to construe the security of the L1 to ensure correctness of co-processing units, but also to ensure that those who attempt to thwart it are heavily punished. [edited]
2025-03-10 20:33 ascriv: Maybe L1.0001?
2025-03-12 10:52 alambicco: hi all. Is there a testnet for JAM ?
2025-03-12 15:44 gav: Coming soon(tm)
2025-03-12 16:25 alambicco: let's say I want to start building a service ... where to start ?
2025-03-12 16:41 sourabhniyogi: https://docs.rs/jam-pvm-common/latest/jam_pvm_common/index.html
2025-03-12 16:51 sourabhniyogi: If this seems bizarre, and you want to build user facing applications, with probability 1, there will be a "CoreVM" service written with the above and you just write a normal-ish [Rust/...] program as a guest program of *that* general service serving users.   I believe JAM ran DOOM (and maybe will Quake next haha!) as an illustration of this idea in a proto-CoreVM -- we should all like to know how to demonstrate this with our friends!
2025-03-12 17:57 alambicco: is there any resource to understand what a "service" is ? 
  ‚Ü≥ 2025-03-12 18:34 danicuki: https://graypaper.fluffylabs.dev/#/85129da/0ba2000ba200?v=0.6.3
  ‚Ü≥ 2025-03-12 18:57 alambicco: ok tahnks
2025-03-12 17:58 alambicco: from a philosophical and design perspective
2025-03-12 22:32 ycc3741: I‚Äôm very curious about how JAM runs DOOM without delay.
What I mean is that JAM itself has a six-second finalization time.
So my inputs go through:
Input (mouse or keyboard) ‚Üí corevm ‚Üí JAM ‚Üí corevm ‚Üí Output (monitor)
Logically, wouldn‚Äôt that result in a six-second delay?
  ‚Ü≥ 2025-03-12 22:40 sourabhniyogi: My guess is that the DOOM demo has the "user" computing the work packages FIRST (and as a result, knowing the exact exportCount), and then what you see in the demo is the stream of work packages submitted by the user into a core (or some number of them), the "frames" going through DA, and the claim that "JAM is running DOOM" is actually "JAM is doing guaranteeing/assuring/auditing AFTER the user has submitted their work package" -- its a streaming demo and a test of N cores doing (a) DA throughput (of the "frames") (b) the same computational process in refine that the user.  So, no jerkiness, but yes, a 6-12 second delay technically between what the user has done in creating N exported segments (representing video frames) and polkavm replicating the same computation.

Just a guess, hope someone can correct it 
  ‚Ü≥ 2025-03-12 22:41 ycc3741: yeah
  ‚Ü≥ 2025-03-12 22:42 ycc3741: there should not be jerkiness
  ‚Ü≥ 2025-03-12 22:42 ycc3741: but lantency might be a issue QQ
  ‚Ü≥ 2025-03-12 22:44 ycc3741: Because when I saw Dr. Wood's demonstration, he didn't directly play DOOM but instead showcased the output. So, I'm not sure how the delay issue was handled.
  ‚Ü≥ 2025-03-12 22:46 sourabhniyogi: Its just a playback of the user-generated work packages from a real user (or a bot, doesn't matter) done at some time before.  
  ‚Ü≥ 2025-03-12 22:47 ycc3741: yeah. I think so, too. 
  ‚Ü≥ 2025-03-12 22:50 sourabhniyogi: You can eliminate the user input with https://playgameoflife.com/ - we'll have this as a corevm-like refine test vector dataset that is easy to turn into a hellow world and more exciting than likecomputing primes.  Not as sexy as shooting things though.  [edited]
2025-03-12 22:33 ycc3741: Or did I misunderstand something?
2025-03-12 22:45 ascriv: Maybe more accurate to say it ran some tool-assisted gameplay playback
2025-03-13 10:15 ultracoconut: Is possible to build a mini Jam toaster with Raspberry pi? [edited]
2025-03-13 10:16 ultracoconut: 1000001546.webp
2025-03-13 10:19 ultracoconut: I guess the arm architecture is a problemü§î
2025-03-13 10:39 danicuki: The architecture should not be a problem. If it is a smaller validator set, with less capacity, I believe it is possible to run. The assumed node capacity for a full network is "a modern 16 core cpu with 64gb ram, 8tb secondary storage and 0.5gbe networking." 
2025-03-13 11:06 ultracoconut: > <@danicuki:matrix.org> The architecture should not be a problem. If it is a smaller validator set, with less capacity, I believe it is possible to run. The assumed node capacity for a full network is "a modern 16 core cpu with 64gb ram, 8tb secondary storage and 0.5gbe networking." 

Great!
2025-03-13 11:40 wabkebab: this could be a good open-source hacker/enthusiast project [edited]
2025-03-13 11:44 jan: Would be way too slow for production, but as a fun test net, sure.
2025-03-13 12:00 ultracoconut: It is for funü•≥ Could 6 Raspberry Pi 5s 16gb ram model run Jam faster than a single Mac Notebook?ü§î
2025-03-13 12:23 gav: > Logically, wouldn‚Äôt that result in a six-second delay?

Probably more than a 6-second delay; the Work Package must first be computed, sent to a guarantor; two of them must then compute the work-report and send it to the author; they must then place the report in the block and accumulate it. At peak usage the pipeline will normally take somewhere around 12-18 seconds, though if refinement is very fast, you have core affinity, you get lucky on the block phase and there's not much to accumulate, it could be less than a second. [edited]
2025-03-13 12:25 gav: So if you wanted to actually run DOOM _through_ JAM and watch JAM's output (i.e. the display) before making your next input (i.e. shooting), you'd probably experience too much lag for an enjoyable session on a game like DOOM. [edited]
2025-03-13 12:26 gav: However, it's conceivable that certain kinds of games (e.g. turn-based, card games &c.) could make use of a pipeline with this kind of latency.
2025-03-13 12:27 gav: The demo was to show off the generality, computation & DA capabilities of JAM. JAM is not going to put Nintendo out of business.
2025-03-13 12:27 gav: JAM could also possibly be "overclocked" (i.e. have a reduced block-time), which would further increase playability of games needing lower latency.
2025-03-13 12:28 gav: And, of course, nothing stops you from peeking at DOOM's output at the package-builder stage and devising sensible inputs "just-in-time" then. That wouldn't involve JAM as a critical part of the "look-aim-shoot" cycle, but would utilize JAM as a guarantor of game-correctness and could be quite an interesting possibility for things like gaming tournaments where you want players' (inter-)actions checked by a neutral platform. [edited]
2025-03-13 12:32 gav: We're already preparing the tooling and code so that anyone with a vaguely viable M2 implementation will be able to demo it on their own testnet.
2025-03-13 12:33 gav: For us, it runs fine in the PVM interpreter; no recompiler needed.
2025-03-13 12:38 gav: I'd recommend you watch one of my recent talks; I spend some time talking about services.
2025-03-13 12:39 gav: You can think of a service as a highly-parallelisable, pipelined and high-throughput smart-contract.
2025-03-13 12:40 gav: It has a somewhat atypical multi-stage execution model, which makes it highly optimal to be executed on a decentralised, distributed platform like JAM.
2025-03-13 12:41 gav: As sourabhniyogi says, writing a service directly is probably not particularly sensible for anyone wanting to make anything user-facing.
2025-03-13 12:41 gav: You can think of JAM as the decentralised equivalent of a bare-metal supercomputer.
2025-03-13 12:43 gav: Services are the basic operating systems that sit on top of JAM. Most of them will allow programmable code to be "loaded" and executed in richer or more "normal" execution model (much like like DOS, Windows, Linux &c provide a richer execution environment for software to run than the bare metal of a machine). A few services might be highly domain-specific with fixed-functionality (e.g. a storage or bridge service). [edited]
2025-03-13 12:45 gav: We can already see some services like CoreVM which provides a docker-like continuous execution VM environment, and imagine a CoreChains service which provides an environment for L2 blockchains to execute, much like Polkadot's Relay-chain. [edited]
2025-03-13 12:46 gav: Much like there are far fewer operating systems than there are pieces of software which run on them, we'll likely not see so many services compared to the amount of software deployed on to them (smart contracts, CoreVM inner software, L2 chains). [edited]
2025-03-13 20:56 xlchen: where can I find the service code showed in the JAM talk?
2025-03-13 22:34 ultracoconut: > <@danicuki:matrix.org> The architecture should not be a problem. If it is a smaller validator set, with less capacity, I believe it is possible to run. The assumed node capacity for a full network is "a modern 16 core cpu with 64gb ram, 8tb secondary storage and 0.5gbe networking." 

I think I said it wrong. What I wanted to build was actually a core jam. One validator per raspberry pi.
2025-03-13 22:35 xlchen: for a small testnet with reduced gas limit and related parameters, I see no reason why it wouldn't work
2025-03-14 08:55 olanod: A small hardware can be a helpful development tool, a tiny rpi powered testnet sounds good, like a plug and deploy device? To be familiar with bare metal RV64 for service development I'm also thinking of a smaller "service emulator". e.g. this [board](https://wiki.sipeed.com/hardware/en/maix/m1s/m1s_dock.html) I got with a RV64GCV core at 480MHz will be helpful while developing a service.
2025-03-14 09:02 olanod: And speaking of services, JAM will be an interesting platform for new kinds of operating systems. If anyone has any thoughts, I wrote a bit about [VOS](https://forum.polkadot.network/t/virtual-operating-system-for-jam-program-with-wink-and-zink/11973), an OS to run WASI programs, the idea is to appeal to non blockchain developers and attract them to our ecosystem(e.g. the many Rust devs that hate to just hear the word blockchain mentioned ;P)
  ‚Ü≥ 2025-03-14 09:09 jan: We're not bound by WASM's limitations, so you don't necessarily need WASI here. With a proper libc port and a service that emulates a subset of Linux syscalls you could run essentially any normal program unmodified just by recompiling it. (Of course that'd probably not be very useful because you still need JAM-specific I/O to do anything useful.)
  ‚Ü≥ 2025-03-14 09:25 olanod: What I like about WASI is the ecosystem, it will have better tooling, compiler support, etc. Wouldn't it be great if we can mix the good parts of WASI with PVM? the SI without the WA ... wasmtime supports no_std not too long ago, the prerequisite is to precompile WASM ahead of time to the target architecture, I think that limitation could be an advantage as we could transpile WASM to PVM so no WASM interpreter is used in the JAM service ... haven't got there yet but it's worth a try ;)
  ‚Ü≥ 2025-03-14 09:39 olanod: I find it very convenient to enable a regular rust program with a main function that reads from stdin or a file and writes an output with regular os primitives for example, any non blockchain dev can do that, it's a program that can be `cargo run` without any extra set up. Wouldn't it be great to enable this kind of development? We could try to contribute a standard library to rust for a `riscv32emac-unknown-someos-polkavm` target but if somebody already did the work with WASI why not use that instead? 
  ‚Ü≥ 2025-03-14 09:49 olanod: like a fake libc, VOS would translate things like reading/writing from files into things that could make sense in the context of JAM, if like Linux we abuse the *everything is a file* to expose JAM I/O as "files" then it can become useful :)
  ‚Ü≥ 2025-03-14 10:06 jan: Yes, that's literally what a libc port + emulation service would do, but without the WASM -> PVM recompilation step. It is a tradeoff - with a WASM -> PVM recompiler you could use existing WASI backends, but you'd get more bloated binaries and worse performance; with a libc port you'd have to reconfigure each compiler to use it (which is extra work, although it's relatively easy to do) but you'd get higher performance and smaller binaries.
  ‚Ü≥ 2025-03-14 10:07 jan: But, in general, I'd love to see a WASM -> PVM recompiler. If you write one please make sure to ping me and let me know. (:
  ‚Ü≥ 2025-03-14 12:56 olanod: I'll first focus on the developer experience, i.e. wink!(we'll use it for regular backend services) but will see what can be done with Cranelift that supports riscv64. Any special considerations you foresee? 
  ‚Ü≥ 2025-03-14 12:57 jan: You won't be able to use Cranelift, as it doesn't support rv64e.
  ‚Ü≥ 2025-03-14 13:00 jan: You'd have to add support for rv64e to Cranelift (which probably shouldn't be too hard, as it's mostly just forcing it to not use the upper 16 registers), but even then it probably won't be a simple job to emit something that can be turned into PVM bytecode (you need to use a very specific memory model with full relocations, and I have no idea whether Cranelift supports all that).
  ‚Ü≥ 2025-03-14 13:00 jan: A much simpler way to do it would be to go through the wasm2c route, that is, convert the WASM bytecode into Rust or C and compile it with a normal compiler.
  ‚Ü≥ 2025-03-14 13:01 olanod: thanks that's helpful!
2025-03-14 09:59 ultracoconut: > <@olanod:virto.community> A small hardware can be a helpful development tool, a tiny rpi powered testnet sounds good, like a plug and deploy device? To be familiar with bare metal RV64 for service development I'm also thinking of a smaller "service emulator". e.g. this [board](https://wiki.sipeed.com/hardware/en/maix/m1s/m1s_dock.html) I got with a RV64GCV core at 480MHz will be helpful while developing a service.

Great idea to use risc-v hardware. The Core Jam Pi could be a cluster of 3 Raspberry Pi 5s  16 GB RAM model, each with its own 1TB NVME SSD. Each would function as a validator. What do you think?
2025-03-14 10:23 ultracoconut: 1000001561.jpg
2025-03-14 13:34 jay_ztc: also related:

https://www.sifive.com/boards

https://github.com/chipsalliance/rocket-chip (much lower layer than our use case but love to see this direction in the hdl scene)
2025-03-14 13:38 jay_ztc: makes me wonder if there's any gas-metering designs on opencores, integrating one into rocket core would be sick (bit beyond this specific scope, but cool to dream about) [edited]
2025-03-14 15:57 ultracoconut: I have more ideas for marketing the Core Jam Pi. If anyone is interested, send me a DM on Twitter.‚úåÔ∏è
2025-03-16 10:20 ultracoconut: Well, I have an update on the concept. Mermelada cubes. Each cube is a Jam core pi. You can add cores by connecting cubes.This is useful if your application needs more than one core.
2025-03-16 10:23 ultracoconut: For example, you can create your rollup and test it in 3 local physical cores.
2025-03-17 08:03 clearloop: hey teams, may I ask if you are requesting the full blocks right after receiving their valid headers?

I found that for only storing headers & communicating with neighbours, we may miss sort of blocks when are about to author blocks (in tiny network, 3 of the neighours only have the headers, they may do best chain selection later then, but when they get the expected block the current node may have already authored a new block), and then, fork occurs even in my local testnet ))

e.g. after receiving a valid block header, as a validator: we announce it & request the full block data [edited]
  ‚Ü≥ 2025-03-17 09:16 clearloop: okay we just got it is caused by our implementation of ce128
2025-03-17 13:38 mnaamani: from Jam prize rule no.20 - "Prizes are paid to the earliest Polkadot/Kusama account IDs stated in the repository's README. In the case of a tie, payment is split equally" - Does that mean that a prize is only allocated to a specific language?

So if I'm considering starting a new implementation, would it make more sense to pick a language that not many teams are currently working on? [edited]
2025-03-17 15:02 gav: No and yes.
2025-03-17 15:03 gav: Prize pool is split between language sets, so it makes sense to select a language from one of the less popular language sets (C and D, currently). [edited]
2025-03-17 15:04 gav: The account ID rule is there to ensure that someone doesn't wait for an implementation to be nearly complete, fork the repo, finish the impl and submit it to collect the entire prize. [edited]
2025-03-17 15:08 gav: As already stated, the JAM prize is intended to incentivize and seed a diverse, distributed, decentralised knowledge base of the JAM protocol. This precludes the substantive use of AI to generate or translate code. We already have some rules to preclude the substantive use of AI, but others may be introduced to help police against it and ensure that implementations are actually clean-room.
2025-03-17 15:08 gav: > Any Jam-implementation code which is viewed before or during implementation must be declared.

Since AI models may be trained on code from other implementations, this precludes the substantive use of AI-generated code.
2025-03-17 15:10 gav: > Interview may be requested after submission to ensure team members are the legitimate authors of the code.

Again, here for the sake of argument "legitimate" means without the assistance of generative AI. [edited]
2025-03-17 15:10 gav: Remember: the purpose is to decentralise. AI is fundamentally centralising.
2025-03-17 15:12 gav: Expect a hard grilling at interview. I (and perhaps others in the Fellowship) will want to see that not only did you write the code but that you *understand* the code and how it relates to the GP. Being able to produce a conformant implementation is not enough to win the prize. It must be convincingly written from scratch by the team behind it without assistance from others, not even if intermediated by an AI model.
2025-03-17 15:15 gav: Happy to answer any questions on the above. [edited]
2025-03-17 15:27 jan: In general when working on something novel AI is pretty much useless in the vast majority of cases. If you need to write a bunch of boilerplate code that was already done a million times - that's where using an LLM shines, but if you're doing novel work it's either going to sabotage you because the code will just plainly be wrong, or waste a bunch of your time because you'll have to rewrite it anyway. Not sure if Gav would agree, but personally I wouldn't care if you'd use AI to help you write some boilerplate unrelated to JAM (e.g. spinning up an RPC server in your language of choice; that has been done a million times already and I see no reason to waste time reinventing it yet again - without an LLM you'd copy-paste it from the library's docs or StackOverflow anyway) or get it to generate some unit tests for you, but everything related to the protocol itself and its implementation should be written entirely manually. [edited]
2025-03-17 18:55 mnaamani: Thanks that was very clear and comprehensive, Glad I asked because I was considering a less popular language from set B (D lang), but given that I'm a bit late to the game, it might make most sense to pick something even more rare from the "Mad" category? But if I was not solely focused on the prize, an implementation in D could still be valuable. I'll ponder on it.
2025-03-17 22:30 ascriv: In the case that N > 5 teams submit milestone 1s at the same time for the same language set, is the prize pool split N ways or are the 5 best chosen, or some other method?
2025-03-19 10:10 gav: It's a first-come-first-serve basis.
2025-03-19 12:09 prematurata: > <@gav:polkadot.io> It's a first-come-first-serve basis.

Was it always like this? I think I remember a discussion about splitting in case more than 5 submit a valid impl.

Wouldn't a change (if any) towards a first come first serve cause a "click day" basically adding more value to the "social posting timing" than the implementation itself?
2025-03-19 13:11 jay_ztc: I think you're making an assumption that M1 secures future payments. Based on the submission rules & milestone delivery repo, completing m1 doesn't "reserve your spot" for future milestones. Currently there is (up to) 100k dot per milestone and 2.5 mil dot per lang pool. It could be the case that 10 teams for a single pool complete & collect m1 and m2 payments- meaning 20x100k dot has been paid out (75% of it linearly vesting). In that case there would only be 500k left in that prize pool.

Someone please correct me if I'm wrong.

https://github.com/w3f/jam-milestone-delivery/blob/main/README.md?plain=1#L31 [edited]
2025-03-19 13:23 ascriv: My question is more like, what do we do in the (maybe unlikely) case that we get 15 (lang set A) valid M1s right when M1 submissions start getting accepted? Or are we tiebreaking by millisecond timing of submission? [edited]
2025-03-19 13:25 jay_ztc: Doesn't say anywhere about the prize being evenly split between milestones. I assume (up to, pending judging) 100k paid to 15 teams meaning only 1 mil dot left in that pool.

Again, not a fellow or w3f member- someone correct me if I'm wrong.
2025-03-19 13:29 dakkk: Would be fun if after working on Jampy for 8 months full time I miss the timing for submission because I was sleeping 
2025-03-19 14:05 clearloop: spacejam-localnet.mov
2025-03-19 14:05 clearloop: spacejam can finally maintain the block finalization in localnet, so much pain debugging with logs these days üò≠
  ‚Ü≥ 2025-03-19 14:45 jaymansfield: Congrats!
2025-03-19 14:45 gav: Well, each language set can support the M1 payout of 25 teams, so I don't think there's going to be significant competition there. [edited]
2025-03-19 14:46 gav: And this would assume all submissions passed all (secret) M1 conformance tests perfectly first time.
2025-03-19 14:49 gav: The published test vectors are obviously not comprehensive (nor are they designed to be) and I find it quite unlikely that all candidates will pass all conformance tests first time.  [edited]
2025-03-20 04:33 waterreptile19: hey all... how do I get started? Is there any codebase I can refer to?
2025-03-20 07:06 mnaamani: There is no codebase, the whole idea is that there is a detailed specification, they gray paper, based on which you would independently create an implementation of jam. https://graypaper.com/
2025-03-20 16:13 eclesiomelo: hey guys, we are fixing some bugs on our PVM implementation and one of it is related to the standard program initialization (definition A.36), more specifically we are trying to run the accumulate test vectors and its test service blob starts with the bytes `0x47000c` (here is one example -> https://github.com/davxy/jam-test-vectors/blob/038bd899ff7e387d61a46a8d509486179ef2efac/accumulate/tiny/accumulate\_ready\_queued\_reports-1.json#L418) and in definition A.37 the 3 first bytes should be the lenght of the `o` term (`E3(|o|)`), but when  decoding them using a normal integer decoding function we get decimal `786503` which is bigger then the accumulate test service blob, so we cannot read the bytes relative to `o`, did anyone face the same problem? The graypapper says `Given some p which is appropriately encoded together with some argument a`, this argument is also in the test service blob? I would appreciate any clarifications, thanks in advance. [edited]
2025-03-20 18:58 gav: Which version of GP are you working from - 0.6.3 saw the introduction of the metadata prefix to program blobs.
2025-03-20 19:06 eclesiomelo: 
2025-03-20 19:06 eclesiomelo: 
2025-03-20 19:09 eclesiomelo: We are using the most updated version, 0.6.4, and the definition is this one https://graypaper.fluffylabs.dev/#/68eaa1f/2bc1022bc102?v=0.6.4, right?
2025-03-20 19:29 gav: That‚Äôs the program blob but not purely what is stored. There is also a metadata prefix 
2025-03-20 19:31 gav: You can see in eg eq. (9.4)
2025-03-20 22:30 eclesiomelo: Oh, we have missed that prefixed metadata, after reading it from the blob we are able to correctly parse the standard program defined at A.37! Really thanks! üòä
2025-03-21 15:29 emielsebastiaan: ima_792adcf.jpeg
2025-03-21 15:29 emielsebastiaan: Big day!! Today we achieved full milestone 1 conformance for the JAM Implementers Prize.

PyJAMaz will be open-sourced when the prize rules allow for it.

https://x.com/jamdottech/status/1903106367826677887?s=46&t=ThX7Y87rr1MIKyk6af4OXg
2025-03-21 17:11 gav: We‚Äôre at 0.6.4!:)) [edited]
2025-03-21 17:49 emielsebastiaan: > <@gav:polkadot.io> We‚Äôre at 0.6.4!:))

Development branches for 0.6.3 & 0.6.4 are pending review. They did not make our weekly ‚ÄòMerge Friday‚Äô. 
2025-03-22 11:25 davxy: Test vectors updated to track GP 0.6.4

https://github.com/w3f/jamtestvectors/pull/28

  ‚Ü≥ 2025-03-22 17:30 jaymansfield: Hey davxy, was it intentional that "exports" in CoreActivityRecord is U16, but "exports" in ServiceActivityRecord is U32? Just wanted to make it wasn't an oversight.
2025-03-22 11:32 davxy: https://github.com/davxy/jam-test-vectors/pull/30
2025-03-22 15:58 ultracoconut:  Mermelada Cubes 

üçì Mermelada Core ‚Üí The main validator cube (Core JAM Pi).
ü´ê Mermelada Parachain ‚Üí Additional cube with a collator for parachain testing.
üçä Mermelada RPC ‚Üí RPC node to interact with the network and visualize data.
üî• Mermelada Extra! ‚Üí A high-performance version with upgraded hardware, storage, and connectivity.
üòãüòÖ


2025-03-22 16:23 danicuki: > <@davxy:matrix.org> Test vectors updated to track GP 0.6.4
> 
> https://github.com/w3f/jamtestvectors/pull/28
> 

Awesome. Thanks for this. I see that you didn‚Äôt put any statistics for cores and services besides zeroes. Do you plan to add some vectors for those as well? 
2025-03-22 16:26 danicuki: > <@davxy:matrix.org> Test vectors updated to track GP 0.6.4
> 
> https://github.com/w3f/jamtestvectors/pull/28
> 

Did you update the Bandersnatch library in these tests? Many of our safrole tests are failing now. 
2025-03-22 17:12 yu2c: Small question: Why do you use `U64` for the [gas_used](https://github.com/davxy/jam-test-vectors/blob/fb3ce3ffa82833cc780338e9ab128e834e72b26e/jam-types-asn/jam-types.asn#L184) type instead of `Gas`, even though they have the same meaning? I know in the Graypaper, it's noted as `uint64`
2025-03-22 19:25 gav: It is intentional, though not important at present [edited]
2025-03-22 19:45 davxy: Probably yes. But that is not at the top of my task list right now [edited]
2025-03-22 19:46 davxy: Yes that is expected. Please update to v0.1.2 (now also available on crates.io). See https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/safrole/README.md#%EF%B8%8F-warning-%EF%B8%8F [edited]
2025-03-22 19:48 davxy: Do you mean in the asn1 syntax file? I suppose because in that context it is just an alias. I can change it btw [edited]
2025-03-23 06:14 yu2c: No, I think it works well as it is. Thanks for the clarification!
2025-03-24 12:35 amritj: A thought, not important for JAM development, but still want to send it out:


People do mock blockchains for not having any use cases except maybe cryptocurrency. The reason for success of cryptocurrencies and what made them different is there is a singular verifiable database, not millions of small databases for each bank that require and trust third-party solutions like SWIFT to securely transfer information between these databases.

But that's only one type of data being transferred daily - health care records, educational records, financial records, property deeds, and million other fucking important records that are still broken up in these mini databases. 

All these Important information is still fragmented, still requiring trust on these third party solutions.

Companies have been trying to build private blockchains for this, but their problem is the same - they are private, most of them are not more than a few nodes of the same company in different locations. They are not secure; an attack on just few nodes not only bring the whole network down but also compromise the integrity of all the data.

JAM is what they need. JAM is what will allow all these private blockchains to be secure and interconnected. These private blockchains could remain private and borrow the security guarantees from JAM by using ZK proofs or maybe some other tech. Even if some company nodes get compromised, it will only make the data of that specific company public but not have any affect on the integrity of the data 

I believe this is what required next.


I know this is not related to JAM development, but just a thought for other devs building on top of it to build strong tooling and support to make this possible, and maybe also for the marketing team :) [edited]
2025-03-24 14:42 decentration: in `reports.results.refine_load` the zero values encode to 1 byte. For `gas-used` it is u64, given that 0 encodes to 1 byte, can you confirm that we now encode with C.6 serializer? without serializer i am expected there to be 8 bytes of zeroes. 
2025-03-24 17:20 jaymansfield: I think you have to use compact encoding for those new fields
  ‚Ü≥ 2025-03-25 02:11 qiwei: where in GP does it say these fields need to use compact encoding?
  ‚Ü≥ 2025-03-27 11:50 decentration: i believe it is referring to C.6
2025-03-24 19:51 danicuki: Are you a JAM implementer and PBA alumni? Let me know!  
2025-03-25 10:52 danicuki: We are planning to have a Polkadot / JAM booth at ETHLisbon. We will need JAM implementors volunteers to be there to spread the word of JAM. React with ‚ù§Ô∏è and reach out to me if you are willing to help.
  ‚Ü≥ 2025-03-25 11:29 wabkebab: In general, is this something that JAM implementors would like to  help representing JAM in different events? [edited]
  ‚Ü≥ 2025-03-25 11:30 wabkebab: I mean _you_ are making JAM a reality also
  ‚Ü≥ 2025-03-25 11:31 wabkebab: we - Pala Labs, organisers of JAM Tour - are drafting some "JAM evangelist" initiative we would share soon [edited]
  ‚Ü≥ 2025-03-25 18:04 sourabhniyogi: Can "JAM evangelists" get your assistance on having the DOOM (or Quake) demo at "foreign" places like this?
  ‚Ü≥ 2025-03-25 18:51 gav: I'm sure we can make that happen
  ‚Ü≥ 2025-03-31 18:41 sourabhniyogi: Can we get a set of work packages (or bundles), exporting the frame buffers as segments, relative to some version (0.6.4 or ___) so we can set an April goal of refining them in time for May meet up?
  ‚Ü≥ 2025-03-31 18:43 sourabhniyogi: Ideally this would come with the exact way to show the demo of rendering the exported DOOM/... segments that even non-implementers could run following some top-level README.
2025-03-25 12:00 milawords: 
2025-03-25 20:13 leonidas_m: Can someone confirm that the encoding of refine_load in the codec vectors is correct? Because I am also confused regarding this
2025-03-25 20:24 gav: As per the GP, the new statistic-related items in work-reports are compactly encoded. [edited]
2025-03-25 20:24 gav: fwiw, this is to save some very valuable space in work-reports.
2025-03-25 20:25 gav: there's already an issue in the GP repo to look for other possible items which can reasonably be compactly encoded
2025-03-25 20:29 leonidas_m: by compact you mean general encoding C.6 right?
2025-03-25 22:16 mkchung: https://graypaper.fluffylabs.dev/#/68eaa1f/1b7c011b7f01?v=0.6.4
https://graypaper.fluffylabs.dev/#/68eaa1f/139c00139c00?v=0.6.4

Is there a specific ordering for segment-root lookup L (or dictionary "D‚ü®K ‚Üí V‚ü©" in general)?
2025-03-25 22:16 danicuki: Please share your team logos here: https://github.com/jamixir/jam-media

This is for the JAM Experience merch. 
2025-03-25 22:37 gav: ~Segment root lookup is never serialised so ordering it is moot~. Dictionaries in general can be serialised and that is defined in the relevant appendix section.  [edited]
2025-03-25 23:33 sourabhniyogi: By C.24 https://graypaper.fluffylabs.dev/#/68eaa1f/379b02379b02?v=0.6.4 -- the segment root lookup l in the work report (included in the guarantee) is serialized and is important since 2 or 3 guarantors have to sign perfectly identical work reports.  Since we don't need to map segment roots to identical segment roots, the only entries in the serialized segment root lookup within the serialized work report would be work package keys mapping to segment roots by this here https://graypaper.fluffylabs.dev/#/68eaa1f/1b78011ba101?v=0.6.4 -- check?  So implementers faced with this segment root lookup ordering question must order by work package hash as described in https://graypaper.fluffylabs.dev/#/5f542d7/37bf0037bf00?v=0.6.4 -- check? [edited]
2025-03-26 07:27 gav: Yes indeed, the previous answer is corrected. The second part still stands: dictionaries are encoded as per the appendix.  [edited]
2025-03-26 22:59 sourabhniyogi: Thank you for clarifying -- We are currently using the segment root lookup within the work report to actually verify the justifications within the bundle and understand the segment root lookup piece of the work report to be absolutely critical to auditing.  If that's wrong, we'd appreciate being corrected as we think we have all the pieces fitting together finally.

In particular, we put some "guarantee test data" together in a new [0.6.4.0 guarantees dataset](https://github.com/jam-duna/jamtestnet/tree/0.6.4.0/guarantees), where we believe we have both generated and verified the self-justifying bundle exactly in the above audit situation.

I wrote up a doc on what we think implementers should do with this [guarantees dataset here](https://github.com/jam-duna/jamtestnet/issues/139) and hope we + others can slog through the heart of this central "puzzle" together soon.

Earlier I was concerned about implementers coding to the test vectors and didn't want to share this kind of writeup (and give away the wrong puzzle answer, and superspread a JAM "mental disease", so to speak, in addition to taking away the delights of solving your puzzle in the first place), but _this_ puzzle is so layered and from our month on getting [0.6.2.x alignment](https://github.com/jam-duna/jamtestnet/releases/tag/0.6.2.12), I've concluded implementers are so independent and puzzle-solving oriented that I'm not concerned anymore:  instead, I'm seeing lots of independent implementations against the same GP produce the anti-fragility you aimed for.

However, if you are concerned, I'd appreciate what you think we should to do to modulate our collective activity a bit. [edited]
2025-03-27 12:32 danicuki: Hi jammers, we are trying to set up a booth at  ETHLisbon to present JAM to event devs. We need a few volunteers to stay there during ETH Lisbon dates (9th-11th). LMK if you want to help
2025-03-28 12:59 stsoen: ‚ÄãActually, it makes sense. Moreover, if we look at the current Rollup Landscape, it appears as a patchwork quilt of different pieces. And the quilt is made not only of fabric but also of other materials that may be poorly compatible with each other. In most cases, there is no idea for existence other than "we made it, come here."‚Äã

JAM, on the other hand, offers a unified approach with reasonable modularity. Instead of immediately creating something complex with a large number of features unnecessary for most users, instances can be made more targeted for specific cases.‚Äã

And this applies not only to cases for companies and enterprises but also to more global and widespread things such as payment systems, data verification, creating common economic layers for a series of games or games from one studio. This also includes cases similar to Hyperliquid, and so on.‚Äã

At the same time, unlike AVS (Networks, and so on in different protocols) for restaking, which is actually properly developed only in EigenLayer, there is no need for an extra layer of "restaking." Moreover, the idea of restaking over the long term seems somewhat questionable because economically it does not work as expected.‚Äã

And JAM looks like something that is in superposition relative to all these options: it does not have the disadvantages of the above options but at the same time possesses their advantages.
2025-03-28 15:21 gav: The JAM `top` is coming on - hope to release it soon along with a provisional node RPC spec so it can be used on all conformant JAM impls.
2025-03-28 15:21 gav: image.png
2025-03-28 15:24 boymaas: Aaah this is why we are implementing 6.4 üòÄ üòâ
2025-03-28 15:24 gav: Indeed:)
2025-03-28 17:59 sourabhniyogi: Schelling point request: should we consider host calls to log as having gas 10 or gas 0 --  https://hackmd.io/@polkadot/jip1 -- totally arbitrary choice right now, just want to pick one of the two. [edited]
2025-03-28 18:14 gav: gas zero - updated hackmd [edited]
2025-03-28 18:29 emielsebastiaan: > <@sourabhniyogi:matrix.org> Schelling point request: should we consider host calls to log as having gas 10 or gas 0 --  https://hackmd.io/@polkadot/jip1 -- totally arbitrary choice right now, just want to pick one of the two.

Non zero gas would potentially alter the flow of anything you‚Äôd wish to debug. So 0 gas please. 
2025-03-29 06:37 clearloop: may I ask what's the correct version of `ark-ec-vrfs` at 0.6.4? the [README](https://github.com/davxy/jam-test-vectors/tree/polkajam-vectors/safrole) specified 0.1.2 while it is yanked on crates.io

---

we are now using https://github.com/davxy/ark-vrf/tree/main?rev=bf2d1cf, everything works now [edited]
2025-03-29 07:33 davxy: > <@clearloop:matrix.org> may I ask what's the correct version of `ark-ec-vrfs` at 0.6.4? the [README](https://github.com/davxy/jam-test-vectors/tree/polkajam-vectors/safrole) specified 0.1.2 while it is yanked on crates.io

`ark-ec-vrfs` v0.1.2 works with 0.6.4.
However, future development will be done on [ark-vrf](https://github.com/davxy/ark-vrf) which is currently basically the same.


2025-03-30 16:21 snowmead: For the PVM definition A.1, is it intentionally left up to the implementor to avoid calling `deblob` for every subsequent recursive call for the same program blob `p`? 
2025-03-30 16:22 snowmead: or is there some reason behind this?
2025-03-30 17:15 gav: > <@snowmead:matrix.org> For the PVM definition A.1, is it intentionally left up to the implementor to avoid calling `deblob` for every subsequent recursive call for the same program blob `p`? 

How would you imagine a recursive call into a program blob?
2025-03-30 17:23 snowmead: couldn't we just `deblob` once before and call a recursive function (which internally calls `psi_1` single step function)? 
2025-03-30 17:26 ascriv: > <@snowmead:matrix.org> couldn't we just `deblob` once before and call a recursive function (which internally calls `psi_1` single step function)? 

Should still fit the gp specifications I think, happy to be corrected
2025-03-30 17:30 ascriv: This is how I ended up interpreting it so I‚Äôm particularly eager to be corrected lol
2025-03-30 18:32 gav: The Gray Paper only states observable behaviour. The performance tests, when benchmark requirements are published, may imply certainly implementation optimisations.
2025-03-30 18:33 gav: For M1/M2 such optimisations are not *required*, but might be sensible to do regardless.
2025-03-30 18:40 gav: signal-2025-03-26-164136.mp4
2025-03-30 18:40 gav: Almost finished!
2025-03-30 19:01 emilkietzman: That‚Äôs amazing, can‚Äôt wait for the results. The real question is the jacuzzi ready to handle the heat!
2025-03-31 08:06 gav: > <@gav:polkadot.io> Almost finished!

I should say, almost finished phase 1 of 2. This is 80 machines of 87 for phase 1. Phase 2 will double that to 173. Each machine has 96 threadripper cores in it. 
  ‚Ü≥ 2025-03-31 10:22 sourabhniyogi: There are many teams with tiny testnets (all independently) producing blocks that are now likely ready to have pair wise interactions with other teams. Should we do this outside of the toaster this spring / summer (because we haven‚Äôt even passed M1) or be trying to get teams to do this within it (so as to get teams get jamnp networking right well before M1/M2 have been formally passed)?  [edited]
  ‚Ü≥ 2025-03-31 10:43 gav: Evaluating and passing M1 should start before end of June; davxy is working hard on getting those conformance tests and 0.7.0 is [within sights](https://github.com/gavofyork/graypaper/milestone/3).
  ‚Ü≥ 2025-03-31 10:44 gav: I don't think running on the Toaster makes much sense until both M1 and M2 functionality exists, and also certain RPC and structured logging functionality is in place.
  ‚Ü≥ 2025-03-31 10:46 gav: We can probably publish a draft spec for tooling-facilitating RPCs quite soon (maybe this week, if it's a high-enough priority). Structured logging format is not yet started AFAIK but should be on the horizon as the Toaster comes online and erin and Arkadiy begin writing the relevant tooling to analyse and visualise it.
  ‚Ü≥ 2025-03-31 11:18 sourabhniyogi: Looking forward to RPC + structured logging functionality details!  Can we aim to make this coordination a central topic in the May Lisbon meetup?
  ‚Ü≥ 2025-03-31 13:20 gav: https://hackmd.io/@polkadot/jip2
  ‚Ü≥ 2025-03-31 13:20 gav: It really needs putting in a more standard form, but hopefully it's helpful as-is.
  ‚Ü≥ 2025-03-31 13:20 gav: If these RPCs are properly implemented then the JAM tooling I've been writing should work with the node.
  ‚Ü≥ 2025-03-31 13:21 clearloop: seems this week just passed in minutes ...
  ‚Ü≥ 2025-03-31 20:54 xlchen: is this JSONRPC or HTTP GET? how are the parameter and responses encoded? JSON or JAM codec?
  ‚Ü≥ 2025-03-31 20:55 xlchen: given the subscriptions methods, looks like JSONRPC over WebSocket?
  ‚Ü≥ 2025-03-31 20:58 xlchen: the types reads like thing should be JAM codec encoded? because otherwise Hash/Blob should really be encoded as hex string instead of array of numbers
  ‚Ü≥ 2025-03-31 22:14 sourabhniyogi: Looks comprehensive but the big "obvious" objects appear to be missing:

1. _block_ - Returns block with the given header hash, or null if this is not known.
2. _state_ - Returns C1-C15 with the given header hash, or null if this is not known.
3. _workPackage_ - Returns work report (including availability spec) with the given work package hash
4. _segment_ - Returns back segment given (requestedHash, index) (either work package hash or exported segments root) from Segments DA

Are these meaningful to add to jip-2?
 [edited]
  ‚Ü≥ 2025-03-31 22:16 sourabhniyogi: Surely, everyone will naturally want content-type choice (JSON vs JAM Codec) in the responses and expect JSON to match up with w3f / davxy choices.
2025-03-31 14:54 gav: I updated my (unofficial) Prize notes: https://hackmd.io/@polkadot/jamprize
  ‚Ü≥ 2025-03-31 21:12 xlchen: can I confirm that generative AI is ok (or not) for:
write documents
write tests
code review
help reading GP
doing research (e.g. how to write a recompiler)
write code that's not covered by GP (e.g. RPC or CLI handling). In theory, those code should not be judged? [edited]
2025-03-31 14:55 gav: They now include the two additional paths for prizes (non-PVM and light-client)
2025-03-31 14:55 gav: This will still need to be discussed and ratified at W3F level. But should give the right flavour.
2025-03-31 14:58 gav: I gave the non-PVM path a conversion option to get almost the same prize as the regular path; it's not quite the same (450,000 vs 500,000) since there's a slight desire to get at least one or two teams building a recompiler soonish.
2025-03-31 14:58 gav: It would be helpful to have a show of hands how many teams plan to go for which prize path. Maybe ü™∂ for light-client path, üé∏ for authoring including PVM and ü§† for non-PVM authoring. [edited]
2025-03-31 15:02 gav: Note that for teams who use one language for business logic but another for specific subcomponents in order to achieve sufficient performance, your language set will be that of the business logic as long as the second language is very clearly limited to the subcomponents and the subcomponents are properly scope-limited. [edited]
2025-03-31 15:06 emielsebastiaan: Most likely ü§† too many performance related research unknowns at this point to aim for üé∏. 
2025-03-31 15:10 ascriv: ^similar boat aiming for guitar but may go cowboy at m3
2025-03-31 15:13 oliver.tale-yazdi: JamBrains is working on authoring with PVM-interpreter, recompiler is currently not planned
2025-03-31 15:16 jay_ztc: I'm very excited to open source my pvm recompiler implementation soon(ish). Following the naturally emergent api boundaries from the GP & reusability across different projects & languages have been design priorities since day 1.
2025-03-31 16:19 jaymansfield: Is there still a talk planned about how to achieve a high performance recompiler? I think I recall seeing something mentioned here in the past.
2025-03-31 17:45 finsig:  Time permitting Martlet will try for ü§†, otherwise ü™∂.
2025-03-31 19:24 tomusdrw: Would be cool to get confirmation if I'm getting the incentives & options for non-fast-set languages right. I'd love to target üé∏ however it might be just impossible to reach the performance requirements, and by investing time&effort into this I'm risking being outpaced by ü§† & ü™∂, right? So with 50k DOT penalty it seems just safer to go ü§†, isn't it? (450k DOT vs 0) [edited]
  ‚Ü≥ 2025-04-01 05:29 clearloop: cowboy in avatar & emojis
  ‚Ü≥ 2025-04-01 11:22 gav: Yeah it'll depend on how much confidence you have in your language(s) of choice. There's only a limited number of spaces for ü™∂ in each language set and they only fetch half the amount, so being outpaced by them at least seems unlikely.
2025-03-31 19:42 danicuki: This is an optional (but I highly recommend) after activity for those who come to JAM Experience in Lisbon:

On May 8th, there will be a very talented and high quality Brazilian music gig at the Lisbon Colosseum. Buy your tickets if you wanna go:

https://www.bol.pt/Comprar/Bilhetes/155009-diogo_nogueira-coliseu_de_lisboa/Sessoes
2025-04-01 06:02 clearloop: our team have good background in compiler and super interested in implementing a re-compiler for fun, however we'd like to target ü§† first since it's safer, we may implement a re-compiler only after passing ~~M4~~ MN4 (else if we can finish it in one week) [edited]
2025-04-01 06:04 jan: You most likely won't be able to pass M3 without a recompiler, nevermind M4. (Unless you mean the non-validating MN4 milestone.)
2025-04-01 06:05 clearloop: can't we use polkaVM for M3 & M4? the non-PVM path? [edited]
2025-04-01 06:08 jan: So you meant the non-validating milestones. Those are called `MN3` and `MN4` in Gav's document. Please use proper unambiguous naming, otherwise it's very confusing.
2025-04-01 06:10 dakkk: > <@jan:parity.io> So you meant the non-validating milestones. Those are called `MN3` and `MN4` in Gav's document. Please use proper unambiguous naming, otherwise it's very confusing.

Which document?
2025-04-01 06:11 jan: The one that Gav posted a few message ago here: https://hackmd.io/@polkadot/jamprize
2025-04-01 06:11 dakkk: > <@jan:parity.io> The one that Gav posted a few message ago here: https://hackmd.io/@polkadot/jamprize

Thx
2025-04-01 06:58 vinsystems: What are the incentives for people to run a light node? What do they bring to the JAM network?
2025-04-01 07:00 bkchr: Light nodes are being run by the people wanting to interact with Jam/services on top of it 
2025-04-01 07:00 bkchr: Not by any other operator 
2025-04-01 07:01 bkchr: And you get trustless access to the chain, as you are verifying the signatures of the blocks etc. 
2025-04-01 07:01 xlchen: there won't be RPC nodes for JAM chain. you have to run a light node to access jam chain data like best block hash etc [edited]
  ‚Ü≥ 2025-04-01 07:03 chungquantin: I'm curious where this info is mentioned? Would love to read more about it.
  ‚Ü≥ 2025-04-01 07:04 xlchen: somewhere in this room üíÅ‚Äç‚ôÇÔ∏è
  ‚Ü≥ 2025-04-01 07:04 xlchen: we don't have much docs about the non GP part as nothing is finalized. we have some ideas of how things should look like, but until some PoC, we can't say for sure it will work
  ‚Ü≥ 2025-04-01 07:07 xlchen: https://hackmd.io/0gSmXyElT2iKawymS5jJKw?view this maybe useful
  ‚Ü≥ 2025-04-01 07:07 chungquantin: I see, thanks for the resource! 
  ‚Ü≥ 2025-04-01 07:15 bkchr: With polkadot we tried to be light client first, but if you don't force people to use it, no one is gonna do it. Or ultra slow 
2025-04-01 11:15 gav: yes!
2025-04-01 11:17 sourabhniyogi: JAM Game of Life demonstration (from www )
 https://www.youtube.com/watch?v=lvkF7i6pmR8

2025-04-01 11:32 ascriv: > <@sourabhniyogi:matrix.org> JAM Game of Life demonstration (from www )
>  https://www.youtube.com/watch?v=lvkF7i6pmR8
> 

Neato 
2025-04-01 13:35 qinwenwang: Hi everyone, I am thrilled to release the Chinese Version of JAM Gray Paper DRAFT 0.6.4. on https://www.lollipop.builders/JAM-Graypaper-Chinese.pdf ÔºõI look forward to feedback, discussions, and further support Mandarin speaking dev community for JAM 
2025-04-01 22:08 jay_ztc: is the repo for the jam-types crate public? noticed the transfer memo length doesn't match the GP spec and was going to open an issue. The gh link on crates.io is 404. [edited]
  ‚Ü≥ 2025-04-03 15:36 jan: Not currently. It's released from our private polkajam repo.
2025-04-03 15:28 clearloop: curious about how do you like your PVM interfaces so for? after following the invocation interfaces strictly, my PVM interpreter turns into functional style finally, it's cool but the function signatures just have too many arguments, I'm thinking of that we may need more composed types defined in GP for the PVM part
2025-04-03 15:48 jan: Do you want to know how my interfaces look like, or are you looking for suggestions? :P If so I'd probably suggest a traditional fetch + eval interpreter loop at a bare minimum, plus a stateful interface to control it. The GP isn't really an implementer's guide and its equations have no bearing on how something should _actually_ be implemented; sure, you can translate its equations directly into code, but you'll be killing your performance by doing that, so for any non-toy implementations I'd probably suggest not to do that (especially for PVM, where you can make your situation potentially orders of magnitude worse even compared to a basic straighforward traditional interpreter design). :P [edited]
2025-04-03 16:02 clearloop: while considering supporting both interpreter and re-compiler in the same interface, we have an abstraction layer for PVM interfaces ( also it is caused by the design of our runtime, things like PVM, validator, storage, and even the network implementation are modular ), so I'd like to confirm if the PVM interfaces in the GP has already been the standard, if so, I'll keep following it atm, otherwise my hands are not tied
2025-04-03 16:09 jan: The GP doesn't define any PVM interfaces in the sense of an interface in a programming language; again, it describes the visible *behavior* of a JAM implementation, but doesn't specifically require *how* that behavior should be achieved. There's no standard PVM interface, and even if there were one it'd most likely look very very different than what the equations in the GP suggest, assuming its intended use would be as an abstraction layer over multiple PVM implementations for a production JAM node.
2025-04-03 16:17 jan: If you want some inspiration on how to structure your interfaces I'd suggest to look at some of the production VMs out there and see how they do it.

For example, some of the WASM VMs:

wasmtime - https://docs.rs/wasmtime/latest/wasmtime/
wasmi - https://docs.rs/wasmi/latest/wasmi/
wazero - https://pkg.go.dev/github.com/tetratelabs/wazero

Or even just look at my interfaces:

https://docs.rs/polkavm/latest/polkavm/struct.Module.html
https://docs.rs/polkavm/latest/polkavm/struct.RawInstance.html

(Feel free to copy them if you want; it's just an interface, and I wouldn't consider it collusion or plagiarism - there isn't really anything super JAM specific in there, and all of it is fairly straightforward if you have any experience with working with VMs.)
2025-04-03 16:19 clearloop: I'm mainly following the interfaces of wasmtime as well since I used to be a WASM developer üôà
2025-04-03 16:26 sourabhniyogi: How shall teams get started with PVM recompilation?  We are ready to plunge into this to get the 50x gains.
2025-04-03 16:30 jay_ztc: clearloop | SpaceJam: I would consider the idea of a "naturally emergent api"-> a product of the GP api & what is practical given todays hardware. I'm actively working on this, more to come soon. [edited]
  ‚Ü≥ 2025-04-03 16:38 clearloop: sounds dope! I'm about to stop talking about PVM here today otherwise I'd like to implement a re-compiler as well now xd, can't afford to race with you since we haven't even finished the runtime part yet ü´†
2025-04-03 16:36 sourabhniyogi: For [CE128 Block request](https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-128-block-request) I _strongly_ agree that a 4-byte (or compact) length prefix preceding each block would be useful.  The additional bandwidth savings from _not_ having this length-prefix is %-wise not meaningful -- if bandwidth savings mattered _that_ much, you could get those savings much more easily (and a bit less work!) by changing the "little-endian 32-bit unsigned integer" [here](https://github.com/zdave-parity/jam-np/blob/main/simple.md#messages) to compact form.   What do you think?
  ‚Ü≥ 2025-04-03 16:38 sourabhniyogi: image.png
  ‚Ü≥ 2025-04-03 16:38 sourabhniyogi: ^ context from last year
  ‚Ü≥ 2025-04-03 16:42 dave: Would rather not change SNP without a really good reason. It's just a temporary protocol; it's not intended to be the final protocol used by JAM. If you open an issue in the repo we can address things like this in the full protocol
  ‚Ü≥ 2025-04-03 16:46 sourabhniyogi: The really good reason is that its not "simple" and creates a lot of pointless busy work.
  ‚Ü≥ 2025-04-03 16:46 dave: How is it not simple?
  ‚Ü≥ 2025-04-03 16:46 dave: Just read the message into a vector and then decode blocks from it
  ‚Ü≥ 2025-04-03 16:46 dave: This is what polkajam does and it's not particularly complicated
  ‚Ü≥ 2025-04-03 16:47 sourabhniyogi: It should not be a requirement to force implementations to decode with streaming when you can just add a length prefix.  Why is this so important to NOT have the length prefix?
  ‚Ü≥ 2025-04-03 16:48 dave: There is a length prefix on every message
  ‚Ü≥ 2025-04-03 16:49 dave: There isn't one for each block in this case. This is something I'm happy to change in the full protocol but it doesn't seem like a big issue honestly
  ‚Ü≥ 2025-04-03 16:51 sourabhniyogi: I am asking for a length prefix for each block in the array of blocks in the CE128 response.  
```
<-- [Block]
```
so that the boundaries between Block X and Block X + 1 are trivial to identify, and don't require decoding the individual pieces of each block just to identify that boundary.  

We are happy to do the busywork, as will a dozen other teams, but just to save a few bytes seems quite unnecessary.
  ‚Ü≥ 2025-04-03 16:52 dave: It's not to save a few bytes, I'm not sure why anyone thinks that is the case. It's simply to avoid the protocol being a moving target. Of course if there are actual issues with the protocol that need to be fixed we can do that, but things like this don't seem particularly important to me [edited]
  ‚Ü≥ 2025-04-03 18:37 sourabhniyogi: Ok its great to know at least one thing is not a moving target!
  ‚Ü≥ 2025-04-04 13:28 tomusdrw: That's a bit weird of an argument imho. if the protocol stated it's a var-len sequence of blocks there wouldn't be any boundaries either.

The only issue I see with this particular encoding is that it's neither var-len sequence nor fixed-len sequence (we don't know the length upfront) as specified in GP, but rather a concatenation of block encodings. [edited]
  ‚Ü≥ 2025-04-04 13:29 sourabhniyogi: It doesn't matter, we'll take the "its not a moving target" to be a relief =)
  ‚Ü≥ 2025-04-04 18:43 gav: > <@tomusdrw:matrix.org> That's a bit weird of an argument imho. if the protocol stated it's a var-len sequence of blocks there wouldn't be any boundaries either.
> 
> The only issue I see with this particular encoding is that it's neither var-len sequence nor fixed-len sequence (we don't know the length upfront) as specified in GP, but rather a concatenation of block encodings.

That‚Äôs a regular sequence encoding as specified in the GP. 
  ‚Ü≥ 2025-04-04 19:40 tomusdrw: Sure, it is, but the receiver does not know how many elements is there.
From that perspective a variable-length sequence encoding (with a length discriminator) is not needed at all.
Obviously there is a much better-defined boundary of the items in sequence (end of the byte stream vs not-matching encoding), but still I'd argue that this kind of usage of fixed-length encoding is rather a peculiar case. [edited]
2025-04-04 18:46 gav: GP requires the double-end-vertical-arrow prefix notation in order to prepend a length. GP doesn‚Äôt state that it *must* be used when the sequence length may not be static, and indeed there are instances (like hashing) where it may reasonably be omitted even if the sequence is of variable length. 
2025-04-04 18:47 gav: Streaming, or decoding from a known size container, would be other such instances. 
2025-04-04 20:26 gav: Again would not be correct to call it a ‚Äúfixed length encoding‚Äù.  [edited]
2025-04-04 20:26 gav: It‚Äôs  just not prefixed with the number of elements. 
2025-04-04 20:27 gav: So most of the time the length prefix will be used when there isn‚Äôt a fixed number of elements but correlation is not equivalence. 
2025-04-04 20:28 gav: As for the wisdom of prefixing with the sequence length or not in this case, I agree it is arguable. 
2025-04-04 20:29 gav: But it‚Äôd be wrong to characterise it as literally incorrect on the mistaken basis that the length prefix strictly *implies and is implied by* the condition of the underlying data being defined as have a fixed length.  [edited]
2025-04-04 20:33 gav: There are already multiple instances in the GP where sequence term with non-fixed length is encoded without the length prefix.
2025-04-04 20:35 gav: And on a more general note, the GP doesn‚Äôt use any kind of formal typing; 42 is 42 whether it is in N_{256} or N_{2^32}. With this set theoretic syntax it is not actually possible to reason about whether the data is fixed or variable length from the perspective of the value itself. 
2025-04-04 20:36 gav: So it‚Äôs best to use terminology that reflects the formalism. 
2025-04-07 10:59 emielsebastiaan: Hello all,

I'd like to kick off a little discussion we had internally in our team meeting recently regarding our collective approach in working towards a public testnet.
Last October in Bangkok those attending JAM0 have initiated an initiative to converge towards a community testnet, called the JAMduna Testnet.
Me and my team believe this is an admirable objective, however we have some worries about potential conflicts with the JAM-prize rules, that may warrent discussion and ideally clarification from W3F and/or Gavin.

The official rules state the following: 
- Rule 6: "Clean-room implementation using the Graypaper and public implementers' channel as the only resources."
- Rule 8: "Relevant private (not in the public implementers' channel) conversations with other implementers must be declared and summarised in reports to the Fellowship."
- Rule 18: "Implementations must pass all relevant public and private conformance/performance tests. These will be shared in the near future."

Gav's Unofficial notes add to rule 6:
- Additional materials may be added here at a later stage.

What we like about the Testnet:
- We believe some coordination is absolutely necessary in order to get to the minimum necessary agreement on practical testnet setups.
- Coordination towards a testnet in our opinion is no different than coordination around the W3F Test Vectors. Like the community findings of W3F Test Vectors, the community findings in the testnet repo lead to higher quality implementations, findings of errors and ambiguities in Graypaper and findings of errors in the W3F Testvectors.

What we are concerned about with the Testnet
- Discussions and thus coordination activities are increasingly happening on other channels like Telegram and Discord (read: NOT the public implementers' channel on Matrix). These channels are arguably public since they were once referenced on the Matrix channels, but these are separate channels that could potentially unlevel the playing field or create an entry barrier.
- Rule 6 and 18 do not explicitly state the Testnet resources to be accepted as a source of coordination (as for the W3F Testvectors for the record).
- Obviously any resource outside Graypaper allows for potential blindspots to emerge (collective misinterpretations). There is however a trade-off to be made here.

Questions we have:
- Is there a risk of JAM-price penalty when a team collaborates on the initiative towards a public testnet?
- Can we classify the JAMDUNA testnet repository in the same category as the W3F Testvectors? And perhaps add this to the (unofficial) rules ("Additional materials may be added here at a later stage"). Or agree on what needs to happen to make this so.
- Can we agree on some do's and dont's in working towards the testnet?

Let's use this thread to have a discussion about this.
2025-04-07 12:22 gav: The rules are there for a reason. Disregarding them, in particular with setting up additional semi-private, invitation only or even merely difficult to discover channels for teams to exchange notes and ideas would endanger those teams ability to claim the prize. [edited]
2025-04-07 13:01 emielsebastiaan: Thank you. Nothing new here, but this strengthens our concern regarding the additional channels.
We are of the opinion that participating in Telegram and Discord channels might not be smart (free advice) when discussing findings, GP-ambiguities, and similar things.

Follow-up question I have:
1. Are current W3F Test Vectors considered public conformance tests? These have proven to be a source of finding Graypaper mistakes and ambiguities.
2. Can JAMDUNA testnet traces (https://github.com/jam-duna/jamtestnet) be considered public conformance tests equally? These have proven to be a source of finding Graypaper mistakes and ambiguities.
3. Can JAM-Docs (https://github.com/jambrains/jam-docs) be considered a public resource for JAM Implementor teams?

When considering (2) and (3) these in contrast to (1) are not listed in the Resources section on Graypaper.com.
There is a collective payoff in these initiatives (better graypaper) and individual payoff (additional source of finding mistakes in your implementation).

4. IMO it would be smart to keep a good accounting record of the list of things your team got from these unofficial resources and the list of things your team contributed to the community due to these unofficial resources.

5. Is working towards to public testnet (JAMDUNA initiative) in its core an activity that might conflict with JAM Prize rules?
2025-04-07 13:16 gav: With regards to a testnet, it‚Äôs a little complicated. In principle I think it is admirable and wonderful to see teams so keen on pushing things forward. It‚Äôs a good ‚Äúproblem‚Äùto have. But indeed it could be a problem. My main concern is over the accessibility of such a network - there are perverse incentives because of the (regrettably necessary) first come first serve nature of the prize. A secondary concern is that those partaking in it may inadvertently get extra ‚Äúknowledge‚Äù over conventions and customs which others do not. This is exasperated by communications happening outside of the two official channels. 
2025-04-07 13:16 gav: 1. Yes, this is the aim. 
2025-04-07 13:18 gav: 2. Feel free to report GP ambiguities or clarification questions that arise from this. Feel very free to publish them.  They cannot be considered official requirements though as there is no W3F review process in place. 
2025-04-07 13:19 gav: 3. No it cannot. It may very be a helpful resource but only the GP is official for the JAM prize. 
2025-04-07 13:20 gav: Even JIPs/RFCs are unofficial conventions until/unless they move or are referenced by the GP. 
2025-04-07 13:21 gav: 5. Potentially yes. 
2025-04-07 13:23 emielsebastiaan: I get your concern about a public testnet, which given your statement may not be smart to pursue.
That said, so far no such public testnet exists only coordination on how such testnet could be set up. 
Is this where a line should be drawn? 

One interesting snippet from my team meeting:
Team member: Gavin's team was looking at the JAMDUNA testnet repository. So it is okay.
My paranoid response: Gavin's team might not be pursuing JAM Prize payout.

2025-04-07 13:23 gav: In so much as conformance to an unofficial testnet has no direct relevance to the GP and thus could be considered either a distraction or outright dangerous for consensus (by forming sub-dialects of the protocol). 
2025-04-07 13:23 gav: Well, naturally I‚Äôm interested to see!
2025-04-07 13:25 gav: But the purpose of the prize is to maximise team independence and expertise. To the extent that an unofficial testnet works in favour of this, I‚Äôm in favour. But it‚Äôs a judgement call, and ultimately i believe it possible for teams to cross the line in pursuit of *their* consensus. Resulting in a case of structurally reduced consensus among JAM impls as a whole.  [edited]
2025-04-07 13:27 gav: I think provided the testnet is 100% open, zero-barrier and responsible to W3F/Fellowship it‚Äôll be fine.
2025-04-07 13:29 gav: Which is precisely why I‚Äôd prefer to limit testnets to the toaster and meet-ups where all teams get an invitation, open access is clear, and communications are recorded for those not present to benefit from
2025-04-07 13:32 emielsebastiaan: Yes I agree fully. I was concerned enough to ask for clarifications. Dropped this here so we can have an open discussion about these things. Thank you Gavin!
2025-04-07 13:44 gav: Without making any promises, I‚Äôd say that outside of the get-togethers, 0.7.0 would be the time to start a persistent, open access, public testnet. It will likely need to be reset on subsequent GP releases (with an appropriate delay to give teams a chance to catch up to any changes).
2025-04-07 14:19 oliver.tale-yazdi: The jam-docs website explicitly mentions to only contain information that is _not_ part of the GP. Which is how I hoped to avoid any controversy around it.  
But I guess the intro sentence still contains the prize link, which can be misinterpreted [edited]
2025-04-07 14:22 sourabhniyogi: This repo has been 100% open for a while -- and we (and many other teams) have learned a ton, not via private communications but via several dozen issues referencing GP equations and derivations (and in a few cases, asking for clarifications)

https://github.com/jam-duna/jamtestnet/releases/tag/0.6.4.4
https://github.com/jam-duna/jamtestnet

So far, there is nothing much in the way of teams actually connecting to each other
https://github.com/jam-duna/jamtestnet/issues/69
Last week was the only connection we made, with the primary discovery that we had to lowercase our SAN, and that we needed to address CE128 multiblock responses.  These conversations can definitely be 100x noisy and require a "did you get header hash 0x4e37..." type level real time communication pattern -- WAY too noisy for a room with several hundred people and I think, a few dozen teams in a "jamtestnet" room, whether for the toaster or just for 2 teams to figure out wire format bugs and QUIC connectivity.   

So far the "jamtestnet" is a total misnomer -- more accurately it can be called "importblocksalignment" but, with a half dozen having achieved that alignment, its possible to achieve real "accumulate-side" testnet alignment, with actual import blocks happening from genesis onwards!

From [this](https://github.com/jam-duna/jamtestnet/issues/69) there are actually only a few teams actually both wanting and ready to participate in a testnet.  Given the "the testnet is 100% open, zero-barrier" requirement, we can quell any "could you make this a little less noisy" type complaints by doing all this testnet work in a public room.  Does it matter if its Discord, Telegram or Matrix?  Or should we just shut down the jamduna/jamtestnet repo and wait for the Toaster? [edited]
2025-04-07 14:28 sourabhniyogi: If Matrix is best, we currently have a "JAM Implementers" room with 59 people -- I have made that public and this could be used to have super noisy testnet work all done in public to meet the "the testnet is 100% open, zero-barrier" goal -- is that the best answer? [edited]
2025-04-07 14:29 emielsebastiaan: My concerns are a reflection of my team‚Äôs internal discussions. It is not a critique of any kind. Simply a note of caution and an attempt to open the discussion of avoiding consensus blind spots. Some great takeaways for everyone in this thread. 
2025-04-07 14:35 rick: can confirm, i'm (goberryjam) a ways from being able to participate in a testnet.. I expect to not be the first in my category but hopeful to make useful contribution in the form of some high quality golang components folks can work into their implementations once we go more open. 
2025-04-07 15:15 p1sar: With all due respect, the concern that participants might "inadvertently gain extra 'knowledge'" not shared by others could just as easily apply to someone attending the PBA or other University, for instance, compared to someone who did not.
2025-04-07 15:48 emielsebastiaan: The PBA example does not have the effect of a slippery slope of compromising implementation/team independence.  
2025-04-07 16:01 sourabhniyogi: I suggest we make this a topic on next weeks call =)
2025-04-07 16:08 sourabhniyogi: For JAM Implementers who may not be aware, this room is now public: 
 https://matrix.to/#/!KKOmuUpvYKPcniwOzw:matrix.org?via=matrix.org&via=parity.io
PARTICIPATE AT YOUR OWN RISK =)


2025-04-09 03:23 xlchen: I am confused about CE128 block request https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-128-block-request

> Note that blocks directly contain only the hashes of included work-reports and preimages. If unknown, the actual work-reports and preimages should be requested using protocols 136 and 143 respectively.

and

> Block = As in GP

but blocks defined in GP already contains the work report and preimages, not just the hashes of them?
  ‚Ü≥ 2025-04-09 08:52 dave: Yeah I think this and/or the GP needs updating. Blocks requested via CE128 are not intended to include reports/preimages. The idea is that the vast majority of the size of a block will be reports, and in practice these are distributed to all validators in advance, so it's a waste of time and bandwidth to distribute them again with new blocks
  ‚Ü≥ 2025-04-09 08:54 xlchen: I see. So is not `As in GP` at current version. It will be a LightBlock or something that the preimages and work reports will be replaced by a hash?
  ‚Ü≥ 2025-04-09 08:54 xlchen: I will do full block for now until the light block is defined
  ‚Ü≥ 2025-04-09 08:56 xlchen: but this is the simple protocol... so maybe just keep it simple? or we are expecting the simple protocol should be as close as possible to the final protocol?
  ‚Ü≥ 2025-04-09 09:30 dave: Full block for now is reasonable. It's effectively what is specified and is what eg Polkajam is currently doing. I'll remove this wording that implies light blocks for now. Light blocks are still the plan for the full protocol, and _may_ be necessary to add to SNP for performance reasons
2025-04-09 15:15 snowmead: quick question: is it ok to rely on the ASN type definitions in the test vectors to quickly create the basic objects and types in our implementation? Obviously I would be validating these types as I implement the protocol and correct any mismatch [edited]
2025-04-09 16:40 codingsh: Hi guys! Is it possible for coretime to become a governance model on JAM? 
2025-04-09 16:46 erin: > <@codingsh:matrix.org> Hi guys! Is it possible for coretime to become a governance model on JAM? 

coretime is not a governance model, it is a market for allocation of blockspace. governance is much more nuanced and can control many more things than blockspace allocation 
2025-04-09 16:56 codingsh: > <@erin:parity.io> coretime is not a governance model, it is a market for allocation of blockspace. governance is much more nuanced and can control many more things than blockspace allocation 

Thank you, I‚Äôve been thinking about PVM, and the need for coretime to be executed today is very cheap, but when we have global adhesion. who has coretime could determine what will be executed?
2025-04-09 16:59 erin: It is a permissionless system. With both coretime and JAM whoever pays for the computation time is able to run what they would like to.
2025-04-09 17:02 codingsh: Awesome, Perfect! 
2025-04-09 19:25 davxy: The ASN.1 module included with the test vectors **should** map one-to-one with the types defined in the GP. If you notice any discrepancies:

- The GP is the authoritative source of truth.
- Please open an issue to report it :-) [edited]
2025-04-09 19:25 snowmead: thanks for letting me know
2025-04-09 22:05 sourabhniyogi: image.png
2025-04-09 22:05 sourabhniyogi: Can we get whoever did these Polkadot Icons here
 https://icons.polkadot.network/ 
to do a refresh for JAM?  I did some placeholders

2025-04-10 06:04 clearloop: interesting, however, seems the repo is outdated now https://github.com/w3f/polkadot-react-icons
2025-04-11 09:54 decentration: just to confirm for M1 in accumulate do we execute separate services in parallel or sequentially? i think i read somewhere that parallelizing services (in accumulate) will be a later version. [edited]
2025-04-11 09:58 clearloop: if I'm not mistaken ,we haven't had the test vectors for PVM integration in accumulate yet, mb ur talking about https://graypaper.fluffylabs.dev/#/68eaa1f/17b90017bb00?v=0.6.4 ? [edited]
  ‚Ü≥ 2025-04-11 10:11 decentration: hmm, but on the jam website:

```
5. PVM instancing, execution and host-functions
```

im interpreting this as do the pvm invocation using current pvm library such as `jam-pvm-common` (in my case using an FFI)... we dont have the vectors yet, but i imagine we should be expecting them to come for M1.  [edited]
  ‚Ü≥ 2025-04-11 10:13 decentration: yes re: sequential or parallel im talking about that part of the GP. where it says execute parallel, but i think i heard in a recent lecture that its currently sequential only... could be mistaken. 
2025-04-11 10:15 xlchen: m1 don‚Äôt have performance requirement so it is not possible to require parallel execution. it is not possible to tell if you generated the output in a single thread or 50
2025-04-11 10:17 decentration: ok makes sense
2025-04-11 11:45 jan: If I don't get screwed over by the airlines I should be able to join the JAM Experience, so I could probably host a talk about writing recompilers during it if there's interest.
2025-04-11 12:35 gav: 
2025-04-11 14:02 jimboj21: This would be super rad I would love to have this happen
2025-04-11 14:22 charliewinston14: I hope that you can record this and share online (or publish live) as not all teams have the funding to fly to portugal. Some of us are on the other side of the world and would benefit from this as well.
2025-04-13 12:44 sourabhniyogi: Can a JAM equivalent of this be put together now? https://spec.polkadot.network/sect-lightclient I believe this is valuable to set in motion this Spring with jip-2 paving the way for storage value proofs and "warp" and not-warp syncing (ie CE128) being a key thing to execute on with paths that jump over M3+M4. It appears natural to chart light client implementation plans first without GRANDPA and then with. [edited]
2025-04-13 13:37 sourabhniyogi: Instead of adapting "7.4.4 Remote Read Messages", I suggest a more proactive jip-2 method `subscribeBlock(withJustifications=true)` explicitly designed for light client verification that returns _all_ the storage value justifications needed to actually reexecute a JAM state transition.

Full node implementations responsive to light clients `subscribeBlock(withJustifications=true)` must track all storage values that are read from state trie and provide justifications of:
(a) pre-state C1-C15 that are actually read
(b) pre-state storage keys/values (including preimages + lookup) accessed via  host function calls: `read`, `lookup`, `solicit`, `forget`, `info`, `eject`, `query`, `transfer`, ...
(c) code in preimages referenced in all ordered accumulation

Light clients can verify all storage value justifications (a)-(c) (or some subset of them), then reexecute ordered accumulation (including PVM using verified code of (c)) just like full nodes do, and if they derive the same state root, the light client considers the individual JAM state transition valid.

To preserve "7.4.4 Remote Read Messages" JAM equivalent so that the light client just requests justifications for _some_ of the pre-state storage keys/values, presumably to not have a lot of bandwidth used up for justifications, then we would still want some parameter input of `subscribeBlock` enable returning _all_ the storage keys+values read in the state transition.

What else is needed?

All of this can be done without GRANDPA and warp syncing in one half of implementation, and then with.  Does that make sense? [edited]
  ‚Ü≥ 2025-04-13 22:30 dave: Maybe I'm not understanding but light clients shouldn't need to execute blocks or even need to fetch enough state to be able to do this. I understand you want to get something working without GRANDPA but that can be done by simply having the light client trust finality without verifying.
  ‚Ü≥ 2025-04-13 22:35 dave: Light clients will use the JAM network protocol (SNP or its successor). The RPC interface is really only intended to be used to connect to locally running nodes. This is for example to make it easy to write tools; instead of incorporating a node tools can just use the RPC interface of a standalone node. Long term it's possible that these tools will just incorporate a light client. In any case I think light client and RPC are probably mutually exclusive things.
  ‚Ü≥ 2025-04-13 22:41 dave: Of course SNP as it stands is not suitable for light clients. If you want something now you can make up your own extension to SNP, but bear in mind that this might not become the standard...
  ‚Ü≥ 2025-04-13 22:46 xlchen: speaking of extensions, it will be great if SNP support some basic implementation name / version discovery so that we can have some feature discovery / telemetry ability
  ‚Ü≥ 2025-04-13 22:53 dave: You can use QUIC/TLS ALPN for this. Obviously that's not going to work very well if there are many extensions, don't think we really want to get to that point though
  ‚Ü≥ 2025-04-13 22:56 xlchen: my main goal is know which implementation/version is the other side running. this can be helpful to for example workaround some bug in some legacy version or know where to report bugs if found out the other side is sending bad data
  ‚Ü≥ 2025-04-14 07:47 gav: Then ALPN should be fine, no?
  ‚Ü≥ 2025-04-14 07:50 xlchen: unless I missed something, ALPN is for protocol version negotiation, how can we use it to discovery the implementation version of peers? [edited]
  ‚Ü≥ 2025-04-14 08:02 gav: I think you can have a fairly arbitrary ID sequence, can't you?
  ‚Ü≥ 2025-04-14 08:02 gav: https://github.com/quicwg/base-drafts/wiki/ALPN-IDs-used-with-QUIC
  ‚Ü≥ 2025-04-14 08:02 gav: E.g. `http/2+quic/NN` allows specification of two protocols and their versions. [edited]
  ‚Ü≥ 2025-04-14 08:04 gav: We currently use `jamnp-s/V/H`, (`V` is protocol version and `H` is genesis hash) but we could extend this to include the impl ID and version? [edited]
  ‚Ü≥ 2025-04-14 08:05 xlchen: well, I am using `msquic`, and it requires a known list of ALPN https://github.com/microsoft/msquic/blob/e2a994c9dc91240147c9d079436d4e6daba75e79/docs/api/ListenerStart.md#parameters
  ‚Ü≥ 2025-04-14 08:05 gav: Sounds like that's not in line with JAM-SNP
  ‚Ü≥ 2025-04-14 08:05 gav: https://github.com/zdave-parity/jam-np/blob/main/simple.md
  ‚Ü≥ 2025-04-14 08:05 xlchen: I can fork it and do the necessary changes, but that's something I want to avoid if possible
  ‚Ü≥ 2025-04-14 08:06 dave: If you want an impl ID/name ALPN is not suitable
  ‚Ü≥ 2025-04-14 08:06 dave: We can add some protocol to request this if necessary
  ‚Ü≥ 2025-04-14 08:07 gav: Ahh I see it's a pattern match thing.
  ‚Ü≥ 2025-04-14 08:09 xlchen: yeah the purpose of ALPN is for protocol version negotiation. I don't think add impl name/version is the right choice
  ‚Ü≥ 2025-04-14 08:10 gav: Yeah then we can try to introduce this to JAM SNP.
2025-04-13 19:40 danicuki: > <@charliewinston14:matrix.org> I hope that you can record this and share online (or publish live) as not all teams have the funding to fly to portugal. Some of us are on the other side of the world and would benefit from this as well.

All content will be recorded and shared 
2025-04-14 00:13 sourabhniyogi: Hmm, for "shouldn't need to execute blocks or even need to fetch enough state to be able to do this" I think we should get on the same page about what a JAM light client should be.   I thought light clients re-execute the minimal state transition logic but _without having to store anything or process every state transition_ -- this means they need to get storage proofs, verify these storage proofs, and verify recent headers ( including the state root which requires doing PVM accumulation, and ordered accumulation at that ), in order to be a _trustless_ light client.   There is surely some 'I'm actually only interested in _my_ services' smarter approach to verifying the storage proofs, but to verify the state root it appears essential to do the PVM accumulation.

Light clients:

- download **and verify** block headers to stay in sync with the chain‚Äôs head. This includes the state root, which requires doing ordered accumulation, including PVM.
- verify that blocks have been finalized (which are GRANDPA finality proofs in both Polkadot+JAM).  I assume the last 28 days will be warp synced
- request storage proofs needed to validate a transition, which is/was the purpose of 7.4.4.

If you have low-powered light clients they can choose to pick some _subset_ of storage proofs (e.g. in a self-centered way, biased to just the services the light client cares about) for reduced security, but as you go from verifying all to verifying nothing, you go from "trustless" light client to "trust me bro, I'm infura" light client.

CE129 could be adjusted to fill the role of 7.4.4 but as of this moment it doesn't return Justifications and is optimized for range queries.  Another CE could be created for light clients to get storage proofs, but there still needs to be a source of which state trie keys have been read. [edited]
2025-04-14 07:48 gav: No.
2025-04-14 07:48 gav: Light clients sync to the most recent finalised block through a GRANDPA proof.
2025-04-14 07:49 gav: They do no re-execution of on-chain logic. Theoretically they could but it's super-cumbersome and it is not generally what is meant by "light-client".
2025-04-14 07:50 gav: Instead, they accept proofs of on-chain state through the (prior) state-root found in the header.
2025-04-14 07:50 gav: They trust this header/state-root because of the GRANDPA finality proof. [edited]
2025-04-14 07:51 gav: > as you go from verifying all to verifying nothing, you go from "trustless" light client to "trust me bro, I'm infura" light client

No.
2025-04-14 07:51 gav: You've totally missed the whole point of JAM/Polkadot's finality. [edited]
2025-04-14 07:53 gav: The point of finality is not merely to avoid reversion. It is also to place economic weight behind _correctness_. With our assumption of no more than 1/3 malicious nodes, GRANDPA will only finalize valid transitions, _including in-core logic_. [edited]
2025-04-14 07:54 gav: This means that trusting in GRANDPA gets a similar degree of security to trusting "JAM" more generally.
2025-04-14 07:56 gav: Now, of course, this is not (quite) as high a confidence level as actually executing everything yourself. But then this isn't practically viable anyway on a system as scalable as JAM/Polkadot firstly as the in-core computation has extrinsic data which is not made indefinitely available (e.g. parachain transactions in Polkadot's case); and secondly you'd need near Toaster-level hardware to re-execute all of the work-packages going through every core. [edited]
2025-04-14 07:57 gav: But this idea of (re-)executing everything in order to gain confidence in correctness is a Bitcoin mind virus.
2025-04-14 07:58 gav: It's not true. The Elves paper is an example of how it's possible to argue for correctness from first principles whilst not presuming (indefinite) ability to re-execute. zk-SNARKS offer another means for doing this.
2025-04-14 08:00 gav: In short, when GRANDPA finalises some state and you have a state-proof for some storage value against it, you can assume one of three things:
1. Elves/JAM/Polkadot has a design flaw nobody knows about.
2. More than 1/3 of validators are misbehaving.
3. It's correct.
2025-04-14 08:01 gav: It's certainly categorically better than your characterisation of "trust me bro, I'm infura". [edited]
2025-04-14 08:11 gav: [JIP-2](https://hackmd.io/@polkadot/jip2) is updated with a new `parameters` RPC.
2025-04-14 08:11 gav: This is intended to allow RPC clients to understand the parameters of the node's chain including number of cores and validators. [edited]
2025-04-14 08:31 xlchen: > <@gav:polkadot.io> I updated my (unofficial) Prize notes: https://hackmd.io/@polkadot/jamprize

can I confirm that generative AI is ok (or not) for:
write documents
write tests
code review
help reading GP
doing research (e.g. how to write a recompiler)
write code that's not covered by GP (e.g. RPC or CLI handling). In theory, those code should not be judged?
2025-04-14 08:32 gav: Most should be fine, yes. The only slight concern would be for GP interpretation.
2025-04-14 08:33 gav: Again, it's generally best to treat genAI as an indirect (and lossy) comms system.
2025-04-14 08:35 gav: And comms concerning GP interpretation is generally best done in easily-discoverable forums visible to all to maximise the chances of clean-room impl and minimise the chances of sub-dialects (inadvertently) forming. [edited]
2025-04-14 08:37 gav: It's written in both English and formal logic in order to minimise the chance of linguistic issues for non-native speakers; I would not expect genAI to help much here and it may easily introduce translation artefacts. In any case, I fear genAI has less of a chance of knowing what I intend the GP to mean than you would. [edited]
2025-04-14 08:57 xlchen: is there any disassembler works with output of `jam-pvm-build`? I tried `polkatool disassemble` and it doesn't work
2025-04-14 08:58 xlchen: ok tried this and looking good so far https://pvm.fluffylabs.dev/?#/
2025-04-14 09:01 jan: Yes, that currently doesn't work. It's just a matter of making a JAM blob -> `.polkavm` blob converter, which is on my TODO list (but PRs are welcome; it should be very simple to do, just do the reverse of what the `jam-pvm-build` does, since it converts a `.polkavm` blob into a JAM blob)
2025-04-14 09:15 sourabhniyogi: After JAM light clients sync to the most recent finalized block through a GRANDPA proof, and receive a set of unfinalized blocks, what verification does the light client do when there is no GRANDPA proof for those unfinalized blocks, if anything at all?  It appears that JAM light clients only will be verifying GRANDPA proofs, and would trust the node that they receive their unfinalized block.  

What was 7.4.4 for?   [edited]
2025-04-14 09:18 gav: > if anything at all?

None.
2025-04-14 09:19 gav: Light-clients are not intended to use unfinalized blocks.
2025-04-14 09:19 gav: User interfaces might interpret them and display them with some sort of "unconfirmed" annotation if there's any serious economic implication of them.
2025-04-14 09:19 sourabhniyogi: Ok thank you for clarifying!  Indeed, I have had a Bitcoin mind virus =)
2025-04-14 09:20 gav: But light-clients generally have no means of knowing.
2025-04-14 09:20 gav: Even re-executing the block doesn't help here - that's the Bitcoin mind virus. You'd have to not only re-execute the block but also re-execute all the cores (at least those that have causal-implications on the service storage you care about, which given the ability for transfers to happen in a block means, theoretically, all of them which can send messages to your service). [edited]
2025-04-14 09:22 gav: To re-execute the cores, you'd need to fetch all of the DA data they require and this is obviously waaaay too much to be doing for a *light*-client. It'd take > 6 seconds and then you may as well wait for GRANDPA. [edited]
2025-04-14 09:23 gav: So yeah, there's really no way around this, and that's by design. We want to off-load correctness entirely into the game-theoretic (staked) machinery. Not have it done by clients on the edges, light or otherwise. [edited]
2025-04-14 09:24 gav: Only this way can we expect to be able to scale to the levels we need (and still not be centralised). [edited]
2025-04-14 09:27 gav: One thing that we can almost certainly do, though not necessarily pre-1.0, is have GRANDPA finalize not only the block but also its posterior state-root. This should be a pretty trivial addition and would mean light-clients are able to get proofs over storage one block earlier than otherwise. Alistair is also considering introducing some other lightweight consensus over blocks produced, but not necessarily correct (i.e. not yet having passed Elves). This wouldn't help all that much for applications which have high economic implications but could help lower apparent UI latency for lesser applications especially if the finalised information included posterior state-root rather than just the header-hash. [edited]
2025-04-14 10:34 sourabhniyogi: Would you expect JAM light nodes going through [the light node path](https://hackmd.io/@polkadot/jamprize#Light-node) to verify this new (not necessarily ELVES-correct) lightweight "GRANDPA 2.0" consensus at the bleeding edge?

The "best vs finalized" bits in jip-2 is causing us to want to fill in the GRANDPA related pieces of JAMNP (which has no vote/commit/... GRANDPA yet so we made some up earlier) and go from little syncs to warp syncs.  Having the GRANDPA 1.0 proof and 2.0 path would be terrific as we are happily auditing WPs now and can connect the dots to "best block" now. [edited]
2025-04-14 10:47 gav: > Would you expect JAM light nodes going through the light node path to verify this new (not necessarily ELVES-correct) lightweight "GRANDPA 2.0" consensus at the bleeding edge?

Possibly, assuming it is in the GP. But given it's presently little more than an idea, it's hard to say for sure if it would be in the GP by 1.0. [edited]
2025-04-14 10:49 gav: > The "best vs finalized" bits of in jip-2 is causing us to want to fill in the GRANDPA related pieces of JAMNP

Sure. Already there's the [GRANDPA paper](https://research.web3.foundation/Polkadot/protocols/finality) if you want to begin implementing the internals. I expect we'll be able to introduce the protocol elements in the near future. [edited]
2025-04-14 10:49 gav: It's not yet amalgamated in to the GP but there's not all that much to do on that front as GRANDPA is quite self-contained.
2025-04-14 15:35 sourabhniyogi: Ok!  So that we may plan our GRANDPA execution, which milestones [there are now 5+5(+1)+3=14] require { GRANDPA finality, GRANDPA proof verification, warp syncing }?

Can you speak to how we may instrument our implementations to measure and report on required performance at the Lisbon meetup for all 3 paths?
2025-04-14 15:36 gav: Yeah I‚Äôll try to state it as well as possible. But for a basic idea it‚Äôll be in line with smoldot. 
2025-04-14 18:29 p1sar: Hello everyone!

This month‚Äôs JAM Implementers Call is happening a bit later than usual due to PBA ‚Äî but we're back! üéâ
As always, this call is a space to foster knowledge sharing and collaboration among JAM developers.

üìù General notes & purpose of the call:
https://hackmd.io/@P1sarb/HJkLHpIwyl

üìÖ Agenda & invite link for this week‚Äôs call:
https://hackmd.io/@P1sarb/rkcn_pc0kl
Feel free to suggest update to the agenda directly on the page (you‚Äôll need to be signed in üòâ).

üìç Join us on Tuesday, April 15 at:
{7:30am PT, 8:30am Denver, 10:30am NY, 3:30pm Lisbon, 4:30pm Berlin, 8:00pm India ST, 10:30pm Beijing, 11:30pm Tokyo, 2:30am New Zealand (Apr 16)}

Everyone is welcome‚Äîsee you there!

PS: All calls are recorded and uploaded to YouTube!
2025-04-15 00:37 clearloop: may I ask when is the Lisbon meetup? where can I find more information about the upcoming events of Jam?
2025-04-15 00:40 sourabhniyogi: https://lu.ma/ob0n7pdy
2025-04-15 14:24 jay_ztc: can someone share the call link for this months session? Thanks!
2025-04-15 14:26 p1sar: The JAM Implementers Call is starting in 5 minutes!
https://meet.google.com/rbb-cxhi-idp ‚Äî Even if you don‚Äôt have anything specific to discuss, come by and say hi! [edited]
2025-04-15 14:36 sourabhniyogi: https://meet.google.com/rbb-cxhi-idp?authuser=0
2025-04-15 16:07 jay_ztc: Was this the room mentioned on the call for coordinating about JAMX? Will any critical messages/updates in the implementors room about jamx be bubbled up to this room (Let's JAM)? I would like to stay in the loop since I will be attending, but not looking to participate in the DAO at this time. [edited]
2025-04-15 17:41 sourabhniyogi: Daniel is hosting the event and will surely be the source of all critical message/updates -- is there a schedule we can look at and try to get ourselves aligned on danicuki | Jamixir since we're starting to get our travel plans together now?
2025-04-15 18:14 wabkebab: So, very quick as I have read ‚Äútravel plans‚Äù , tomorrow, we - Pala Labs - will do a more official announcement but as a appetiser, the JAM action will continue in ETHLisbon with a JAM dedicated booth and a - probably in Sat as it is a moving target - keynote about JAM by Daniel C. [edited]
2025-04-15 18:15 wabkebab: Stay tuned to the usual JAM channels!
2025-04-15 23:17 danicuki: Unfortunately I missed today‚Äôs call to give some updates. The event agenda (beta version) was sent by email to all attendees last week. The organization team is very open to suggestions and ideas of anything different from what was sent. DM me anytime. The event is for everyone. I am just a mere enthusiast organizer. [edited]
2025-04-15 23:18 danicuki: > <@sourabhniyogi:matrix.org> Daniel is hosting the event and will surely be the source of all critical message/updates -- is there a schedule we can look at and try to get ourselves aligned on danicuki | Jamixir since we're starting to get our travel plans together now?

Unfortunately I missed today‚Äôs call to give some updates. The event agenda (beta version) was sent by email to all attendees last week. The organization team is very open to suggestions and ideas of anything different from what was sent. DM me anytime. The event is for everyone. I am just a mere enthusiast organizer.
2025-04-16 07:43 gav: JAM SDK 0.1.21 is out and with it `jamt` and `jamtop`, usable by any node which has implemented jip2. [edited]
2025-04-16 08:10 xlchen: I have some questions about JIP2:
- Can you confirm if it is JSON RPC over WebSocket? or something else?
- What encoding format is used? e.g. for Hash, is it hex string or JSON array of numbers?
- Only subscribe methods are defined but not unsubscribe?
- JSON RPC subscriptions requires another notification method as parameter, which is not included in the document
  ‚Ü≥ 2025-04-16 08:28 dave: It's JSON RPC over WS yes. We're using Parity's jsonrpsee crate + serde to implement it. I believe hashes are arrays of 0-255. Unsubscribe methods exist, I believe they're named eg unsubscribeX for subscribeX
  ‚Ü≥ 2025-04-16 08:31 xlchen: those details are crucial for others to follow. can someone update the docs? best to have some example request/response 
  ‚Ü≥ 2025-04-16 08:48 clearloop: I was trying to indicate these stuffs via a mock server XD, however, the panic messages of jamtop 

```
RUST_BACKTRACE=1 jamtop --rpc ws://0.0.0.0:6789
Error: Parse error: invalid type: map, expected a tuple of size 2
```
seems not yet well wrapped with helpful context

  ‚Ü≥ 2025-04-16 09:14 gav: Yeah, that'll be some invalid response data I expect.
  ‚Ü≥ 2025-04-16 09:14 gav: To debug you'll probably want to dump communications
  ‚Ü≥ 2025-04-16 09:15 gav: Bryan Chen | Laminar & Acala: Already stated in JIP2:

> - `Hash`: a 32 item array with each item numeric between 0 and 255 inclusive.
  ‚Ü≥ 2025-04-16 09:15 gav: See the text immediately below the section "RPC Specification":
  ‚Ü≥ 2025-04-16 09:16 gav: image.png
  ‚Ü≥ 2025-04-16 09:16 xlchen: ok. that wasn't the most efficient encoding method so I had to confirm
  ‚Ü≥ 2025-04-16 09:16 gav: It's pretty explicit :P
  ‚Ü≥ 2025-04-16 09:16 gav: I'm not sure how I could have made it more so...
  ‚Ü≥ 2025-04-16 09:17 xlchen: any reason it is not hex encoded just like substrate rpc?
  ‚Ü≥ 2025-04-16 09:17 gav: Yeah - this is the simplest way.
  ‚Ü≥ 2025-04-16 09:20 gav: jip2 updated with the other clarifications. [edited]
2025-04-16 09:58 clearloop: I can see the dashboard of `jamtop` now, from my case, it has no stdout on launch, but after `ctrl+c`, the dashboard shows

```
Services: 0 total, 0 active, 0 refining, 0 acc'ing                         0                                                                                                                        20:00:00
APU: 0% acc/0% xfer/100% idle;  Cores: 0%/0%/100% idle                     1                                                                                                                               0
Processed: 0 refines/0 gas; 0 accs/0 gas; 0 memos/0 gas                    A                                                                                                                       00000000‚Ä¶
D3L: 0 imports; 0 exports; 0 extrinsics/0B; 0 prov/0B                      X

ID       NAME                 FLGS ITMS REFS %RGC  ACCS %AGC  XFRS %XGC  PRVZ PRVS  IMPS EXPS XTS  XTZ   STRS STRZ  BAL   FBAL  MBAL
```

it's currently empty with my RPC, to make it alive, seems we have to fullfill the service features now
2025-04-16 15:05 jimboj21: Hey hey, I have a question about the accumulation test vector's pvm execution:

Why do the accumulation test vectors not result in a change to the service storage state? I dont believe the storage attribute is included in these tests. Unless I am mistaken, based on the test service code there should be a host write call which if executed correctly should update the jam state for that service. If the service storage state isn't tested here, isn't the pvm invocation in these tests basically just a no-op then as far as passing the tests is concerned? Am I missing something here?
2025-04-16 15:20 dakkk: > <@jimboj21:matrix.org> Hey hey, I have a question about the accumulation test vector's pvm execution:
> 
> Why do the accumulation test vectors not result in a change to the service storage state? I dont believe the storage attribute is included in these tests. Unless I am mistaken, based on the test service code there should be a host write call which if executed correctly should update the jam state for that service. If the service storage state isn't tested here, isn't the pvm invocation in these tests basically just a no-op then as far as passing the tests is concerned? Am I missing something here?

Have you tried to execute the pvm running those tests? 
2025-04-16 15:25 jimboj21: Yeah I have. I am working to fix a bug in my pvm right now, so I am not 100% on my execution. This is partly why I ask, maybe i am missing context from the correct execution, however, I still pass all the test vectors. 
2025-04-16 16:19 sourabhniyogi: For the notion of structured logs (which we can do some set up for), what do you think it should cover out of these:
(a) PVM execution: (i) auth/refine execution (ii) acc/transfer execution (iii) auditing (iv) jip-1 logs
(b) Refining \[superset of (a)(i)\] (i) bundle details (ii) work report/work result/availability spec generation
(c) Accumulation / Transfer (i) wrangled results (ii) ordering (iii) MMR / Beefy accumulation roots (iv) statistics  (v) C1-C15 state changes (vi) service storage/preimage/lookup changes
(d) Block authoring \[superset of (a)(ii), (c)\] (UP0) (i) sealing (ii) ticket generation (CE 131/132)
(e) Block Validation errors
(f) Audit Announcements [CE 144] / Judgement Publication [CE 145]
(g) Preimage Announcements [CE 142] / Requests+Responses [CE 143]
(h) _Selected_ JAM NP sends/receives not well covered by the above:
* CE 133: Work-package submission, 
* CE 134: Work-package sharing,  
* CE 135: Work-report distribution. 
* CE 136: Work-report request, 
* CE 137: Shard distribution
* CE 138: Audit shard request,
* CE 139/140: Segment shard request, 
* CE 141: Assurance distribution
 [edited]
  ‚Ü≥ 2025-04-16 16:33 jimboj21: For me personally I am currently focusing on M1/block importing so a) and c) and i think e (if i understand what validation errors means) are the most useful to me at this moment.

The others all seem useful as well, but I will let others speak to that. I imagine the log level can be specified to determine which of these we wish to see? 
2025-04-16 16:56 0xjunha: I just tested with my implementation, and I could find the PVM code blobs of the accumulate test vectors include `ECALLI`. This is what we can guess from the test service code, which includes `jam_pvm_common::accumulate::set_storage`.

However, when I actually ran all accumulate test cases, and tracked trace of all executed opcodes, no single `ECALLI` was executed.
So my guess is that either `items` argument for the test service `accumulate` function is an empty vec, or `item.result` is not `Ok` and therefore no host function is executed even `accumulate` is invoked. (https://github.com/davxy/jam-test-vectors/blob/562f11d129d3a6ab35bfb91ad5973358ae0654fa/accumulate/test-service/src/main.rs/#L27C48-L27C74)

And I think this is just for simplicity, mainly focusing on Accumulate Queue/History STFs for now and I expect host function test cases might be added in the future.
My implementation is not complete yet, so there could be bugs in mine as well.\
2025-04-16 17:01 gav: > <@sourabhniyogi:matrix.org> For the notion of structured logs (which we can do some set up for), what do you think it should cover out of these:
> (a) PVM execution: (i) auth/refine execution (ii) acc/transfer execution (iii) auditing (iv) jip-1 logs
> (b) Refining \[superset of (a)(i)\] (i) bundle details (ii) work report/work result/availability spec generation
> (c) Accumulation / Transfer (i) wrangled results (ii) ordering (iii) MMR / Beefy accumulation roots (iv) statistics  (v) C1-C15 state changes (vi) service storage/preimage/lookup changes
> (d) Block authoring \[superset of (a)(ii), (c)\] (UP0) (i) sealing (ii) ticket generation (CE 131/132)
> (e) Block Validation errors
> (f) Audit Announcements [CE 144] / Judgement Publication [CE 145]
> (g) Preimage Announcements [CE 142] / Requests+Responses [CE 143]
> (h) _Selected_ JAM NP sends/receives not well covered by the above:
> * CE 133: Work-package submission, 
> * CE 134: Work-package sharing,  
> * CE 135: Work-report distribution. 
> * CE 136: Work-report request, 
> * CE 137: Shard distribution
> * CE 138: Audit shard request,
> * CE 139/140: Segment shard request, 
> * CE 141: Assurance distribution
> 

It should be primarily for the various off-chain events (ie not accumulate) - the on-chain stuff is easily discoverable already. 
2025-04-16 17:02 gav: Receiving a block, importing, authoring and publishing are all sensible things to be cataloguing too. But this is perhaps something to discuss in-person in Lisbon. 
2025-04-16 17:05 rustybot: > <@jimboj21:matrix.org> Hey hey, I have a question about the accumulation test vector's pvm execution:
> 
> Why do the accumulation test vectors not result in a change to the service storage state? I dont believe the storage attribute is included in these tests. Unless I am mistaken, based on the test service code there should be a host write call which if executed correctly should update the jam state for that service. If the service storage state isn't tested here, isn't the pvm invocation in these tests basically just a no-op then as far as passing the tests is concerned? Am I missing something here?

I need to check. If not I'll add a couple 
2025-04-17 06:42 emielsebastiaan: Can anybody direct me to the specification jip2 please. üôèüèª [edited]
  ‚Ü≥ 2025-04-17 06:43 clearloop: https://hackmd.io/@polkadot/jip2
2025-04-17 09:11 danicuki: A sneak peek of the JAM Experience event T-Shirt
2025-04-17 09:11 danicuki: Screenshot 2025-04-17 at 10.09.52.png
2025-04-17 13:19 wabkebab: **JAM Toaster visit & JAM presence at ETHLisbon !**

Hey JAM fam!

We've got some exciting news - Pala Labs is bringing JAM to **ETHLisbon** (May 9-11)! Since many JAM-ers will already be in Lisbon for the **JAM Experience**, we thought: why not introduce JAM to the Ethereum crowd too?

**Quick highlights**

- A keynote session dedicated to JAM on ( tentatively) May 10
- We'll be having a cool JAM booth with some surprises ‚Ä¶
- For builders, there's also a Smart Contract hackathon on Kusama from 9 to 11 of May

**Exclusive invite for JAM Implementers!**

We're planning an exclusive JAM Toaster visit just for JAM implementers on 6th May, 4 to 9 PM - free transportation, toaster visit, and poolside drinks & canap√©s.

Limited spots available! ([Sign up here](https://lu.ma/jamtoastervisit) )

And of course, cool JAM merch with fantastic designs, like the one just on top of these lines, from the inkwell of xylodrone  - our talented inhouse designer.

Want to help at the booth or just hang out? Reach out to us!

See you in Lisbon! üöÄ [edited]
2025-04-17 21:03 sourabhniyogi: Here is a wishlist for a workshop agenda:
(1) From Tiny Testnets to Everyone in the Toaster: jip2 \[jamtop\] + Telemetry, Structured Logging -- and how to do this in an "anti-fragile" way
(2) Recompiler 101 + Advanced topics (must have Jan Bujak)
(3) Building services with SDK + polkatool, CoreVM + guest programs
(4) Mind Viruses in the World and how to combat them
(5) DOOM Dissection and how to sell JAM [edited]
2025-04-17 21:35 jay_ztc: Will the Node RPC from JIP2 be used in milestone acceptance testing? I wonder if some full node implementations will choose to forego implementing the spec, given that light clients are the stated preference & their development is now incentivized directly from the prize pool. [edited]
2025-04-18 04:12 gav: Agreed we need to do a seminar on structured logging - I thnk this will be a crucial next step for making serious use of the Toaster erin arkadiy David Emett ... [edited]
2025-04-18 04:13 gav: We're pretty much ready to go with the tiny testnet for any teams who want to try connecting; getting 1023 node active might be a challenge... [edited]
2025-04-18 04:15 gav: I'll be happy to talk about SDK (minimal as it is right now) and hopefully a walkthrough of CoreVM. We're working hard on getting CoreVM releasable (along with PVM Doom) by May.
2025-04-18 04:16 gav: If you're at M2 with a high-efficiency interpreter PVM you might be able to run DOOM on your own JAM. (We can with PolkaVM interpreter.) [edited]
2025-04-18 04:17 gav: I'll give a presentation on the Polkadot Palace if people are interested, too.
2025-04-18 04:19 gav: Parity PolkaJAM team (including myself) are having a longer retreat based out of the Lisbon Parity office for the following week and a half after the JAMXP; any teams who want to stick around and try to continue to get interop are ofc welcome to work from the Parity office too.
2025-04-18 05:19 jtxmp: 
2025-04-18 05:25 boymaas: That‚Äôs amazing news. Just to confirm, is it permissible under the rules for teams to begin coordinating the networking aspects with one another in advance, provided all communication takes place through public channels?
  ‚Ü≥ 2025-04-18 05:55 sourabhniyogi: Opening a thread right here so we can prep before during and after üòÄ
  ‚Ü≥ 2025-04-18 06:48 gav: Yes, provided comms are open and easily discoverable by other teams/newcomers, and of course that it doesn't impact the nature of the clean-room rules, then it's fine. [edited]
  ‚Ü≥ 2025-04-18 06:49 gav: Generally speaking, if discourse happens openly and in easily discoverable channels and it's solely about getting the interop working then there shouldn't be a problem. [edited]
  ‚Ü≥ 2025-04-18 06:52 gav: Also, I'm cogniscant that forcing everything to happen in these two channels isn't ideal. So I've a bit of a plan here:

1. Get some sort of automation to periodically archive these two channels.
2. Host the archive in one or more obvious places (graypaper.com, jamcha.in, others?)
3. Request that others who want to have discourse away from these channels offer up the same thing and provide linking/hosting on these central spots for it.
4. Have some AI guy train an "official" AI model periodcally on the content of these channels as well as any lectures of mine, the Gray Paper &c.
5. Provide the model as a download for anyone to use with e.g. Jan. [edited]
  ‚Ü≥ 2025-04-18 06:54 gav: As long as *all* non-official channels data gets into this central easily-searchable/discoverable knowledge base in a timely fashion, then I don't see a huge problem with expanding out from the two official channels.
  ‚Ü≥ 2025-04-18 06:54 gav: Of course I won't necessarily be monitoring other channels.
  ‚Ü≥ 2025-04-18 08:34 boymaas: Thanks gav , that‚Äôs clear. We‚Äôll make sure all coordination stays open and easy to find, and respects the clean-room principles.
  ‚Ü≥ 2025-04-18 12:18 sourabhniyogi: image.png
  ‚Ü≥ 2025-04-18 12:18 sourabhniyogi: https://discord.gg/aEhVqngM
  ‚Ü≥ 2025-04-18 12:20 sourabhniyogi: How would you improve on this:
"100% public channel for JAM Implementers to set up JAM testnets with each other in prep for participation in a JAM Toaster testnet.   

IMPORTANT:
This channel will be periodically archived and may be freely used to train an AI model and form a searchable/discoverable JAM knowledge base.    If you are not comfortable with this, do not participate in this channel.

See also: https://hackmd.io/@polkadot/jamprize
"
3/4/5 is super reasonable and easy to execute on 


  ‚Ü≥ 2025-04-18 13:12 sourabhniyogi: https://github.com/davxy/jam-test-vectors/issues/40
  ‚Ü≥ 2025-04-21 09:01 gav: Yes, just needs proper linkage from community centrepoints like graypaper.com and jamcha.in
2025-04-18 07:15 gav: As a start to this I initiated https://hackmd.io/@polkadot/jip3 as a collaborative doc, which teams are welcome to add their own messages to. [edited]
2025-04-18 12:22 subotic: Hey gav, as I'm looking into how to best approach implementing the recompiler and PVM native execution, I'm trying out different things. Regarding the prize, some time ago you mentioned, that as long as more than 50% of the codebase is in one language (in our case Scala), it would be ok to write small parts of it in another language. In our case, the PVM interpreter is implemented in Scala, but I'm looking at using Rust to implement the native execution parts for the PVM. Would that be fine, or would the Rust code fall under a different language category, irrespective of the size?
2025-04-18 12:33 jay_ztc: according to https://hackmd.io/@polkadot/jamprize#Language-Sets, pvm is one of the components that doesn't impact an implementations language set categorization [edited]
2025-04-18 12:36 subotic: Thank you very much! Great to hear.
2025-04-19 12:45 ascriv: Is it possible to get more clarity on what the M1 validation process will look like? Will it be a set of test vectors a la jam-test-vectors? Will they have the same format?
2025-04-19 17:22 gav: > <@ascriv:matrix.org> Is it possible to get more clarity on what the M1 validation process will look like? Will it be a set of test vectors a la jam-test-vectors? Will they have the same format?

Best check with [davxy](https://matrix.to/#/@davxy:matrix.org). 
2025-04-19 18:47 davxy: The conformance testing tool will engage directly with your implementation (the target) in a more interactive fashion.

Naturally, passing all test vectors is a prerequisite, as the tool may expose your implementation to more complex or unforeseen scenarios. 

The overall process is relatively straightforward. Once the tool communicates the genesis state to the target, it will begin submitting procedurally generated blocks, which your implementation should attempt to import. It will then validate the resulting state root against the expected one. 

On failure, a test vector is produced (prior raw state kv + block + posterior diff with expected state).

The content of these blocks is pseudo-random and determined by a specific seed. To reproduce a particular run, the corresponding seed must be known.

The format of the state will align with the trace format adopted by the community, i.e. the whole state raw key-value (refer to the jam duna traces, also see https://github.com/davxy/jam-test-vectors/issues/40). 

The communication between the conformance testing tool and the target implementation will occur over a simple pipe.

Additionally, the tool is capable of instructing the target to adopt a specific state, after which it can function as a pure fuzzer submitting millions of mutated versions of the same block (currently via libfuzzer, but we may experiment AFL as well)

Nothing is written in stone btw. The tool is currently a work in progress, and new ideas may emerge to refine it.  Further details can be discussed in Lisbon.

Some initial ideas were also drafted here:
https://github.com/w3f/jamtestvectors/issues/21 [edited]
2025-04-20 00:42 jaymansfield: Screenshot 2025-04-19 at 8.41.23‚ÄØPM.png
2025-04-20 00:42 jaymansfield: Are there any teams that have implemented JIP-2 and have jamtop working with their implementations? I finished off all functionality for JIP-2 and running into some difficulties with jamtop. For me it starts up and requests parameters, best block and service info (data and preimages), subscribes to statistics, and then basically stops updating the interface and sending requests. No errors or anything are shown. [edited]
2025-04-20 04:06 gav: > <@jaymansfield:matrix.org> Are there any teams that have implemented JIP-2 and have jamtop working with their implementations? I finished off all functionality for JIP-2 and running into some difficulties with jamtop. For me it starts up and requests parameters, best block and service info (data and preimages), subscribes to statistics, and then basically stops updating the interface. No errors or anything are shown.

The interface updates are driven by updates from the statistics subscription, which should come once per block. Are you sure your node is sending these?
  ‚Ü≥ 2025-04-21 15:46 jaymansfield: Yes it is sending statistics for each block. I noticed one thing not defined in JIP-2 and I'm wondering if it‚Äôs related to that.

Initial subscription:
{‚Äújsonrpc":"2.0","id":1,"method":"subscribeStatistics","params":\[false\]}

Response:
{‚Äújsonrpc":"2.0","id":1,"result":"7c0f6de3-75f6-4056-b24f-da377bb00a09"}

Notification:
{‚Äújsonrpc":"2.0","method":"subscribeStatistics","params":{"subscription":\["7c0f6de3-75f6-4056-b24f-da377bb00a09"\],"result‚Äù:\[\[0,0,0,‚Ä¶‚Ä¶\]\]}}

For the actual notifications/subscription events, what should the ‚Äúmethod‚Äù be populated as? Right now for these I‚Äôm using the original method they subscribed too , for example: ‚ÄúsubscribeStatistics‚Äù as there doesn‚Äôt seem to be a standard set in the JSON-RPC spec for this and seems it's up to the implementation. I also tried just "statistics". Some other RPC implementations use method: ‚Äúsubscription‚Äù, ‚Äúnotification‚Äù, ‚Äúevent‚Äù, etc but not sure what jamtop is expecting here. [edited]
2025-04-20 18:45 sourabhniyogi: I suggest we reuse JAMSNP's exact encoding method to the fullest extent possible, and do every single CE -- modeled here

https://hackmd.io/@sourabhniyogi/jip3-recommendation

Any changes going from JAMSNP to JAMNP, including codec encoding of the JAM representations, would be expected to follow in JIP3, making telemetry be a "whatever you do in QUIC, you send to the telemetry server".

This enables each team with a working \[tiny\] testnet to simply share their entire logs with another team prior to working with them by simply providing their telemetry server endpoint (and their genesis state, which includes the validator set). This can be used as a prerequisite to enter into a larger network, including the "full" JAM Toaster.

What do you think of this?

And... Happy Birthday JAM Gray Paper! =) [edited]
2025-04-21 09:03 gav: Loggin the receipt (and even transmission) of network messages can be helpful, but it's only scratching the surface. [edited]
2025-04-21 09:04 gav: Really what we care about is uncovering and describing internal state of the off-chain mechanisms and visualizing them in aggregate [edited]
2025-04-21 12:13 danicuki: > <@sourabhniyogi:matrix.org> I suggest we reuse JAMSNP's exact encoding method to the fullest extent possible, and do every single CE -- modeled here
> 
> https://hackmd.io/@sourabhniyogi/jip3-recommendation
> 
> Any changes going from JAMSNP to JAMNP, including codec encoding of the JAM representations, would be expected to follow in JIP3, making telemetry be a "whatever you do in QUIC, you send to the telemetry server".
> 
> This enables each team with a working \[tiny\] testnet to simply share their entire logs with another team prior to working with them by simply providing their telemetry server endpoint (and their genesis state, which includes the validator set). This can be used as a prerequisite to enter into a larger network, including the "full" JAM Toaster.
> 
> What do you think of this?
> 
> And... Happy Birthday JAM Gray Paper! =)

Happy Birthday JAM. It is amazing to see how much we‚Äôve built in just one year. And we are just getting started! Let‚Äôs JAM 
2025-04-21 14:27 sourabhniyogi: To support M3 PVM interpretation => recompilation, we should desire the timing (# of microseconds) spent executing all the timings of the key PVM operations + then do similar erasure encoding + justification generation

- 0 \[block announcement for authoring\]
- 131/132 \[ticket generation\]
- 133/134/145 \[work package refinement/auditing\].
- 137/138/139/140 \[DA encoding\]
- 224/225 \[BLS Signature Generation\]

The telemetry server can usefully pipe this into Jaeger tracing (or similar) for visualization, but from attempting multihop XCM visualization, it probably helps to also have work package hash (133/134/145/137/138/139/140) and header hash (0/192/193/224/225) so the telemetry server doesn't have to do any JAM-specific indexing -- then you can see a "trace" for any workpackage (refining and auditing) or a header hash (authoring, validating, finalizing).

Having data streams to attack bottlenecks that motivate [RFC-139 - Faster Erasure Coding](https://github.com/ordian/RFCs/blob/main/text/0139-faster-erasure-coding.md) and  [super-I/O centric NOMT](https://github.com/thrumdev/nomt) would be cool.

With benchmark workpackages + services, a implementer leaderboard should be developed, focussing on KPIs central to meeting M3/M4 "Kusama-performance" and "Polkadot-performance" -- where we need guidance on what this means exactly so it falls out of the telemetry server dataset.  What else is required? [edited]
  ‚Ü≥ 2025-04-21 15:00 jaymansfield: What is 224/225 referring to here?
  ‚Ü≥ 2025-04-21 16:16 sourabhniyogi: Some placeholders for [Section 18](https://graypaper.fluffylabs.dev/#/5f542d7/1e78011e7801?v=0.6.2) that haven't been fully worked out yet.  Just a total guess on my part but its been modeled in the GP some already.
  ‚Ü≥ 2025-04-21 16:17 jaymansfield: Thanks!
  ‚Ü≥ 2025-04-21 16:18 jaymansfield: Btw, gamifying the optimization process for M3 with a leaderboard is a great idea.
  ‚Ü≥ 2025-04-21 23:19 sourabhniyogi: Ok, thanks for the encouragement -- I'll make a Dune dashboard out of it before Lisbon. 
2025-04-22 14:10 jay_ztc: Many thanks for organizing this event üôè. When can we expect approvals to start being processed for this registration?
2025-04-22 19:58 wabkebab: I don't have the exact date but it will be very soon. You can approach Mila‚Äâ|‚ÄâPala Labs as she can provide you more details about it
2025-04-23 04:47 ewaddicor: I'm thinking about submitting a JAM interest form... does anyone know which programming languages have not yet been used?
  ‚Ü≥ 2025-04-23 04:51 xlchen: this is a non-complete list of what languages are used https://graypaper.com/clients/
  ‚Ü≥ 2025-04-23 04:54 ewaddicor: thank you
2025-04-23 04:54 ewaddicor: 
2025-04-24 08:53 xlchen: Does PolkaVM already have some benchmarking script that we can reuse to check the performance of our PVM implementation? I don't expect our current interpreter to be fast but I want to know how slow it is
2025-04-24 09:00 jan: Yes, I have some benchmarks, but they might be tricky to run for you. (Making a universal harness for PVMs to be able to run them is on my TODO list.)

The benches are here: https://github.com/paritytech/polkavm/tree/master/guest-programs

The number are here: https://github.com/paritytech/polkavm/blob/master/BENCHMARKS.md

Here's the binary I use to run them: https://github.com/paritytech/polkavm/tree/master/tools/benchtool

I run these benchmarks across a lot of different VMs, so the tool has multiple backends: https://github.com/paritytech/polkavm/tree/master/tools/benchtool/src/backend
So in theory you could add your VM there.
2025-04-24 09:09 jan: You could parse the `.polkavm` blobs with https://docs.rs/polkavm/latest/polkavm/struct.ProgramParts.html and https://docs.rs/polkavm/latest/polkavm/struct.ProgramBlob.html and load them into your VM.  Here's some code for reference how a JAM blob is made from a `.polkavm` blob: https://docs.rs/jam-pvm-builder/0.1.21/src/jam_pvm_builder/lib.rs.html#282
2025-04-24 10:37 oliver.tale-yazdi: The code to parse those blobs is not relevant for the GP, right? So we can take a look at it? [edited]
2025-04-24 10:46 jan: Correct.
2025-04-24 10:50 jan: Here's a pastebin of the relevant code to parse them: https://pastebin.com/L2CsuVNR
2025-04-24 10:59 jan: Essentially the format looks like this:

```
struct Blob {
    magic: [u8; 4],
    version: u8,
    length: u64,
    sections: [Section]
}

struct Section {
    kind: u8,
    length: varint,
    body: [u8; Self::length]
}

struct MemoryConfigBody { // kind == 1
    ro_data_size: varint,
    rw_data_size: varint,
    stack_size: varint,
}

// RO_DATA and RW_DATA sections just have the raw byte payloads

struct ImportsBody { // kind == 4
    import_count: varint,
    import_offsets: [u32; Self::import_count],
    import_symbols: [u8; ...until end of the section...]
}

struct ExportsBody { // kind == 5
    exports: [Export; ...until end of the section...]
}

struct Export {
    program_counter: varint,
    name_length: varint,
    name: [u8; Self::name_length]
}
```
2025-04-24 11:01 jan: It's somewhat similar to how `.wasm` blobs look internally. Basically it's a preset header + list of sections where each section has an ID and a length, the sections must always be given in order (so you don't have to write a loop to parse this format because e.g. you always know that memory config section must *always* come before the ro data section, etc.), there is a list of imports and exports (so unlike the JAM blob the imports and exports are *not* hardcoded), and it also supports debug info (which the JAM blobs don't).
2025-04-24 18:24 erin: hello all, I've created hosted archives of the JAM and graypaper chats with plaintext versions also available at https://paritytech.github.io/matrix-archiver/

there are a few quality of life improvements still to be done but any feedback or comments are welcome if you find this useful. This is also now linked on the jamcha.in site.
2025-04-24 18:25 erin: These are updated daily at ~3am UTC.
2025-04-24 18:29 erin: Other JAM-related channels are welcome to be archived - they need to be unencrypted and world-readable (history available to "Anyone"). Please open an issue [here](https://github.com/paritytech/matrix-archiver) with the internal room ID if you wish to archive a channel. [edited]
2025-04-26 14:17 clearloop: just found that the archiver is even easier than matrix to search chat history lmao, hope we can integrate more sources into the static site asap

it even supports links to messages, threads with paddings, great work, direct and efficient [edited]
  ‚Ü≥ 2025-04-26 14:23 erin: thank you!
2025-04-27 21:59 decentration: Just working on the pvm implementation i just want to confirm with what is the minimum requirement for M1... in the article (https://hackmd.io/@polkadot/jamprize) it references PVM for M3 but not M1. 

1. Is it enough to expose the JAM host-function interface while stubbing the RISC-V runtime?
2. Or do we already need full RISC-V sandbox execution (load blob -> run -> trap -> return ephemerals) in M1?
3. If execution is required, may we rely on an existing impl such as PolkaVM as a temporary backend and postpone a custom PVM to M3?
4. Alternatively, is all PVM work evaluated only from M3 onward?
5. And, is there a difference between M1 and MN1? [edited]
  ‚Ü≥ 2025-04-28 06:58 subotic: You need a working PVM for M1 (accumulate needs the PVM). For M1 and M2 it can be an interpreter, while from M3 on it needs to be more performant and thus recompiler based. There are different paths described in the linked HackMD, and from what I understand, an original PVM is needed for the first milestone for all paths, as you cannot import a block without.
2025-04-28 13:36 wabkebab: **JAM _action_ next week**

The following week comes with a packed JAM schedule. JAM Experience, Toaster visit and ETHLisbon JAM weekend (booth and keynote during ETHLisbon) will keep you engaged for the whole week.

For those who have not confirmed their presence on the Toaster visit, please sign up on the following link: https://lu.ma/jamtoastervisit

Limited spots! [edited]
2025-04-28 14:01 jay_ztc: Hi Mila‚Äâ|‚ÄâPala Labs , hope you're doing well. Are you able to share if registration approvals for the toaster tour have started to be processed yet? My teammate & I still see our registration as pending.
  ‚Ü≥ 2025-04-28 14:49 milawords: Hi Jay | ZTC thanks for reaching out. We will review all outstanding registrations today and tomorrow. [edited]
2025-04-28 15:07 milawords: Your support needed: JAM‚Äôs first official sponsorship; JAM Booth at ETHLisbon

Dear Implementers,

We are excited to organise JAM‚Äôs first official sponsorship of an Ethereum conference - the JAM booth at ETHLisbon.

We would love your support in representing JAM at the booth as you are the faces behind JAM. You won‚Äôt need to be there the entire time but rather flexible time slots based on your availability.

As a thank you, we are organising a dinner for everyone who helps with the booth. It will be a great opportunity to meet the Pala Labs team and discuss how we can better support JAM implementers moving forward.

Please feel free to reach out to me directly and looking forward to hearing from you!

Mila

2025-04-28 15:39 oliverb: Mila‚Äâ|‚ÄâPala Labs: Hi - hope you're well. Have you invited Parity people to this separately? I know you probably want lots of non-Parity people as well but happy to help spread the message internally...
2025-04-28 23:47 sourabhniyogi: Here is a JAM Implementer Dune Dashboard Proof-of-Concept 
 https://dune.com/substrate/jamtestnet
Earlier thought we should log all of JAMSNP activity but after thinking about what was really important to a implementer leaderboard and M3 performance, ended up at the above instead -- hope we can discuss how to make this really work next week!
  ‚Ü≥ 2025-05-01 20:29 jaymansfield: This is cool. Will be very useful once we can test on standardized hardware (toaster for example). 
  ‚Ü≥ 2025-05-01 20:29 jaymansfield: For the analytics to be a valid comparison, we'd need some standard test cases defined for each. For example block authoring we need to all be including the same items in the block (same number of tickets, assurances, etc) otherwise the completion times would not be comparable
2025-04-29 13:18 dave: FYI A small behavioural change has been made to SNP. Previously the SNP spec stated that validators should _not_ announce preimages to each other. This has been changed to state the opposite: validators _should_ announce preimages to each other. See https://github.com/zdave-parity/jam-np/commit/ebc6139eb89dfaa49f5fa12a5a0abdc1af0bd578. The wire protocol is unchanged.
2025-05-01 11:55 danicuki: I will present JAM at ETHLisbon next week. Open for ideas of things to share with the ETH community. It will be a 30min talk. Since we still don‚Äôt have a full stack running node in Jamixir, I won‚Äôt be able to make a quick demo. But I can easily add video snippets / screen recordings to my presentation if anyone sends it to me. 
2025-05-01 11:58 gav: I expect we can provide a Linux binary for a PolkaJAM testnet if desired. 
2025-05-01 16:59 sourabhniyogi: We desire a "how to run DOOM with the PolkaJAM testnet" workshop (which we should all like to replace the PolkaJAM part with our own ASAP of course!), which can dual as a "how to sell JAM in a world of mind viruses".    It is a very good conversation starter as to what really really is going on since most people are naturally like "oh yeah? but what about ethproofs/zkVM/SP1/...?"   Must this be public?
2025-05-01 17:16 danicuki: We still have a Workshop slot available on May 7th. If gav or anyone else in the PolkaJAM team could give this DOOM on JAM workshop , I can use it on my presentation at ETHLisbon (and other scheduled talks to come). 
2025-05-01 17:25 sourabhniyogi: That would be terrific.  We have enough stuff to transform https://docs.jamcha.in into a more direct competitor of https://docs.succinct.xyz/docs/sp1/getting-started/quickstart (this is the "competitor" I know and understand, probably you all have others) and similar -- Not sure if this transformation should be done by JAM implementers in community-driven way (any binary should be able to replace or compose with the other) OR from W3F+Parity central. 

A little push and coordination to turn that "OR" into an "AND" would go a long way?

Our 2-core testnet can do 12-16 hours processing thousands of fib/fib2/gameoflife/megatron WPs (486 work packages per hour) and then something bad happens =(  but its not very sexy to lookat relative to DOOM =) [edited]
2025-05-01 20:30 jaymansfield: 
2025-05-02 10:17 gav: jambrains guys: https://github.com/JamBrains/jam-docs/pull/39
2025-05-02 10:19 gav: Note that we use PVM, short for Polkadot Virtual Machine, to mean the ISA specification which JAM implementors implement. PolkaVM, on the other hand, is the first implementation of it (and indeed what it was pretty much entirely derived from), currently developed under the Parity umbrella (but historically a side project of Jan). [edited]
2025-05-02 10:41 gav: They're confusingly similar (ugh), but I'm not sure that JAM Virtual Machine/JVM would be much less confusing ;)
2025-05-02 10:42 clearloop: JAM VM (JVM) is too similar to JavaVM (JVM)
2025-05-02 10:42 xlchen: our PVM module is currently named PolkaVM. I guess we need to rename it to avoid confusion 
2025-05-02 11:10 danicuki: J‚±ØM - pushing to the limit... üòñ
2025-05-02 11:38 oliver.tale-yazdi: Thanks for the clear up. I was actually unter the impression that they meant the same üòÖ  
Cisco put one review comment and then I can subsequently rename the page to PVM
2025-05-02 15:34 jaymansfield: Think we all may have did that üòÄ
2025-05-03 20:23 sourabhniyogi: erin: arkadiy David Emett  Would one of you (who is around at the Lisbon meeting) like to lead a "workshop" discussion on structured logging + jamsnp + docs.jamcha.in along these lines  https://x.com/byteboro/status/1902037543274553631 -- I can scribe / orchestrate with you as much or as little as you'd like ?
2025-05-03 21:41 dave: Sure, I'd be happy to do that
2025-05-04 06:53 clearloop: Hope there will be record for the events and the workshops! I'm not able to join the events since my visa has not been approved yet ü•≤
2025-05-04 13:28 boymaas: Hey danicuki | Jamixir , we are already in your hometown since two days :-) Nice place. I have a question: is there still a small slot available for a short presentation of 5 to 10 minutes on JamZig?
2025-05-04 16:50 danicuki: > <@boymaas:matrix.org> Hey danicuki | Jamixir , we are already in your hometown since two days :-) Nice place. I have a question: is there still a small slot available for a short presentation of 5 to 10 minutes on JamZig?

Sure! 
2025-05-04 16:50 danicuki: ima_bf46e03.jpeg
2025-05-04 16:51 danicuki: JAM Experience - all set! 
2025-05-05 15:36 sourabhniyogi: JAM Doom replication:
 https://www.youtube.com/watch?v=ltWMjg2EHS8
  ‚Ü≥ 2025-05-05 15:48 clearloop: just watched 5 times to confirm that wu ignored the second enemy 
  ‚Ü≥ 2025-05-27 12:45 sourabhniyogi: For doom, yes [this](https://github.com/clw8998/jam_doom) is our write up (from  @www ) .  Note that this is *not* submitting WPs so its not accurate to say "JAM is running DOOM" but that "PVM is running DOOM".   I believe the world deserves the true "JAM is running DOOM" tutorial showing how to actually break it up into WPs, and we don't actually know how to do that cleanly.    
2025-05-05 15:55 ascriv: Unwatchable 
2025-05-05 16:10 alice_und_bob: hey, coming back to this question --> https://matrix.to/#/!wBOJlzaOULZOALhaRh:polkadot.io/$tMICwJ4QJLhbaG4P0gH7DyDM8j67XmiHbs\_dheO\_hGM?via=polkadot.io&via=matrix.org&via=parity.io

I try to understand who eventually determines to order of WP accumulation.

Let's say a WP doesn't define a pre-requisite other WP, is the order then determined in the accumulate stage from the leader? [edited]
2025-05-05 17:16 krystian50: 
Hi everyone!
At Fluffy Labs, we‚Äôve recently kicked off a new project aimed at searching though JAM resources.

It already includes a few features:
    ‚Ä¢    Integration with the JAM Channels Archive (thanks to erin !)
    ‚Ä¢    Integration with the Graypaper
    ‚Ä¢    A few search options to explore the data

We‚Äôre still in the early development phase and actively experimenting, so the UI is evolving quickly - features may appear and disappear. If you have any feedback, we‚Äôd love to hear it!

tomusdrw , mateuszsikora and hey_im_stas will be at JAM Experience, so feel free to give them the feedback directly üôÇ

üîé  https://search.fluffylabs.dev
2025-05-06 08:22 kianenigma: order within the WPs of the same service, or of different services?

Within the same service, it is up to the accumulate code. Each service is accumulated just once during each block. It receives all possibly parallel refines as input, and has to decide what to do with them, and in which order. [edited]
2025-05-06 08:24 alice_und_bob: what I understand is that there can be an unordered set of WPs reaching the (same) service. So the accumulate logic is confronted with an unordered set. But somehow an order needs to be chosen. What I try to get down to is if the order can be set arbitrarily by the leader or how the order is eventually chosen
2025-05-06 08:25 gav: The block builder has no relevance. 
2025-05-06 08:26 alice_und_bob: I have an unordered set of WPs. How is the eventual order of accumulation decided? If it is decided by the service, how does it decide the order of the unordered set? And on which machine (set of machines) does this happen?
2025-05-06 08:27 gav: It isn‚Äôt
2025-05-06 08:27 gav: Accumulation happens on all full nodes. 
2025-05-06 08:28 gav: And as Kian says, service code executes once per accumulation round, being given access to all work results. 
2025-05-06 08:28 gav: It is up to that code to do something with them. 
2025-05-06 08:28 alice_und_bob: so when the service iterates through the set, it has to pick its own ordering logic? e.g. asc by wp hash?
2025-05-06 08:29 gav: In principle it could be a commutative operation. 
2025-05-06 08:29 gav: Eg addition. Order in that case wouldn‚Äôt matter.  [edited]
2025-05-06 08:29 gav: If some sequential processing were needed, then it could randomise the processing order  [edited]
2025-05-06 08:30 gav: > <@alice_und_bob:matrix.org> so when the service iterates through the set, it has to pick its own ordering logic? e.g. asc by wp hash?

Yes
2025-05-06 08:31 alice_und_bob: okay, I guess my confusion was coming from the assumption of having a transaction-based system; while a service can in principle be transactionless.

but any transaction-based service will pick an ordering-mechanism.

Does the service have access to randomness provided by JAM? [edited]
2025-05-06 08:39 gav: It does as of 0.6.6. 
2025-05-06 15:18 rick: Hi All -- I'll be on a panel at Decentralized Lugano on Thursday.

Will also be around on the 9th and 10th for ethDAM. 

 If anyone is attending either event please reach out, would love to meet in person. 
2025-05-06 17:14 erin: Reminder for anyone in Lisbon, event link for tomorrow: https://lu.ma/6monb9f9
2025-05-07 13:57 kianenigma: Jan Bujak I missed your recompiler talk this morning, would it be possible for you to share the slides here or in a JAM chat to be able to save it for later? thanks!
2025-05-07 16:27 jan: talk_recomp.pdf
2025-05-07 16:27 jan: Yes, that was the plan. Here are the slides.
2025-05-07 16:41 dave: The HackMD for JAM "TART" brainstorming is here: https://hackmd.io/@zdave/rJts9T_lxl. This is all about gathering and visualisation of statistics/events/etc from testnets running on the JAM toaster. Please comment there if there's some data you'd like to see exposed, if you have ideas on how to visualise things, etc.
2025-05-07 22:08 danicuki: > <@kianenigma:parity.io> Jan Bujak I missed your recompiler talk this morning, would it be possible for you to share the slides here or in a JAM chat to be able to save it for later? thanks!

We have the recording that will be available soon on the JAM Community YouTube channel. 
2025-05-07 22:10 danicuki: Thank you everyone for coming to JAM Experience. I hope you all had a great time in Lisbon. Enjoy the rest of your stay and have a safe trip back home. See you soon! 
2025-05-07 22:13 danicuki: Those others who have slides, please share them here and I will organize to make them publicly available somewhere 
2025-05-07 22:16 sourabhniyogi: Thank you for organizing JAMXP and everyone who made the visit to the Polkadot Palace so special -- nothing beats meeting people in real life and getting each other psyched about Polkadot/JAM's future together!

https://docs.google.com/presentation/d/13YUumFSMPXT8085GwwVe0YCoOVjjCaBm/edit?slide=id.g353759b2ff6_0_18#slide=id.g353759b2ff6_0_18
2025-05-07 22:17 jay_ztc: Thank you for arranging the event!  danicuki | Jamixir:  It was great to meet the community of builders. jamstatus.xyz
2025-05-07 23:10 sourabhniyogi: gav: If you can kindly post the PolkaJAM binary \[Mac binary ok,  Linux whenever ready?\] along with any needed instructions about how to launch it with our own implementations in a tiny testnet targeting 0.6.6 and beyond (something like `jam -spec tiny -v 5 --quic-port 9900 --rpc-port 10800 -start-time +2025-05-08 00:05:56`), this will kick off a lot of us basically doing the same (and probably adapting "flags" pseudo standards to match to keep us sane)!  

With not too much luck, I believe we can have a tiny multiclient testnet this month.  

We definitely want to kick ourselves into high gear by matching PolkaJAM linear recompilation with doom demo before the start of Summer =). [edited]
2025-05-07 23:26 jaymansfield: Does this break any clean-room implementer rules? Since I wasn‚Äôt able to make jam experience I‚Äôm not really sure what was discussed there regarding this. If it is confirmed to be allowed within the rules, I‚Äôd be willing to share a binary of mine that has all of M2 implemented (except grandpa) but obviously will wait for official confirmation [edited]
2025-05-08 07:04 subotic: Hey Jan Bujak, thank you very much for slides. Would have been great to talk to you again in person. I hope some other time. The slides are very much appreciated and really helpful. Many questions that I had are now resolved and even questions that I didn't know that I had :). Thank you very much! ‚ù§Ô∏èüëçÔ∏è
2025-05-08 08:23 danicuki: gav: could you share your presentation slides? I would like to use some of the content for my talk at ETH Lisbon tomorrow. Tks!
2025-05-08 09:37 gav: Right now the binary is targeted towards 0.6.5, but I'll put the mac single-node and tiny-testnet binaries on the GP release page. [edited]
2025-05-08 09:37 gav: Maybe one of the linux people can upload their pair of binaries there too
2025-05-08 09:38 gav: If anyone else wants to share, please send a link and I'll upload to the GP page. I'd say 0.6.5 minimum for now to reduce leg work.
2025-05-08 09:49 clearloop: we'd like to share spacejam binaries but it is currently at 0.6.4, also the network part was a fast implementation so worried about if it contains too many bugs > <

willing join it after connecting to PolkaVM successfully!
2025-05-08 10:32 clearloop: may I ask if it is possible to checkout a tag or branch for 0.6.5 in the test vectors repo ? davxy 
2025-05-08 14:22 danicuki: Anyone who has photos or videos from the event, please share them here: https://drive.google.com/drive/folders/1SLDSDjSDkVs-qoiDyRO0R0UHY9aw4ur5?usp=sharing
2025-05-08 21:14 xlchen: any plans for M2 testvectors?
  ‚Ü≥ 2025-05-09 04:02 clearloop: ref https://github.com/w3f/jamtestvectors/issues/41
2025-05-09 12:09 arkadiy: We've created a repo for the JIPs:
https://github.com/polkadot-fellows/JIPs
2025-05-09 12:09 arkadiy: gav: Could you publish the RPC spec there?
2025-05-09 12:10 arkadiy: There's also a common chain spec file format proposal:
https://github.com/polkadot-fellows/JIPs/pull/1
2025-05-09 12:27 jan: Here are polkajam binaries (+ some of the tooling) for you to play around:

macOS (aarch64):
https://drive.google.com/file/d/1VzCbIUA7RYmsVD8VZwoSnfjgRXlE9b8D/view?usp=sharing

macOS (x86\_64):
https://drive.google.com/file/d/1OnbpSWeMVA1LrUk6y3Td-Vp4AIjQP9Q7/view?usp=sharing

Linux (x86_64):
https://drive.google.com/file/d/1q\_v-YoVUd21ZHKWQcFGlLgR04H5n2uB-/view?usp=sharing

Linux (aarch64):
https://drive.google.com/file/d/1Oj1AICgG6ZDpv7stC6xXkwfyMfXqY4Ko/view?usp=sharing

Windows:
https://drive.google.com/file/d/1Op1ZNUVsy-ek5PUwHUwQANE2MUHXyQr3/view?usp=sharing

Please do let us know if they are any problems with them. (Also, Windows binaries are untested and unsupported; I cross-compiled them because I could in case someone finds them useful, but we only intend to "support" Linux and macOS binaries as no one at Parity uses Windows) [edited]
  ‚Ü≥ 2025-05-09 12:35 oliver.tale-yazdi: `VmEngine(EngineInitializationFailed(Error(Owned("failed to initialize Linux sandbox: not all required userfaultfd features are available; you need to update your Linux kernel to version 6.8 or newer"))))`  
I guess this is expected? Or can i disable the sandbox?
  ‚Ü≥ 2025-05-09 12:46 rotarur: Did you try update your kernel? 
  ‚Ü≥ 2025-05-09 12:47 jan: This is expected. What's your Linux kernel version?
  ‚Ü≥ 2025-05-09 12:48 jan: you can check it with `uname -a`
  ‚Ü≥ 2025-05-09 12:49 oliver.tale-yazdi: `5.10.0-32` üòÖ okay I will nuke the server.  
But it is not possible to run it without sandbox?
  ‚Ü≥ 2025-05-09 12:50 jan: You can run it with the interpreter, in which case it doesn't need a newer kernel.
  ‚Ü≥ 2025-05-09 12:52 jan: IIRC, there should be a command line argument to do it
  ‚Ü≥ 2025-05-09 14:02 davxy: Aside from referencing the GP, perhaps we should explicitly list the tools and node versions in the package?
I assume we'll be publishing updated versions quite often.
For example, we recently integrated gas charging for host calls, and I‚Äôm assuming the shared binary doesn‚Äôt yet include that.
  ‚Ü≥ 2025-05-09 17:38 jan: I've updated the binaries. Changelog:

- macOS binaries were added
- chain ID was removed from app protocol, as this is not (yet?) part of the spec
- gas is now charged for the host calls
  ‚Ü≥ 2025-05-09 21:07 sourabhniyogi: This is awesome --  Ok attempting first contact with PolkaJam "--dev-validator 0..4" , with us as "--dev-validator 5" being 1/6! [edited]
  ‚Ü≥ 2025-05-09 21:12 sourabhniyogi: https://github.com/polkadot-fellows/JIPs/pull/1
  ‚Ü≥ 2025-05-09 21:13 sourabhniyogi: What are the dev seeds for `--dev-validator 0` through `--dev-validator 5`

```
./polkajam -d /tmp/d0 -c /tmp/c0 --chain dev --parameters tiny run  --dev-validator 0 --rpc-port=19800 &
./polkajam -d /tmp/d1 -c /tmp/c1 --chain dev --parameters tiny run  --dev-validator 1 --rpc-port=19801 &
./polkajam -d /tmp/d2 -c /tmp/c2 --chain dev --parameters tiny run  --dev-validator 2 --rpc-port=19802 &
...
```

I believe knowing this will enable us to achieve first contact =) [edited]
  ‚Ü≥ 2025-05-10 07:02 dave: I believe they should match the keys here https://docs.jamcha.in/basics/dev-accounts
  ‚Ü≥ 2025-05-10 07:02 dave: So dev validator 0 is alice, 1 is bob, and so on
  ‚Ü≥ 2025-05-10 09:04 sourabhniyogi: will triple check!

  ‚Ü≥ 2025-05-10 09:12 sourabhniyogi: Where is this "Inserts the keys for the validator into the keystore before running." described for `--dev-validator` in `./polkajam help run` going? [I was expecting these dev seeds to go `.config/polkajam/dev/keys` but no luck]
  ‚Ü≥ 2025-05-14 05:54 shwchg: David Emett Jan Bujak Is there an official chainspec file available for use?
I attempted to generate one myself, but it couldn't be decoded by your binary.
2025-05-09 14:30 danicuki: 10MB binary for PolkaJAM? Impressive! Can I try to run it on my old Atari?
2025-05-09 14:40 clearloop: and 4 MB of the 10MB could be rocksdb if using it ... while we are surprised by the compact binary of polkajam, polkajam guys may confused about why our binaries are larger than 10 MB ü•≤ [edited]
2025-05-10 09:04 sourabhniyogi: Thank you for posting the `polkajam` binaries!  I believe this `polkajam` binary creates a model for how all our binaries should work at a minimum down to flag interfaces, and probably a lot of us will follow almost all of the polkajam flags model.  It shouldn't restrict our binaries from having other flags as we like of course, but some early conventions would help a lot.

Notes/Ideas/Questions:

- We should have a standardized way of doing fuzz testing of refine (work bundle since its self-contained) and accumulate (exactly [traces](https://github.com/davxy/jam-test-vectors/pull/45)) with flags as an input, and supporting both .json and .bin as per w3f jamtestvectors
- Having a flag for _optional_ pvm execute trace generation for the above in standardized form programmatically comparable will be enormously valuable to see when implementations differ on pvm traces - pc, step, gas, registers cover 99% of this -- the first diff is enough.  (Its what people have asked each other for, most commonly, usually for fixing host function implementations).  Since refine pvm traces can get super huge, a "show only on every N steps" flag parameter would be excellent to have as well.  I think this flag should be an output file destination with a line of JSON for each step separated by newlines where "diff" does all the work.
- Having `polkajam-testnet` be _multiclient_ with a testnet config would be wonderful.   Can we make it open source or should we start rolling our own opensource `jamtestnet`?
- Having clarity on the timing of the first authored block's slot would help a lot!  What is the testnet wide approach to this if its not a flag?
- Having each client with verbosity control flags standardized (warn, info, debug, trace) would support the above, with jamtestnet having the same verbosity flag passed into each client.
- Running the client with `--dev-validator` (eg `./polkajam --temp --chain dev --parameters tiny run  --dev-validator 2 --rpc-port=19802`) should follow "Inserts the keys for the validator into the keystore before running." and put 32 byte seed into the same place ( `.config/{client}/dev/keys/`) in a way that can scale from `tiny` to `full`
- Perhaps each client can have unique multiclient seeds instead of the Alice/Bob/... "dev seeds" as [here](https://docs.jamcha.in/basics/dev-accounts) using the name we registered [here](https://jamcha.in/clients).  This could be used for JAM TART `sender_id`?
- Having "jamxyz -V" show the GP version we are using as a convention probably will save us all a lot of grief.  Similarly, we should NOT have our binaries all be named `jam` but something in obvious relation to our team name (jamduna, jambrains, jamixir etc.) starting when we publish it.  An optional git commit should help a lot as well!
- Could stub `-t, --telemetry` https://hackmd.io/@polkadot/jip3 as a flag even though its under design, and similarly for any other "we definitely expect to have this" (refine/accumulate/auth testing, benchmarking) sections so we stub it all out and then have our own short flags for other things, since there are only so many letters in the alphabet ;) [edited]
2025-05-10 10:26 boymaas: Thank you, Jan. If possible, could we also have a Linux aarch64 version?
2025-05-10 10:53 danicuki: I will start uploading videos to our YouTube Channel:
https://www.youtube.com/@PolkadotJAM

Already added many media files to our open github repo:
https://github.com/jamixir/jam-media/ (you can PR there as well with any relevant media you would like to share)
2025-05-10 14:32 jan: Added a link to my original post.
2025-05-10 14:33 boymaas: Thank you Jan Bujak üöÄ
2025-05-12 15:48 james.wilson: Hey guys! Just curious; is there any summary of which teams are currently implementing the JAM spec (and in which languages)? I'm curious to know if there's any interesting space that hasn't been covered already :) 
2025-05-12 15:49 dave: Hey, there's a list of teams here: https://graypaper.com/clients/, not sure how up-to-date it is
2025-05-13 12:35 johnnyb42: Hey, everyone! I've just started learning JAM and trying to understand the possible applications. Especially real-time scenarios.

I've heard about CoreVM and continuous computation without having to worry about the internals of JAM, but I'm still not entirely sure what level of real time I can expect.

Let's say I have a sensor that publishes data at 10 Hz. I want to process this data using a some service on JAM cores.

1) Is there any way I can deliver and process data at this rate in the core? Or am I limited by the fact that the data have to go through DA, be registered in a work-package, and only then enter the core (in 6 s timeslot)?

2) If I pay for several cores, can I parallelize, say, the proccessing data flow of hundreds of MB/s and do it with the same frequency 10 Hz? Or am I limited by the fact that the cores have to generate work-reports, which have to go through the Accumulate stage, etc ‚Äî that is, I need to wait for the next timeslot? So, additional cores != now I can quickly process a large data in one Refine stage and get the result right away.

3) So did I understand correctly that the cores are isolated from each other at the Refine stage and they can only computate their own piece of data (specified in the work-package)?
2025-05-13 16:25 dave: I'll do my best to answer these...

1. It's certainly possible to process 10 Hz data, the more important questions are (a) how much data and (b) what are the latency requirements. Currently a JAM core can accept ~12MB of input data per 6-second slot, so ~2MB/s. Regarding latency, accumulation should typically occur 12-18 seconds after submission of a work-package. If you want to wait for finality, you will typically need to wait an additional 20-30 seconds. There may be protocol changes in the future to improve latency.

2. Yes, JAM is explicitly designed to support scaling in this way: in theory _every_ JAM core could execute a particular service's refine function in one time slot. Hundreds of MB/s would require many cores but should be feasible with the current JAM parameters. Note that when parallelising in this way, your accumulate function will see the results of each refine and be able to combine them together however you see fit, but the refine executions on each core are independent.

3. Yes, the cores are isolated from each other during the refine stage. Each core can access only its own package's extrinsic and imported data. Each core/package can output ~48kB of data to the accumulate stage, and ~12MB to DA. The accumulate stage sees the ~48kB output from every package/core and is free to combine this data however it likes, though note that there is much less accumulate gas available in total than refine gas as accumulate is always executed on every validator.
2025-05-13 16:36 dave: To clarify the latency point a bit: JAM is pipelined, so although there will be quite a few 6-second periods between a work-package submission and the results of this work-package being finalized, a new work-package can be pushed into the pipeline on every core every 6-second slot. Your accumulate function will execute every 6-second slot with whatever new refine outputs are available.
2025-05-14 04:19 tony_lollipop: 
2025-05-14 05:28 tony_lollipop: Is there any guide documents for the polkajam-repl tool?
2025-05-14 05:56 tony_lollipop: Hi, Jan
Is there any guide document about polkajam-repl? We wonder how to load, start, debug a JAM service with it.
2025-05-14 07:59 danicuki: For those who came to JAM Experience Lisbon, your feedback is really important. Please, give us 5 minutes to fill this feedback form?

https://docs.google.com/forms/d/e/1FAIpQLSeJPAATC6Y76RNvvUWo4KHzZqeC4zIkyyb8T9ng_6L5fE0UPQ/viewform
2025-05-14 08:38 johnnyb42: Thanks for the explanation! 

So, I can only send *new* data only once per 6-second timeslot, right? I mean, if new data comes more often and I need to process it right away (in a dozen milliseconds) to get the result, I can't do it in the core. Or am I missing something?
2025-05-14 08:41 dave: Right, if you need milliseconds of latency then JAM is not suitable
2025-05-14 08:45 ascriv: I wonder if it‚Äôs possible to mathematically prove some sort of latency lower bound within some reasonable (secure, decentralized etc) regime/model of blockchain
2025-05-14 08:46 boymaas: We are experimenting with the repl to create a very simple service and send a work package to it. This is not trivial since we do not have access to any source code. For example, we are struggling with the initial step of loading the simplest service. We are trying:

```
t+0 0> boot-create-service 0x5edc11abc426e8906bd52de205d3c57ea7fbcbbb9a5780e29eee69cb14c47ea3
Integer parse error: invalid digit found in string
t+0 0>
```

If anyone could provide a simple walkthrough on creating a service with a code hash, including how to provide the code preimage, set a null authorizer, and send a work package, it would save us a lot of time figuring out the basics.

Another error we are encountering is using jamt to deploy a service to a local devnet. We receive an indication that the max-refine-code-size is missing there. ü§î [edited]
2025-05-14 10:19 bkchr: This is not completely true. It really depends on what latency you are interested in. Are you talking about latency until finality or work package getting guaranteed? Yeah, milliseconds are not possible. However, it depends on your economical requirements. It is maybe enough to trust the guy building the work package and this guy could give you the result in milliseconds. You just need to be aware that later in the process it can be found out that this guy was lieing to you and then you would need to revert stuff.

Simple example, if I gonna buy a coke for 3 euro. The terminal can directly trust the server that accepts it, because no one will scam you for 3 euro. If I'm buying a TV for 3K, maybe I should wait for work package being guaranteed. If I'm buying a house, I should clearly wait for finality :) 
2025-05-14 10:29 johnnyb42: Yes, I thought about this too, these considerations also need to be kept in mind.

I'm thinking more about technical latency here, how much can be squeezed out of the protocol so that it still makes sense to use it.
2025-05-14 11:00 gav: -h/help can be helpful. Otherwise, I‚Äôm afraid these tools don‚Äôt (yet) come with user support :) [edited]
2025-05-14 11:17 gav: FWIW `jamt` will have (has already?) distributed source code.  [edited]
2025-05-14 11:20 boymaas: We already realized that user support would be limited. üòÅ We have found the source for `jamt`. For others working on it, it can be obtained using `cargo clone`. It seems we need to keep fiddling until we get it to work.
2025-05-14 12:25 davxy: Something worth keeping an eye on: https://github.com/PolkadotOpenSourceGrants/apply/pull/14
Especially useful as a future reference point for other potential implementations 
2025-05-14 14:04 ascriv: Hmm.. until that server or system is handling coke purchases worldwide, then there would be incentives to hack? Or maybe we could have a federated system of work package builders  [edited]
2025-05-14 17:40 danicuki: > <@kianenigma:parity.io> Jan Bujak I missed your recompiler talk this morning, would it be possible for you to share the slides here or in a JAM chat to be able to save it for later? thanks!

https://youtu.be/iXsng4YCDQg?si=-wOBXhLKHnYxO5nA the first minutes got lost in the recording, but it doesn‚Äôt compromise to understand the full presentation. 
2025-05-14 18:30 sourabhniyogi: We updated our jamduna binary to more or less match the polkajam binary in terms of having the same flags, and hope other teams will do the same.

For us to make first contact with PolkaJAM we need the PolkaJAM JIP-4 chainspec, and the following Quic TLS nitty gritty nailed down:

- Using polkajam's "Best final block: 0x0259fbe9b7dd6f3c..." output from running `./polkajam -d /tmp/d0 -c /tmp/c0 --chain dev --parameters tiny run  --dev-validator 0 --rpc-port=19800` we spoofed the ALPN protocol string 0259fbe9, which got the polkajam instance opening a connection to our jamduna instance and the TLS cert's `ed25519_public` key indeed match the [dev accounts](https://docs.jamcha.in/basics/dev-accounts)
- However, the peerIDs/SANs/dns\_alt\_names do not, which you can see varying --dev-validator from 0 to 5
"This node is e3r2oc62zwfj3crnuifuvsxvbtlzetk4o5qyhetkhagsc2fgl2oka@127.0.0.1:40000"
"This node is ecjn4brac2kgu25kiykefww6p6ai7noueo6p5af5tnwjgra4eisya@127.0.0.1:40001"
..
"This node is ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005"
none of which match up with the `dns_alt_name` of https://docs.jamcha.in/basics/dev-accounts.
- The UP0 handshake process errors out with "invalid peer certificate" errors, we speculate, due to the SAN issues.
I put together a `go test -run TestPolkajam`  case [here](https://github.com/jam-duna/jamtestnet/tree/main/client)
Can you assist on this? [edited]
  ‚Ü≥ 2025-05-14 19:31 dave: Will take a look tomorrow. The SAN is supposed to be a very simple translation of the public key, almost certainly a trivial bug somewhere...
  ‚Ü≥ 2025-05-15 01:01 sourabhniyogi: Here are the 2  sort-of-competing formats:

1. https://github.com/jam-duna/jamtestnet/blob/main/tiny-00000000.json
2. https://github.com/jam-duna/jamtestnet/blob/main/chainspec.json

Is there some consensus or advice on which one implementers should target -- 1 is very M1-implementer friendly, 2 is very extensible, but not quite sure what implementers should do with the bootnodes attributes
  ‚Ü≥ 2025-05-15 10:38 dave: Support for 2 will likely be required for running on the toaster
  ‚Ü≥ 2025-05-15 10:40 dave: Bootnodes can probably be ignored for now; you can just connect to the validators specified in the state. On a long-running network, the genesis validator nodes would not be expected to be up still, hence the provision of separate bootnodes that you can use to sync the chain and acquire the latest validator set etc
  ‚Ü≥ 2025-05-15 12:22 dave: I'm not sure how the SAN stuff on docs.jamcha.in has been computed. The computation was not specified particularly precisely in the SNP doc, so I'm guessing the computation used for docs.jamcha.in was slightly different to what we have. I've updated the SNP doc to include a precise definition, which should match what PolkaJam does (although I might have made a mistake :)
  ‚Ü≥ 2025-05-15 12:22 dave: https://github.com/zdave-parity/jam-np/commit/222139da2a2393e142c921c7699dd90569c04d33
  ‚Ü≥ 2025-05-15 13:55 shwchg: David Emett: I got our SAN matches, but still have the ALPN mismatch problem

```
2025-05-15 21:43:21 Chain ID: dev
2025-05-15 21:43:21 Config dir: /home/shawn/.config/polkajam/dev
2025-05-15 21:43:21 Data dir: /tmp/.tmpQ5NxZG
2025-05-15 21:43:21 Reading state...
2025-05-15 21:43:21 Writing genesis block.
2025-05-15 21:43:21 Best final block: 0x0259fbe9b7dd6f3c...
```

I saw your log of genesis block is 0x0259fbe9b7dd6f3c... ?
so we adjust our ALPN to

```
alpn=jamnp-s/0/0259fbe9 
alpn_builder=jamnp-s/0/0259fbe9/builder
```

but still got

```
"CRYPTO_ERROR 0x178 (remote): peer doesn't support any known protocol"
``` [edited]
  ‚Ü≥ 2025-05-15 14:15 dave: If you run `polkajam` under `env RUST_LOG=jam_node::net=trace` you should get a log message printed containing the expected application protocol
  ‚Ü≥ 2025-05-15 14:15 dave: Something like:

    2025-05-15 15:13:41 main TRACE jam_node::net  Using application protocol jamnp-s/0/0259fbe9
  ‚Ü≥ 2025-05-15 14:16 dave: This is what I got running `polkajam` just now. Seems to match what you expect, so I guess some deeper debugging required.
  ‚Ü≥ 2025-05-15 14:19 dave: I guess one possibility is that you have a newline character at the end of your protocol string or something like this?
  ‚Ü≥ 2025-05-15 14:26 shwchg: ```
2025-05-15 22:24:01 main TRACE jam_node::net  Using application protocol jamnp-s/0/dev/0259fbe9
```
  ‚Ü≥ 2025-05-15 14:27 dave: Ah. This was fixed very recently on the polkajam branch, I thought the latest release included this change
  ‚Ü≥ 2025-05-15 14:29 shwchg: ok!
If possible, please let us know whether you can use our chainspec file or genesis STF file. 
if you can provide one for us to use, that would work as well.
  ‚Ü≥ 2025-05-15 14:29 dave: AFAICT the binaries most recently posted by Jan have this change
  ‚Ü≥ 2025-05-15 14:29 dave: Linux binaries here: https://drive.google.com/file/d/1q_v-YoVUd21ZHKWQcFGlLgR04H5n2uB-/view
  ‚Ü≥ 2025-05-15 14:30 shwchg: oh ok! let me try it
  ‚Ü≥ 2025-05-15 14:30 dave: If you have a chainspec file you should be able to use it with `--chain <path-to-chainspec-file>`
  ‚Ü≥ 2025-05-15 14:32 dave: It's possible to generate one with `polkajam gen-spec` though the input to that is not really documented yet! üòÖ
  ‚Ü≥ 2025-05-15 14:32 sourabhniyogi: Can you post the chainspec for `dev` in a gist matching up with 0259fbe9 in whatever form?  Or should we do CE128+CE129 basically after first contact?
  ‚Ü≥ 2025-05-15 14:33 dave: Yeah I'll do that, give me a few mins...
  ‚Ü≥ 2025-05-15 14:49 dave: https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d
  ‚Ü≥ 2025-05-15 14:49 dave: You can make `dev-spec.json` from `dev-config.json` with `polkajam gen-spec dev-config.json dev-spec.json`
  ‚Ü≥ 2025-05-15 14:50 dave: We'll hopefully document the `dev-config.json` format at some point, but hopefully it should be fairly self-explanatory [edited]
  ‚Ü≥ 2025-05-15 14:51 dave: `dev-spec.json` should match JIP-4 (https://github.com/polkadot-fellows/JIPs/pull/1), pass to `polkajam` like: `polkajam --chain dev-spec.json`
  ‚Ü≥ 2025-05-15 14:55 dave: `dev-config.json` is quite limited in what it can control; most of the state is just fixed by `gen-spec`. In particular, `gen-spec` always includes a null authorizer (https://crates.io/crates/jam-null-authorizer) and a bootstrap service (https://crates.io/crates/jam-bootstrap-service)
  ‚Ü≥ 2025-05-15 14:55 sourabhniyogi: Thank you!  We'll check it out and report back soon!
  ‚Ü≥ 2025-05-15 15:24 shwchg: David Emett: 
Is it possible to provide a more detailed explanation of the TLS handshake? We encountered the following issue in our implementation:
```
from polkajam
2025-05-15 22:36:18 tokio-runtime-worker DEBUG jam_node::net  [::ffff:127.0.0.1]:35615: Incoming connection failed: the cryptographic handshake failed: error 42: invalid peer certificate: UnhandledCriticalExtension

from us
WARN [05-15|22:36:18.072] sendQuicBytes-length                     peerID=2 err="CRYPTO_ERROR 0x12a (remote): invalid peer certificate: UnhandledCriticalExtension" code=0 msgLen=73 
```

It‚Äôs possible that some verification checks have been added or removed by us or by you.
  ‚Ü≥ 2025-05-15 15:26 dave: Hmm this means you have some extension in your certificate that is marked critical but is not understood by polkajam
  ‚Ü≥ 2025-05-15 15:26 dave: At the moment the only extension we expect is the SubjectAlternativeName extension
  ‚Ü≥ 2025-05-15 15:31 shwchg: ok! thanks!
I will remove the verification from our side for now
  ‚Ü≥ 2025-05-15 15:31 dave: I think this is coming from our implementation, not yours
  ‚Ü≥ 2025-05-15 15:32 dave: You need to remove whatever extension you have from your certificate, or mark it as non-critical
  ‚Ü≥ 2025-05-15 15:34 dave: Possibly we could be more lenient here
  ‚Ü≥ 2025-05-15 15:39 shwchg: I removed some extensions, and it looks like the connection was successful.
We‚Äôll start trying to sync with your node.
If we encounter any issues, we‚Äôll reach out to you.
Thanks for your response!
  ‚Ü≥ 2025-05-15 15:40 dave: Nice!
  ‚Ü≥ 2025-05-16 07:42 shwchg: David Emett: 
Did you support to use the genesis block to do the block request?
  ‚Ü≥ 2025-05-16 07:44 dave: There is no genesis block, only a genesis header
  ‚Ü≥ 2025-05-16 08:38 shwchg: so the only way to catch up is using direction = 1 ? [edited]
  ‚Ü≥ 2025-05-16 08:52 dave: Sorry I think I misunderstood the original question. I think you should be able to request "ascending" starting from the genesis header
  ‚Ü≥ 2025-05-16 08:52 dave: You can't request the block with the genesis header itself though as there is no such block
  ‚Ü≥ 2025-05-16 09:00 shwchg: ok I see!

one more question
are you guys using the same stream for all of the request?

I got this
How do you determine a peer's poor rating?
```
2025-05-16 16:54:48 tokio-runtime-worker TRACE jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:58178: New incoming connection
2025-05-16 16:54:48 tokio-runtime-worker TRACE jam_node::net::peer_manager::peer  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Poor rating
```
  ‚Ü≥ 2025-05-16 09:07 shwchg: the good news is we got the up0 handshake success and got the new block header!
  ‚Ü≥ 2025-05-16 09:32 dave: > <@shwchg:matrix.org> ok I see!
> 
> one more question
> are you guys using the same stream for all of the request?
> 
> I got this
> How do you determine a peer's poor rating?
> ```
> 2025-05-16 16:54:48 tokio-runtime-worker TRACE jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:58178: New incoming connection
> 2025-05-16 16:54:48 tokio-runtime-worker TRACE jam_node::net::peer_manager::peer  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Poor rating
> ```

Poor rating is likely to be caused by not following the protocol. We're planning to change this behaviour so we don't disconnect so aggressively, but obviously protocol bugs should be fixed. The first time a peer is disconnected the QUIC "reason phrase" should contain an error message
  ‚Ü≥ 2025-05-16 09:33 dave: The protocol bug could be on our side of course üòÖ
  ‚Ü≥ 2025-05-16 09:35 dave: Re "using the same stream for all requests": we use streams as described in the SNP doc, so generally a separate stream for each request
  ‚Ü≥ 2025-05-16 09:36 dave: Note that the block announcement stream is an exception to this: it is stateful and should be kept open
  ‚Ü≥ 2025-05-16 09:40 shwchg: we get `Application error 0x4 (remote)` from our log

and got this from yours
```
2025-05-16 17:25:23 tokio-runtime-worker ERROR jam_node::sync  Failed to receive Block: Stream half closed error: Half stream killed
2025-05-16 17:25:23 tokio-runtime-worker TRACE jam_node::net::peer_manager::peer  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Misbehaviour: network i/o failed: timed out (5000ms)
2025-05-16 17:25:23 tokio-runtime-worker TRACE jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:54499: New incoming connection
2025-05-16 17:25:23 tokio-runtime-worker TRACE jam_node::net::peer_manager::peer  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Poor rating
```

and I didn't see our node pop in this kind of log (I guess this is from the server side?)
```
2025-05-16 17:25:18 tokio-runtime-worker TRACE jam_node::net  e3r2oc62zwfj3crnuifuvsxvbtlzetk4o5qyhetkhagsc2fgl2oka@127.0.0.1:40000: Opening BlockRequest stream
```
  ‚Ü≥ 2025-05-16 09:41 shwchg: Maybe we could standardize some error codes
would that be helpful?
  ‚Ü≥ 2025-05-16 10:01 dave: It looks like polkajam requested a block then there was a timeout reading it from the stream. Probably we shouldn't disconnect in this case, but I would look into what's going on there anyway
  ‚Ü≥ 2025-05-16 10:05 dave: > <@shwchg:matrix.org> Maybe we could standardize some error codes
> would that be helpful?

Yes I think we will include error codes in the network protocol eventually. QUIC supports a "reason phrase" on connection close, which polkajam fills with a human-readable error message. I would recommend printing this in your logs
  ‚Ü≥ 2025-05-16 10:09 shwchg: because we fail to request the block from the other node
I will look for the reason
  ‚Ü≥ 2025-05-16 10:11 dave: You shouldn't announce blocks before you have them yourself
  ‚Ü≥ 2025-05-16 10:11 dave: And have verified them
  ‚Ü≥ 2025-05-16 10:12 dave: We could maybe relax the verification requirement for validator<->validator connections
  ‚Ü≥ 2025-05-16 10:20 shwchg: yes! let me check it
thank you!
  ‚Ü≥ 2025-05-16 10:44 shwchg: Is there a way to get the logs related to stream dispatch or incoming bytes?
  ‚Ü≥ 2025-05-16 10:51 dave: I think RUST_LOG=trace will give you everything. We use Quinn for QUIC which produces a lot of logs, not sure exactly what as I haven't yet spent much time looking through them
  ‚Ü≥ 2025-05-18 06:05 sourabhniyogi: Can you explain the semantics of this error, or Polkajam's [temporal] requirement for incoming tickets 

```
2025-05-18 05:56:24 Error processing incoming ticket: finality lagging (final: 1969160, curr: 1969164)
```

  ‚Ü≥ 2025-05-18 06:27 sourabhniyogi: We moved our ticket sending operation to the 5th phase of the epoch to avoid the above and I gather from 

```
2025-05-18 06:23:18 Error processing incoming ticket: current node is not the proxy for the ticket
```

it means all implementations _must_ do the proxying of CE131/132, check?
 [edited]
  ‚Ü≥ 2025-05-18 12:11 dave: Yes you should implement the proxying stuff described in the SNP doc. Without this the tickets aren't really anonymous, kind of defeating the point of Safrole.
  ‚Ü≥ 2025-05-18 12:14 dave: > <@sourabhniyogi:matrix.org> Can you explain the semantics of this error, or Polkajam's [temporal] requirement for incoming tickets 
> 
> ```
> 2025-05-18 05:56:24 Error processing incoming ticket: finality lagging (final: 1969160, curr: 1969164)
> ```
> 

The timing requirements are described in the SNP doc, though with the really short epochs we have with the "tiny" params some of the constants need adjusting. Will post these later.
  ‚Ü≥ 2025-05-18 22:59 sourabhniyogi: image.png
  ‚Ü≥ 2025-05-18 23:00 sourabhniyogi: An explanation would be useful -- it was simple to change to send tickets on phase 4/5 and get 131/132 working. 


  ‚Ü≥ 2025-05-19 23:01 dave: https://github.com/zdave-parity/jam-np/commit/ec45e7ce0e0c1e239b2d7c123f6f688f06a40b00
  ‚Ü≥ 2025-05-19 23:03 dave: Not sure what you mean by phase 4/5 but hopefully that change makes sense; for the "tiny" network it means each wait is basically just one slot instead of minutes...
  ‚Ü≥ 2025-05-19 23:47 sourabhniyogi: Will incorporate (by phase 4/5 I just meant the 4th/5th slot of the epoch) - thank you!

We have all the different weights 2+4, 3+3, 4+2, 1+5, 5+1 working well in fallback+safrole-- so now have to get into the real work of work packages.

I'm having a hard time getting polkajam to recognize our chainspec -- it appears to basically ignore our input and continue to use `dev` no matter what

```
# ./polkajam --chain k.json --temp run --dev-validator 3 --rpc-port=19803
2025-05-19 23:45:02 Chain ID: dev
2025-05-19 23:45:02 Config dir: /root/.config/polkajam/dev
2025-05-19 23:45:02 Data dir: /tmp/.tmphmRvKD
2025-05-19 23:45:02 Reading state...
2025-05-19 23:45:02 Writing genesis block.
2025-05-19 23:45:02 Best final block: 0x0259fbe9b7dd6f3c...
```

Is there some other requirement I've missed?
  ‚Ü≥ 2025-06-03 07:38 knight1205: Hi David Emett ,

I had a few questions:

1. Certificate validation happens on both sides right when a client node connects to a server (mTLS) or only on client side (TLS). And in particular when each node's client has to initiate connection to other node's server. In my case I don't seem to get direct access to client's certificate on server node using quic library.
2. In jamnp, it's mentioned that cert is required and needs to be self signed, but need not be verified. But self signed certificates throw error.
3. Also, will there be CA certs as mentioned in jamcha docs? as for now we are just providing SAN as per snp. [edited]
  ‚Ü≥ 2025-06-04 13:46 knight1205: sourabhniyogi David Emett do let me know about this.
  ‚Ü≥ 2025-06-04 13:49 dave: Certificates should be presented and checked by both sides yes. Some QUIC libraries do not provide a good way of accessing the "client" certificate; this is one reason we're using quinn rather than for example s2n-quic in PolkaJam.
  ‚Ü≥ 2025-06-04 13:52 dave: At most one connection should be opened between a pair of nodes, there shouldn't be a connection opened in each direction. In the case of validator-validator connections the SNP doc provides a rule for deciding which validator should initiate the connection
  ‚Ü≥ 2025-06-04 13:55 dave: What do you mean by "self signed certificates throw error"? If you mean in your QUIC implementation then yes by default that is likely the case. SNP requires some overriding of the certificate handling as it does not use certificates in the normal way.
  ‚Ü≥ 2025-06-04 14:03 dave: No there won't be CA certs or anything like this. Certificates are only really used because that's what TLS uses. We don't really use any of their features. In SNP peers are identified by their Ed25519 key which is verified by the TLS handshake signature, all the certificate really does is provide this key. The purpose of the DNS alt name stuff is to fit in with libraries which allow an expected server name to be provided; the DNS name stuff allows an expected Ed25519 key to be placed here.
  ‚Ü≥ 2025-06-04 14:07 knight1205: Thanks, will look into this. 
  ‚Ü≥ 2025-06-04 14:07 dave: > <@sourabhniyogi:matrix.org> Will incorporate (by phase 4/5 I just meant the 4th/5th slot of the epoch) - thank you!
> 
> We have all the different weights 2+4, 3+3, 4+2, 1+5, 5+1 working well in fallback+safrole-- so now have to get into the real work of work packages.
> 
> I'm having a hard time getting polkajam to recognize our chainspec -- it appears to basically ignore our input and continue to use `dev` no matter what
> 
> ```
> # ./polkajam --chain k.json --temp run --dev-validator 3 --rpc-port=19803
> 2025-05-19 23:45:02 Chain ID: dev
> 2025-05-19 23:45:02 Config dir: /root/.config/polkajam/dev
> 2025-05-19 23:45:02 Data dir: /tmp/.tmphmRvKD
> 2025-05-19 23:45:02 Reading state...
> 2025-05-19 23:45:02 Writing genesis block.
> 2025-05-19 23:45:02 Best final block: 0x0259fbe9b7dd6f3c...
> ```
> 
> Is there some other requirement I've missed?

Think I missed this message before, sorry. This was probably because the --dev-validator argument used to override the --chain argument. I assume this is working for you now, let me know if this is not the case...
  ‚Ü≥ 2025-06-23 13:08 knight1205: David Emett: can you please share what all fields/extensions are required to be set while building certificates? 

Currently, while connecting to Polkajam, I am encountering errors: InvalidForName, ServerNameMustContainOneHostName.
  ‚Ü≥ 2025-06-24 01:48 dave: You just need the alternative name extension, with a single DNS name as defined in the SNP doc
  ‚Ü≥ 2025-07-01 12:17 prasad-kumkar: hi David Emett: could you please share how polkajam binary does syncing? We are trying to request all blocks from genesis till the latest time-slot via CE128, but not sure if this is correct as we are unable to get a response, and we get a timeout
  ‚Ü≥ 2025-07-07 12:13 dave: Sorry have been on holiday. If you aren't getting a response you may not be sending a properly formatted request.
  ‚Ü≥ 2025-07-07 12:18 dave: There is no prescribed strategy for syncing the chain. As long as you follow the protocol described in the SNP doc any reasonable strategy should work.
  ‚Ü≥ 2025-07-07 13:34 oliver.tale-yazdi: >to request all blocks from genesis till the latest time-slot via CE128, but not sure if this is correct as we are unable to get a response, and we get a timeout

I thought about the same thing to do, but SNP only mentions that the responding nodes needs to respond with *a child*, not the canonical one. So you could get stuck in old forks.  
Not sure if this is the intended meaning, but it leads to the consequence of having to do reverse order
  ‚Ü≥ 2025-07-07 13:35 oliver.tale-yazdi: Just doing descend downloading would be like trying to random-walk a tree downwards.
  ‚Ü≥ 2025-07-07 13:35 oliver.tale-yazdi: Maybe the spec could be amended to prioritize blocks of the final (or best fork)? [edited]
  ‚Ü≥ 2025-07-07 14:27 dave: CE128 shouldn't return blocks that can't be finalised, I'll clarify this in the doc. But if there are multiple forks yes you need to request them explicitly in reverse order, there isn't really a way to ask for a particular fork otherwise as you say.
2025-05-15 02:56 sourabhniyogi: Published jamduna binaries:

https://github.com/jam-duna/jamtestnet/releases/tag/0.6.6.1
2025-05-15 07:25 prematurata: is the repl interface shown in some of the jam sessions public? looking forward building a repl interface that matches the same commands/args to keep compatibility
2025-05-15 10:36 dave: We've released a binary here. Source will be released at the same time as polkajam.
2025-05-15 14:26 shwchg: 
2025-05-16 14:05 davxy: @room

After reviewing the open issues related to compatibility with GP-0.6.5, I've tagged the test vectors for version 0.6.5.
Everyone is welcome to try them out and report any issues they encounter.
We'll begin integrating 0.6.6 shortly.
From now on, all changes between tags will be listed in the changelog explicitly.

https://github.com/davxy/jam-test-vectors/releases/tag/v0.6.5
2025-05-17 14:02 sourabhniyogi: image.png
2025-05-17 14:04 sourabhniyogi: First contact successful, thank you David Emett Jan Bujak for all your help and posting the binaries.  In a 5 Polkajam + 1 jamduna tiny testnet, we can import Polkajam-authored blocks and Polkajam can import jamduna-authored blocks.
2025-05-18 16:08 stsoen: I have studied Gray Paper closely, I have also scrutinized all the comments in the issues in https://github.com/gavofyork/graypaper

Further, I was confused by this mention of XCMP in the context of JAM here: https://wiki.polkadot.network/learn/learn-jam-chain/#:~:text=run%20excessively%20long.-,XCMP,%C2%B6,-Moving%20on%20to

And I have a question. I understand that JAM cores should be able to communicate with each other in asynchronous mode. So I assumed that JAM would use XCMv2 and higher versions.

But how will the cores actually communicate with each other?
2025-05-18 17:05 gav: Cores don‚Äôt communicate. 
2025-05-18 17:06 gav: Services and things which run on top of them may interoperate/communicate. 
2025-05-18 17:06 gav: Cores are stateless and isolated with the exception of D3L access. 
2025-05-18 20:56 stsoen: gav Thank you very much! I would really appreciate it if you could help me clarify this:

Do I understand correctly that a service running in core1 can communicate with a service running in core2?

Will there be some framework to connect services and dApps to each other?

For example, I am considering this kind of usecase:
- core1 is running a perp protocol (similar to Hyperliquid) or a lending protocol. Dedicating all processes related to their engine in a separate Core allows more speed for platform computation.
- core2 launched a oracle protocol, whose participants (e.g. providers/reporters/oracles etc) provide price feeds and are responsible for correct calculation of clearing prices based on on-chain and off-chain data sources. 
- core3 launched a service that holds an auction for liquidator bots (OEV extraction and maximization of profit from liquidations). In addition, it can also run auctions for the best acquiring transactions (like CoW, UnswapX, 1inch Fusion etc).

Will these cores be able to exchange prices and positions information with each other? Or should the connection method for services running in different cores be developed separately?

For example: core1 and core3 receive data from core2, then core3 interacts with positions ( liquidate them) in core1
2025-05-18 20:58 xlchen: core is like cpu core, we don't usually talk about communication between cpu cores during application development. instead, IPC mechanism will be used for that, e.g. XCMP
2025-05-18 20:59 xlchen: and an app can be multi core, or sharing a core with other apps etc
2025-05-18 21:00 xlchen: and like PC, a core can't really send a message to another core. it is done via register or memory. same thing here
2025-05-18 21:02 stsoen: Thank you!

In that case, can different services running in different cores communicate with each other in any standardized way?

For example, as in the case I described above, when different services/protocols are created by different developers
2025-05-18 21:03 xlchen: services can send token + memo to other services. this is defined by GP
2025-05-18 21:10 stsoen: Do you mean Authorize token that includes opaque data that are included in the work package? Or do you mean a token as a ticker?

I'm interested in whether any data can be transferred between different services in different cores as messages or something similar (like price feeds).
2025-05-18 21:11 xlchen: by token I mean DOT. basically the answer is yes. how depends on the exact use case
2025-05-18 21:15 stsoen: Thanks for the clarification! So, does JAM have any built-in native protocol for inter-service messaging similar to how it is implemented in XCM?
2025-05-18 21:16 xlchen: I already said, service can send DOT token + a memo message to other services for message passing
2025-05-18 21:19 stsoen: So JAM will use a DOT or other native token for JAM, right? Because it looks like it should be some kind of basic gas token for the ecosystem. 

And let's say a minimum amount of DOT (0.00001 for example) can be used to transfer information between services (in memo)?
2025-05-18 21:19 xlchen: DOT is the native token / gas token
2025-05-18 21:23 xlchen: I think it is possible to send 0 DOT and still attach a message with it but someone need to read the GP to confirm [edited]
2025-05-18 21:30 gav: > <@xlchen:matrix.org> I think it is possible to send 0 DOT and still attack a message with it but someone need to read the GP to confirm

Indeed it is. 
2025-05-18 21:52 stsoen: Am I correct in understanding that spam exclusion will occur during the Auditing and Judging process?
2025-05-19 08:27 gav: > <@stsoen:matrix.org> Am I correct in understanding that spam exclusion will occur during the Auditing and Judging process?

Spam exclusion? 
2025-05-19 08:28 gav: Perhaps you‚Äôre under the misapprehension that JAM processes transactions?
2025-05-19 08:29 gav: (Zero-value transfers still must be processed and thus still cost gas - this is not a spam vector)
2025-05-19 09:51 danicuki: I know it may be boring, but spending 5 minutes filling this feedback form will really help us to organize more events like JAM Experience. We had only 15% of attendees filling it. Thanks for your help: 
https://forms.gle/dK1xPhx3rBZq8gpg9 
2025-05-19 12:00 stsoen: 
2025-05-19 12:01 stsoen: I‚Äôm considering the following situation:

- There is a certain service1 that performs some important functionality, which, for example, makes it a target for an attacker.
- It is mentioned that JAM has ultra-low gas costs, so the attack shouldn't become expensive.
- service2, running on top of core2, starts sending a huge number of DOT tokens to service1 in the form of separate chunks (since the token has to be sent from somewhere and delivered somewhere, right? A token transfer from one address to another can be called a transaction, correct? I don't know how else to refer to transactions between cores other than as transactions).
- This service1 starts receiving a lot of incoming zero-value DOT transactions from service2, and it has to include them in the work package, which interferes with other ongoing processes.

Situations that have occurred, for example with Inscriptions, clearly demonstrated that even high-performance networks can experience significant issues due to something trivial and temporary.

And I‚Äôm trying to understand where the filtering of such malicious coordinated spam will happen. Will this be prevented at the Authorizer level? Or will it be rejected on-chain during work packages validation? [edited]
2025-05-19 12:37 dave: > zero-value DOT transactions from service2, and it has to include them in the work package

This is a misunderstanding. Any transfers triggered by service2's accumulate function are "paid for" out of service2's accumulation gas limit and are handled as part of block execution. They are not included in service1's work packages or anything like this.
2025-05-19 15:01 dvdplas: Our team would like to ensure the developer experience for JAM application builders is as best as it can be when the first hackathons will be held.

What would be the first service, apart from CoreChains, that devs most probably want to build on top of?

Is it expected that more devs build services or applications on top of an existing service?

  ‚Ü≥ 2025-05-19 17:33 kianenigma: a good staring point for this would be to look at JAM SDK aka https://docs.rs/jam-pvm-common/latest/jam_pvm_common/ and try it out
2025-05-19 15:07 stsoen: Service 1 receives tokens, albeit zero-value and with a memo message. It should change its state, right?
2025-05-19 15:08 dave: That's totally up to what service 1 does in its on-transfer function. It might just ignore the memo.
2025-05-19 15:11 stsoen: All of my questions are specifically about the ability to pass messages between services running in different cores. 
Accordingly, if a service can ignore certain memos - it needs to include the allowed whitelist of memos that it considers correct and available for processing, right? [edited]
2025-05-19 15:13 dave: If you write a service which expects to be sent memos from other services, I expect you would document the expected format of these memos yes. Not sure if that's what you mean.
2025-05-19 15:14 stsoen: Yes, that's what I meant, thank you! It's similar to administration with creating allowed domains and allowed requests/commands [edited]
2025-05-19 15:22 dave: FWIW I wouldn't think about services running on or being assigned to particular cores. Services are somewhat orthogonal to cores. You will be able to buy core time and submit work-packages using this core time which run any services you like. Of course what effect these work-packages have is up to the author of the service code. You will be able to create services without paying for any core time, leaving it to some other party to pay for core time and submit work-packages.
2025-05-19 15:26 sourabhniyogi: stsoen@Lollipop: If you want one service A to communicate with another service B, you can design a mailboxing system *outside* the transfer memo process, where 
(a) Service A writes (using the host function `write`) into a certain set of keys designated for B 
(b) Service B reads (using the host function `read`) from the above set of keys from Service A's storage
(and in the reverse direction.) JAM does not impose constraints on service A + B on how to do this except that the `write` and `read` could only be in the `accumulate` invocation of the service.  So for the services `refine` operation done in core, the content of what is written in these keys have to be output in work results.   This requires some degree of getting used to but I would recommend you just jump in and just write your service A and B to explore this -- the testnets are basically ready for experimentalists to post work packages and see this kind of messaging happen.

You could imagine a bunch of interoperable services having a structured way of doing this, and perhaps a JIP could and should be devised specifically for this purpose, informed by HRMP's Queues or something else.  There are no real constraints for this, and it doesn't have to be put into XCM/XCMP formats/protocols -- you are free to just work directly with writes and reads.  With some luck, you'll have "here is how we did inter-service messaging" story to report back with. 
2025-05-19 15:28 stsoen: For some reason, I got the impression that different Cores may have machines (servers/nodes) with different characteristics. For example, some core might include machines with simplified specs for performing basic tasks. And some cores might have machines with powerful GPUs and TEE chips for handling highly specialized, resource-intensive tasks. (TEE for RISC-V is currently under development, but given the openness of RISC-V, this will require separate specifications)

Or is this incorrect, and all cores will have the same set of hardware?


2025-05-19 15:33 gav: > <@dvdplas:matrix.org> Our team would like to ensure the developer experience for JAM application builders is as best as it can be when the first hackathons will be held.
> 
> What would be the first service, apart from CoreChains, that devs most probably want to build on top of?
> 
> Is it expected that more devs build services or applications on top of an existing service?
> 

CoreVM quite possibly, but maybe there will be other more transaction-orientated services. 
2025-05-19 15:36 gav: It is incorrect. Cores are homogeneous and fungible. They have a specific and fixed amount of I/O bandwidth and processing power specified in 6-second intervals.  [edited]
2025-05-19 15:38 stsoen: So all Cores have the same hardware requirements? 

And if I want to get Core AI-oriented computing - I can't deploy GPU-based nodes there? [edited]
2025-05-19 15:38 gav: The hardware *requirement* for a core isn‚Äôt really a thing. 
2025-05-19 15:39 gav: JAM guarantees correctness of all of the compute which is done on its cores. Exactly what the hardware requirements were for any given core varies and in some sense is unknowable.  [edited]
2025-05-19 15:40 gav: However the theoretical specifications of its cores are well-defined. 
2025-05-19 15:41 gav: There is no affordance to increase the capabilities of individual cores. This is a basic implication of the JAM correctness mechanism, where any validator may be called upon to audit any piece of work. 
2025-05-19 15:42 gav: In the future we may see JAM instances whose cores are more substantial than that which the GP presently defines. For example we may introduce a GPU invocation host call. 
2025-05-19 15:42 gav: This might be quite helpful for AI inference workloads. 
2025-05-19 15:44 gav: It won‚Äôt be part of 1.0 but it could make it into eg 2.0, however it must be balanced against making all validator nodes‚Äô hardware & running costs substantially higher. 
2025-05-19 15:44 gav: The running costs imply a baseline pricing for core time. For an economy around JAM to be sustainable, pricing and costs must be aligned with each other. 
2025-05-19 15:45 gav: If validator costs double, then Coretime revenue must also double or the system is not economically sound.  [edited]
2025-05-19 15:51 gav: For this reason cloud compute services (where different servers provide different capabilities) don‚Äôt make an ideal point of comparison.
2025-05-19 15:53 stsoen: Yes, that's exactly the problem with modern cloud computing: modern tasks, due to poor optimization, require such a huge amount of resources that the cost of renting hardware either breaks the economics or makes the product unnecessarily expensive.

That's why I'm impressed with the RISC-V integration, because maybe it will finally allow for a more rational treatment of optimization capabilities. And maybe it will make processes more optimized instead of constant power inflation with loss of process execution quality due to bloated libraries and frameworks.
2025-05-19 22:33 sourabhniyogi: Can someone publish the { bootstrap, null_authorizer, ... } services included in polkajam genesis state (and compilation Makefile, if it exists)?  Goal is to test multi-client workpackage submissions.   We can then retire our [bootstrap](https://github.com/colorfulnotion/polkavm/tree/dev/services/bootstrap) and [null authorizer](https://github.com/colorfulnotion/polkavm/tree/dev/services/null_authorizer) -- this way there is just one `dev` JIP-4 chain spec for multi-client tiny testnet setups and process to create new services.
2025-05-19 22:34 dave: These are published on crates.io: https://crates.io/crates/jam-null-authorizer, https://crates.io/crates/jam-bootstrap-service
2025-05-19 22:35 jan: Regarding the possibility of JAM having GPU compute capabilities built-in - as Gav alluded there is a _possibility_ of it being part of JAM 2.0, but I would suggest to not get too excited for now. It would require significant design work and most likely some major changes/improvements to the protocol, as GPU compute is _fundamentally_ very different than CPU compute. You can't really guarantee determinism with GPUs (even a different version of the same GPU driver can make your GPU kernels produce different results!), gas metering is pretty much impossible, and for e.g. workloads like AI the I/O requirements are _extreme_ so without at least some support for having a ton (_gigabytes_) of persistent local data (for storing the weights pinned to the same core) across blocks it would be so insanely expensive that practically it'd be completely useless.

If you're interested in decentralized GPU compute there are people currently doing some pioneering work on it here: https://www.primeintellect.ai/blog/intellect-2

So _if_ we're going to do GPU compute on JAM it would probably be _something_ like that, except we would try to make it as general purpose as possible instead of just hardcoding it to a single type of workload. Just as we took the fundamental mechanism of what makes parachains possible from Polkadot and now with JAM we've generalized it so that you can implement parachains _on top_ of JAM, we could maybe also generalize what the prime intellect people are doing for GPU compute. But, again, this would require significant design work to be practical/economical.

That said, of course you could have an _offchain_ GPU compute provider and use JAM as-is to facilitate that/buy GPU compute time on it even _today_. [edited]
2025-05-19 22:35 dave: Not sure if they're up-to-date
2025-05-19 22:35 dave: They can be built into a PVM binary using https://crates.io/crates/jam-pvm-build
2025-05-19 22:38 dave: The JIP-4 chainspec I posted before (https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d) contains this null authorizer and bootstrap service, though possibly more recent versions than currently released on crates.io
2025-05-19 22:43 sourabhniyogi: The repo/source for both are in https://github.com/paritytech/polkajam only and thus invisible?  Is it possible to move these out of closed source `polkajam` and into open source `jam-services` ?
2025-05-19 22:48 dave: You can fetch the source from crates.io using something like this https://crates.io/crates/cargo-clone
2025-05-19 22:49 jan: You can also create a dummy project, and use `cargo add` + `cargo vendor` to download the sources without any extra tools.
2025-05-19 22:55 dave: I've updated the SNP doc so that it makes sense for eg "tiny" network parameters, see https://github.com/zdave-parity/jam-np/commit/ec45e7ce0e0c1e239b2d7c123f6f688f06a40b00
2025-05-19 22:57 dave: This isn't intended to change anything in the "full" 1023-validator parameters case, but hopefully avoids guesswork in other cases
2025-05-19 22:59 dave: In particular the ticket distribution timing is now based on the epoch length and so should make sense with the really short epochs you get with the tiny params
2025-05-19 23:08 jaymansfield: Does the published polkajam binary use these settings already?
2025-05-19 23:08 dave: Yes it should do
2025-05-19 23:56 sourabhniyogi: Is there some `polkajam`  env variable that reveals that `polkajam` is (or is not) reading the `--chain k.json` input of `./polkajam --chain k.json --temp run --dev-validator 3 --rpc-port=19803\` -- we cannot get it to read our JIP-4 chainspec =( [edited]
2025-05-20 00:16 jaymansfield: I noticed if ‚Äîdev-validator is set it ignores ‚Äîchain and always defaults to dev instead. Would be nice if they could be used together though. [edited]
2025-05-20 00:29 sourabhniyogi: How do we supply a seed manually then?
2025-05-20 00:32 dave: `--dev-validator` forces `--chain dev` yeah, this is documented in `--help`. Guess it would be useful for it to only change the default.
2025-05-20 00:39 dave: Not sure it's actually possible to load the keys for a dev validator without `--dev-validator` as they are unfortunately not derived from the seed in the same way as the on-disk seeds generated by `gen-keys`! Might be a good idea to fix this, though I expect many teams have implemented the dev validator key stuff so this could be fairly disruptive
2025-05-20 00:43 dave: The difference is that on-disk seeds are hashed to produce different seeds for Ed25519 and Bandersnatch, to avoid any issues that could arise from using the same seed for both. This hashing is not currently done for the dev validator keys.
2025-05-20 00:45 dave: I'll put together a fix for this tomorrow anyway and release some new binaries.
2025-05-20 00:50 dave: I'll also document how key seeds are currently handled by PolkaJam; guess this can go in a JIP. The extra hashing goes like `ed25519_seed = blake2b(personal = b"polkajam-ed25519", seed_from_file); bandersnatch_seed = blake2b(personal = b"polkajam-bsnatch", seed_from_file)`
2025-05-20 00:51 sourabhniyogi: Terrific!  FYI we also could not get polkajam to parse your provided `dev-spec.json` [here](https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d) which can serve a a controlled test case?

```
# ./polkajam --chain chainspecs/dev-spec.json run 

thread 'main' panicked at crates/cli/src/lib.rs:81:58:
Error loading chain spec file: "Error decoding genesis_header: Could not decode `Header::epoch_mark`:\n\tCould not decode `Option::Some(T)`:\n\t\tCould not decode `NextEpochDescriptor::validators`:\n\t\t\tCould not decode `EpochKeySet::bandersnatch`:\n\t\t\t\tCould not decode `Public.0`:\n\t\t\t\t\tNot enough data to fill buffer\n"
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Aborted (core dumped)
```
2025-05-20 00:51 dave: If you're keen it should be possible to `gen-keys` a bunch of keys and generate a chainspec using these
2025-05-20 00:53 dave: Ah. I might have made the mistake of testing this with `--dev-validator` üòÖ, will look into tomorrow
  ‚Ü≥ 2025-05-20 05:00 shwchg: David Emett: 
Could you please explain more about how to use jamt?
For example, how do you choose the TCP port, and how do the parameters work?
```
~/Desktop/colorfulnotion/jam/bin/polkajam_bin$ ./jamt create-service <some hex bytecode> 1000000 
Bootstrap service #0 identifies as jam-bootstrap-service v0.1.21 by Parity Technologies <admin@parity.io>
Work package submitted at slot 1997397. Monitoring...
Service eeeb3531 created at slot 1997398
Providing service code...
Submitted. Waiting for provision...
Service code provided at slot 1997399
```
  ‚Ü≥ 2025-05-20 05:14 shwchg: and we got this 
```
thread 'tokio-runtime-worker' panicked at crates/node/src/lib.rs:131:27:
not implemented
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

thread 'tokio-runtime-worker' panicked at crates/node/src/lib.rs:131:27:
not implemented
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

thread 'tokio-runtime-worker' panicked at crates/node/src/lib.rs:131:27:
not implemented
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
Can u also help me check this?
  ‚Ü≥ 2025-05-20 18:41 dave: `jamt` uses RPC, as defined in JIP-2. The RPC endpoint is specified with `--rpc`. `--help` should cover usage. If you have any specific questions that aren't answered by `--help` feel free to ask in this channel.
2025-05-20 02:13 jaymansfield: JavaJAM now works running alongside polkajam nodes and they can import each others blocks (safrole and fallback) üòÄ
2025-05-20 07:37 emielsebastiaan: > <@dave:parity.io> I'll put together a fix for this tomorrow anyway and release some new binaries.

Will this release based on GP-0.6.6?
2025-05-20 09:15 gav: No - I'm going to prioritise getting GP to 0.7 over bring the codebase/vectors up to 0.6.6
2025-05-20 18:25 dave: Sorry just got around to looking at this. You currently need to specify the chain parameters separately as they are not included in the spec, so `./polkajam --parameters=tiny --chain chainspecs/dev-spec.json run` should work.
  ‚Ü≥ 2025-05-20 18:41 sourabhniyogi: Ah, but is there a way to get the `dev-validator` input working with it though?

```
./polkajam --parameters=tiny --chain chainspecs/jamduna-spec.json run --dev-validator 3
```

This is what we are hoping will be possible in your next binary push

In the meantime, we are using the `jamt create-service` to get some work packages using the `dev` bootstrap, and we believe that polkajam CE134 is not sending a `WorkPackageBundle` but merely a `WorkPackage`... because what `polkajam` sends is basically decodable as a `WorkPackage` but not a `WorkPackageBundle` -- could this be a temp solution you've employed or do you think we have our `WorkPackageBundle` decoding concepts wrong when there are 0 extrinsics and 0 justifications?  We are not aware of any testvectors for `WorkPackageBundle`.

PS We have been able to import polkajam-authored blocks with guarantees (from this `jamt create-service` way of triggering CE133/134) followed by assurances -- the CE142/143 situation is bottlenecked by a basic need for pvm execution logs from accumulate.  [edited]
  ‚Ü≥ 2025-05-20 18:44 dave: Auditing protocols are not currently enabled in PolkaJam releases, this is probably the issue
  ‚Ü≥ 2025-05-20 18:45 dave: I'll drop the `unimplemented()` and just make PolkaJam close these streams immediately for now
  ‚Ü≥ 2025-05-20 19:17 sourabhniyogi: https://github.com/davxy/jam-test-vectors/pull/45#issuecomment-2895537979
  ‚Ü≥ 2025-05-20 20:38 dave: > <@sourabhniyogi:matrix.org> Ah, but is there a way to get the `dev-validator` input working with it though?
> 
> ```
> ./polkajam --parameters=tiny --chain chainspecs/jamduna-spec.json run --dev-validator 3
> ```
> This is what we are hoping will be possible in your next binary push
> 
> In the meantime, we are using the `jamt create-service` to get some work packages using the `dev` bootstrap, and we believe that polkajam CE134 is not sending a `WorkPackageBundle` but merely a `WorkPackage`... because what `polkajam` sends is basically decodable as a `WorkPackage` but not a `WorkPackageBundle` -- could this be a temp solution you've employed or do you think we have our `WorkPackageBundle` decoding concepts wrong when there are 0 extrinsics and 0 justifications?  We are not aware of any testvectors for `WorkPackageBundle`.
> 
> PS We have been able to import polkajam-authored blocks with guarantees (from this `jamt create-service` way of triggering CE133/134) followed by assurances, .. and are checking what's up with our CE137/CE142 life now.  

Yes, binaries coming soon that should make the dev-validator stuff work. Re CE134 I believe our implementation matches the SNP doc. The bundle encoding is as in the GP, note that a number of the lists in the bundle are not length-prefixed, instead having their length implied by the work-package. See 14.15 in the GP and note that lists are only length-prefixed when there is a ‚Üï symbol in front
  ‚Ü≥ 2025-05-20 21:21 sourabhniyogi: Hmm -- for a WP with 0 extrinsics, 0 imported segments and thus 0 justifications, for the J term of the work package bundle described in  [14.14](https://graypaper.fluffylabs.dev/#/9a08063/1b43021b4302?v=0.6.6) where there _is_ a  ‚Üï symbol, do you get _one_ 0x00 byte after the work package a per [C.8](https://graypaper.fluffylabs.dev/#/9a08063/394401394401?v=0.6.6) in the work package bundle?  

Understand about the extrinsic lengths and imported segments implied by the WP items, but some bundle codec test cases here would go a long way.
  ‚Ü≥ 2025-05-20 21:24 dave: The ‚Üï symbol in 14.14 is on each justification. There is no ‚Üï symbol on the list of justifications, the number of justifications is implied by the work-package
  ‚Ü≥ 2025-05-20 21:25 dave: Agree it would be great to have bundle test vectors
  ‚Ü≥ 2025-05-20 21:25 sourabhniyogi: Ah got it -- thank you!
  ‚Ü≥ 2025-05-21 02:04 sourabhniyogi: Your latest binary enabled polkajam to use our chainspec, we can now do things with our bootstrap/null_authorizer/... etc -- thank you again.

Also, we were able to address the WorkPackage/Bundle decoding problem so CE133/134 are happy together... now need to get refine+accumulate alignment.  
  ‚Ü≥ 2025-05-22 01:21 mkchung: Could we have a codec test vector for WorkPackageBundle?

Also, if a WorkPackage contains multiple WorkItems, and only some of them include imported segments or justifications ‚Äî should the "S" (imported segments) and "J" (justifications) fields omit entries for WorkItems that don‚Äôt have any, or should "J" still be encoded as empty for those items given the  ‚Üï?

In the following example, workItem_1 is the authorization item (which has no importedSegment or justification):
https://gist.github.com/mkchungs/ee6ec72a8ab9d0ee98904a926a427840
The bundle codec is encoded without workItem_1 in "S" and "J".

Can we expect the WorkPackageBundle JSON test vector to follow a similar format to Option 1?
2025-05-20 21:31 dave: New release of PolkaJam here: https://github.com/paritytech/polkajam-releases/releases/tag/manual-2025-05-20. This has the requested change to the `--dev-validator` flag; it will now no longer override an explicitly provided `--chain` option
2025-05-20 21:32 dave: Nightly builds of PolkaJam should now be automatically created and uploaded here: https://github.com/paritytech/polkajam-releases/releases
2025-05-20 21:34 dave: The GP version implemented is now shown by `./polkajam --version`
2025-05-20 23:30 jaymansfield: > <@dave:parity.io> Nightly builds of PolkaJam should now be automatically created and uploaded here: https://github.com/paritytech/polkajam-releases/releases

Should we use the same repo for issues? I‚Äôve had polkajam crash a few times while running. 
2025-05-20 23:33 dave: Yes feel free to open issues there
2025-05-21 06:51 clearloop: on connecting polkajam,

```
 polkajam --chain dev run -d 0 --dev-validator 0  
```

I got

```
// this error is from spacejam
2025-05-21T06:34:29.224367Z ERROR transport::verifier: invalid certificate: expected e3r2oc62zwfj3crnuifuvsxvbtlzetk4o5qyhetkhagsc2fgl2oka, got ehnvcppgow2sc2yvdvdicu3ynonsteflxdxrehjr2ybekdc2z3iuq
```

`e3r2oc62zwfj3crnuifuvsxvbtlzetk4o5qyhetkhagsc2fgl2oka` is defined in the [dev-spec](https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d) indeed, however I got `ehnvcppgow2sc2yvdvdicu3ynonsteflxdxrehjr2ybekdc2z3iuq` via extracting & encoding the ed25519 public key from the received cert, (which is matched with \[0; 32\] as seed for ed25519 keypair)

anybody knows where `e3r2oc...` comes from? also, if I want to specify a peer-id for polkajam, I'll get

```
polkajam --chain dev run -d 0 --dev-validator 0  --peer-id  ehnvcppgow2sc2yvdvdicu3ynonsteflxdxrehjr2ybekdc2z3iuq
error: invalid value 'ehnvcppgow2sc2yvdvdicu3ynonsteflxdxrehjr2ybekdc2z3iuq' for '--peer-id <PEER_ID>': Non-zero trailing bits

For more information, try '--help'.
```

version: `polkajam-nightly-2025-05-21`

---

my current strategy is disable the check and allow alt_name mismatched with the parsed dns name, anybody met this 'problem' as well? [edited]
  ‚Ü≥ 2025-05-21 08:38 dave: I recently added a section to the SNP doc which precisely defines how the alt-name should be derived: https://github.com/zdave-parity/jam-np/blob/main/simple.md#alternative-name
  ‚Ü≥ 2025-05-21 08:42 clearloop: thanks! I had ignored this formula since I thought I have already implemented it correctly > <
  ‚Ü≥ 2025-05-22 11:58 clearloop: any ideas about

```
ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Misbehaviour: Malformed jam_node::sync::message::Announce: Could not decode `Announce::header`:                                           
        Could not decode `Header::parent`:         
                Could not decode `HeaderHash.0`:   
                        Not enough data to fill buffer          
```

we're communicating with the latest polkajam node on osx, for the `up0` steps in spacejam:

1. send \[0\] to open the stream ‚úÖ
2. wait for the handshake from polkajam ‚úÖ
3. send the handshake from spacejam to polkajam ‚ùå

the handshake message from spacejam follows \[length, encoded\_handshake\], but it seems polkajam is trying to decode the handshake from spacejam as a block announcement

if we skip handshake and enter the announcement loop, we'll get

```
DEBUG jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:55443: Static(BlockAnnouncement) stream closed: First receive killed (Dropped) by local, then transmit killed (Dropped) by local
DEBUG jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:55443: Peer disconnected with reason: Unknown: stream reset by peer: error 1                               
``` [edited]
  ‚Ü≥ 2025-05-22 12:11 clearloop: or we need to embed this handshake in connection level, but we can decode handshake from polkajam in the stream of up0 )) [edited]
  ‚Ü≥ 2025-05-22 14:04 dave: FWIW you should do (2) and (3) concurrently, and you should only do (1) if you are the one that opened the stream. But I don't think either of these is your issue üòÖ
2025-05-21 07:52 dvdplas: What I have in mind:
1. Scaffold a new CoreVM app template, ready to build
- Is there a name for apps build on top of CoreVM?
2. Launch JAM locally (either deploys the CoreVm app automatically to JAM, like added to the genesis or separately:)
- Is there the plan for zombienet to support JAM?
3. Deploy the CoreVM app and interact with it.
- Is there an example somewhere of interacting with an app build on top of CoreVM?

This will be added to the Pop CLI: https://github.com/r0gue-io/pop-cli
2025-05-21 07:52 gav: 1. ‚ÄúGuest‚Äù is the current term used. 
2025-05-21 07:53 gav: 2. Not as far as I know. 
2025-05-21 07:53 gav: 3. CoreVM doesn‚Äôt presently support input. Right now we‚Äôre just about finished getting it into a releasable shape. Input could come quite soon after, but it‚Äôs not especially trivial.  [edited]
2025-05-21 08:05 dvdplas: Thanks for your response. I will closely follow the developments around JAM and continue the conversation when we get closer to the first hackathon in November. Our team is super motivated to build the tooling so that devs can successfully build CoreVM guests (or any other desired service app) and enjoy the required developer experience.

Daan | R0GUE
2025-05-21 08:33 jan: For tooling you might want to check out this repository: https://github.com/paritytech/polkaports

This is where we're working on a work-in-progress CoreVM SDK, and we already have a prototype toolchain for building C programs (that's how we've been porting Quake to CoreVM). In the future we also plan to add support for other languages and libraries, e.g. C++, Rust, Go, Python, etc. If you're interested in collaborating you're welcome to do so.
2025-05-21 08:59 prematurata: Hello all about state deserialization how could you properly deserialize `a_s` given that the write host call accepts an arbitrary `ko ... kz` from registers 7 and 8 to define the storage key along with the service index and the merklization fn T only uses 27 bytes of such key that gets further reduces when going through the C fn?
2025-05-21 09:04 ascriv: > <@prematurata:matrix.org> Hello all about state deserialization how could you properly deserialize `a_s` given that the write host call accepts an arbitrary `ko ... kz` from registers 7 and 8 to define the storage key along with the service index and the merklization fn T only uses 27 bytes of such key that gets further reduces when going through the C fn?

Yes, you can‚Äôt recover the full key when deserializing
2025-05-21 09:04 ascriv: You can only recover 23 bytes actually 
2025-05-21 09:05 ascriv: But it‚Äôs still possible to have an implementation which is GP conformant even with this restriction 
2025-05-21 09:07 prematurata: i was more worried about testing the implementation given that my impl should "start" from the same state of someone elses implementation
2025-05-21 09:08 prematurata: if i am unable to reconstruct original from "merklized" which apparently is being used by different "testing suites"
2025-05-21 09:08 ascriv: Yes that ‚Äúwarp sync‚Äù ability might require you to rejigger some aspects of your impl, I also had to
2025-05-21 09:10 prematurata: I wonder if we can do any better considering that `a_s` seems to be the only one that is impossible to fully 'recover'
2025-05-21 09:23 dakkk: I would suggest to add the missing part of the key in the beginning of the value; this is a minor edit but it solve the issue. Something like this:

C(s, E4 (2**32 ‚àí 1) ‚å¢ k0...27 ) ‚Ü¶ k23...32 ‚å¢ v
2025-05-21 09:41 greywolve: But the traces assume your storage keys are just state keys, but that is certainly another way to do it :)
2025-05-21 09:53 prematurata: correct but this alone prevents anyone from taking the state + block and verify outcome.

Basically right now in order to verify block N you need to have applied yourself the previous blocks where the storage keys required by N were written 

 [edited]
2025-05-21 10:06 greywolve: Not entirely true, see this [comment](https://github.com/davxy/jam-test-vectors/pull/45#issuecomment-2848736219).
2025-05-21 10:50 jaymansfield: > <@prematurata:matrix.org> I wonder if we can do any better considering that `a_s` seems to be the only one that is impossible to fully 'recover'

You also can‚Äôt recover the preimage historical lookup key if you dont have possession of the preimage itself.
2025-05-21 11:02 jaymansfield: > <@prematurata:matrix.org> correct but this alone prevents anyone from taking the state + block and verify outcome.
> 
> Basically right now in order to verify block N you need to have applied yourself the previous blocks where the storage keys required by N were written 
> 
> 

State+block is all you really need a few of us have made this work already. You‚Äôll just have to rework your internal storage to use state keys instead of relying on the original values. 
2025-05-21 11:05 prematurata: thanks for the info but isnt that different from what the gp states
2025-05-21 11:05 prematurata: especially for the write and read host callse
2025-05-21 11:06 prematurata: if the implementation is meant to use state key there to fetch/store the data, i guess GP should also state that
2025-05-21 11:09 faiz_871: Can someone please clarify how the data is encoded before signing and then distributing a work report to other nodes?

  ‚Ü≥ 2025-05-21 11:14 jaymansfield: Which data are you referring too? The work report itself?
  ‚Ü≥ 2025-05-21 11:22 faiz_871: Yeah we have to make signature using work report  and core\_index  [edited]
2025-05-21 11:13 ascriv: > <@prematurata:matrix.org> if the implementation is meant to use state key there to fetch/store the data, i guess GP should also state that

Your impl‚Äôs representation of state does not have to match the GP representation. In fact it can‚Äôt, if it supports warp sync
2025-05-21 11:18 prematurata: otherwise the end result would be that we have 2 almost identical impl in terms of behavior. 1 is following GP but makes it impossible to rebuild state from `trace`, the other is not following GP but produces same results as 1.

the only gotcha i can see about using the second solution (besides being out of spec from what GP states) is that it creates another possible hash collision point.

One of which is reducing `k` from 32 bytes to 27 and then 23 and then using this as key for read/write where multiple hashed keys. N

not trying to be picky here but 23 bytes collision between `warp client` and ` full client`... how hard can they be to do?
2025-05-21 11:31 gav: Yes, a change was made fairly recently removing a secondary hash.  [edited]
2025-05-21 11:32 gav: It is true that 5 bytes of the service storage key don't make it into the state merkle tree key. [edited]
2025-05-21 11:33 gav: 
2025-05-21 11:35 gav: But with a secondary hash, between the initial 5 byte removal and the second 4 byte removal, there should still be 27 bytes of entropy in the final key. That's not the case at present, and most likely needs to be fixed.
2025-05-21 11:39 gav: https://github.com/gavofyork/graypaper/issues/403
2025-05-21 12:28 prematurata: another solution would be to re-add the keys before the value. You don't lose entropy and allow warp/full impl to behave exacty the same
2025-05-21 12:29 prematurata: @gav ^^
2025-05-21 12:49 gav: Yeah true. It‚Äôs just a little more storage, and there‚Äôs UB in the case of a collision, which is quite a bit more likely with only 23 bytes of entropy. We‚Äôd need to define which of two colliding keys took precedence.  [edited]
2025-05-21 18:05 nicholasonchain: Are there any way to fetch `block` and C(1)-C(15) `state` from header hash in polkajam binaries?
2025-05-21 18:05 nicholasonchain: We would to see polkajam support new JIP-2 methods to fetch a block and one or more of C(1)-C(15) state by header hash to support basic explorer -- is this possible?
2025-05-21 19:15 dave: Certainly possible, can't promise a time frame though these things should be easy to add
2025-05-21 21:34 sourabhniyogi: Is there an env variable to turn on pvm trace execution logs in `polkajam` to compare with our own binaries logs, e.g something like [this](https://github.com/jam-duna/jamtestnet/blob/main/traces/reports-l0/00000003.log#L2-L3135)?
  ‚Ü≥ 2025-05-22 10:12 jan: Force the interpreter backend and set `RUST_LOG=polkavm=trace`
  ‚Ü≥ 2025-05-22 12:53 sourabhniyogi: Awesome -- any way to get the registers to appear at least some of the time, or other options?

```
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter  Compiling block:
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [4]: 8206: charge_gas
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [5]: 8206: sp = sp + 0xfffffffffffffd00
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [6]: 8210: u64 [sp + 0x2f8] = ra
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [7]: 8214: u64 [sp + 0x2f0] = s0
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [8]: 8218: u64 [sp + 0x2e8] = s1
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [9]: 8222: i32 s0 = a0 + 0
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [10]: 8224: jump 9459 if s0 == 0
2025-05-22 20:22:42 tokio-runtime-worker TRACE polkavm::interpreter::raw_handlers    -> resolved to fallthrough
2025-05-22 20:22:42 tokio-runtime-worker TRACE polkavm::interpreter::raw_handlers  [4]: charge_gas: 6 (49999999 -> 49999993)
```
2025-05-22 13:34 dave: Proposal for a standard secret key derivation method here: https://github.com/polkadot-fellows/JIPs/blob/c888a85736b18261b848224a5e242e6a42f8e4ff/JIP-5.md. We're planning to make PolkaJam follow this method. Note that we intend to use the same method for deriving keys from on-disk seed files as for deriving the "dev chain" validator keys. Currently different methods are used which means for example it is not currently possible to use an on-disk seed file for a dev chain validator.

This change _will_ cause breakage, in particular the dev account keys listed here will change: https://docs.jamcha.in/basics/dev-accounts. The new dev account keys are listed in the "test vectors" section at the bottom of the linked doc. Apologies for any hassle this causes, hopefully this change will make things simpler and easier in the long run though!
2025-05-23 12:00 ascriv: Are the alt names still accurate in http://docs.jamcha.in/basics/dev-accounts ? Cant reproduce the alt name for Alice using the alt name formula in the SNP  [edited]
2025-05-23 12:50 oliver.tale-yazdi: They have been reported wrong by Dave last week while he extended the spec to be more explicit. I will remove them for now to avoid confusion until fixed. Thanks for the ping here :) [edited]
2025-05-23 17:31 ascriv: for integrating with the polkajam-testnet, to receive assurances/guarantees/tickets/etc, are we meant to impersonate one of the existing validators (e.g. alice) when doing the TLS handshake? 
2025-05-23 19:06 dave: It depends on the chainspec you're using. If you're using the one I uploaded then yes, the validators for that use the "well-known" alice/bob/etc keys and you should use one of these for your validator. If you want some of the validators to be polkajam then you should launch polkajam instances manually using --chain and --dev-validator N. polkajam-testnet will launch polkajam instances for all the validator nodes; things will not work properly if you then launch your own validator as it will necessarily have the same ID as one of the polkajam ones
2025-05-23 22:45 mkchung: besides key derivation, is blake2b "personal" being used for any other hashing operation, like codec or justifications?
2025-05-23 23:23 dave: I've changed the proposal to no longer use Blake2 personalisation as some Blake2 libraries don't support this; see the latest version of the PR here https://github.com/polkadot-fellows/JIPs/pull/2/files
2025-05-24 18:26 ascriv: > <@dave:parity.io> Nightly builds of PolkaJam should now be automatically created and uploaded here: https://github.com/paritytech/polkajam-releases/releases

should we tag each release with what version of GP it proports to implement? or can we assume it's always on head of main of the graypaper repo?
2025-05-24 18:31 dave: It's certainly not always up to date with the GP. They're not currently tagged but you can see the GP version by running `polkajam --version` [edited]
2025-05-25 21:10 oliver.tale-yazdi: I integrated the JIP-5 changes now here, if other teams want to compare the DNS alt name: https://docs.jamcha.in/basics/dev-accounts
2025-05-25 23:24 jaymansfield: > <@sourabhniyogi:matrix.org> JAM Doom replication:
>  https://www.youtube.com/watch?v=ltWMjg2EHS8

Is there a tutorial anywhere on how to do this with our PVMs?
2025-05-26 08:52 clearloop: confused about how to send handshake of up0 to polkajam

1. if sending the handshake after received up0 stream, polkajam will close the connection via failed to parse block announcement, ideally, it should parse the handshake data of up0 but not block announcement at the beginning
2. if not sending handshake data, polkajam will reset the connection again and again
3. we can read the handshake data from polkajam correctly
  ‚Ü≥ 2025-05-26 09:30 clearloop: interesting, just caught it, we do have problem in encoding however it's in handshake data but not block announcement
 [edited]
2025-05-26 10:12 interweb_: The code is available for:
official: https://github.com/paritytech/polkavm/tree/master/examples
doom: https://github.com/clw8998/jam\_doom
quake: https://github.com/paritytech/polkaports/blob/master/apps/quake/README.md
I have not seen any tutorial for getting started...  [edited]
2025-05-26 15:39 ericki: GM Jammers!
I was wondering if there are any implementoooors based in Berlin? We have around Protocolberg (18th June) a side event where Jam devs were requested to join (as speakers or to hangout for networking). [edited]
2025-05-27 07:32 tony_lollipop: We use the jamt like next to use the customized bootstrap service:
./jamt -b 858108b6 create-service ../jam-counter-service 111 "jam-counter-service5"

But we got error:
error: invalid value '858108b6' for '--bootstrap-service-id <BOOTSTRAP_SERVICE_ID>': invalid digit found in string

The "858108b6" is the new bootstrap service We just deployed:
$ ./jamt create-service ../jam-bootstrap-service 1 "jam-bootstrap-service2"
Bootstrap service #0 identifies as jam-bootstrap-service v0.1.21 by Parity Technologies <admin@parity.io>
Work package submitted at slot 2099563. Monitoring...
Service 858108b6 created at slot 2099565
Providing service code...
Submitted. Waiting for provision...
Service code provided at slot 2099566

Could someone help us? Thanks!
  ‚Ü≥ 2025-05-27 07:57 clearloop: ```
invalid digit found in string
```

It's a parsing issue, idk, maybe `8588108b6` could not be parsed as service id, which should be u32
  ‚Ü≥ 2025-05-27 15:18 dave: FWIW we've fixed the parsing of this option to use hex, in line with other service ID args. This change will be included in tonight's PolkaJam release [edited]
2025-05-27 08:11 clearloop: May I ask if the traces test vectors are aligned with polkajam?

we can pass all fallback/safrole traces test vectors (including state root calculation), but we calculate different state root comparing with polkajam for the genesis state, `polkajam(0x566a95e5ae04266c715387e8f6db64aaa446afa9f168f2bb7fac96082a443bd7), spacejam(0x9718becbd5e5ed6885bc115fa0e287691be55fb382f64f12030435fb050745af)`

1. we are using genesis state in https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d
2. the version of polkajam is nightly-2025-05-27
3. parameters used in polkajam is being like `polkajam -p=tiny -c=dev run -d 0 --dev-validator 0`
2025-05-27 08:27 tony_lollipop: We now change the service id into decimal mode, and got another error:
$ ./jamt  --bootstrap-service-id 2239826102 create-service ../jam-counter-service 111 "jam-counter-service5" 
2025-05-27 08:18:31 Fatal error: Bootstrap service metadata not found
2025-05-27 13:41 emielsebastiaan: https://x.com/thekusamarian/status/1927347226331717649?s=46&t=ThX7Y87rr1MIKyk6af4OXg
2025-05-27 13:44 emielsebastiaan: How many fps?
2025-05-27 14:34 clearloop: localnet.mp4
2025-05-27 14:34 clearloop: SpaceJam now can author & sync blocks with PolkaJam  üëæ
2025-05-27 14:40 dave: `jamt` currently requires the bootstrap service code blob to contain metadata in the format described here: https://github.com/polkadot-fellows/JIPs/pull/3
  ‚Ü≥ 2025-05-28 00:53 tony_lollipop: image.png
  ‚Ü≥ 2025-05-28 00:53 tony_lollipop: David, Thanks for your kindly reply. I have one more question. Do you mean we should change the Cargo.toml for the customized bootstrap service with our own information in the [package] as the picture:

  ‚Ü≥ 2025-05-28 17:02 dave: I assume you're using the published `jam-pvm-build` crate to build this service? I believe the currently published crates use the SCALE codec rather than the codec defined in the gray paper. Unfortunately this means that the PVM binaries produced are not compatible with the nightly polkajam builds; these now use the GP codec. I'll see what I can do about getting updated versions of the SDK crates released, which should fix this issue.
2025-05-27 15:06 gav: 24
2025-05-27 15:15 dave: FYI tonight's PolkaJam build will contain this change. I've updated the dev chainspec gist to reflect the new dev chain validator keys: https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d
2025-05-27 15:47 jimboj21: I unfortunately will not be able to make protocolBerg this year, but maybe some of the Gossamer team will be there Kyrylo Pisariev | Gossamer | CS 
2025-05-27 21:02 interweb_: I have a simple rpc client in js. 
```
console.log
    Received best block: {
      header_hash: [
        202, 175,  36, 124, 104, 125, 165,
        140,  60,  27, 121, 252, 207,  22,
        109, 156,  50, 116, 107,  45,  28,
        101, 200, 231, 111, 238,  52, 210,
        240, 205,  84, 162
      ],
      slot: 2107741
    }
```
I am able to get bestBlock, but subscribeBestBlock is not responding. It is implemented?
2025-05-28 01:50 mkchung: Could you confirm whether Polkajam is encoding the availability specifier exactly like u = M\_B (\[|x| x \<‚àí T\[b*, s*\]\]) specified in GP 14.16?? It seems we‚Äôre actually seeing justifications of the form M\_B (\[|x| x \<‚àí T\[s*, b*\]\]) from polkajam binaries. [edited]
  ‚Ü≥ 2025-05-28 11:35 dave: Looks to me like we've got it backwards in PolkaJam! Thanks for reporting, will let you know when this is fixed
  ‚Ü≥ 2025-05-28 12:28 sourabhniyogi: We would like to achieve erasure coding alignment by checking that we can generate the same 6 shards as that of the CE137 responses of a guarantor from a 5 polkajam+1 jamduna tiny network.  We collected it [here](https://github.com/jam-duna/jamtestnet/blob/main/erasurecoding/test_segment_shards_tiny_polkajam.json) and attempted our total guess at what we believe is a  unnecessary-but-compliant transformation [here](https://github.com/jam-duna/jamtestnet/blob/main/erasurecoding/src/lib.rs#L31-L41) and failed.   Previously, we attempted to achieve alignment with [this](https://github.com/davxy/jam-test-vectors/tree/erasure_coding/erasure_conding) but now that we have live `polkajam` binaries to achieve alignment with I think we should nail the tiny encoding/decoding transformation down with [reed_solomon_simd 3.0.1](https://docs.rs/reed-solomon-simd/3.0.1/reed_solomon_simd/) -- how do you recommend we proceed?
  ‚Ü≥ 2025-05-28 12:46 jaymansfield: I tried test_segment_shards_tiny_polkajam.json and get a different result as well. Here is what I end up with: https://gist.github.com/jaymansfield/af6cb7d1bdd8092402e9bc2112c102b6
  ‚Ü≥ 2025-05-28 12:51 dave: Are you saying you have matched davxy's test vectors now or no? I would recommend getting those matching first if not
  ‚Ü≥ 2025-05-28 13:01 jaymansfield: I don't think anyone was able to match those
  ‚Ü≥ 2025-05-28 14:51 sourabhniyogi: No one was able to (that we know of) and @davxy s  PR was closed.  but we assume polkajam is surely self consistent with encoding / decoding work package bundles ‚Äî and that it‚Äôs best if we just spell out the package we all ffi into , write the tiny specific pseudocode that matches polkajam s presumably GP compliant encoding/decoding and get verifiable auditable bundles correct in a multi client testnet.   
  ‚Ü≥ 2025-05-28 14:53 dave: I think we should focus on getting the test vectors matching first; these should match what PolkaJam does
  ‚Ü≥ 2025-05-28 14:55 dave: Doesn't look like the EC test vectors include bundle encoding/decoding. This is somewhat orthogonal to EC, I agree it would be helpful to have test vectors for this
  ‚Ü≥ 2025-05-28 15:27 sourabhniyogi: Ok davxy I think its time to revisit https://github.com/davxy/jam-test-vectors/pull/28 and get tiny+polkajam compliant clear
  ‚Ü≥ 2025-05-28 15:28 sourabhniyogi: Can we reopen this PR and get a test case that is exactly what polkajam does and (a) get specific about package (b) get specific about tiny transforms?
  ‚Ü≥ 2025-05-28 16:37 sourabhniyogi: Would you be able to supply a change to 
https://github.com/jam-duna/jamtestnet/blob/main/erasurecoding/src/lib.rs#L32-L41
that does work with https://gist.github.com/jaymansfield/af6cb7d1bdd8092402e9bc2112c102b6 
  ‚Ü≥ 2025-05-28 17:07 davxy: I'll be working on it over the next few days and will leave a note here as soon as I pick it back up
  ‚Ü≥ 2025-05-28 17:07 dave: We've pushed a fix for this, should be in tonight's build
  ‚Ü≥ 2025-05-28 21:08 jaymansfield: I actually got a bit further on this today. I can now encode and get the same result as polkajam (but im still working on decode). This was a big help: https://github.com/davxy/jam-test-vectors/pull/28#issuecomment-2706094497
  ‚Ü≥ 2025-05-28 21:08 jaymansfield: I'll write up a few details after finishing on what I had to change to make it work
  ‚Ü≥ 2025-05-29 02:53 sourabhniyogi: https://github.com/davxy/jam-test-vectors/pull/63/files
https://hackmd.io/@sourabhniyogi/jam-appendixh-tiny
  ‚Ü≥ 2025-05-29 14:33 jaymansfield: Ok I am now able to encode/decode the EC output from polkajam and get the same result, as well as the old EC vectors in the closed PR.

I‚Äôm not sure if it fully follows the GP. Two main things:

1. The GP defines the data blob input into erasure coding to be d ‚àà Y684k, but in the erasure coded work package sent from polkajam was erasure coded at length 272 (the exact bytes of the WP). I would have expected this needed to be padded with zeros to match the 684 in the GP spec. Without padding I get the same result. If I pad the work package bytes to a multiple of 684 the recovery shards are different and no longer match. Hopefully someone from Parity can comment on which is correct.
2. I removed split, join, unzip, lace from the GP and started fresh. Just calculated number of expected pairs, then extracted each 2-byte pair from the same position across the original shards. Each of these pair groups were erasure coded, and then combined each set of results afterwards. I did not get the same results using the exact helper functions in the GP, but can now match polkajam. [edited]
  ‚Ü≥ 2025-05-29 15:01 sourabhniyogi: Here, similar to sbrk, a public implementation (in Rust) of the exact encoding / decoding transformations to cover the 272, 4104 etc in tiny AND full would be best. The "get the same result" would shift from trivial usage of erasure coding packages to being able to author and verify justifications in CE137/138/139/140, which are much more substantive.
  ‚Ü≥ 2025-05-29 15:04 jaymansfield: Wish I could help with the rust part, but all the transformations I did were done in my implementations language prior to calling the rust library which basically only calls reed_solomon_simd::encode().
  ‚Ü≥ 2025-05-29 15:07 sourabhniyogi: Do you see any point to the transformations?  I do not.
  ‚Ü≥ 2025-05-30 02:04 mkchung: Hey David Emett : so far we have NOT seen any release getting published in the last 48+hrs. Is the nightly release actually running? 
  ‚Ü≥ 2025-05-30 05:12 sourabhniyogi: Against a 5 polkajam+1 setup with the 05-28 nightly release (which we assume is s-b still, so we have been looking for the latest, to verify CE137 Justifications), what we found is that its not possible to use jamt to get past this in a 5+1 setup

```
# bin/jamt --rpc ws://0.0.0.0:19801 create-service $(xxd -p -c 999999 ./services/fib.pvm | tr -d '\n') 1000000 
Waiting for network status...
Providing service code to Bootstrap service...
Found Bootstrap service at #0: jam-bootstrap-service v0.1.21 by Parity Technologies <admin@parity.io>
Solicited 1 items in package 0x1638ae995e457b8c... with anchor at #214143
```
is met with 
```
2025-05-30 05:06:14 tokio-runtime-worker ERROR jam_node::chain::guarantors::guarantor  Failed to validate work package: in-core error: AuthorizationLacking
```
Is there a setup step we have missed?  What is it?
  ‚Ü≥ 2025-05-30 05:12 sourabhniyogi: image.png
  ‚Ü≥ 2025-05-30 08:20 dave: > <@mkchung:matrix.org> Hey David Emett : so far we have NOT seen any release getting published in the last 48+hrs. Is the nightly release actually running? 

Looks like there's a release here built this morning: https://github.com/paritytech/polkajam-releases/releases/tag/nightly-2025-05-30
  ‚Ü≥ 2025-05-30 11:35 sourabhniyogi: Ok, got the latest release --  The 2025-05-30 has the same "AuthorizationLacking" (and 50/50 when we get the wp, we report back "getAuthorizeCode: Authorization code(fa75..60b6)not found") [edited]
  ‚Ü≥ 2025-05-30 11:36 sourabhniyogi: image.png
  ‚Ü≥ 2025-06-01 17:54 jaymansfield: Were you able to get around this? Facing the same issue. 2025-06-01 13:52:48 tokio-runtime-worker ERROR jam_node::chain::guarantors::guarantor  Failed to validate work package: in-core error: AuthorizationLacking
  ‚Ü≥ 2025-06-01 21:14 sourabhniyogi: We backtracked from using

(a) polkajam chainspec with jamt submitting a new service to polkajam bootstrap services


to just


(b) jamduna chainspec with our own test submitting to our bootstrap service with "new/write/transfer" (same as what happens in assurances/orderedaccumulation)

We now have identical work reports EXCEPT for the erasureroot (so.. no workreporthash signature matching =(), so if there are 2/3 of polkajam it goes |E\_G|=1 => |E\_A|=5 (or 6) => |E\_P| = 1 for the new services.  BUT this implies that if we replicate your EC transformations (or figure out what they should REALLY be), you/we can get to the promised land.  

Are you posting your binaries? [edited]
  ‚Ü≥ 2025-06-01 21:41 jaymansfield: Thanks I might take the same route as you in the meantime then until it‚Äôs resolved and use my own spec and WP publisher. I do have jamt sending directly to my node, but same issue still with the WP authorizer not matching the ones in the dev chainspec. I‚Äôll publish a binary early this week I have been pretty focused on polkajam compatibility and forgot I was going to post one. 
  ‚Ü≥ 2025-06-02 01:14 sourabhniyogi: Ok, I replicated your result using your tip (2):

https://github.com/jam-duna/jamtestnet/tree/main/erasurecoding
  ‚Ü≥ 2025-06-02 13:32 sourabhniyogi: Erasure root matches now, see this gist
https://gist.github.com/sourabhniyogi/6430caee2cff365ff6e51dcff115fb86
  ‚Ü≥ 2025-06-02 13:45 sourabhniyogi: Notes:
* we did not see the bClub <=> sClub swap fix yet.  
* For CE133, having 0 extrinsics still requires sending in a 4 byte 0 message length
  ‚Ü≥ 2025-06-02 13:46 sourabhniyogi: ```
--> [Extrinsic] (Message size should equal sum of extrinsic data lengths)
```

  ‚Ü≥ 2025-06-02 19:25 sourabhniyogi: David Emett: It appears you reversed the ordering of the path (awesome, thank you!) but not bClub / sClub ?   See https://gist.github.com/sourabhniyogi/6430caee2cff365ff6e51dcff115fb86#file-polkajam-wp-match-log-L602-L623) for how we currently have sClub first then bClub where we are able to match erasure roots and, amazingly enough, verify Justifications with your path ordering from CE137 against the the erasure root.  
  ‚Ü≥ 2025-06-02 20:57 dave: sourabhniyogi: AFAIK we've swapped around the bundle-shard & segments-shard hashes to match the GP. This fix was in the nightly-2025-05-30 release. I'm not sure what you mean by the "ordering of the path"?
  ‚Ü≥ 2025-06-02 22:06 mkchung: @David Emett:

From GP 0.6.7 (¬ß14.17) https://graypaper.fluffylabs.dev/#/7e6ff6a/1c3b011c4c01?v=0.6.7 (or GP 0.6.5 ¬ß14.16 https://graypaper.fluffylabs.dev/#/cc517d7/1cb1001cb100?v=0.6.5), we expect the erasure root to be built with leaves of (bClub ++ sClub). NOT (sClub ++ bClub)
  ‚Ü≥ 2025-06-02 22:07 mkchung: Based on May 30th PolkaJam binary, I believe PolkaJam is still using (sClub, bClub) as leaves to construct the erasure root -- which deviates from the either GP specification.  It appears that justification ordering has been reversed/swapped to validate an erasure root built using (sClub, bClub) as leaves. But we are expecting (1) the erasure root to be built using (bClub, sClub) and (2) justification paths to match that (bClub, sClub)'s erasure root.
  ‚Ü≥ 2025-06-02 22:08 dave: Oh I see, possibly we missed that in the change. Will take a look.
  ‚Ü≥ 2025-06-02 22:18 dave: Seems the change didn't actually swap things around, sorry. It refactored things so that the order was determined in one place, but the actual swapping of the order doesn't appear to have been done üôÉ
  ‚Ü≥ 2025-06-02 22:23 dave: Should actually be fixed in tonight's build ü§û Apologies!
  ‚Ü≥ 2025-06-03 01:40 jaymansfield: Are you able to share the chainspec file used with that WPB? [edited]
  ‚Ü≥ 2025-06-03 01:46 sourabhniyogi: https://github.com/jam-duna/jamtestnet/blob/main/chainspecs/jamduna-spec.json
  ‚Ü≥ 2025-06-03 17:59 sourabhniyogi: Is there a way to get polkajam to report back
(a) the 6 sclubs when guaranteeing
(b) its core index, or maybe all 6 validator  core assignments as they switch
We need some visibility into (a) for getting erasure roots for WPs with exported segments.   For (b), we have found both our impl and polkajam rejecting each other WPs due to not being on the same core just often enough to believe we have our core rotation algorithm slightly wrong.  `Failed to validate work package: invalid core: 1 not in [0]` Or maybe we want R to be a higher number somehow. [edited]
  ‚Ü≥ 2025-06-03 18:07 sourabhniyogi: (c) for any "Bad Justification" errors that you generate (we see them CE141 [ok!] but also for for CE128 [why, we cannot explain..]), can we get a bit more in the logs (the raw justification you think you got). 

In general, you have excellent logs for us to work with, and other implementers are likely to follow them and get just as "fussy" =)
  ‚Ü≥ 2025-06-03 18:27 dave: Re core rotation there are some test vectors for the shuffle, worth checking that you match these if you haven't yet
  ‚Ü≥ 2025-06-03 18:30 dave: For (a) I assume you have the segment EC test vectors matching now? So the question is about the merkle roots computed from the segment shards?
  ‚Ü≥ 2025-06-03 18:34 dave: Will look into logs later, agree it would be helpful to have trace logs for some of these things
  ‚Ü≥ 2025-06-03 20:18 sourabhniyogi: Yes, we have the shuffle test vector passing, the old davxy EC test vector for the 4104 segment encoding/decoding (theres only one!), as well as real CE137 + CE138 responses decoding back to the bundle EC decoding (BUT only when there aren't any segments).  

So yes, for (a) we mean the CDT merkle root computed from the segment shards EC encoding, which is next level.  
  ‚Ü≥ 2025-06-05 00:57 mkchung: Hello David Emett,

We can confirm that Jamduna now has fully compatible CE-137 & CE-138 against PolkaJam‚Äôs 2025-06-03 nightly (yay!). However, we are unable to arrive at the same exports_root even with just one segment.

Here‚Äôs a Gist with W3F‚Äôs test vector as a preliminary test case:
https://gist.github.com/mkchungs/e9c31a55a2e7f5ee212b53bf70a88f63

Could you double-check whether your CDT implementation is using the ‚Äúleaf‚Äù prefix as shown in (E.1) of GP 0.6.7? See
https://graypaper.fluffylabs.dev/#/7e6ff6a/3c7f013c9501?v=0.6.7

Since there‚Äôs only one leaf (exportedSegmentCnt = 1) in this case and the root should be that hashed leaf itself, can you share how you arrived at 0x3cad‚Ä¶c9243? Our result by computing
```
Blake2Hash(‚Äúleaf‚Äù || segment) 
```
is 0x0931‚Ä¶a53cf.

Perhaps polkajam's cdt implementation is using different prefix? Not sure...

  ‚Ü≥ 2025-06-05 01:25 dave: Seems like polkajam is padding the list of segment hashes H("leaf" || segment) with zero hashes up to a multiple of the proof page size (64). Agree this does not match the GP.
  ‚Ü≥ 2025-06-05 18:13 mkchung: thanks for the clue! can we expect a nightly fix on this?
  ‚Ü≥ 2025-06-05 18:15 mkchung: At the meantime, Im able to match polkajam's cdt root by padding to 64. will do a bit more tessting
```
 go test -v -run TestPolkajam64ExportsRoot
=== RUN   TestPolkajam64ExportsRoot
Level 0: [Branch: 0x3cad...dc9243]
Level 1: [Branch: 0x8325...b2a8e7]  [Branch: 0xcc1c...57daee]
Level 2: [Branch: 0x197f...2f2905]  [Branch: 0x57ff...80a67d]  [Branch: 0x57ff...80a67d]  [Branch: 0x57ff...80a67d]
Level 3: [Branch: 0x212e...d305a2]  [Branch: 0x68a3...acd894]  [Branch: 0x68a3...acd894]  [Branch: 0x68a3...acd894]  [Branch: 0x68a3...acd894]  [Branch: 0x68a3...acd894]  [Branch: 0x68a3...acd894]  [Branch: 0x68a3...acd894]
Level 4: [Branch: 0x4079...924f6b]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]  [Branch: 0x68da...34b426]
Level 5: [Branch: 0x33c8...1d9093]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]  [Branch: 0xd8ce...bf049e]
Level 6: [Leaf: 0x0931...9a53cf]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]  [Leaf: H0]
CDT root with 1 leaves: 0x3cad8b17c454b16bbc6ee84ea73a3c4b979568523f2c5d615a91e211fadc9243
--- PASS: TestPolkajam64ExportsRoot (0.00s)
```

  ‚Ü≥ 2025-06-05 19:25 dave: > <@mkchung:matrix.org> thanks for the clue! can we expect a nightly fix on this?

I'm looking into a fix
  ‚Ü≥ 2025-06-06 18:05 dave: Fixes for this and a few related issues pending code review, they will likely be in a release some time next week
  ‚Ü≥ 2025-06-06 19:45 mkchung: Hello David Emett,

For your upcoming release next week, are you encoding pageProof's L‚ÇÜ(s,i) in GP ¬ß 14.11 using the ‚Äú‚Üï‚Äù length discriminator (here: https://graypaper.fluffylabs.dev/#/7e6ff6a/1b2b021b2d02?v=0.6.7)? 
  ‚Ü≥ 2025-06-06 19:46 mkchung: I'm wondering if that would be part of your fixes as well
  ‚Ü≥ 2025-06-06 19:49 dave: Yeah that's one of the other fixes
  ‚Ü≥ 2025-06-06 19:50 dave: The proofs are also currently ordered the wrong way
  ‚Ü≥ 2025-06-06 19:59 mkchung: Can you provide a bit of details on which proofs are being ordered "incorrectly" as of the 2025-06-05-nightly release? Are you talking about CE 139/140 specifically? For disclosure, I have to reverse our co-path ordering for CE137/CE138 in order to be compatible with current polkajam. But that may be an issue on our side
  ‚Ü≥ 2025-06-06 20:03 dave: I believe proofs to the erasure root as in CE 137/138 are generated/checked as per the GP/SNP spec. If you disagree please let me know! The proofs that are currently backwards are those in the proof pages and the import proofs in work-package bundles. [edited]
  ‚Ü≥ 2025-06-06 20:05 dave: By my reading of the GP all proofs are supposed to be from the root down to the leaf
  ‚Ü≥ 2025-06-06 20:08 dave: Re CE 139/140 I don't believe polkajam currently uses CE 140. It will respond to it but I wouldn't be surprised if the response is not currently correct üòÖ
  ‚Ü≥ 2025-06-06 20:11 mkchung: https://graypaper.fluffylabs.dev/#/7e6ff6a/3ca0013ca101?v=0.6.7

I believe you are absolutely correct. But just find it weird as root has to be to compute from bottom to top anyway
  ‚Ü≥ 2025-06-07 00:19 dave: Fixes should be in tonight's build.
  ‚Ü≥ 2025-06-09 21:58 mkchung: Thanks for sharing the binary. we are now have the same erasureRoot & exportRoot using **nightly-2025-06-09** for exports_counts up to 128!  Will do more testing and confirm whether both clients agree on same pageProofSegment for any arbitrary segment_count
  ‚Ü≥ 2025-06-09 22:55 dave: Great, thanks for the update!
2025-05-28 07:07 tony_lollipop: 
2025-05-28 15:32 stsoen: Does anyone have the presentation that Gav gave yesterday at ETH Prague? I would be very grateful if someone could share it as a file (not the video, but the presentation itself)
2025-05-28 17:06 rustybot: 
2025-05-28 19:16 davxy: üöß Progress Update on Block Import Test Vectors ([#45](https://github.com/davxy/jam-test-vectors/pull/45))

Several teams have now successfully processed the test vectors designed to exercise the block import procedure.  
This marks an important milestone, as these vectors use the format planned for the upcoming M1 conformance testing tool. They also start to test PVM and host call implementations - thought still in a relatively straightforward way.

It's great to see implementors gradually getting on the same page as they work through these vectors as a practical support to the GP. Your feedback has also been invaluable in helping us improve the quality of the vectors - some issues on our side would have gone unnoticed without it.

We're currently proposing three classes of vectors. You can find details in the [README](https://github.com/davxy/jam-test-vectors/blob/traces/traces/README.md). I invite more implementors giving them a look.

In the coming days, we'll be proposing increasingly complex scenarios to exercise additional host calls. [edited]
2025-05-28 21:22 kianenigma: re-posting this issue form a few days ago I opened in test vectors repo in case anyone else knows the answer: https://github.com/w3f/jamtestvectors/issues/48
  ‚Ü≥ 2025-05-29 12:16 dave: GP definition seems reasonable to me. By my reading the PolkaJam source matches the GP, and this is what is used to generate the test vectors. So don't know what's going on there.
  ‚Ü≥ 2025-05-29 12:21 dave: Looking at the `preimage-not-needed` cases, I believe these cover invalid blocks: it is not permitted to include a preimage in the extrinsic unless it has been requested. Not sure what "post_state" is meant to indicate in this case.
  ‚Ü≥ 2025-05-29 12:26 dave: Note that it _is_ possible to include a preimage in the extrinsic that does not get integrated: integration occurs after accumulation, and accumulation may `forget` the preimage
2025-05-29 03:10 clearloop: anybody knows what's the format of the preimages in the accumulate test vectors? we can not deblob them with standard program format nor program format, as I hacked the binary, I can see the header of it is debug-info which is not specified in graypaper üòÖ [edited]
  ‚Ü≥ 2025-05-29 04:27 clearloop: e.g.

```
G\0\u{c}test-service\u{6}0.1.21\nApache-2.0\u{1}%Parity Technologies <admin@parity.io>\u{8}0\0\0\0\0\u{1}\0\0 \0/home/davxy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/jam-codec-0.1.0/src/codec.rsunsafe precondition(s) violated: ptr::write requires that the pointer argument is aligned and non-nullunsafe precondition(s) violated: ptr::add requires that the address calculation does not overflowassertion failed: new_len <= self.capacity()/home/davxy/.rustup/toolchains/nightly-2024-11-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rscalled `Result::unwrap()` on an `Err` value/mnt/ssd/develop/jam/polkajam/crates/jam-pvm-common/src/mem.rsunsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlapunsafe precondition(s) violated: ptr::read requires that the pointer argument is aligned and non-nullunsafe precondition(s) violated: ptr::add requires that the address calculation does not overflowunsafe precondition(s) violated: ptr::sub_ptr requires `self >= origin`unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`/home/davxy/ ...
```

or if this is metadata but it is prefixed with length 71 [edited]
  ‚Ü≥ 2025-05-29 06:31 clearloop: it's indeed metadata, works after fixing my Y function
  ‚Ü≥ 2025-05-29 07:31 greywolve: yeah we ran into this too, was just the metadata
  ‚Ü≥ 2025-05-29 07:33 greywolve: specified [here](https://graypaper.fluffylabs.dev/#/9a08063/109a01109a01?v=0.6.6).
2025-05-29 12:28 arjanz: 
2025-05-29 12:30 arjanz: When we wanted to use the `dev-spec.json` exported from `polkajam` as genesis, we ran into some issues with the is-authorized invocation (B.1).

After some trial and error we found that the arguments supplied to the is-authorized invocation seems to be in a different format than GP 0.6.5 specifies.

We would expect serialization of the WorkPackage and core\_index as Varint, but that always results in a panic. However, when we change the arguments and add a serialised `Vec<u8>` in front containing the auth params en modify the core\_index from `VarInt` to a `u16`, the is-authorized invocation is successful. The signature in the jam-null-authorizer service code also hints this structure:

```rust
impl jam_pvm_common::Authorizer for Authorizer {
	fn is_authorized(param: AuthParam, package: WorkPackage, core_index: CoreIndex) -> AuthOutput {
		info!(
			"Null Authorizer, [{core_index}], {} gas, {param} param, {} token",
			gas(),
			package.authorization
		);
		if package.authorization.0 != param.0 {
			panic!("Authorization failed")
		}
		let m = String::from_utf8_lossy(&package.authorization);
		alloc::format!("Auth=<{m}>").as_bytes().to_vec().into()
	}
}
```

Is our assumption correct that the is-authorized arguments of `polkajam` currently deviates from GP 0.6.5? [edited]
2025-05-29 12:43 davxy: > <@arjanz:matrix.org> When we wanted to use the `dev-spec.json` exported from `polkajam` as genesis, we ran into some issues with the is-authorized invocation (B.1). 
> 
> After some trial and error we found that the arguments supplied to the is-authorized invocation seems to be in a different format then GP 0.6.5 specifies. 
> 
> We would expect serialization of the WorkPackage and core_index as Varint, but that always results in a panic. However, when we change the arguments and add a serialised `Vec<u8>` in front containing the auth params en modify the core_index from `VarInt` to a `u16`, the is-authorized invocation is successful. The signature in the jam-null-authorizer service code also hints this structure:
> 
> ```rust
> impl jam_pvm_common::Authorizer for Authorizer {
> 	fn is_authorized(param: AuthParam, package: WorkPackage, core_index: CoreIndex) -> AuthOutput {
> 		info!(
> 			"Null Authorizer, [{core_index}], {} gas, {param} param, {} token",
> 			gas(),
> 			package.authorization
> 		);
> 		if package.authorization.0 != param.0 {
> 			panic!("Authorization failed")
> 		}
> 		let m = String::from_utf8_lossy(&package.authorization);
> 		alloc::format!("Auth=<{m}>").as_bytes().to_vec().into()
> 	}
> }
> ```
> 
> Is our assumption correct that the is-authorized arguments of `polkajam` currently deviates from GP 0.6.5?

Currently akf, but looks you are right. Do you mind open an issue in the vectors repo? (my fork pls)
2025-05-29 12:50 arjanz: Sure thing: https://github.com/davxy/jam-test-vectors/issues/64
2025-05-29 14:06 interweb_: For RPC API, is there any more detail? 
I found https://hackmd.io/@polkadot/jip2#JIP-2-Node-RPC but there is no way to get account balances using the api?
2025-05-29 14:14 dave: I assume you mean service balance? This is included in the data returned by `serviceData`
2025-05-29 15:28 interweb_: Thanks, that helped me!
2025-05-29 17:53 sourabhniyogi: Jan Bujak: What is (or will be) the idiomatic way of allocating heap in a parent JAM service in a Rust program (which I presume maps into SBRK now, and \[somehow\] its host function replacement in the future) vs a child guest program?

I think I'm looking for a recipe like "When building { JAM Services / guest programs }, don't do `static mut OUTPUT_BUFFER: [u8; 32] = [0; 32];` ( because __ ), do `let mut buffer = Box::new([0u8; 32]);` ( because __ ) and then you will see ___" 

As we adjusted our little toy JAM services to map into your `sbrk` recommendation, we ended up moving our bits of memory so they happened to be in the "heap" ... and we'd like to get this done properly now -- what is the way (or ways) we should do this now vs later? [edited]
2025-05-29 22:43 sourabhniyogi: I'd like to get the "Simple Transfers" in sec 20.2.2 coded up and ready for Toaster testing, ideally with the 1.4MM TPS claims backed out in a way that can be presented to US States like Wyoming Stable Token Commission or Texas BlockChain Council (see also 1553 ) How can we develop a plan for this? [edited]
2025-05-29 22:50 tsaf325: Just to give a little context, Thanks to the Texas Blockchain Council, I met two representatives from the Texas banking association who are looking into how Texas banks can stay competitive in the banking landscape with stablecoin adoption. I would like to outreach to them with some more info about how Polkadot can play a role in this. 
2025-05-30 08:18 dave: 
2025-05-30 11:42 clearloop: hi there, I'm wondering about what's the specified `test-service` used in the accumulate test vectors

1. the [current one](https://github.com/davxy/jam-test-vectors/tree/master/accumulate/test-service) seems outdated since it's using 0.1.12, and can not be compiled by jam-pvm-build 0.1.21 & 0.1.16
2. it's using [AccumulateItem](https://docs.rs/jam-types/latest/jam_types/struct.AccumulateItem.html) from jam-types however it missed the gas field and the order seems mismatched from graypaper as well
2.1 I'm confused about the gas field because @jaymansfield mentioned in the issue [#52](https://github.com/davxy/jam-test-vectors/pull/52#issuecomment-2870399904), while if the program is compiled with jam-types, there should be no gas field
2.2 the order is addressed in [#53](https://github.com/davxy/jam-test-vectors/issues/53), but still, don't know what's the exact operand the program is using in the test vectors
3. after debugging the encoded operands, I found jam-types encode `vec![0; 32]` as `[[128], [0; 32]].concat()` instead of `[[32], [0; 32]].concat()` which seems not following variable length prefix and don't know where it comes from XD

our implementation can execute instructions however can never reach the storage write instruction üòÖ so I guess there are some problems in the encoding of [accumulate params](https://docs.rs/jam-pvm-common/latest/src/jam_pvm_common/service.rs.html#32), but after investigating in it, I'm getting more confused now... [edited]
  ‚Ü≥ 2025-05-30 13:30 james.wilson: > after debugging the encoded operands, I found jam-types encode vec!\[0; 32\] as \[\[128\], \[0; 32\]\].concat() instead of \[\[32\], \[0; 32\]\].concat() which seems not following variable length prefix and don't know where it comes from XD

Not sure this will help at all, but 32, when compact encoded, is indeed a single byte 128, so `[[128], [0; 32]].concat() ` looks correct to me as the byte encoding for the vec [edited]
  ‚Ü≥ 2025-05-30 13:33 dave: JAM encoding is not the same as SCALE. The issue is probably that the currently published crates use SCALE encoding for everything rather than the JAM codec as specified in the GP. We'll be releasing new crates soon that should fix this issue!
2025-05-30 14:33 ascriv: Have we given much thought to how upgrades will happen with JAM? It seems like from what I‚Äôve heard we should expect never to have to upgrade, but doesn‚Äôt that seem unrealistic?
2025-05-30 14:55 gav: Hard fork.
2025-05-30 14:55 gav: Pretty much how L1 protocols do it now, including, for what it's worth, Polkadot (for the core protocol upgrades, which is the stuff which JAM upgrades would be comparable to). [edited]
2025-05-30 14:58 gav: There may be some upgrade consensus mechanism allowing e.g. validators to specify which GP versions they support and then automating the hard-fork once ~95% support the upgraded protocol.
2025-05-30 14:58 gav: There's also a change coming in 0.7 series to add versioning to account items to allow for lazy state upgrades. [edited]
2025-05-30 14:59 gav: I don't foresee a highly frequent upgrade cycle; perhaps a protocol upgrade once every 18 months or so, but with more frequent upgrade to the services ofc.
2025-05-30 15:04 ascriv: Ok. So we‚Äôd be leaning on social consensus then. I suppose we could lean on the technical fellowship or something similar to tell everyone what‚Äôs the ‚Äúright‚Äù fork.
2025-05-30 15:06 gav: Yes some service/parachain could help coordinate this. 
2025-05-30 19:04 gav: The Parity JAM SDK version 0.1.22 is released on crates.io; it should be in line with GP 0.6.5
2025-05-30 19:05 gav: It includes most of the CoreVM development stuff (but not yet Builder or Monitor - these will come soon). It also includes the CoreVM Doom binary. [edited]
2025-05-31 08:05 clearloop: as I can see in crates the codec seems migrated to jam-codec correctly now! finally can try building the test-service!

however, I met some bugs on decoding the manifest of program, caused by the unwraps in the builder https://docs.rs/jam-pvm-builder/0.1.22/src/jam\_pvm\_builder/lib.rs.html#168-172, opened an issue on https://github.com/paritytech/polkajam-releases/issues/2 not sure if it is the correct place
 [edited]
2025-05-31 08:10 rustybot: > <@clearloop:matrix.org> as I can see in crates the codec seems migrated to jam-codec correctly now! finally can try building the test-service!
> 
> however, I met some bugs on decoding the manifest of program, caused by the unwraps in the builder https://docs.rs/jam-pvm-builder/0.1.22/src/jam_pvm_builder/lib.rs.html#168-172, opened a issue on https://github.com/paritytech/polkajam-releases/issues/2 not sure if it is the correct place
> 

What service you're trying to build?
  ‚Ü≥ 2025-05-31 08:15 clearloop: still, the [test-service](https://github.com/davxy/jam-test-vectors/blob/master/accumulate/test-service/Cargo.toml) in accumulate tests üòÖ, it does not have author field and license fields so triggered the unwrap panics

I've been guessing the encoding of AccumulateItem in the test vectors from yesterday, so I'm now trying to replace the binary with a program built with certain params )) [edited]
  ‚Ü≥ 2025-05-31 08:31 clearloop: The cache management looks weird as well, could not find the build cache, after updating the deps from 0.1.21 to 0.1.22, it re-compiles the previous dependencies, and failed to sync with the new dependencies, that I have to move it out of the workspace then compile it

I can build binary now but still have no clue where is the cache, the program re-compiles everything on each time running `jam-pvm-build` [edited]
  ‚Ü≥ 2025-05-31 08:51 clearloop: I guess the cache management problem could be caused by 

https://docs.rs/jam-pvm-builder/0.1.22/src/jam_pvm_builder/lib.rs.html#250

```
jam-pvm-build
ü™§ PVM module type: Service
üéØ Target name: riscv64emac-unknown-none-polkavm
‚ÑπÔ∏è `rustup` and toolchain installed. Continuing build process...

thread 'main' panicked at /Users/clearloop/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/jam-pvm-builder-0.1.22/src/lib.rs:168:70:
called `Result::unwrap()` on an `Err` value: Error("EOF while parsing a value", line: 1, column: 0)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

I got this problem with jam-pvm-build 0.1.22, seems like it's translating built the files with the cache built by the previous 0.1.21 toolchain
  ‚Ü≥ 2025-05-31 08:53 clearloop: seems like there is a cache management problem as well
2025-05-31 08:52 rustybot: Mmm Cargo.toml needs to updated with the required fields for metadata. Ty for reporting
2025-05-31 08:52 clearloop: 
2025-05-31 08:53 clearloop: idk how to ref the message from thread, but seems there is a cache management problem as well
2025-05-31 08:55 rustybot: And perhaps the builder also needs being more informative when the metadata can't be built because of missing info
2025-05-31 08:55 clearloop: I guess the cache management problem could be caused by 

https://docs.rs/jam-pvm-builder/0.1.22/src/jam_pvm_builder/lib.rs.html#250

```
jam-pvm-build
ü™§ PVM module type: Service
üéØ Target name: riscv64emac-unknown-none-polkavm
‚ÑπÔ∏è `rustup` and toolchain installed. Continuing build process...

thread 'main' panicked at /Users/clearloop/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/jam-pvm-builder-0.1.22/src/lib.rs:168:70:
called `Result::unwrap()` on an `Err` value: Error("EOF while parsing a value", line: 1, column: 0)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

I got this problem with jam-pvm-build 0.1.22, seems like it's translating built the files with the cache built by the previous 0.1.21 toolchain
2025-05-31 09:10 clearloop: okay it's caused by <del>jam-pvm-build is using temp\_dir and the temp\_dir is not cleaned after the build, however on the following build, it seems re-used part of the temp\_dir</del> workspace problem, the jam-pvm-builder failed to read the manifest using cargo read-manifest [edited]
2025-06-01 07:16 sourabhniyogi: We finally managed to get our first workpackage authorized/guaranteed/assured/accumulated, not with jamt with polkajam chainspec but with jamduna chainspec using our bootstrap service.  However, we had to add the following hack due to what we think is a polkajam 0.6.5-specific bug: Polkajam (at 0.6.5) appears to be be using a slightly off encoding of "a" (argument inputs) in authorization in its standard program initialization -- instead of [E(p,c)](https://graypaper.fluffylabs.dev/#/cc517d7/2c58032c5803?v=0.6.5) (p=the work package , c=varint core index), it appears to have an extra few bytes for "c".

We found this by seeing `a1 = 0x10c` (r8=268) in polkajam pvm trace of the authorization execution with a 265-byte work package (which polkajam reported back in its CE135 work report), indicating that for some reason it encodes "c" with 3 bytes.  If we are going to be at 0.6.5 for most-to-all of June (useful for multiclient testnet construction), this is worth a quick fix.  We coped by adding a couple extra bytes to match the 3 bytes, though its [E\_2(c)](https://graypaper.fluffylabs.dev/#/7e6ff6a/2eb6002eb600?v=0.6.7) now.

Is there some ideathat we should target 0.6.5 in early June and 0.6.7 in late June or something like that? [edited]
2025-06-01 08:06 gav: Thanks - we‚Äôll take a look into the encoding. 
2025-06-01 08:06 gav: As for versions, I don‚Äôt expect it to be too long to implement 0.6.7 and cut 0.6.8 with any needed changes.   [edited]
2025-06-02 14:29 sourabhniyogi: We are able to get jamduna guarantor work reports to match work reports from polkajam guarantors, specifically erasure roots.  This was enabled by a critical tip from Jason | JavaJAM  [here](https://paritytech.github.io/matrix-archiver/archive/_21wBOJlzaOULZOALhaRh_3Apolkadot.io/index.html#$Xn4h_YKcAp0dHw6sNMYmwO6IcAFUE2AxaQ59u0FwDXs) to match Polkajam's erasure coding as observed in CE137 responses 
(which doesn't follow Appendix H exactly) using [this inefficient implementation](https://github.com/jam-duna/jamtestnet/blob/7c85551b9d454fded58418454f7ebf526bc28f5e/erasurecoding/src/lib.rs#L22-L37).

Since I imagine most of us will FFI into [reed-solomon-simd/3.0.1](https://docs.rs/reed-solomon-simd/3.0.1/reed_solomon_simd/), I think its imperative to clean up details in Appendix H with a matching efficient Rust reference implementation with any required transformations -- perhaps scheduling the polkajam fix as of a certain version would be useful so we can do it in sync?  

By Rule 1, we do not see a problem with just publishing an efficient reference Rust implementation 
of any actually required transformations, a confirmation would be useful.  We would appreciate an explanation of why these transformations  are actually required.
2025-06-03 07:56 interweb_: I am subscribing to statistics, and I can't find the starting point to decode the `value` array. Could someone please point me to the docs/ref implementation? [edited]
2025-06-03 07:56 interweb_: image.png
2025-06-03 07:58 interweb_: Where I have looked:
- https://github.com/w3f/jamtestvectors/blob/master/statistics/statistics.asn
- https://hackmd.io/@polkadot/jip2
- https://github.com/gavofyork/graypaper/blob/b499b22b82804ce2e60c719d621320b513196415/text/statistics.tex#L36
2025-06-03 09:12 dave: See the C(13)-> bit in Appendix D of the GP
2025-06-03 10:24 ascriv: Has anyone done the exercise of scoping out what building a minimal actually useful end-user product powered by jam might look like (e.g. email)? Maybe assuming we‚Äôve already built the middleware required for building apps using regular programming languages etc  [edited]
2025-06-03 12:58 shwchg: Jan Bujak:
we have a work item with this code

```
     :                          @0
     0: 28 0d 00 00 00           jump @3
      :                          @1
     5: 28 13 00 00 00           jump @4
      :                          @2
    10: 28 f9 02                 jump @87
      :                          @3 [export #0: 'refine']
    13: c8 87 07                 a0 = a0 + a1
    16: 95 77 e0                 a0 = a0 + 0xffffffffffffffe0
    19: 33 08 20                 a1 = 0x20
    22: 32 00                    ret
```

but ran into error code 4 in your implementation during refine process [edited]
2025-06-03 13:00 shwchg: Is there anything we‚Äôve missed?
2025-06-03 13:02 clearloop: looks like `polkavm::interpreter` charges gas for unexecuted instructions (mb in pre-compiling ?) in https://github.com/davxy/stuff/blob/6f03f00ed8e0847c8be44b68e5cf6c0323a61ba0/pvm-traces/process\_one\_immediate\_report-1.log#L82-L114, if this is expected? [edited]
2025-06-03 13:04 jan: OOB error is only returned from `peek`/`poke` hostcalls, so I'm confused what you're actually asking about here, as this is code for a toplevel service, and it doesn't even do anything.
  ‚Ü≥ 2025-06-03 13:13 shwchg: we are passing the pu value into accumulate by using the work results
  ‚Ü≥ 2025-06-03 13:13 jan: ...I'm afraid that still doesn't tell me anything :P
  ‚Ü≥ 2025-06-03 13:15 shwchg: because the log didn't show anything about the refine process even I enable the pvm log during refine this item
  ‚Ü≥ 2025-06-03 13:15 shwchg: it just came back with the error code 4
  ‚Ü≥ 2025-06-03 13:18 shwchg: I am expecting it will show
```
Resolving arbitrary jump: 0
```
but it didn't [edited]
  ‚Ü≥ 2025-06-03 16:05 sourabhniyogi: Pardon -- Our bad, we incorrectly interpreted polkajam 0.6.5 work result error codes with 0.6.6 work result error codes, so it wasn't an OOB but "BAD", which we're checking why  this would be.   [edited]
  ‚Ü≥ 2025-06-03 21:13 sourabhniyogi: Polkajam seems to be able to absorb our code's preimages (because it authors blocks with |E\_P|=1, upon CE142/143 which we validate happily) after using our bootstrap service (new=>write=>transfer), but not fetch it upon demand in a later WP, returning back with BAD.

I tried using CE129 to inspect the whole state (0x0000 ... 0xFFFF..FF) to check if polkajam's preimage was in state, but got this:

```
2025-06-03 14:00:54 tokio-runtime-worker WARN jam_node::chain::state_db  Missing value hash in range proof: [195, 153, 202, 58, 128, 172, 64, 203, 177, 7, 182, 55, 32, 87, 42, 16, 130, 38, 16, 128, 135, 156, 111, 71, 70, 163, 203, 188, 191, 146, 112, 140]
```

Is CE129 supposed to be usable in this way yet?

We coped by putting our { fib, auth\_copy } services in our genesis state for now.

We are able to get a few work packages guaranteed, assured, accumulated (one that creates a new service, another that exports a segment), but any WP that imports the exported segment \[ by (wph, index) \] reliably reports back:

````
2025-06-03 13:54:51 tokio-runtime-worker ERROR ```
jam_node::chain::guarantors::guarantor  Failed to process package 0xe6420b365310d562...: Import error: Import not found: root Direct(0x590a50a6d3899507...), index 0
````

In addition, for any WP that exports a segment, we do not get the same segments root or erasure root.  But, if we have no exported segments from our WPs, we get matching erasure roots. [edited]
  ‚Ü≥ 2025-06-04 10:00 dave: Re CE 129 we don't use that for anything at the moment AFAIK so wouldn't be surprised if it had bugs. For a preimage to be usable in refine the block that introduced it must have been finalized. We haven't yet enabled our finality implementation so currently blocks are just finalized after a few slots. Possibly you are falling foul of this? [edited]
  ‚Ü≥ 2025-06-04 10:06 sourabhniyogi: ah, will use that "it must have been finalized." and see if that does the trick
  ‚Ü≥ 2025-06-04 10:11 dave: See the stuff in the GP around the "lookup anchor" and the historical-lookup function
2025-06-03 13:04 jan: PolkaVM charges gas per basic block, not per instruction.
  ‚Ü≥ 2025-06-03 13:06 clearloop: if this also means, that in a block, there is a jump instruction in the middle, even if we jump to other blocks at that point, we still charge the gas of the entire block?
  ‚Ü≥ 2025-06-03 13:06 jan: You can't have a jump instruction in the middle of a basic block.
  ‚Ü≥ 2025-06-03 13:08 clearloop: I got you! however, still don't get why block 3644-3653 charges gas even though, we should jump to 5326 from 3491 

---

3491 -> jump to 5326

compiling block { 3644-3653 } \<--- why this happens

block {5326 ...} [edited]
  ‚Ü≥ 2025-06-03 13:09 jan: It's not charging gas.
  ‚Ü≥ 2025-06-03 13:10 jan: "compiling" means that it just compiled the block, and not that it was executed
  ‚Ü≥ 2025-06-03 13:11 clearloop: thank you!, I'll keep digging other parts! 

our implementation has a 66 gas diff for each of the test vectors in accumulate üòÇ
  ‚Ü≥ 2025-06-03 13:15 jan: Note that technically even if your implementation charges gas per instruction and not per basic block the final gas amount should still be the same as long as it finishes successfully (that is, if no basic block is interrupted in the middle by e.g. accessing inaccessible memory then whether you charge gas per instruction or per basic block won't make a difference)
  ‚Ü≥ 2025-06-03 13:23 clearloop: yes we can execute successfully, start/end at the same pc, storage matches, however we take less 66 gas for each of the test vectors...

we are charging host calls per 10 gas as defined in the docs, that the only thing I can do is comparing instructions one by one now to debug it )))
  ‚Ü≥ 2025-06-03 13:53 clearloop: hmm, I assume I forgot to sync gas at sort of invocation interactions, debugging the instructions is endless ...
  ‚Ü≥ 2025-06-03 18:18 sourabhniyogi: Is there some way to get a dump of all the registers out of polkajam, prior or after the execution of each compiled block.  
  ‚Ü≥ 2025-06-04 06:29 jan: No. Only the registers changed by the program are printed out, and some of the source registers depending on the instruction.
  ‚Ü≥ 2025-06-07 22:45 jaymansfield: > <@jan:parity.io> PolkaVM charges gas per basic block, not per instruction.

Is it expected then that everyone charges per block and not per instruction? Otherwise on all non-successful invocations (accessing bad memory, etc) our work results gas used will differ.
  ‚Ü≥ 2025-06-08 11:26 gav: This will be made clear under ‚Äúgas costs‚Äù in 0.7 series.  [edited]
2025-06-04 07:26 subotic: 
2025-06-04 08:20 davxy: New batch of import traces: [PR #70](https://github.com/davxy/jam-test-vectors/pull/70)

(Currently exercises the happy paths for preimages `solicit` and `forget`) [edited]
2025-06-04 18:11 jimboj21: So I am working on a pvm issue for reports-l0 00000003.json, and i am a bit confused about the blob. I pass all current accumulation test vectors, and when i plug in this 00000003.json blob to one of those tests the pvm panics. Even though I wouldnt expect it to pass the stf I would expect it to still execute. There isnt any different in how to process/store the primages in the reports-l0 tests is there? Has anyone else had any issues processing the blob?

Given other teams execute okay I imagine not, but inspecting the blob it seems odd to me (for example the first 10 bytes of the program blob for me are: [40 67 105 0 0 40 127 118 0 0] which does not actually align with my bitmask I read. So multiple points of confusion here. If someone could confirm the first 10 bytes of the actual program code against mine that would be great, to make sure I have the right data at least. I havent run into issues with blob parsing in yet so I am a bit confused as to why I might be now (or I am just missing something on how to handle it) so thought i would shoot a message here to see if anyone has any info/could check those bytes
2025-06-05 12:24 interweb_: in jam-test-vectors I see some problem with validating codec:

```bash
 codec % python validate.py
* Validating:  data/work_package.json
* Validating:  data/guarantees_extrinsic.json
* Validating:  data/tickets_extrinsic.json
* Validating:  data/block.json
Traceback (most recent call last):
  File "~/jam-test-vectors/codec/validate.py", line 15, in <module>
    validate(schema, path)
  File "~/jam-test-vectors/jam-types-asn/utils.py", line 52, in validate
    decoded = schema.decode(schema_name, json_bytes, check_constraints=True)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "~/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/compiler.py", line 167, in decode
    decoded = type_.decode(data)
              ^^^^^^^^^^^^^^^^^^
  File "~/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/codecs/jer.py", line 523, in decode
    return self._type.decode(json.loads(data.decode('utf-8')))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "~/rust/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/codecs/jer.py", line 86, in decode
    value = member.decode(data[name])
            ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "~/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/codecs/jer.py", line 86, in decode
    value = member.decode(data[name])
            ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "~/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/codecs/jer.py", line 288, in decode
    for element_data in data:
TypeError: 'NoneType' object is not iterable
```

I see the json has:

```json
 "tickets_mark": null,
```

and the defn is:

```asn
tickets-mark       TicketsMark OPTIONAL,
```

Should I raise an issue on github for this ? [edited]
2025-06-05 13:39 rustybot: > <@interweb_:matrix.org> in jam-test-vectors I see some problem with codec:
> ```bash
>  codec % python validate.py
> * Validating:  data/work_package.json
> * Validating:  data/guarantees_extrinsic.json
> * Validating:  data/tickets_extrinsic.json
> * Validating:  data/block.json
> Traceback (most recent call last):
>   File "~/jam-test-vectors/codec/validate.py", line 15, in <module>
>     validate(schema, path)
>   File "~/jam-test-vectors/jam-types-asn/utils.py", line 52, in validate
>     decoded = schema.decode(schema_name, json_bytes, check_constraints=True)
>               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>   File "~/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/compiler.py", line 167, in decode
>     decoded = type_.decode(data)
>               ^^^^^^^^^^^^^^^^^^
>   File "~/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/codecs/jer.py", line 523, in decode
>     return self._type.decode(json.loads(data.decode('utf-8')))
>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>   File "~/rust/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/codecs/jer.py", line 86, in decode
>     value = member.decode(data[name])
>             ^^^^^^^^^^^^^^^^^^^^^^^^^
>   File "~/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/codecs/jer.py", line 86, in decode
>     value = member.decode(data[name])
>             ^^^^^^^^^^^^^^^^^^^^^^^^^
>   File "~/jam-test-vectors/venv/lib/python3.11/site-packages/asn1tools/codecs/jer.py", line 288, in decode
>     for element_data in data:
> TypeError: 'NoneType' object is not iterable
> ```
> 
> I see the json has: 
> ```json
>  "tickets_mark": null,
> ```
> 
> and the defn is:
> ```asn
> tickets-mark       TicketsMark OPTIONAL,
> ```
> Should I raise an issue on github for this ?

Are you using this fork of asn1tools? https://github.com/davxy/asn1tools/ 
2025-06-05 13:41 interweb_: 
2025-06-07 17:05 jaymansfield: If anyone is interested in comparing compatibility and cross testing with more JAM implementations, I've released 0.6.5 binaries for JavaJAM. https://github.com/javajamio/javajam-releases 
2025-06-07 21:38 sourabhniyogi: Jan Bujak: We have gotten knee-deep into linear recompilation work following [your Recompilers 101](https://www.youtube.com/watch?v=iXsng4YCDQg), now doing pvm byte  => X86\_64  recompiles (in Go) and gotten 180 pvm testcases to pass in compiler mode.

Some questions:

1. What X86 registers can we safely "clobber", if any?
2. In many cases, our PoC implementation maps a single PVM instruction to 2-8 x86\_64 instructions and I'd like to check that the larger cases (5-8) are sensible.   Some of these larger cases appear necessary to cover the "inst\_{divide,rem}\*\_by\_zero" situations and we're wondering if we're off track?
3. Does it make sense to have a  battery of pvm-to-x86 target outputs as public test vectors for M3 linear recompilation?  Or, can we see polkatool's "recompiled x86\_64" output somehow, block by block, or across an entire disassembled .pvm file to check for cases where we are doing a few too many x86\_64 instructions per PVM Instruction?  How do we do this if so?
4. there are many PVM opcodes (ROT\_R\_64\_IMM, MUL\_UPPER\_S\_S, COUNT\_SET\_BITS\_32, SIGN\_EXTEND\_16, REVERSE\_BYTES ...) that do not yet have a simple test case in the [pvm test vectors](https://github.com/w3f/jamtestvectors/pull/3) like [inst\_add\_64](https://github.com/koute/jamtestvectors/blob/master_pvm_initial/pvm/programs/inst_add_64.json) (powering both interpreter and recompiler testing) -- is this something we should expect from you or should we be on our own for this?
5. Generically, for different recompiler efforts, if in the end, we had exactly one public "best" way to map each PVM instruction to some number of x86\_64 instructions, how do you expect PVM executions (excluding host function calls) to actually differ?   If you expect they will differ very little to none, why not have a single open-source high-performance C recompiler that maps into this "best" way per architecture (starting with x86\_64) that we all build and FFI into just like w3f bls+bandersnatch libs? [edited]
  ‚Ü≥ 2025-06-08 16:41 subotic: Hey sourabhniyogi, if you are adventurous, here is an open PR with a few more test vectors for some of the mentioned instructions:
https://github.com/paritytech/polkavm/pull/258
  ‚Ü≥ 2025-06-09 06:06 jan: 1. Depends on how you're sandboxing. Read up on: https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI

In general it's possible to clobber all of them as long as you're careful.

2. Yes, some PVM instructions will require multiple AMD64 instructions, e.g. multiplication and division definitely are one of the bigger ones because the semantics don't map 1-to-1.

3. In general I'd probably consider copy-pasting the exact assembly generated by PolkaVM to be against the rules of the JAM prize. It's fine to borrow general techniques as long as they're documented in isolation (e.g. my gas metering trick I've shown on the slides), but you shouldn't copy-paste exactly what PolkaVM is doing.

The only extra tests we will need are performance tests that will measure how fast your recompiled code runs, regardless of what assembly you emit (this is just an implementation detail).

4. Yes, as Ivan mentioned he made a PR adding more simple tests for those. I'll merge it eventually when I get some time (sorry for the delay Ivan Subotic !)

  ‚Ü≥ 2025-06-09 12:22 sourabhniyogi: So the primary competition on M3 is on how PolkaVM maps to X86 and its all intended to be secret, and we don't have to generate the same answer.  What are some initial benchmarks for us to use to see if we are 5%, 10%, 25%, 50%, 75%, of PolkaVM that we can run ourselves this summer?  We would like to know if we should do this in Go at all to get to 70%.  
  ‚Ü≥ 2025-06-09 12:24 jan: At very least you can run DOOM and see if you can hit 60 FPS.
  ‚Ü≥ 2025-06-09 12:24 jan: Getting good execution performance should be easier; more challenging will be getting the recompilation performance high enough.
  ‚Ü≥ 2025-06-09 12:28 jan: I have plans to eventually create a PVM harness for benchmarking. Fluffy Labs guys started one here so I'll probably contribute there: https://github.com/FluffyLabs/pvm-test-harness

Feel free to integrate your PVM there.
  ‚Ü≥ 2025-06-09 12:31 jan: (Integration into such a harness will most likely be required for the M3+ milestones, as I certainly ain't gonna benchmark each PVM implementation manually.)
2025-06-08 09:58 olanod: You know what next cool actually useful "demo" could be? self-hosting, CoreVM running cargo/rustc to compile itself. What would it take? filesystem ‚úÖÔ∏è, multi-threading ‚ùéÔ∏è , wizzardy to get rustc happily compiling to PVM ‚ùìÔ∏è 
2025-06-08 12:05 ascriv: @gav you mentioned in your Mr shift interview you wish you had made polkadot privacy-first from the beginning. Are there plans to make jam with privacy as the default?
2025-06-09 07:10 ascriv: I think it could be a good idea to launch JAM with some example products to show the capabilities, like how the Wii came with Wii sports. Thoughts?
2025-06-09 07:53 dvladco: Hello, can someone check the `same_code_different_services` test vector for accumulation? for service with id `1730` the fields `bytes` and `items` seem to have wrong values since there is no storage items or preimages for that service. Is it a bug in the test vector or am I missing something?
  ‚Ü≥ 2025-06-09 07:56 clearloop: as you can see the hash of the two preimages are the same, that it's related to the shared preimage part, you can find it in GP
  ‚Ü≥ 2025-06-09 08:01 dvladco: Yes I noticed that code_hash is the same, but the preimages for 1730 is empty, can one service access the preimages of another?
  ‚Ü≥ 2025-06-09 08:05 clearloop: while it is shared preimages, the bytes and items can be calculated from the shared one
  ‚Ü≥ 2025-06-09 08:09 dvladco: ok thank you, I will look more into the shared preimages
  ‚Ü≥ 2025-06-09 08:12 greywolve: Which section is the shared preimages part? 
  ‚Ü≥ 2025-06-09 08:18 clearloop: I can't recall it clearly...but it's somewhere closed to the arguments of the accumulation, there is a formula, re-composing the account params
  ‚Ü≥ 2025-06-09 09:26 dvladco: I don't see the arguments being recomposed, we just pass the state: `let (n, o, t, C, u) = ‚àÜ+(g, W‚àó, (œá, Œ¥, Œπ, œÜ), œág )`
  ‚Ü≥ 2025-06-09 09:27 dvladco: Also I was thinking, does it make sense to charge a service for the storage items that it doesn't store?
  ‚Ü≥ 2025-06-09 10:56 dvladco: davxy: can you also take a look at this test vector?
  ‚Ü≥ 2025-06-09 11:49 davxy: I will, but if you want to be sure I don't forget, please open an issue in the repo.
2025-06-09 19:07 danicuki: Hello, I have a doubt about CE 142: Preimage announcement and CE 143.

When preimage is announced (CE-142), how does the receiving node knows which port it should connect to call CE-143? It knows the calling node IP, but doesn't know the port this node is listening on for CE calls.  [edited]
  ‚Ü≥ 2025-06-09 19:08 dave: It should use the same connection
  ‚Ü≥ 2025-06-09 19:09 danicuki: but didn't CE-142 close the connection after complete?  [edited]
  ‚Ü≥ 2025-06-09 19:09 dave: No, you're confusing streams and connections
  ‚Ü≥ 2025-06-09 19:11 dave: I'll add some text to clarify this. The intended behaviour is that if for example a non-validator node connects to a validator to submit a preimage, it will announce the preimage using CE 142 and then keep the connection open until the preimage is requested (presumably giving up after some reasonable timeout)
2025-06-09 19:12 dave: 
2025-06-09 23:19 sourabhniyogi: image.png
2025-06-09 23:19 sourabhniyogi: Super happy to report that we have 2+2+2 JAM tiny testnet doing fallback+safrole between polkajam, javajam and jamduna at 0.6.5 AND matching erasure roots + exports roots between 3 different client guarantors, with the latest binaries from polkajam + javajam.  See  [Makefile](https://github.com/jam-duna/jamtestnet/blob/main/Makefile).  Published an [updated jamduna binary](https://github.com/jam-duna/jamtestnet/releases/tag/0.6.5.3) (only for implementers trying to do the same =)). [edited]
2025-06-10 18:12 sourabhniyogi: Some questions, mostly concerning getting robustness in pursuing the above:

1. Getting 3 clients to accept a work package with CE133/134 requires some degree of luck (with R=4 anyway), as we frequently get this:

```
2025-06-10 10:37:33 tokio-runtime-worker ERROR jam_node::chain::guarantors::guarantor  Failed to validate work package: invalid core: 1 not in [0]
```

indicating we're not on the same page on _when_ our clients are supposed to rotate exactly, causing us to check what [GP 11.3](https://graypaper.fluffylabs.dev/#/7e6ff6a/14f70114f701?v=0.6.7) says exactly about client behavior on exactly when validator switch their core beyond "Every block, each core has 3 validators uniquely assigned to guarantee work reports for it." -- is there something we've missed?   Is there a way to get visibility on the instant when a `polkajam` node switches its core assignment to as to respond with "invalid core: {} not in {}"?

2. For starting up a testnet where there might be 5-10 seconds between the first client launching and the last, its valuable for every client to wait to author a block until some specific time, so as to allow time to launch, peer, etc and not author right away -- is there some way to do this with `polkajam`?
3. We are able to have WPs with imported segments specified by export root (woohoo!)

```
2025-06-09 18:40:04 tokio-runtime-worker TRACE jam_node::chain::exec::in_core  fetched segment 0xeb390c02e701e9c3... for spec ImportSpec { root: Direct(0x0931694d2f7f25ea...), index: 0 }; lookup: None
```

but not by work package hash still:

```
2025-06-10 10:30:31 tokio-runtime-worker ERROR jam_node::chain::guarantors::guarantor  Failed to process package 0x58a40e64c7ccdab7...: Import error: Import not found: root Direct(""), index 0
```

is this expected?

4. Is this a problem:

```
2025-06-10 10:24:48 tokio-runtime-worker ERROR authoring  Error authoring block: Authoring is lagging behind the best block slot
``` [edited]
  ‚Ü≥ 2025-06-10 18:43 jaymansfield: I've seen #1/#4 multiple times as well. For #1 in JavaJAM there is no real timing to rotation. I do core assignment calculations in real-time when a WP arrives to see if it should be accepted or not, but since its based off best block there definitely could be timing issues if the WP is sent while a node is still processing a block [edited]
  ‚Ü≥ 2025-06-10 19:05 sourabhniyogi: We must have missed something in GP concerning "its based off best block"-- where is this
  ‚Ü≥ 2025-06-10 19:10 jaymansfield: Actually looking back that may have been an assumption of mine. Hopefully someone can clarify.
  ‚Ü≥ 2025-06-11 00:27 dave: 1. I think reasonable behaviour would be to start accepting work-packages for a rotation 1 slot before the rotation actually starts, and stop accepting when the rotation ends. polkajam does not quite do this at the moment, its transitions currently occur one slot earlier. I thought we had changed this but apparently not. I'll push a change tomorrow to adjust this.
  ‚Ü≥ 2025-06-11 00:28 dave: 2. Don't understand why this is necessary. Clients that are late to start should be able to sync any blocks they missed and quickly get to a point where they can do useful things?
  ‚Ü≥ 2025-06-11 00:29 dave: 3. Not sure how well this has been tested. I believe it's _supposed_ to work.
  ‚Ü≥ 2025-06-11 00:34 dave: 4. Looks like polkajam can produce this error if a block is produced too early. I think we're possibly supposed to avoid importing blocks which are produced too early, don't think we have any logic for this at the moment though
  ‚Ü≥ 2025-06-11 00:38 dave: FWIW I think currently we require a work-package to have been made available before we allow importing its exports in any way. It should be possible to reduce this latency in the happy case, by requesting the segments from the guarantors directly. There is currently no protocol defined for doing this.
  ‚Ü≥ 2025-06-11 00:45 dave: Looking at the logs you posted it looks like the block published at 16:18:29 should not have been published until 16:18:30. It's reasonable to start authoring a bit before the slot time, but if you finish early you should wait for the slot before announcing. FWIW, for simplicitly, polkajam currently doesn't even start authoring until the slot time is reached
  ‚Ü≥ 2025-06-11 00:47 dave: polkajam at least just bases core assignments on wall-clock time.
  ‚Ü≥ 2025-06-11 04:48 sourabhniyogi: 1. Much appreciated! Any logging you add on at the start (1 slot before) and at the end, we will match the logging as well as this suggested behavior, thank you.
2. When nodes author a block in their block prior to peering with everyone in the grid (esp with polkajam nodes), we end up with forks.   We can cope by using `at`, no worries
3. Ok - don't believe it works yet -- we adjusted to exported segment root
4. Alright -- will adjust (a) when we submit a work package to be after its imports are made available, and (b) when we announce a block to be after the slot time is reached.   I think (b) is reasonable but question (a) as I'd expect pipelining WPs with prereqs in refine-accumulate to be a serious priority.

Is it possible to slip in a fix for E(p,c) along with 1 reported [here](https://paritytech.github.io/matrix-archiver/archive/_21wBOJlzaOULZOALhaRh_3Apolkadot.io/index.html#$45Z1ZHd5_sjqHnlNeil6Gxo4qi43X1km5n65JARQ1II)?  We cannot get authorization pvm to match with `jamt create-service` (but otherwise match on everything else in the work report!) due to the slight byte mismatch [edited]
  ‚Ü≥ 2025-06-11 09:41 sourabhniyogi: We managed to get { 1, 2, 3, 10, 31, 32, 33,  63, 64, 65, 127, 128, 129, 255, 256, 257,  511, 512, 513, 1023, 1024 } segments to match up with polkajam's export segment roots + erasure roots.   

We need a battery of work package bundles to test how the import/export process match up with correct work reports and expected CE137/138/139  responses.  There are many different ways we could approach this, but in the end I believe we want jam binaries be able to take in a fixed self-contained bundle and output xyz, in the same way we want to be able to take the "state transitions" for accumulate.   For simplicity, I would set `historical-lookup` aside for another day and treat refine to be 100% stateless.   Do you have an opinion on what xyz should be?

I believe if we design xyz with some foresight, we'll save ourselves massive debugging time later, not unlike the situation with pvm trace logging. [edited]
  ‚Ü≥ 2025-06-11 09:43 dave: 1. There aren't good spots for such log messages as we just determine the acceptable cores when a WP arrives; no code runs when the actual transitions happen
  ‚Ü≥ 2025-06-11 09:48 dave: 2. Forks need to be handled and should be resolved as more blocks are authored?
  ‚Ü≥ 2025-06-11 09:52 dave: Will take a look at the E(p,c) thing.
  ‚Ü≥ 2025-06-11 09:55 sourabhniyogi: We will use `at` for 2, don't worry about it.  We use old school stuff like ansible playbooks and can't wait to see how 1023 nodes in the toaster will work with forks all being handled with grandpa. [edited]
  ‚Ü≥ 2025-06-11 09:57 dave: FWIW if a node is reasonably sure it is behind the head of the chain it should probably avoid authoring a block. It should be able to determine this based on the slots announced by peers, before any blocks are downloaded. Obviously still possible to get forks...
  ‚Ü≥ 2025-06-11 10:02 dave: > <@sourabhniyogi:matrix.org> We managed to get { 1, 2, 3, 10, 31, 32, 33,  63, 64, 65, 127, 128, 129, 255, 256, 257,  511, 512, 513, 1023, 1024 } segments to match up with polkajam's export segment roots + erasure roots.   
> 
> We need a battery of work package bundles to test how the import/export process match up with correct work reports and expected CE137/138/139  responses.  There are many different ways we could approach this, but in the end I believe we want jam binaries be able to take in a fixed self-contained bundle and output xyz, in the same way we want to be able to take the "state transitions" for accumulate.   For simplicity, I would set `historical-lookup` aside for another day and treat refine to be 100% stateless.   Do you have an opinion on what xyz should be?
> 
> I believe if we design xyz with some foresight, we'll save ourselves massive debugging time later, not unlike the situation with pvm trace logging.

This sort of thing will be handled by the fuzzing/conformance testing tool davxy is working on. Can't comment on input/ouput formats yet, but likely they will just be binary encoded using the GP codec.
  ‚Ü≥ 2025-06-11 12:27 dave: I agree the current behaviour of polkajam does not match the GP. It seems that we currently include the authorization config blob from the work-package (p_p) at the start of the argument blob, followed by the package and the core. We also encode the core index with E_2 AFAICT rather than E. This stuff has been reworked in GP 0.6.6, which we're currently implementing. We likely won't fix the 0.6.5 behaviour, instead well just move forward with 0.6.6.
  ‚Ü≥ 2025-06-11 14:53 jaymansfield: This helped, thanks! "Authoring is lagging" error is now gone for me after tweaking my block creation/announcement time.
  ‚Ü≥ 2025-06-11 18:40 sourabhniyogi: We used your clue to get jamt Authorization PVM correct, so we can use jamt create-service and polkajam spec to submit WPs now -- thank you for the hint! [edited]
  ‚Ü≥ 2025-06-11 23:25 sourabhniyogi: Ok, we looked into replicating this idea of "no code runs when the actual transitions happen" but in [reports](https://github.com/w3f/jamtestvectors/blob/26016ac6ca25cca9baecf90c233fc661d65283c3/reports/README.md?plain=1#L103) there is a ["Unexpected guarantor for work report core." test vector](https://github.com/w3f/jamtestvectors/blob/26016ac6ca25cca9baecf90c233fc661d65283c3/reports/tiny/wrong_assignment-1.json) where we thought it necessary to recompute core-validator assignments for each guarantee based on the guarantees slot.  How can you have "no code runs when the actual transitions happen" and properly validate guarantees included in the block without computing a validator-core assignment based on each guarantees slot?

Is it that you have one  on-demand computation when WPs are received (based on "Wall clock" time) and a separate computation when Guarantees are validated (based on the guarantee slot)?

Is the blocks time slot relevant at all?  It seems the first sentence of 11.3 should be "Every slot, each core has 3 validators.. " rather than "Every block, ..." [edited]
  ‚Ü≥ 2025-06-11 23:31 sourabhniyogi: What time slot a guarantee core-validator assignement is supposed to be validated against -- is it the wall clock time or the time slot in the guarantee?  (We assumed the latter.)

What does the first guarantor (the validator receiving CE133) do to compute the guarantee's time slot exactly -- is it the time of receiving the WP, when it starts refining, when it completes, or something else still?

It seems to me the only place we could possibly want to be using the wall clock time is the time when a WP is received.    [edited]
  ‚Ü≥ 2025-06-12 00:42 dave: > Is the blocks time slot relevant at all? It seems the first sentence of 11.3 should be "Every slot, each core has 3 validators.. " rather than "Every block, ..."

Yes, that's probably true; there are two possible sets of validators for a core from the perspective of including guarantees in a block, as you can include a guarantee using the previous rotation
  ‚Ü≥ 2025-06-12 00:46 dave: For verifying a guarantee included in a block you should use the slot in the guarantee. AFAIK the only way in which the validity of a block depends on the wall-clock time is that the block's time-slot must not be in the future: "A block may only be regarded as valid once the time-
slot index Ht is in the past" (Section 5)
  ‚Ü≥ 2025-06-12 00:59 dave: A guarantee's time slot is only relevant for determining the rotation and hence what the validator assignments are. As a guarantor constructing a guarantee, you should set the time slot to one in which you and the other guarantors you shared the package with are assigned to the core. This slot should be close to the current slot (as otherwise you would presumably have refused to process the work-package), but may be slightly in the future.
  ‚Ü≥ 2025-06-12 01:01 dave: The wall-clock time should be used to determine whether or not to accept a work-package from a builder or another guarantor, but shouldn't really be used for anything else.
  ‚Ü≥ 2025-06-12 12:44 jaymansfield: Theres a bug somewhere that can cause the polkajam nodes to crash (completely shutdown and need to be started again):  2025-06-11 11:18:36 tokio-runtime-worker ERROR jam_node  Finality task returned an error: Chain error: State(MissingBlock)
2025-06-11 11:18:39 main ERROR jam_cli  Error: Chain error: State(MissingBlock)  
  ‚Ü≥ 2025-06-13 01:11 mkchung: Does polkajam support CE134 with non-empty Segments-Root Mappings? so far Ive not seen CE134Resp from polkajam with Segments-Root Mappings. Also for sharing workpackage that contains importSegments with polkajam binary via 134. I got the following errors WITH or WITHOUT including Segments-Root Mappings

```
Disconnecting: Misbehaviour: Malformed jam_node::availability::net::protocol::SegmentsRequest: Could not decode `SegmentsRequest::erasure_root`:
	Could not decode `ErasureRoot.0`:
		Not enough data to fill buffer
```
  ‚Ü≥ 2025-06-13 01:15 mkchung: However, sending a work package that "requires" importSegments to the PolkaJam binary via CE133‚Äîand relying on PolkaJam to perform the CE134 step‚Äîappears to work, although the segment-root mappings come back empty from CE134resp. not exactly sure why. [edited]
  ‚Ü≥ 2025-06-17 21:05 mkchung: David Emett
Apologies for the ping‚Äîjust wanted to check if you saw my previous message?

We‚Äôve published our latest binary here: https://github.com/jam-duna/jamtestnet/releases/tag/0.6.5.4

we are now fully compatible with CE133/137/138/139 and have generally improved our compatibility after changing our core rotation logic. However, I don‚Äôt believe Polkajam currently supports workpackages containing importSegments in CE134. Can you confirm?
  ‚Ü≥ 2025-06-18 00:20 dave: > <@mkchung:matrix.org> David Emett
> Apologies for the ping‚Äîjust wanted to check if you saw my previous message?
> 
> We‚Äôve published our latest binary here: https://github.com/jam-duna/jamtestnet/releases/tag/0.6.5.4
> 
> we are now fully compatible with CE133/137/138/139 and have generally improved our compatibility after changing our core rotation logic. However, I don‚Äôt believe Polkajam currently supports workpackages containing importSegments in CE134. Can you confirm?

Hey, on holiday at the moment. Possibly Ivan can help with this.
  ‚Ü≥ 2025-06-18 08:25 igankevich: > 12025-06-10 10:37:33 tokio-runtime-worker ERROR jam\_node::chain::guarantors::guarantor  Failed to validate work package: invalid core: 1 not in \[0\]

If you _occasionally_ see this error when you submit work package from a builder, then it _might_ be an indicator that an epoch change occurs while the package is in transit between the builder and the guarantor.

One way to fix that is for the builder to switch the rotation for which the package is built _shortly after_ the guarantor switches the rotation for which it accepts work packages. You might also want to accept packages for the next rotation shortly before the switch occurs and stop accepting them for the current rotation shortly before the next rotation switch. Then this error should disappear.

I'm a bit hesitant to share the exact amount of overlap between rotation acceptance periods that we use because I realized that our current values are way to big for a rotation that spans only 4 slots. Let's just say that you probably shouldn't build the package for the current rotation if it's less than one slot away from the next one...

> 12025-06-10 10:30:31 tokio-runtime-worker ERROR jam\_node::chain::guarantors::guarantor  Failed to process package 0x58a40e64c7ccdab7...: Import error: Import not found: root Direct(""), index 0

Referencing by package hash should work. I wonder why it prints the hash as an empty string? Is it all zeroes?

> the segment-root mappings come back empty from CE134resp

Hmm... CE134 response doesn't have any mappings :)

If you see "fetched segment ... for spec ..." in the logs, this means that the segment-root was added to SR mapping that will go into CE134 message. [edited]
  ‚Ü≥ 2025-06-18 18:48 mkchung: ```
Segments-Root = [u8; 32]
Segments-Root Mappings = len++[Work-Package Hash ++ Segments-Root]
Work-Package Bundle = As in GP

Guarantor -> Guarantor

--> Core Index ++ Segments-Root Mappings
--> Work-Package Bundle
--> FIN
<-- Work-Report Hash ++ Ed25519 Signature
<-- FIN
```

Regarding the ‚ÄúGuarantor (polkajam) ‚Üí Guarantor (jamduna)‚Äù direction, we‚Äôve consistently observed that the request from polkajam is missing the [Work-Package Hash ++ Segments-Root] portion, even when the shared package includes importSegments. In such cases, I would have expected non-empty Segments-Root Mappings from polkajam.

Additionally, in the opposite direction‚Äî‚ÄúGuarantor (jamduna) ‚Üí Guarantor (polkajam)‚Äù‚Äîwhen we share a work package that includes Segments-Root Mappings, our CE134 submission is rejected with error code 1, likely due to the issue you mentioned:
```
2025-06-18 11:30:53 tokio-runtime-worker ERROR jam_node::chain::guarantors::guarantor  Failed to validate work package: invalid core: 0 not in [1]
2025-06-18 11:30:53 tokio-runtime-worker ERROR jam_node::chain::guarantors::stream_receiver  failed to receive WorkPackageSharing: tokio error
```

We‚Äôll adjust our submission approach based on your suggestion. However, Im curious why do we _never_ receive non-empty Segments-Root Mappings in the ‚ÄúGuarantor (polkajam) ‚Üí Guarantor (jamduna)‚Äù direction, even when the work package clearly contains segment imports?


The null case in  ‚ÄúGuarantor (jamduna) ‚Üí Guarantor (polkajam)‚Äù direction is caused by trying to match polkajam's behavior -- i.e. not sending "Segments-Root Mappings" even though there probably should be one:
```
12025-06-10 10:30:31 tokio-runtime-worker ERROR jam_node::chain::guarantors::guarantor Failed to process package 0x58a40e64c7ccdab7...: Import error: Import not found: root Direct(""), index 0
```
  ‚Ü≥ 2025-06-19 09:43 igankevich: > the request from polkajam is missing the [Work-Package Hash ++ Segments-Root] portion, even when the shared package includes importSegments.

Polkajam only sends mappings for the imports that use work package hash to reference the segments. For imports referenced by segment-root the mapping between the work package hash and the segment-root is not sent because (1) guarantors can query the segments from DA via segment-root, there is no need to know work package hash to do that, (2) multiple work packages might produce segments with the same root, so the mapping is not bijective.

If you see log message `fetched segment ... for spec ... lookup Some(...)` with non-`None` lookup, then the mapping from the message will be sent to the guarantors.

> trying to match polkajam's behavior -- i.e. not sending "Segments-Root Mappings" even though there probably should be one:

The log message says that there is an import with zero segment-root. It comes directly from the work item rather than from segment-root mapping.

As far as I can tell from the current code any additional/unexpected mapping shouldn't really break anything, it will simply be ignored by Polkajam. I think this is what is happening here.
  ‚Ü≥ 2025-06-23 18:29 mkchung: Also what flag should we use if we want to run the latest `polkajam` bin (2025-06-23-nightly) with a different chainspec in `tiny` setting?  

We used to run `polkajam` with cmd like:

```
./polkajam --chain chainspecs/jamduna-spec.json  --parameters tiny run  --temp --dev-validator 1
```

We are now seeing errors:
```
error: unrecognized subcommand 'parameters'
Usage: polkajam [OPTIONS] <COMMAND>
```

And 
```
thread 'main' panicked at crates/cli/src/lib.rs:98:22:
Error loading chain spec file: "Missing or invalid 'protocol_parameters' field"
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Not sure how to set the  "protocol_parameters" flag. can you advise?
  ‚Ü≥ 2025-06-24 15:32 arkadiy: See https://github.com/polkadot-fellows/JIPs/pull/1/files#diff-921114467d2dd89436b03d6a57b0784da847a6cd1cc5237d1e4a220ee22c6148R13
2025-06-11 12:31 ascriv: Can we expect the next polkajam release to be compliant with 0.6.7 or later since 0.6.7 is out already?
2025-06-11 13:13 dave: We're working on 0.6.6 at the moment. Don't have an exact ETA for a build. There aren't many changes though so hopefully shouldn't be long.
2025-06-12 11:59 interweb_: Poss related: https://github.com/davxy/jam-test-vectors/issues/39

When decoding `statistics/tiny/stats_with_epoch_change-1.bin`
Is there any error in the definition of any of these fields for statistics?

At offset 1644 we see the `02` for GuaranteesExtrinsic: count: 2
At offset 1915 we see the `01` for WorkResults: count: 1
  ‚Ü≥ 2025-06-12 11:59 interweb_: image.png
  ‚Ü≥ 2025-06-12 11:59 interweb_: Between these offsets we are not able to decode the bin into expected json

```bash
[DEBUG] offset 1644: readGuaranteesExtrinsic: count: 2
[DEBUG] offset 1645: readGuaranteesExtrinsic: i: 0
[DEBUG] offset 1645: readReportGuarantee
[DEBUG] offset 1645: readWorkReport
[DEBUG] offset 1645: readWorkPackageSpec
[DEBUG] offset 1745-1746: readWorkPackageSpec: exportsCount: 0
[DEBUG] offset 1747: readRefineContext
[DEBUG] offset 1747-1778: readRefineContext: anchor: 0x0000000000000000000000000000000000000000000000000000000000000000
[DEBUG] offset 1779-1810: readRefineContext: stateRoot: 0x0000000000000000000000000000000000000000000000000000000000000000
[DEBUG] offset 1811-1842: readRefineContext: beefyRoot: 0x0000000000000000000000000000000000000000000000000000000000000000
[DEBUG] offset 1843-1874: readRefineContext: lookupAnchor: 0x0000000000000000000000000000000000000000000000000000000000000000
[DEBUG] offset 1875-1878: readRefineContext: lookupAnchorSlot: 0
[DEBUG] offset 1879: readPrerequisites: count: 0
[DEBUG] offset 1879-1879: readRefineContext: prerequisites: []
[DEBUG] offset 1747-1879: readRefineContext: context: {
  "anchor": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "state_root": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "beefy_root": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "lookup_anchor": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "lookup_anchor_slot": 0,
  "prerequisites": []
}
[DEBUG] offset 1880-1881: readWorkReport: coreIndex: 0
[DEBUG] offset 1882-1913: readWorkReport: authorizerHash: 0x0000000000000000000000000000000000000000000000000000000000000000
[WARN]  offset 1914: readCompactInt: mode: 0
[DEBUG] offset 1914-1914: readWorkReport: len: 0
[DEBUG] offset 1915: readWorkReport: authOutput: 0x


HERE: we have reached offset 1915, but we still need to read one octet to get the count of results... so I'm expect one more 00, before we hit 01


[DEBUG] printNextBytes: next 128 bytes: 
01000000000000000000000000000000 - [  1   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0] - 1 - 1 - 1
00000000000000000000000000000000 - [  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0] - 0 - 0 - 0
00000000000000000000000000000000 - [  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0] - 0 - 0 - 0
00000000000000000000000000000000 - [  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0] - 0 - 0 - 0
00000000000000000000000000000000 - [  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0] - 0 - 0 - 0
00000000000000000002000000000000 - [  0   0   0   0   0   0   0   0   0   2   0   0   0   0   0   0] - 0 - 0 - 0
00000000000000000000000000000000 - [  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0] - 0 - 0 - 0

```
2025-06-13 05:02 hitchhooker: Is the current networking plan to drop IPv4 routes completely, or just map them in IPv6 format (e.g., ::ffff:192.0.2.1) and use them as a fallback? Dropping IPv4 and gossip simultaneously seems like quite a radical move in terms of resiliency (IPv6 transit routes are much more centralized among fewer ISPs, with many requiring BGP communities set for blackholing at the /128 level for peering due to DDoS). 

Also, has there been any consideration of using QUIC multipath (https://datatracker.ietf.org/doc/draft-ietf-quic-multipath/) for improved resiliency in JAM-NPs?
2025-06-13 07:50 dave: You can use an IPv4 address by mapping it into IPv6 as you say. It's not intended to be IPv6-only. I'm not sure what you mean by dropping gossip; a few things are gossiped (eg blocks and preimages).
2025-06-13 07:59 dave: The S in JAMNP-S stands for simple; it's intended to be a basic protocol to get things going. It will be replaced by a more fully-featured protocol eventually. We can consider supporting eg multipath at that point. [edited]
2025-06-13 08:09 dave: > <@dave:parity.io> You can use an IPv4 address by mapping it into IPv6 as you say. It's not intended to be IPv6-only. I'm not sure what you mean by dropping gossip; a few things are gossiped (eg blocks and preimages).

That said it is only currently possible to set one address for a validator, this may need changing. Haven't given it much thought at this point.
2025-06-16 13:48 prematurata: hey @davxy can you tell a bit more about the dev validators metadata you using? i see  0x00000000000000000000ffff7f000001 40 9c .... and 40 is being incrementedd
2025-06-16 14:17 interweb_: is there any update to the https://hackmd.io/@polkadot/jip2 Node RPC Spec?
Does it have a formal github repo perhaps?

Is anyone implementing this for their nodes? I am making progress on a jam explorer... but the json-rpc data does not seem to match the GP [edited]
  ‚Ü≥ 2025-06-16 15:00 jaymansfield: https://github.com/polkadot-fellows/JIPs
  ‚Ü≥ 2025-06-16 15:03 jaymansfield: There's an open PR with some changes but I don't think even it is fully up to date yet. I've noticed jamt and jamtop require some other differences not documented yet but easy to determine them from the jam tools.
  ‚Ü≥ 2025-06-16 16:44 interweb_: It seems the blob response from the rpc does not match the formats in jamtestvectors...
  ‚Ü≥ 2025-06-16 16:46 interweb_: We can decode all jamtestvectors/codec and statistics examples
  ‚Ü≥ 2025-06-17 14:39 interweb_: I can see the request / response between jamtop and the node with a proxy. The response does not seem to be encoded per the GP so I have asked the question [here](https://github.com/paritytech/polkajam-releases/issues/3)
2025-06-16 20:24 davxy: > <@prematurata:matrix.org> hey @davxy can you tell a bit more about the dev validators metadata you using? i see  0x00000000000000000000ffff7f000001 40 9c .... and 40 is being incrementedd

Where exactly? If you're referring to the test vectors, it's mostly dummy data
2025-06-16 21:26 prematurata: I think it was the traces data
2025-06-17 07:20 basedafdev: Hi davxy:  how should we handle STF execution for the genesis_00000000.json trace test vectors? The block header‚Äôs extrinsic hash is a ZERO hash given an empty extrinsic, which seems inconsistent since in 00000001.json, an empty extrinsic results in a defined (non-zero) hash.
2025-06-17 07:24 greywolve: I assume that's because it's the genesis block
2025-06-17 07:31 greywolve: But I guess maybe it should have the same empty extrinsic hash, thinking about it more
2025-06-17 07:35 basedafdev: The reason I ask is that we‚Äôre parsing the genesis file by starting with the empty pre-state in that file and executing the STF for the genesis block, but this violates the header‚Äôs extrinsics check (among other things), but if we're expected to just save the block & post state as is then that makes life easy [edited]
2025-06-17 08:33 prematurata: it is somehow related to my question above. the genesis header + pre state given in those files are not providing everything needed to compute the same post state. 


2025-06-17 10:31 davxy: > <@basedafdev:matrix.org> Hi davxy:  how should we handle STF execution for the genesis_00000000.json trace test vectors? The block header‚Äôs extrinsic hash is a ZERO hash given an empty extrinsic, which seems inconsistent since in 00000001.json, an empty extrinsic results in a defined (non-zero) hash.

I'll remove 000..0.bin and replace it with an explicit genesis.bin, which aligns better with the JIP specifications
  ‚Ü≥ 2025-06-17 11:57 basedafdev: thanks üôè
2025-06-17 12:10 ricardo.rius: 
2025-06-18 15:23 clearloop: I just found `polkajam` even has this log üëÄ

```
eled3vb5nse3n7cii6ybvtms5s2bdwvlkivc7cnwa33oatby4txka@127.0.0.1:40005: Connection from peer with our ID!
```

seriously I'm not sure what to do if meet this in production ... [edited]
2025-06-19 06:03 clearloop: https://x.com/spacejamapp/status/1935578763670282643

just released the spacejam binaries at graypaper 0.6.5 üëæ, also introduced a testnet manager which is similar to `polkajam-testnet` but with customized config, see https://github.com/spacejamapp/specjam/blob/0.6.5/testnet.toml if helps! [edited]
2025-06-19 17:06 vinsystems: Hi! The block import traces for M1 will be in tiny or in full mode?
2025-06-19 17:13 davxy: I've opened a PR with test vectors for GP v0.6.6.
I encourage all teams to try them out.
If you'd like to discuss the proposal, please comment directly in the PR.

https://github.com/davxy/jam-test-vectors/pull/82

**These vectors should be compatible with what you can expect in the next PolkaJam nightly release**
2025-06-20 07:51 faiz_871: David Emett  Could you please help me understand the exact meaning of this notation?
Justification = \[0 ++ Hash OR 1 ++ Hash ++ Hash\]
Justification = \[0 ++ Hash OR 1 ++ Hash ++ Hash OR 2 ++ Segment Shard\]

I'm trying to interpret what each part signifies. [edited]
2025-06-20 10:12 clearloop: hope polkajam can update `jam-pvm-common`(+ jam toolchains) on crates.io for `GP-0.6.6`, which would be helpful for debugging the [test vectors for GP-0.6.6](https://github.com/davxy/jam-test-vectors/pull/82) [edited]
2025-06-20 21:42 boymaas: Does anyone here have an opinion on whether it would be feasible to have a very simple community JAM testnet running somewhere around  November, given that some teams have their nodes somewhat M2 ready?
2025-06-21 05:03 gav: I would push to get a testnet under way as soon as 0.7.0 is out (which should be very soon now). 
2025-06-21 05:04 gav: It‚Äôll inevitably need some restarts since we‚Äôll no doubt find incompatibilities between the implementations and the GP.  [edited]
2025-06-21 05:06 clearloop: curious about would it be under tiny parameters or full parameters
2025-06-21 06:10 gav: Probably somewhere in between. 
2025-06-21 08:06 boymaas: That is good news and makes sense. Looking forward to it 
2025-06-21 17:34 i35359595: Hi, is anyone working on rust implementation? My team would like to start digging into it.
2025-06-21 18:25 gav: > <@i35359595:matrix.org> Hi, is anyone working on rust implementation? My team would like to start digging into it.

In fact 8 teams are each working on their own rust implementation! You can see which teams have declared themselves on https://graypaper.com/clients/
2025-06-21 19:00 i35359595: Perfect, now there'll be 9 :)
2025-06-23 07:13 subotic: Hey guys, I'm trying to debug a problem that we have with accumulate, specifically with `accumulate_ready_queued_reports-1.json` test vector. When our VM is initialized, then I see that the contents of the first read-only section has something like this as it's contents: 
```/home/davxy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/jam-codec-0.1.0/src/codec.rsunsafe precondition(s) violated: ptr::write requires that the pointer argument is aligned and non-nullunsafe precondition(s) violated: ptr::add requires that the address calculation does not overflowassertion failed: new_len <= self.capacity()/home/davxy/.rustup/toolchains/nightly-2024-11-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rscalled `Result::unwrap()` on an `Err` value/mnt/ssd/develop/jam/polkajam/crates/jam-pvm-common/src/mem.rsunsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlapunsafe precondition(s) violated: ptr::read requires that the pointer argument is aligned and non-nullunsafe precondition(s) violated: ptr::add requires that the address calculation does not overflowunsafe precondition(s) violated: ptr::sub_ptr requires `self >= origin`unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed 
```/home/davxy/.rustup/toolchains/nightly-2024-11-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs/home/davxy/.rustup/toolchains/nightly-2024-11-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/accum.rsErrorOutOfBoundsIndexUnknownStorageFullBadCoreNoCashGasLimit ...```
Does this seem right, or is this the metadata from formula (9.4) that managed to sneak in? Any help is appreciated.
  ‚Ü≥ 2025-06-23 07:19 jan: This looks like normal RO data to me.
  ‚Ü≥ 2025-06-23 07:20 subotic: Thanks for confirming üëçÔ∏è
2025-06-24 14:26 ascriv: It seems inevitable that some people will decide to make sovereign jam chains with new tokens and validators etc. in what ways has the protocol been designed to allow for easy communication between different instances? [edited]
2025-06-24 17:45 gav: It uses merkle commitments and a fast-finalising protocol, which make bridging relatively easy. Beefy can also help. However the protocol was not designed with the intention to facilitate multiple sovereign JAM instances with their own tokens - it‚Äôs just an outcome of the protocol-centric design.  [edited]
2025-06-24 17:46 gav: What was in the back of my mind, though, was to be able combine many JAM instances over the same staking mechanism and overall validator set. In effect forming a JAM ‚ÄúGrid‚Äù
2025-06-25 15:38 danicuki: ima_75f32cf.jpeg
2025-06-25 15:41 danicuki: I have a doubt about the prize submissions. Initially, submissions wouldn‚Äôt be accepted before 1.0

@gav mentioned in JAM XP Lisbon that M1 would begin on June with 0.8.0 

Now we have 0.7.0 released. I understand that sometimes deadlines are not precise. But would be nice to have an idea about what changed since May in terms of Roadmap. 

What can we expect for the coming months? 
  ‚Ü≥ 2025-06-25 15:55 clearloop: I can see there are only 9 tasks listed for [0.7.x](https://github.com/gavofyork/graypaper/milestones), same, looking forward to see some more detailed small milestones for M1, on the other hand don't want to see releasing v1.0 for releasing it ))
2025-06-25 15:56 gav: 0.7.0 is where I would be happy to begin accepting M1 submissions. [edited]
2025-06-25 15:56 gav: With the understanding that submissions (even submissions for minor corrections) must be against the most recent GP release. [edited]
2025-06-25 16:03 clearloop: hope there will be a small guide for submissions, for example, 

1. pass all trace tests for 0.7.0
2. submit PR to the repo
3. --> how to share private repos to w3f?
2025-06-25 16:14 gav: To cut down on work and avoid speculative introduction of bureaucracy we'll initially accept M1 executables which take the same CLI arguments and pass all published M1 trace tests. With these we'll fuzz them internally against other implementations.
2025-06-25 16:15 gav: The fuzzing will take some weeks. Once we're confident they are compliant only then will we want to take a look at the codebase and commit history. [edited]
2025-06-25 16:16 gav: We'll expect organic coding over the commit series and for distinct lack of similarity to other impls beyond inherent protocol similarities.
2025-06-25 16:17 gav: Based on this outcome we'll want to make an interview to the coders of the submission to check that they credibly understand what they have submitted; it'll include me (as GP author) and any other impl teams who have passed the M1 submission. [edited]
2025-06-25 16:19 gav: (Passing M1 submission gets you a seat in the Polkadot Fellowship and accompanying salary, but as a first-level JAM expert this comes with a requirement to help judge others trying to join also) [edited]
2025-06-25 16:21 gav: The months in the target timeline were a bit speculative, but I always expected the series to be over the whole month. So 0.7 series I expected to take the whole of June (in reality, it'll likely take until the end of July now).
2025-06-25 16:23 clearloop: on taking binaries, the network part will be required XD, would be helpful if can share which CEs are required, for example, we currently just introduced UP0 + CE128 + CE132, also our network implementation is not that stable atm (could be down in 30mins)ü•≤
2025-06-25 16:28 gav: With 0.7.0 I would also be happy to begin having vaguely persistent testnets. Persisting until a little after the following GP release, anyway. [edited]
2025-06-25 16:52 jimboj21: clearloop | SpaceJam: maybe i am misunderstanding but why is networking required for submission? 
  ‚Ü≥ 2025-06-25 16:55 clearloop: bcz on running a testnet, the only way w3f can test our binaries is across the network, and once 0.7.0 expects a testnet, it means the more we implement the faster we can be confirmed as aligned with the spec

for example, in the testnet, we got broken on a CE request, they will not have any ideas why we are broken, etc.
  ‚Ü≥ 2025-06-25 16:57 clearloop: only if there will be a new command called `import` could be introduced for testing M1 only?
  ‚Ü≥ 2025-06-25 17:09 p1sar: but according to Gav's quote: 
`To cut down on work and avoid speculative introduction of bureaucracy we'll initially accept M1 executables which take the same CLI arguments and pass all published M1 trace tests.` 
Nothing about networking. Only by definition, fuzzing also does not need networking per se. Untill networking is specified fully.  CLI could be a good instrument to fuzz block building, STF, etc.
  ‚Ü≥ 2025-06-25 21:28 davxy: I designed the fuzzer to interact with the target through a dedicated, low-overhead communication channel, currently a Unix socket.
The protocol, which will be shared in the next days, will be trivial and composed of messages such as ImportBlock, GetStateRoot, SetState, and GetState.
Using testnet block sharing mechanisms would introduce unnecessary complexity and overhead.
The goal is to process blocks as quickly as possible.
So basically your CLI will need something like `--fuzz` param to open this channel [edited]
  ‚Ü≥ 2025-06-26 09:36 kianenigma: If and when this is final, please do share it with the teams so we can implement it üëçÔ∏è
  ‚Ü≥ 2025-06-26 10:10 p1sar: davxy: Great! Thank you for the clarification! 
2025-06-25 17:09 gav: Possible, [davxy](https://matrix.to/#/@davxy:matrix.org)?
2025-06-25 17:32 ge0321: Hi everyone üëã ‚Äî just joined this space to dive deeper into JAM and Coretime.
I‚Äôve built a few things in the past (not a heavy hitter dev, but I can code), and I‚Äôm especially interested in real-world use cases like decentralized newsletters and government/public sector applications.

I‚Äôm here to learn, build, and make friends ‚Äî who knows where this journey takes us.
Also, if there's another room more suited for beginner/intermediate devs to ask questions, I‚Äôd really appreciate a pointer! üôè
2025-06-25 18:27 gav: > <@ge0321:matrix.org> Hi everyone üëã ‚Äî just joined this space to dive deeper into JAM and Coretime.
> I‚Äôve built a few things in the past (not a heavy hitter dev, but I can code), and I‚Äôm especially interested in real-world use cases like decentralized newsletters and government/public sector applications.
> 
> I‚Äôm here to learn, build, and make friends ‚Äî who knows where this journey takes us.
> Also, if there's another room more suited for beginner/intermediate devs to ask questions, I‚Äôd really appreciate a pointer! üôè

Welcome! This is probably the better room of the two. You‚Äôll find all of the dev teams in here who are going to be most knowledgeable about JAM and development on it. We expect a testnet in the next few weeks; in the meantime there‚Äôs always space to converse about use-cases and how they might be implemented. 
2025-06-25 19:49 ascriv: > <@gav:polkadot.io> The fuzzing will take some weeks. Once we're confident they are compliant only then will we want to take a look at the codebase.

The fuzzing will presumably require a lot of iteration as teams fix bugs? can you explain what that process will look like more? Or will it be a black-box ‚Äúnot compliant‚Äù check from the implementers‚Äô perspectives 
2025-06-25 20:06 cisco: The test-service file in w3f/jamtestvectors master right now seems to use jam-pvm-common 0.1.12 which is very old. Is this what's included in the preimages on the test files? Or are we expected to compile it with a newer version and put it in ourselves?
2025-06-25 21:33 davxy: > <@ascriv:matrix.org> The fuzzing will presumably require a lot of iteration as teams fix bugs? can you explain what that process will look like more? Or will it be a black-box ‚Äúnot compliant‚Äù check from the implementers‚Äô perspectives 

Fuzzing is black box. On state root mismatch we'll be able to get a test vector that triggered the contention. A bit of further analysis will be required to find out who is wrong and how. I'm not sure who will be in charge of digging into the target. But for sure, given the vector that triggered the mismatch, the analysis will be easier for the implementor
2025-06-25 21:38 davxy: > <@cisco:parity.io> The test-service file in w3f/jamtestvectors master right now seems to use jam-pvm-common 0.1.12 which is very old. Is this what's included in the preimages on the test files? Or are we expected to compile it with a newer version and put it in ourselves?

We recently delivered the test vectors for version 0.6.6. Some teams are already processing them correctly. See this open PR: https://github.com/w3f/jamtestvectors/pull/49.

@gav I believe ^this is ready to be merged.

And this https://github.com/davxy/jam-test-vectors/pull/82 for more context


2025-06-26 05:40 shankarwarang: Is there any dedicated matrix channel for PolkaVM?
  ‚Ü≥ 2025-06-26 06:34 jan: There's no public channel. If you have any questions feel free to ping me here.
2025-06-26 06:32 ascriv: > <@davxy:matrix.org> Fuzzing is black box. On state root mismatch we'll be able to get a test vector that triggered the contention. A bit of further analysis will be required to find out who is wrong and how. I'm not sure who will be in charge of digging into the target. But for sure, given the vector that triggered the mismatch, the analysis will be easier for the implementor

Will we be able to play around with the fuzzer to keep the iteration loop tight?
2025-06-26 07:31 olanod: Any implementers settled on being the very best browser friendly rust light client? nothing less, nothing more.
  ‚Ü≥ 2025-06-26 07:48 olanod: I'm thinking of a protocol that submits work packages directly from the the web(with Rust), e.g. I hand the WP to the in device light node and it broad casts it to peers via WebTransport API or something, no intermediate blockchain or anything. It would be cool to know if any team is going to specialize on this kind of light client from the get go.
  ‚Ü≥ 2025-06-26 07:56 clearloop: We have sort of design, but since we are not open source yet, could be hard to share atm, <del>however we can introduce such features in our explorer in next few weeks</del>

what if a light client that have configs subscribing incoming WPs to specified endpoints (don't need to modify the code of light client, but like a blackbox, but at this case, rust or not it doesn't matter anymore)? mb this is more closed to the need? [edited]
  ‚Ü≥ 2025-06-26 08:43 olanod: knowing there are teams considering this is already good :) if sources still need to be kept private for a while I suspect one can link against a precompiled static .rlib, or you publish a standalone wasm that one talks to via a JS API or a worker's messaging APIs
  ‚Ü≥ 2025-06-26 09:00 clearloop: using WASM would be dope! glad to hear WASM is still considered as development components nowadays, I can introduce this feature in our light node next week (if no unexpected problems...) [edited]
  ‚Ü≥ 2025-06-26 09:07 interweb_: before implementing a light client I have been working on the json-rpc and explorer. I am happy to get involved in this if there is a collaboration.
At the moment we have all the jamtestvectors decoded in js, however I find the json-rpc data structures do not match the GP.
  ‚Ü≥ 2025-06-26 09:09 interweb_: I imagine a light client would implement the native GP protocol, and then we still need the js/ts libs to decode/encode data into the wasm
  ‚Ü≥ 2025-06-26 09:37 clearloop: our interface is basically designed for any external data analysis usages  with low-level API, sadly we have a simple explorer in development as well internally XD, but it's always good to see my work can be integrated with others' products! will push the WASM API idea asap anyway after fixing know issues in my implementation
2025-06-28 15:58 davxy: The fuzzer source code definitely won't be released before the M1 contest is over. As for the binary, honestly, I'm not sure. In theory, it can operate over the network, which might be another way to let the teams play with it independently. However, I'm currently not informed about the actual strategy
2025-06-28 16:04 ascriv: I imagine there will be a lot of work to get implementations passing the fuzzer tests so a binary would help tighten that iteration loop
2025-06-28 16:04 ascriv: Test vectors have been great too though
2025-06-28 16:04 davxy: Here are some details about the protocol used during fuzzy testing:

https://github.com/davxy/jam-stuff/blob/main/fuzz-proto/README.md

I currently have this working with GP 0.6.6 (although the fuzzing engine itself is still being improved).
It appears to be functioning well, but I'm open to suggestions for enhancements. Please feel free to leave any comments or proposals in the repository. [edited]
  ‚Ü≥ 2025-06-28 16:47 oliver.tale-yazdi: Nice, thanks. Will the fuzzer have the PolkaJAM code backed in or can it be used to compare arbitrary implementations?  
I was thinking `fuzzer --impl 0.0.0.0:8080 --impl 0.0.0.0:8081` or something and it would just treat neither of those as canonical and just report differences.  

But the protocol reads like anyone could implement that as well if they wanted
  ‚Ü≥ 2025-06-28 16:48 oliver.tale-yazdi: And would this doc be turned into an JIP or what is the final distribution format? We can also add it to the wiki
  ‚Ü≥ 2025-06-28 16:52 oliver.tale-yazdi: If the PolkaJAM code is not backed in then it could also be open-sourced and freely distributed to the teams for comparison of different binaries [edited]
  ‚Ü≥ 2025-06-28 16:54 oliver.tale-yazdi: Okay i guess that does not really work since the fault injection code should be private...
  ‚Ü≥ 2025-06-28 17:01 davxy: Basically when you start the fuzzer against a target you can specify a `--source` arg.
Currently it can be:

- `local`: polkajam engine (no I've not rewritten the whole onchain logic for the fuzzer ;-) )
- `remote`: some other impl
- `trace`: traces in the filesystem. Same format as the ones in jam-test-vectors.

Only the `local` source is fuzzed using the logic I wrote. Nothing prevents someone to implement their source to be used as `remote` source by the tool. The source must follow the protocol I shared (the fuzzer side in this case) [edited]
  ‚Ü≥ 2025-06-29 07:44 yu2c: Since we've updated our implementation to v0.7.0, we were wondering whether there will be an updated for test vectors( v0.6.7 or v0.7.0) ‚Äî or will it go straight to fuzz testing for the M1 conformance test?
  ‚Ü≥ 2025-06-29 12:04 clearloop: I don't get the remote option, if it is not specified yet? for what I under stand so for:

1. `local` use the unix socket
2. `trace` may accept a folder full of trace tests
3. `remote`: no ideas

perhaps still need one more flag to tell the program if it is testing others or it is being tested [edited]
  ‚Ü≥ 2025-06-29 16:11 clearloop: we just released our 0.6.6 with a command `fuzz` can make `spacejam` a fuzz target, the unix sockets part is not tested yet since currently we don't have the `fuzz` binary, however, the trace command still can be used for processing traces

https://github.com/spacejamapp/specjam/releases/tag/0.6.6 [edited]
  ‚Ü≥ 2025-07-04 16:55 jaymansfield: Hey davxy, what should our implementations do when an invalid block is received by ImportBlock? How should this be communicated back to the fuzzer?
  ‚Ü≥ 2025-07-04 18:13 jaymansfield: Second question/comment relating to the fuzzer. I think I saw it mentioned that the chain spec can be derived from the number of validators present in the state. The problem I see is that is the header is sent first when using SetState, and it requires knowing the chain spec to know how many epoch mark validators are present. The order of arguments in SetState would need to be swapped to send the state first for this to work. [edited]
2025-06-29 12:17 davxy: These fuzzer options define where the fuzzer tool picks blocks to be sent to the target. "remote" indicates that blocks can be taken from a remote source.

That said, these are fuzzer details and aren't particularly relevant to the target itself, which simply communicates with the fuzzer via a Unix socket, as outlined in the draft I shared
2025-06-29 12:22 davxy: Of course, I imagine that the targets currently capable of importing pre-built traces (e.g., test vectors) are also implementing the "trace" source themselves, but that's a separate matter. I was specifically referring to the source from which our fuzzer selects the blocks it sends to the target during a fuzzing session.

2025-06-29 12:30 clearloop: Thanks! I'll try implement the target features atm, and then update when needed
2025-06-29 12:52 boymaas: Thanks for the fuzzing protocol spec davxy - ooo What constants are we fuzzing with, production(341 validators etc) or tiny?
2025-06-29 13:33 davxy: > <@boymaas:matrix.org> Thanks for the fuzzing protocol spec davxy - ooo What constants are we fuzzing with, production(341 validators etc) or tiny?

Good question. Spec "flavor" can be deduced from the validators count in the state we're sending you. Not sure if  worth adding it to the PeerInfo message
2025-06-29 17:14 boymaas: That presents a challenge for JamZig's implementation because the validator count is a compile-time setting in my implementation. I compile binaries based on specified constants using Zigs comptime features. Is a fluid/runtime adaptable validator count and other parameters a strict requirement to pass the conformance tests?
2025-06-29 17:19 clearloop: same, we need big refactor to support customized parameters
2025-06-29 17:31 ascriv: +1
2025-06-29 17:35 boymaas: 
2025-06-29 17:38 ascriv: Inverting serialization is not necessary for making a compliant impl 
2025-06-29 17:41 ascriv: You can do gets and sets and deletes on service account storage for example without having the original key that was used 
2025-06-29 17:43 boymaas: I am curious about how you would initiate the initial storage state. Imagine service X has some storage keys present. How would you deconstruct the actual storage keys used from the initial set state message?
2025-06-29 17:44 davxy: > <@boymaas:matrix.org> That presents a challenge for JamZig's implementation because the validator count is a compile-time setting in my implementation. I compile binaries based on specified constants using Zigs comptime features. Is a fluid/runtime adaptable validator count and other parameters a strict requirement to pass the conformance tests?

no, I don't think so.
You can easily provide 2 binaries. Also I think that we'll start with tiny
2025-06-29 17:45 ascriv: You don‚Äôt have to. get/set/delete operations can do the key construction function themselves and now they‚Äôre operating in ‚Äústate key space‚Äù
2025-06-29 17:45 boymaas: That is a big relief üòÖ
2025-06-29 17:47 boymaas: Just to ensure we're on the same page, I assume the SetState format for State and for example Storage Keys will be as specified here: https://graypaper.fluffylabs.dev/#/9a08063/3bab023bb802?v=0.6.6 [edited]
2025-06-29 17:49 ascriv: > <@boymaas:matrix.org> Just to ensure we're on the same page, I assume the SetState format for Storage Keys will be as specified here: https://graypaper.fluffylabs.dev/#/9a08063/3bab023bb802?v=0.6.6

Yes. So the service storage get function you have implemented already would have to be replaced with one that, given the key, calls C(s,E_4(‚Ä¶)k0‚Ä¶27) to get the state key, then looks in your storage for the value 
2025-06-29 17:50 ascriv: So you never have to invert C(*), which is not invertible anyway 
2025-06-29 17:57 boymaas: I understand your perspective. [edited]
2025-06-29 17:59 ascriv: My implementation does this without custom host calls 
2025-06-29 17:59 ascriv: But I think if I explain further it might break clean room requirements  [edited]
2025-06-30 06:34 clearloop: anybody has an extra discount code for web3 submit üôè

2025-06-30 11:58 emielsebastiaan: Any chance jam-pvm-builder v0.1.23 could be released on crates.io? üôèüèª
https://crates.io/crates/jam-pvm-builder/versions

Context: https://github.com/paritytech/polkajam-releases/releases/tag/v0.1.23 [edited]
2025-07-01 09:37 dakkk: I'm stuck in implementing 0.6.7 / 0.7.0 on jampy, since when constructing the state from the merklerized, I'm unable to determine if a merklerized key is a storage key of a_s or a (key, len) of a_l, in the case that the preimage is not present in a_p.

I've found that someone opened an issue regarding this https://github.com/gavofyork/graypaper/issues/436;

Idk if anyone else is facing the same issue, or if there is a solution that I can't see.
2025-07-01 09:39 gav: > <@dakkk:matrix.org> I'm stuck in implementing 0.6.7 / 0.7.0 on jampy, since when constructing the state from the merklerized, I'm unable to determine if a merklerized key is a storage key of a_s or a (key, len) of a_l, in the case that the preimage is not present in a_p.
> 
> I've found that someone opened an issue regarding this https://github.com/gavofyork/graypaper/issues/436;
> 
> Idk if anyone else is facing the same issue, or if there is a solution that I can't see.

That is intentional. 
2025-07-01 09:39 gav: In general you cannot expect to be able to reconstruct state from the merkle nodes.  [edited]
2025-07-01 09:40 gav: There will be some elements which you can reconstruct, but being able to get everything back is clearly not supported, since there are parts which we hash. 
2025-07-01 09:42 dakkk: I know, I don't want to reconstruct it entirely; I only want to distinguish two different things (keys of a\_l and keys of a\_s); should I put everything in a big container containing both? It's the only way I see, but maybe not so good [edited]
2025-07-01 09:51 gav: Generally, yes.
2025-07-01 09:51 gav: That is the implication, anyway.
2025-07-01 10:01 dakkk: ok, got it; I don't like it, but now I can implement the ability of using traces in 0.7
2025-07-01 10:02 gav: Between convenience and security, we're going to choose security:)
2025-07-01 10:02 prematurata: I am glad I was not the only one noticing it. The proposed solution in my issue above does allow to distinguish all the keys, preserves entropy and removes some compexity compared to current 0.7.0... 

Or am i missing something? 
2025-07-01 10:05 gav: Your suggestion misses the fact that adding a request is permissionless.
2025-07-01 10:05 gav: image.png
2025-07-01 10:05 gav: It's trivial to create a collision.
2025-07-01 10:05 gav: Just request the same hash with a different length.
2025-07-01 10:06 prematurata: thanks i didnt think about that
2025-07-01 10:07 prematurata: I guess it can be fixed by having the key opaque in a_l. but using 254, 253 and 252
2025-07-01 10:07 prematurata: like proposed,
2025-07-01 10:09 prematurata: image.png
2025-07-01 10:09 prematurata: basically this:

2025-07-01 10:13 gav: C doesn't take 3 arguments.
2025-07-01 10:15 prematurata: yeah sorry it was part of my issue above. here would be the modified C
2025-07-01 10:15 prematurata: image.png
2025-07-01 10:15 prematurata: Again, i might be missing something very obvious :)
2025-07-01 10:16 gav: C still only takes 2 args in your image there. [edited]
2025-07-01 10:16 prematurata: image.png
2025-07-01 10:17 prematurata: sorry
2025-07-01 10:19 gav: But anyway, the root of the problem is simple: we are forced to fit more than 31 bytes of information into just 31 bytes of entropy. We need to split it opaquely by service since services are mutually trustless and we don't want one service artificially lengthening another service's keys' merkle paths. Services are 4 bytes, so that only leaves 27 bytes of entropy. This is now at the limit of security; any further opaque data in the key will reduce the effective entropy by which we shield permissionless data (such as lookups) potentially allowing a determined attacker to cause a collision. [edited]
2025-07-01 10:20 gav: Your suggestion removes an additonal byte, turning our 27 bytes of entropy into 26.
2025-07-01 10:20 gav: This reduces the security threshold from the "probably secure for a few years" to the "possibly attackable within a few years"
2025-07-01 10:22 gav: The only real way around this is to handle collisions gracefully. However this will either be a huge amount of work, highly inconvenient to service authors or introduce further insecurities, especially over consensus.
2025-07-01 10:23 gav: This issue with handling collisions is that you need to do something sensible in an exceptional circumstance and in the worst case there may not be a very sensible thing to do other than reversion. And reversion comes with its own issues especially over liveness. [edited]
2025-07-01 10:30 gav: The 26 vs 27 vs 31 vs 32 is admittedly a lot of guesswork and we can only speculate about the amount of resources an attacker may wish to throw at breaking it. However we knew, ~ten years ago, that 20 bytes was on the bounds of security. [edited]
2025-07-01 10:32 gav: There's nothing magical about 32 bytes and we can reasonably expect to lower it *somewhat* and retain practical security, but inevitably the bound of insecurity will have been creeping up from 20 bytes over the years.
2025-07-01 10:36 gav: The degree to which 27 bytes is truly secure against a determined and well-resourced adversary can be argued indefinitely. But what we can say is that reducing from 27 to 26 will make their job a *lot* easier, reducing it by, at face value, over 100x difficulty and turning something which would take a year of concerted effort into a 2 or 3 days.
2025-07-01 10:37 gav: I would not want to compromise to that level on the basis of implementation convenience.
2025-07-01 10:37 dakkk: Won't this be solved by restoring 32 bytes keys (instead of 31)? [edited]
2025-07-01 10:38 gav: That would buy us an extra byte of entropy, but our expectation is that it would cost substantial levels of speed. [edited]
2025-07-01 10:39 gav: 31 byte keys allow us to pack nodes very efficiently into disk blocks.
2025-07-01 10:39 gav: That all gets screwed up with 32 byte keys. [edited]
2025-07-01 10:40 gav: The priorities are:

- Security
- Performance
- Implementation convenience (or, indeed, supporting implementors' flawed protocol assumptions!) [edited]
2025-07-01 10:41 gav: My apologies for not catching this earlier. The hashing should always have been there and then nobody would have written any flawed code. [edited]
2025-07-01 10:46 prematurata: Thanks for the in-depth explanation on the reasoning behind all the values/lengths etc. 

Do you think it's best to close that issue up or keep it open in case someone have a better idea? Maybe i write a summary of what has been said here [edited]
2025-07-01 10:46 dakkk: NP, the main drawback are us arguing about it, and you having to reply üòÑ 
2025-07-01 11:02 ascriv: I think one additional quirk the hashes introduce is now it‚Äôs not as simple to get all storage for a given service index anymore (can‚Äôt use 8-byte prefix search). So e.g. when a service is ejected it‚Äôs not as simple now to go through and make sure all of that service‚Äôs storage is removed from state. Or am I wrong about needing to purge ejected service storage ? [edited]
2025-07-01 11:12 gav: It's trivial because we track the number of items in the account. [edited]
2025-07-01 11:17 ascriv: In the case where an ejected service has a bunch of items though, it‚Äôs not easy to actually find them and remove them from the state, I think 
2025-07-01 11:21 gav: We guarantee that the service cannot be deleted unless it has first deleted its items.
2025-07-01 11:21 gav: Service item enumeration is not a feature of the base JAM protocol. [edited]
2025-07-01 11:22 gav: (I mention it because perhaps you're mistakenly asserting that it is or should be.)
2025-07-01 11:27 ascriv: No, I just missed where we guarantee all items are deleted before deleting the service. Where is that in the gp?
2025-07-01 11:31 gav: See `eject`: 
2025-07-01 11:31 gav: image.png
2025-07-01 11:32 gav: This basically just guarantees that storage is empty and there is only one preimage left (the code, which must be there or there'd have been nothing to `upgrade` to the zombie code. [edited]
2025-07-01 11:33 ascriv: ah i was wondering what that was all about
2025-07-01 11:36 emielsebastiaan: > <@emielsebastiaan:matrix.org> Any chance jam-pvm-builder v0.1.23 could be released on crates.io? üôèüèª
> https://crates.io/crates/jam-pvm-builder/versions
> 
> Context: https://github.com/paritytech/polkajam-releases/releases/tag/v0.1.23

Bumping this üëÜüèª
Q: is a release jam-pvm-builder v0.1.23 an option? Or is it not a priority? 
2025-07-01 11:48 gav: Noted that the latest version is desired. Unfortunately I'm the only one who can make a release and my schedule is not exactly replete with free time. [edited]
2025-07-01 11:51 emielsebastiaan: Np only asking so we can schedule tasks on our end. 
2025-07-01 15:53 decentration: do we know yet how long is the deadline window for M1? when does it open/close. 
2025-07-02 13:00 gav: There's no planned closure. However Later milestone submissions take precedence over earlier ones: if W3F must choose between evaluating an M4 candidate vs an M1 candidate, it will prioritise the M4 candidate.
2025-07-02 20:29 prasad-kumkar: Jan Bujak: From your recompiler talk- if we use `r14` as the base pointer for guest memory, should we exclude it from the guest register mapping set (leaving us with only 12 registers), or is there a way to safely use it for both? Thanks!
  ‚Ü≥ 2025-07-03 03:34 jan: If you're going to use a register for the VM then obviously you can't use it for guest registers.
  ‚Ü≥ 2025-07-03 03:34 jan: I can give you a hint though: you only need one register for the vmctx and the guest memory if you put the vmctx at a *negative* offset to the guest memory.
2025-07-03 11:51 ascriv: @[davxy - ooo] to support the fuzzer, should our implementation be able to reconstruct the full posterior state for all header hashes in history, or just the most recent one?
2025-07-03 13:51 decentration: i see, so priority for higher milestone submission waiting to be evaluated. and i am assuming if a milestone is submitted and evaluated successfully it is safe for winning a prize.  [edited]
2025-07-03 14:30 gav: The prize pool is limited overall, and individual language sets are also limited further. So hypothetically (at least) there could be a situation where two teams are competing over the same prize. 
2025-07-03 14:30 gav: For this reason it‚Äôs important to have a means of prioritizing. 
2025-07-04 18:32 rustybot: > <@jaymansfield:matrix.org> Hey davxy, what should our implementations do when an invalid block is received by ImportBlock? How should this be communicated back to the fuzzer?

on import failure the prior state root should be returned.
2025-07-04 18:37 rustybot: > <@jaymansfield:matrix.org> Second question/comment relating to the fuzzer. I think I saw it mentioned that the chain spec can be derived from the number of validators present in the state. The problem I see is that is the header is sent first when using SetState, and it requires knowing the chain spec to parse the epoch mark validators. The order of arguments in SetState would need to be swapped to send the state first for this to work.

The number of validators in the epoch marker matches the number of validators in the state, so either can be used to infer the spec flavor. That said, I'm open to adding this parameter to PeerInfo if it simplifies things
2025-07-04 18:38 rustybot: > <@ascriv:matrix.org> @[davxy - ooo] to support the fuzzer, should our implementation be able to reconstruct the full posterior state for all header hashes in history, or just the most recent one?

The most recent. This is used only to give you back a report  with state diff. Expected vs actual
2025-07-04 18:42 jaymansfield: Yes it matches, but the header is sent first for SetState,  and without knowing the spec at that point how would you know when to stop reading in validators for the epoch mark? The number of bytes for the header isn't known (just header+state together).  If the state was sent first, it would be easy to derive since the key value lengths can be determined. [edited]
2025-07-04 18:53 ascriv: It seems that for a lot of impls, knowing the flavor is more convenient at compile time, so maybe we can decide on the flavor for the fuzzing and not have to worry about run-time flavor switching? [edited]
2025-07-04 18:54 ascriv: or provide multiple binaries of different flavors which we describe a priori if the fuzzing requires. which I think davxy proposed [edited]
2025-07-04 19:00 rustybot: Of course. I don't think that the spec flavor surprise factor is part of the fuzzing procedure. So you can submit two bins (tiny/full)
2025-07-05 06:07 clearloop: will we have test vectors for work package computation this or next month?
2025-07-05 13:19 oliver.tale-yazdi: Some Qs about this:

- Can Docker images be submitted or does it have to be an executable?
- Just Linux amd64, I assume?
- In the case of requiring a binary, what system libraries can we expect to exist (and what glibc version)? [edited]
2025-07-05 14:24 emielsebastiaan: > <@oliver.tale-yazdi:parity.io> Some Qs about this:
> 
> - Can Docker images be submitted or does it have to be an executable?
> - Just Linux amd64, I assume?
> - In the case of requiring a binary, what system libraries can we expect to exist (and what glibc version)?

Generalized question for delivery of interpreted languages I suppose. Docker would be ideal. Please advise. üôèüèª 
2025-07-05 15:01 clearloop: for interpreted languages running in docker, ain't people can still fetch the source via entering the container? I know typescript can compile javascript into non-human-readable exprs, but what about python, just curious
2025-07-05 19:27 oliver.tale-yazdi: Opened one question issue around the unix socket operation mode https://github.com/davxy/jam-stuff/issues/3
2025-07-05 19:55 davxy: I'm not sure where the official conformance testing process will eventually run (as it will run no-stop for... days? weeks?), but as far as I'm concerned:
- **Docker**: I'm totally fine with you providing a Docker image instead of a plain binary. The key requirement is that the container exposes a Unix domain socket and forwards traffic to your binary inside the container. I haven‚Äôt done this myself, but it should definitely be doable. If you go this route, please make sure everything is set up so that we only need to start the container and point the fuzzer to the socket - I think no additional setup on our side is preferable.
- **Target architecture**: Right now, I believe we‚Äôre targeting `amd64`. Not sure yet if we'll fuzz M1 over other platforms (and if it makes sense). 
- **Binary**: A statically built binary would be very much appreciated. If that‚Äôs not feasible, then the Docker approach becomes even more preferable (compared to getting crazy with dynamic lib deps). [edited]
2025-07-05 19:58 davxy: If Docker is chosen solely to prevent access to the source code of interpreted langs, we'll need to get our hands on the sources anyway :-)
2025-07-06 06:55 ascriv: @[davxy - ooo] are you going to make test vectors for 0.6.7 and then 0.7.0 before we start m1 conformance? Can we please have a rough timeline for these?
2025-07-06 19:55 boymaas: II have created some static builds for you. davxy - ooo In case you would like to test against a target during your development. The STF passed the v0.6.6 test vectors and the v0.6.6 traces. I've added a README.

https://github.com/jamzig/conformance-releases [edited]
  ‚Ü≥ 2025-07-06 20:46 oliver.tale-yazdi: Very cool! I was about to ask if other teams could publish binaries so that we can try our fuzzer. Perfect timing it seems.
  ‚Ü≥ 2025-07-06 20:46 oliver.tale-yazdi: Also looks like it does not like our state root üòÜ
  ‚Ü≥ 2025-07-06 20:46 oliver.tale-yazdi: Screenshot 2025-07-06 at 22.46.47.png
  ‚Ü≥ 2025-07-06 20:47 oliver.tale-yazdi: (nvm, we closed the connection on accident) [edited]
  ‚Ü≥ 2025-07-06 23:08 jaymansfield: > <@oliver.tale-yazdi:parity.io> Very cool! I was about to ask if other teams could publish binaries so that we can try our fuzzer. Perfect timing it seems.

Which GP version is the fuzzer right now?
  ‚Ü≥ 2025-07-07 00:06 clearloop: we have a 0.6.6 release with fuzzer target here, not sure if we can  get matched üëÄ

https://github.com/spacejamapp/specjam/releases/tag/0.6.6
  ‚Ü≥ 2025-07-07 06:21 boymaas: You can't read the message I sent, strange? The Fuzzer target generates some simple blocks: fallback and safrole. The target "targets" version v0.6.6. 
  ‚Ü≥ 2025-07-07 11:08 boymaas: Aah, okay, that explains it. I created the fuzzer solely to test the target, so it generates only simple blocks. And is not hardened.
  ‚Ü≥ 2025-07-08 12:01 prasad-kumkar: Boy Maas | JamZig: Thank yo ufor sharing this. For the blocks where our implementation produces a different state root, I‚Äôm wondering if is there a simpler way to fetch the target state from your binary?
  ‚Ü≥ 2025-07-08 13:23 boymaas: Do you mean that you are the fuzzer and JamZig is the target, or is it the other way around, where you are using the JamZig fuzzer against your implemenation as the target? I wrote in the README that the fuzzer is only for simple testing, it uses some random generated blocks.

If there is interest I can add a state dump on the JamZig's fuzzer side, which displays the differences which led to the difference in StateRoot. I believe Oliver Tale-Yazdi was also requesting this.
  ‚Ü≥ 2025-07-08 13:30 oliver.tale-yazdi: Yea would be helpful to have a "Why did it fail"-diff.  

GrayMatter also supports both fuzzing and target, so we can also do it on our side, but it will find different issues since our fault injection code will be different form the JamZig fuzzer
  ‚Ü≥ 2025-07-08 13:41 boymaas: Okay, let me add it.
  ‚Ü≥ 2025-07-08 18:27 prasad-kumkar: Yeah kind of both. Currently we are using JamZig fuzzer against our impl - for cases where we get a mismatch, it'd be super helpful to fetch JamZig target's transitioned state for the same block to compare [if not too complicated ofcourse]

I'm trying this in the meanwhile - to have a script targeting our impl with Jamzig fuzzer, save the blocks+state just before mismatch, replay them on JamZig's target and call GET_STATE, and compare this with our state. I will share if this works, but I guess there could be better ways
  ‚Ü≥ 2025-07-08 18:47 boymaas: image.png
  ‚Ü≥ 2025-07-08 18:47 boymaas: Just added this; I will upload a new version later.
  ‚Ü≥ 2025-07-08 18:55 boymaas: https://github.com/jamzig/conformance-releases/tree/main/releases/202507082050_c20074d
  ‚Ü≥ 2025-07-08 18:56 boymaas: This output will be generated on the fuzzer side once it detects a state root mismatch.
2025-07-07 06:58 dakkk: Does the fuzzer protocol uses asn.1? I see asn.1 syntax, but asn.1 is not mentioned in the README
2025-07-07 07:02 ascriv: The serialization/deserialization is as in the GP 
2025-07-07 07:08 dakkk: The "Message" choice, how should be serialized? Like the optional value in the gp with more than two values?
2025-07-07 07:14 ascriv: Like the 0-6 or whatever it was? It‚Äôs a byte 
2025-07-07 07:14 ascriv: After the length, iirc. I‚Äôm not at my laptop though 
2025-07-07 07:15 dakkk: ok
2025-07-07 07:41 ascriv: yeah looking at https://github.com/davxy/jam-stuff/blob/main/fuzz-proto/README.md again actually it doesn't explicitly say the enum value is the byte after the 4 bytes for the message length, but that seems to be the case. the 2 encoding examples are evidence of this (they use enum values 0 and 5 correctly). @[davxy - ooo] to confirm for sure though
2025-07-07 09:04 alice_und_bob: image.png
2025-07-07 09:04 alice_und_bob: any suggestions on what dates I should push CoreChains and CorePlay back to?
2025-07-07 09:04 alice_und_bob: and what is the latest in regards to XCMP? Is it still roadmap relevant or did plans here change?
2025-07-07 11:11 gav: > <@alice_und_bob:matrix.org> any suggestions on what dates I should push CoreChains and CorePlay back to?

From my perspective, CorePlay is still in ideation & research and has an open timeline. 
2025-07-07 11:12 gav: For CoreChains, prototyping can performance testing can begin, though it is not a priority for me or the PolkaJam team. 
2025-07-07 11:14 gav: I understand Basti had started some initial work here. 
2025-07-07 11:15 gav: XCMP is a Polkadot-1, parachains specific protocol. It is unclear to what extent it will be implemented with CoreChains. 
2025-07-07 11:16 gav: Hyperbridge may be enough. Or perhaps there will be a more general JAM-wide inter-service message passing protocol.  [edited]
2025-07-07 11:17 gav: This is all dependent on CoreChains successfully being able to replace the Relay-chain. 
2025-07-07 11:17 gav: That is presently speculative. 
2025-07-08 15:24 alice_und_bob: Thx for the detailed response gav!
2025-07-08 19:23 davxy: [@boymaas:matrix.org](https://matrix.to/#/@boymaas:matrix.org)    I haven't had a chance to try it yet, but I definitely will once I'm back (together with our fuzzer).

A few questions in the meantime:

- Are you using the fuzzer protocol I proposed?
- (maybe) would be nice to formalize a bit the final report (on mismatch) form. I can integrate it directly into the fuzzer spec. Our report is similar to the one you proposed anyway. 
- What functionalities does your fuzzer exercise? For example:  
  - Does it only generate "valid" blocks, or also try to trigger faults?  
  - Does it include blocks with safrole vs fallback, or a mix of both?  
  - Does it exercise some host functions as well?
- Which GP version are you currently targeting?

Edit: I'm particularly interested in the techniques you used to generate blocks, especially faulty ones (if your fuzzer produces any). The same questions apply to anyone including a fuzzer source in their binaries. [edited]
2025-07-08 19:46 danicuki: Hey all! I have a question about CE 133: Work-package submission

- Why the builder needs to send the core info? 
- Why not sending just the work package? 
- what if the core sent is not the core that the receiver guarantor belongs to? Should the guarantor reject the package? 
- If builder needs to know the core each validator belongs to, it should inspect the chain state, right? 
2025-07-09 06:44 boymaas: Great questions! Targeting GP v0.6.6:

**Fuzzer Protocol**: Yes, the binary conforms to the fuzzer protocol you proposed - it was developed to support jamzig's fuzz target, though not as the main development effort. I could put a bit more energy in it.

**Report Format**: Formalizing the mismatch report format would be valuable for integration into the fuzzer spec.

**Functionality**:
‚Ä¢ Only generates "valid" blocks that can be imported (no fault triggering)
‚Ä¢ Includes both safrole and fallback blocks
‚Ä¢ No host function exercising
‚Ä¢ Targeting GP v0.6.6

**Block Generation**: Straightforward generation of importable blocks only - no sophisticated techniques for faulty blocks since the fuzzer was only implemented to help test the fuzzing protocol on the target. [edited]
2025-07-09 06:55 boymaas: 
2025-07-09 06:57 boymaas: One thing I added to the target and fuzzer parameters is the ability to dump the actual constants used to build the binary. This could be handy for debugging and might be worth formalizing in the spec.
2025-07-09 10:08 dakkk: I also wrote a fuzzer-target on jampy following davxy spec, and compiled it for gp 0.6.6, 0.6.7 and 0.7.0
2025-07-09 14:50 dakkk: Boy Maas | JamZig: I'm trying your fuzzer against my target, but I'm receiving blocks where an empty extrinsic has an hash full of zeros; I think this is wrong [edited]
  ‚Ü≥ 2025-07-09 15:33 vinsystems: I get the same error, my target raise a "bad extrinsic hash" error. Also, if I ignore this error and continue with the block check I also get a "seal verify failure".
  ‚Ü≥ 2025-07-09 15:33 dakkk: same on both
  ‚Ü≥ 2025-07-09 16:25 boymaas: That seems to be a successful fuzzing session as I indeed generate blocks with a "bad extrinsic hash". The fuzzing appears to be effective.
  ‚Ü≥ 2025-07-09 16:26 dakkk: so we have to send back the same state, right?
  ‚Ü≥ 2025-07-09 16:28 boymaas: Good question. We should follow the protocol. What does it instruct us to do in this scenario? I believe this is not described yet. [edited]
  ‚Ü≥ 2025-07-09 16:30 boymaas: I believe this indicates that the target refused to process the block. So that could work.
  ‚Ü≥ 2025-07-09 17:10 vinsystems: After a bad extrinsic hash error I send back the same state root that I had before, but the fuzzer appears to have an updated state root.  [edited]
  ‚Ü≥ 2025-07-09 17:13 vinsystems: I also think that the fuzzer may not be reading the full state properly when it is requested to me through the GetState request. When it shows to me the differences, I see that the first one has a byte which is the number (15) of key-values of the full state.  [edited]
  ‚Ü≥ 2025-07-09 17:14 vinsystems: image.png
  ‚Ü≥ 2025-07-09 18:03 boymaas: I have not yet implemented the case with the same root. This was not included in the protocol description.I never intended for anyone other than me to use the fuzzer. üòÖ 

Let me add that when a target sends the same root, the fuzzer interprets the target encountered some kind of import error.

Could you send me the state you are sending, or your target binary, so I can develop further based on that? I am on linux-aarch64. Prefer the binary.
 [edited]
  ‚Ü≥ 2025-07-09 19:30 vinsystems: Sure, here is my target binary for linux-aarch64 https://github.com/bloppan/conformance_testing
  ‚Ü≥ 2025-07-10 05:27 boymaas: Bernar | Vinwolf: I believe you accidentally sent me the wrong file. 

vinwolf: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=1d84327094cbade1a61ec09270fb016823ea98ef, not stripped
  ‚Ü≥ 2025-07-10 08:13 vinsystems: yeah sorry, I updated the repo with the correct one, let me know if you can execute it properly
  ‚Ü≥ 2025-07-10 08:32 boymaas: Thanks Bernar | Vinwolf I can execute it properly. Will update the fuzzer
  ‚Ü≥ 2025-07-10 09:03 dakkk: these are mine: https://github.com/dakk/jampy-releases/tree/main/dist
  ‚Ü≥ 2025-07-10 14:06 vinsystems: Is your fuzzer running as a server? My target is running as a server because the protocol says that "the fuzzer always initiates requests". Therefore, in my opinion, it is the target that should run as a server, since it has to wait for the first request from the fuzzer. [edited]
  ‚Ü≥ 2025-07-10 14:07 dakkk: the link I posted contains a fuzzer-target and my fuzzer-target is running as a server
  ‚Ü≥ 2025-07-10 14:12 vinsystems: ah ok, I thought it was running as fuzzer (producing blocks) 
  ‚Ü≥ 2025-07-11 09:16 dakkk: image.png
  ‚Ü≥ 2025-07-11 09:17 dakkk: I'm also writing a fuzzer, it works against my target but it only creates empty blocks for now
  ‚Ü≥ 2025-07-11 09:55 boymaas: Nice looks awesome. üî•
  ‚Ü≥ 2025-07-12 07:36 boymaas: https://github.com/jamzig/conformance-releases An update for v0.6.6: I tried to fuzz yours with one and ran into this issue.

```
2025-07-12 07:31:40,134 DEBUG chainstate ‚è© Processing block: 0x011de566b887c216d17bb79904b176d8ad459a30abd1e381a9193a84ba1392d6

thread '<unnamed>' panicked at src/lib.rs:43:41:
called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Traceback (most recent call last):
  File "jampy/fuzzer.py", line 164, in <module>
  File "jampy/fuzzer.py", line 160, in target
  File "jampy/fuzzer.py", line 130, in _target
  File "jampy/fuzzer.py", line 71, in handle_connection
  File "jampy/chainstate.py", line 365, in process_block
  File "jampy/safrole/safrole.py", line 417, in next
  File "jampy/crypto/vrf.py", line 97, in __init__
pyo3_runtime.PanicException: called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }
[PYI-1:ERROR] Failed to execute script 'fuzzer' due to unhandled exception!
Jampy fuzzer target is listening on /app/jc.sock
New connection: fd=4
Received: PeerInfo
Received peer info: PeerInfo(jamzig-fuzzer, version=0.1.0, jam_version=0.6.6)
Sent: PeerInfo
Received: SetState
Sent: StateRoot
Received: ImportBlock
```
HandShake is OK, SetState is OK, and the initial roots match after SetState. However, an error occurs when importing the first block.
  ‚Ü≥ 2025-07-12 07:38 dakkk: Mh It Is missing the files needed by the rust wrapper; I Will have a look 
  ‚Ü≥ 2025-07-12 07:43 boymaas: Bernar | Vinwolf: I attempted to run yours, but we are not aligned on the block seal on the first block. It appears we have a protocol mismatch regarding the sending and receiving of the state. When I send, you receive correctly, and we build the same state root. However, when I run GetState and you send your state our protocols are not in sync. [edited]
  ‚Ü≥ 2025-07-12 11:19 dakkk: I fixed my target, and released the fuzzer (empty blocks) [edited]
  ‚Ü≥ 2025-07-12 16:50 boymaas: dakkk | JamPy: The protocol is functioning, but the JamPy target is failing on the seal signature. However, after this failure I do receive the correct state. So with the JamPy implementation, the JamZig fuzzer gets a working GetState, and I obtain the correct key values and can produce a good state diff. [edited]
  ‚Ü≥ 2025-07-13 10:53 boymaas: Just pushed a cleaned up version: https://github.com/jamzig/conformance-releases [edited]
  ‚Ü≥ 2025-07-13 11:20 boymaas: Bernar | Vinwolf:  https://asciinema.org/a/rZfU3E9kqfC3hCeU0vaPioVjD almost there.
  ‚Ü≥ 2025-07-14 11:33 boymaas: Hi Bernar | Vinwolf , could you check why our protocols are mismatched? At random points, when I run the official traces, against the Vinwolf target it stops unexpectedly. Is this an issue on my side or yours? When I run it against my target, it always works.


  ‚Ü≥ 2025-07-14 12:15 qiwei: hi Boy Maas | JamZig , Boka target matches with jamzig fuzzer when using --trace-dir, can pass all traces
  ‚Ü≥ 2025-07-14 12:18 vinsystems: image.png
  ‚Ü≥ 2025-07-14 12:18 vinsystems: yes, there was an issue on my side, now I can pass all traces as well, I've updated my vinwolf_target binary Boy Maas | JamZig. My GetState response is not fixed yet [edited]
  ‚Ü≥ 2025-07-14 12:40 boymaas: Nice! That makes sense. Let me try this as well.
  ‚Ü≥ 2025-07-14 12:41 boymaas: Cool, the fuzz protocol seems to be working! Now we need to initiate some real fuzzing. 
  ‚Ü≥ 2025-07-20 12:20 oliver.tale-yazdi: Yes the `--trace-dir` is quite useful. GrayMatter can pass Fallback and Safrole tests in this manner.  
We are debugging our authoring logic to maybe also get JamZig to import our blocks
  ‚Ü≥ 2025-07-20 12:22 boymaas: Great to hear that it's useful. I added it to provide some "objective" fuzzing, ensuring that our protocol implementations function correctly before we proceed with implementing our own fuzzers.
2025-07-09 17:09 vinsystems: 
2025-07-10 07:44 clearloop: If there is any guide on error handling of the network protocol?

we can work with polkjam nodes for days locally without any bugs, however once put them on a remote server, would be easy to run into a stale status, after checking the logs from polkajam side, I can see there is a lot of `max ack delay reached` emitted without obvious error logs, results in polkajam nodes won't request the newly authored blocks broadcasted by spacejam

PS: polkajam & polkajam nodes are working together perfectly ))

EDITED: seems it is mixed with an issue that we are not handling forks of forks properly, will give it another try anyway [edited]
  ‚Ü≥ 2025-07-10 13:28 dave: Not sure what you mean by error handling exactly. In general if there is an error on a particular stream you should close that stream but _not_ the connection (for example, if there is a timeout, or a request is made that you cannot respond to). In the case of a failed request, you probably want to try making the request again but to a different peer. There will likely be guidance eventually on how to deal with misbehaving peers, how to rate limit requests etc, as for this stuff to work well implementations will probably need to be somewhat consistent. There will almost certainly still be scope for implementations to have their own strategies though.

FWIW currently PolkaJam is too unforgiving about misbehaviour/timeouts. There are changes in the works to improve this. With a good network this shouldn't really be a problem though.
  ‚Ü≥ 2025-07-10 20:12 clearloop: > In general if there is an error on a particular stream you should close that stream but not the connection (for example, if there is a timeout, or a request is made that you cannot respond to).

Thanks! this helps, can confirm we have diff on this and explain why some behaviors are out of my exception

> Not sure what you mean by error handling exactly. 

sorry for the misunderstanding, it's pretty like the case you just pointed out, also, I'm curious about on closing/resetting streams, if different error code should trigger different behaviors, for example, error code 0, do nothing, error code N, reset streams and try re-connecting, etc.
  ‚Ü≥ 2025-07-11 00:08 dave: Currently stream/connection error codes have no prescribed meaning. At some point we may define some standard error codes, to make mixed-implementation debugging easier at least.
2025-07-10 07:47 vinsystems: 
2025-07-11 22:06 boymaas: 
2025-07-12 06:48 emielsebastiaan: I have a few questions regarding the Polkadot (and Kusama) implementation of JAM, particularly in the context of on-chain governance:

1. Will the Polkadot/JAM instance feature a more tailored bootstrap service? Specifically, the current bootstrap service exposes a wide range of (host) functions, and Polkadot may need more granular access control for these.
2. Related to this, in a 2024 interview, Gav mentioned the idea of enshrining DOT supply and issuance into the Polkadot/JAM system. The goal would be to remove this functionality from on-chain governance processes, thereby increasing the friction required for changes‚Äîessentially limiting control over DOT issuance to the hard fork mechanism of Polkadot/JAM. Are there any preliminary ideas or approaches for how this might be implemented?
3. More broadly, how will governance be structured between Polkadot and JAM? What will the relationship look like between Polkadot Governance and JAM Governance?
2025-07-12 08:38 xlchen: this is just my interpretation which could totally be wrong‚Ä®1: the current service is for development only and a real one will be created later after GP 1.0 is out and service sdk is relatively stable‚Ä®2: if we bake issuance logic into GP, then it cannot be modified unless GP is updated. And JAM is not designed to be upgradable, so the only way is to hardfork. but keep in mind, this only concerns about DOT issuance on JAM chain.‚Ä®3: the fellowship will take overseeing position of JAM chain. but because JAM don‚Äôt have any modifiable parameters, there isn‚Äôt much to govern. other core functionality such as staking, coretime etc are going to be implemented on a system parachain (or some system service) which the usual polkadot governance process applies [edited]
2025-07-12 08:49 ascriv: Even though jam isn‚Äôt designed to be upgraded, there will still be upgrades, albeit not very frequently. Is there no way around relying on hard forks/social consensus for this? 
2025-07-12 08:55 xlchen: other than critical bugs, I cannot think of any reason to upgrade. note that features like staking, coretime, governance etc are not part of JAM, they are implemented in services, which are upgradable
2025-07-12 09:00 ascriv: I think it‚Äôs risky to presume jam shouldn‚Äôt need to change much, considering we aspire to have this system persist for decades or longer. In the long term it seems inevitable that there will be contention and community splits etc if we rely on hard forks, just not as badly as other ecosystems perhaps because most of the core functionality is delegated to services 
2025-07-12 09:02 ascriv: Which is fine, maybe, consider the benefits of having jam not ‚Äúneed‚Äù to be upgraded
2025-07-12 09:03 xlchen: the point is that JAM doesn‚Äôt need upgrades. besides, hardfork JAM chain can be pretty transparent to the services 
2025-07-12 09:04 xlchen: we are going to have a trial run upgrading current relaychain to JAM chain
2025-07-12 09:09 ascriv: How can we prevent the outcome where a consortium of services desire not to upgrade with the rest of the services? Or should we rely on network effects such that any cecession is economically disincentivized? 
2025-07-12 09:10 ascriv: Or that an upgrade is so clearly better that rejection is irrational?
2025-07-12 09:12 xlchen: it is kinda similar (but still very different) to some eth contracts may not want certain eth upgrades. how do people prevent it?
2025-07-12 09:37 dakkk: 
2025-07-12 10:53 gav: 1. Parity's Bootstrap service will likely mature over the coming months and become more feature complete and with a better documented Work Item/Memo format. Like PCs and the plethora of BIOS software, there will likely be other Bootstrap implementations. Each could quite possibly follow a subset or superset of the Parity Bootstrap service's Work Item/Memo format.
2. I continue to believe this a sensible direction and intend to propose a model for this in the not too distant future. I have previously considered œÄ10^9 and I think it a reasonable, memorable and elegant number. The JAM protocol is agnostic to economic policy but is capable (hard-forks notwithstanding) of constraining the supply arbitrarily. We would simply create a JAM genesis block with an appropriately limited amount of DOT tokens. In the simplest imagining of this, there would be a single Bootstrap service and it would contain all œÄ10^9 tokens; these would in turn be passed into whatever service(s) record existing balances and/or are empowered with minting any as yet unminted tokens (e.g. the Staking and overall governance services).
3. Any particular version of the JAM protocol shall be defined as the contents of some Gray Paper version. The latest JAM protocol will be the latest Gray Paper version. Some versions will be noted as externally audited and thus production grade. Polkadot, via its governance, can decide its base protocol in terms of a JAM version. Other networks could do the same. I intend to remain editor-in-chief of the Gray Paper for the foreseeable future. However I also intend to institute a Gray Paper Editorial Board to help devise and oversee specific changes to the Gray Paper and to deliberate and determine longer-term protocol priorities. In case I am or become unavailable, this Editorial Board would be the de facto governance for the JAM protocol. If Polkadot Governance (expressed, most likely, through the Polkadot (Core) Fellowship) disliked the GPEB's direction, it would of course have the sovereignty to hard-fork into some other protocol, potentially forking the GP into some other paper (and colourü§≠). I intend, after proper consideration and after version 1.0, to place the Gray Paper under some public licence allowing for forking under proper conditions, likely a copyleft licence with patent provisions/protections. As long as Polkadot continues its intention to base itself on JAM, then I expect Polkadot Treasury to contribute materially to the maintenance funding for the GPEB, helping support its meetings and deliberations. If other protocols make use of JAM I would invite and expect them to contribute similarly. Initially I will seed the Editorial Board with those I consider the most capable and useful contributors. Deep and excellent technical involvement with a JAM implementation will be an expectation (though probably not an absolute requirement). In time, and while I am still active Editor-in-Chief, I expect to announce one or more deputies and devolve the duty of selecting, inviting and deciding on the members of the Board to others, probably the Board itself, any deputies and perhaps external bodies such as Polkadot's (Core) Fellowship, the Web3 Foundation Research team and others. [edited]
2025-07-12 11:03 gav: I would expect any JAM protocol updates to retain support for the existing JAM service API.
2025-07-12 14:47 dvdplas: Hello JAM Implementors DAO, 

I'm reaching out to you regarding our Pop CLI proposal: https://polkadot.polkassembly.io/referenda/1619

I have replied to JAM DAO's comment and hope to have resolved your concerns. The comments describe the DAO would like to see a CLI tool that improves onboarding and general developer experience. This is exactly what the Pop CLI tool does and it is the only tool in the ecosystem at the moment.

I am more than happy to answer any other questions or resolve any other concerns that the JAM DAO has.

The votes have, at the last moment, shifted to NAY. We would really appreciate if you could reassess your vote.

Thanks in advance.

Daan | R0GUE
2025-07-13 12:05 krystian50: Hello! At FluffyLabs we've been working on a JAM Search app. An app to search through all the JAM related knowledge. We opened a discussion for retroactive funding for this tool. Any comments are welcome! 

Discussion: https://polkadot.polkassembly.io/post/3296

App: https://search.fluffylabs.dev
2025-07-13 12:10 emielsebastiaan: IMO we should try to keep this channel free from treasury funding discussions and free from JAM Implementers DAO discussions. 
2025-07-13 12:17 gav: Sounds sensible. 
2025-07-15 17:19 carpathiancoder: üëã any problem in changing the email commited in git? I used a wrong one for like 5 commits and I would like it corrected...which means I need to do a rebase or something... I can leave it as is tho.. [edited]
2025-07-15 17:26 vinsystems: 
2025-07-16 05:37 sourabhniyogi: We have a working recompiler getting > 10 FPS on Doom now  (> 20 FPS if we don't do any gas checks/charging) -- yay!

The results between different x86 machines vary widely though (one machine gets 5FPS, the other 10 FPS, etc.) so we're wondering how we can do meaningful apples-to-apples comparisons and know where we stand relative to whatever you've achieved on Doom with respect to 50%/100% performance.

Using an extra ecalli call per basic block _temporarily_ added for analytics, we collected data to answer "how many x86 instructions were used in executing XYZ PVM instruction" in a run of doom -- measuring over many exported frames (>2T gas).  Thankfully, the top 15 PVM instructions (ADD_64, SHLO_L_IMM_64, LOAD_IMM_JUMP_IND,  LOAD_IND_U64... ) ended up with >85-90% of x86 instructions executed.   While like half of these 15 are optimizable (in that we will proceed to eliminate push/pop/movs/...), the other half are not (being 1 already.. or 2-3 irreducible).  The raw data cannot support a 6x improvement -- if we magically mapped every PVM instruction to just 1 X86 instruction, we'd only get a 4.75x gain.  So we're puzzled how you can suggest 60 fps.

While we can of course optimize relative to X machine, we appear to need to talk hardware specs to make fair apples-to-apples comparisons.  While the Toaster would solve this, it seems reasonable to do this outside by counting (or estimating) how many x86 instructions were executed per frame on average or in aggregate (or something similar, like, average # of x86 instructions per basic block, # of basic blocks)... or just move onto more "real" benchmarks.  Do you have DOOM statistics like this or some "real" benchmarks to share? 
 
  ‚Ü≥ 2025-07-16 05:54 jan: The harware specs should be irrelevant here; you should be able to run DOOM at 60+ FPS on virtually any machine.

Most PVM instructions should result in only a couple of native instructions. If you need to use `push`/`pop` then you're most likely doing something wrong - essentially only at most three types of instructions should even necessitate the need to push anything to the stack - division and remainder, upper multiplication instructions, and _maybe_ indirect jump instruction. All of the rest of the instructions should have no pushes/pops.

To give you an example: the `add_64` instruction should be recompiled either to a) a `mov` followed by `add` (when the destination register is different than both source registers), or b) a single `add` instruction (when the destination register is equal to either of the source registers).

Also, note that the instruction counts don't necessarily correlate linearly with performance; certain instructions are more expensive than others. [edited]
  ‚Ü≥ 2025-07-16 10:09 sourabhniyogi: Thank you so much for the guidance -- we will proceed to eliminate all the  push/pop/movs/... we can and report back summary stats!
  ‚Ü≥ 2025-07-21 00:02 sourabhniyogi: Jan Bujak: We finally realized our way of running Doom for 1000 frames with our recompiler [here](https://github.com/colorfulnotion/polkavm/blob/0.6.5.3/services/doom/src/main.rs#L61-L126) _within_ a `refine` operation of a service (that does what you do **outside** [here](https://github.com/paritytech/polkavm/blob/master/examples/doom/src/main.rs#L143-L145)) is very unlikely to be an apples-to-apples comparison... and adds a considerable amount of overhead the way we do it.

We believe we should do apples-to-apples comparisons in a tiny 6-node jam testnet with "pvm-backend" set to "compiler" for exact "Doom" work packages between polkajam and our (and other)  implementations, comparing refine executions.

How can we get the first 5 work packages of { doom, quake } into a jam testnet with jamt (or the repl or something else still)?

In the absence of the above, we developed a set of "numerical recipes in C" battery of like 150 simple algorithms to generate what we think of as is a controlled set of work packages (but without any of Doom/Quake's "ext\_initialize/ext\_tick" IO sexiness).  However, we need to get in sync on versions though -- to compare recompiler execution times on the exact same work on the exact same machine (or identical hardware on 6 different ones).   Can you advise when polkajam will move from 0.6.6 to 0.6.7 or 0.7.0 so we can do our 3-guarantor compiler comparison on this "numerical recipes in refine" work packages battery (or better: Doom/Quake)?

What does it mean when Polkajam shows a refine \[PVM\] execution time exactly when pvm-backend is "compiler"? [edited]
  ‚Ü≥ 2025-07-21 00:04 sourabhniyogi: image.png
  ‚Ü≥ 2025-07-21 00:04 sourabhniyogi: Above is our week's optimization on the top 90% of actual PVM instruction execution for 1000 frames.  Is this permissible to share? [edited]
2025-07-16 08:26 danicuki: We are going to have a JAM nodespace today at Web3Summit Berlin. Join the JAM builders from 12pm til 2pm at the nodespace 3. 
2025-07-16 09:13 clearloop: We'll have one introducing the status of spacejam and related rust tools tmr 2pm at nodespace 1, the topic is open, feel free to DM me that I can prepare more context
2025-07-16 20:18 tomusdrw: Is the source code for the service being accumulated in test vectors (`stf/accumulate`; latest master of `w3f/jamtestvectors` aka 0.6.6) available somewhere? It seems the `test-service` link from README doesn't work any more and there is no JAM-SDK service in the repo any more. [edited]
2025-07-16 20:29 davxy: > <@tomusdrw:matrix.org> Is the code for the service being accumulated in test vectors (`stf/accumulate`; latest master of `w3f/jamtestvectors` aka 0.6.6) available somewhere? It seems the `test-service` link from README doesn't work any more and there is no JAM-SDK service in the repo any more.

It was removed because it's using jam-pvm-common 0.1.23, which is the version compatible with GP 0.6.6 and not yet published on crates.io.
If you think it's useful, I can reintroduce it, but it won't build until the new crates are published.
2025-07-16 20:46 tomusdrw: I see. I was trying to look for some more debug info in the service itself to figure out what it's doing since it seems unhappy with my constants and/or operands encoding, that I feel is matching the GP, hence asking. But I feel what you are saying is that there are no significant changes to the service code and it's just the `jam-pvm-common` version that's different, right? 
2025-07-16 22:11 clearloop: We have [a fork of jam-pvm-common](https://github.com/spacejamapp/jade/blob/main/polkajam/jam-types/src/types.rs#L307) aligns to pvm at `0.6.6`, the data structure of `AccumulateItem` and the `fetch` call in the accumulate could be root case ...

btw we now support [local testing](https://github.com/spacejamapp/jade/blob/main/services/simple-token-service/src/tests.rs) for the accumulate interface, it's a fast impl atm, things could be better in next month )) [edited]
2025-07-21 13:23 aang114: image.png
2025-07-21 13:23 aang114: @boymaas:matrix.org: Hi, we ran JamZig‚Äôs fuzzer with Tiny Config (https://github.com/jamzig/conformance-releases/) against the GP 0.6.6 fuzzer-target implementation of our JAM client. It fails after processing the first block and the only difference is the authorizer-pool state component (i.e the state key 01000000000000000000000000000000000000000000000000000000000000). As you can see in the screenshot, the fuzzer‚Äôs authorizer-pool was still empty for the 2 cores (i.e 0000). While in our implementation, it had added an item to each of the 2 cores (therefore becoming 010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000). 

Surprisingly, if we disable updating the authorizer-pool state component when processing a block, we are able successfully process all the blocks of the fuzzer.

Therefore, could this be an oversight in the processing of the authorizer-pool state component in the fuzzer? Thanks [edited]
  ‚Ü≥ 2025-07-21 14:54 oliver.tale-yazdi: I actually hit the same thing yesterday but did not check yet which is correct 
  ‚Ü≥ 2025-07-21 14:54 oliver.tale-yazdi: Screenshot 2025-07-21 at 16.54.25.png
  ‚Ü≥ 2025-07-23 06:52 boymaas: aang114 | Gossamer | CS:  That is a very interesting find. I will look into it! If you run with --trace-dir, do you pass everything?
  ‚Ü≥ 2025-07-23 12:17 aang114: It passes all the 100 blocks when I do `--trace-dir <safrole trace folder>` and `--trace-dir <fallback trace folder>`.

However, it fails on the 5th and 3rd block respectively when I do `--trace dir <reports-l0 trace folder>` and `--trace-dir \<reports-l1 trace folder>`. What's interesting in our local tests everything passes (including the reports-l0 trace folder and the reports-l1 trace folder).

So I'm honestly not sure what's going on here. Does the JamZig fuzzer compare our local state-root against JamZig's calculated state-root or the state-root in the JSON trace files? [edited]
  ‚Ü≥ 2025-07-23 12:20 aang114: image.png
  ‚Ü≥ 2025-07-23 12:21 aang114: image.png
  ‚Ü≥ 2025-07-23 12:22 aang114: the two screenshots above are from `--trace dir <reports-l0 trace folder>` and `--trace dir <reports-l1 trace folder>` respectively
  ‚Ü≥ 2025-07-23 21:04 boymaas: It compares the state root in the JSON files. Therefore, the Local State root is <unavailable>. Multiple teams can successfully import the --trace-dir using the official vectors. Assuming JamZig and the other teams can successfully import those via the fuzzer using --trace-dir, and your local tests are passing, my guess is that something might go wrong in the protocol or in the state reconstruction from the keyvals. 
  ‚Ü≥ 2025-07-25 09:21 boymaas: aang114 | Gossamer | CS Oliver Tale-Yazdi : 

Just released a new version: https://github.com/jamzig/conformance-releases 

Fuzzer genesis state now begins with authentication queues filled with 0x0 which should match your expected output.
  ‚Ü≥ 2025-07-26 17:05 oliver.tale-yazdi: GrayMatter passes it now, thanks
  ‚Ü≥ 2025-07-27 15:31 oliver.tale-yazdi: Boy Maas: do you have an idea why this would happen? It is on the first block, and the block references the genesis header.
  ‚Ü≥ 2025-07-27 15:31 oliver.tale-yazdi: Screenshot 2025-07-27 at 17.31.21.png
  ‚Ü≥ 2025-07-27 17:14 oliver.tale-yazdi: Boy Maas: GrayMatter rejects block with slot 248 when importing tiny blocks from `./jam_conformance_fuzzer -b 1000 --seed 1753635650` with this `ticket useless` error which corresponds to this condition, can you please check whether your authoring logic might include useless tickets in the extrinsic? https://graypaper.fluffylabs.dev/#/9a08063/0f8f010f9a01?v=0.6.6 [edited]
  ‚Ü≥ 2025-07-28 16:31 vinsystems: Hi Boy Maas: Could you please check if the fuzzer is applying the condition `i = Ha` [from Eq. 6.16](https://graypaper.fluffylabs.dev/#/1c979cb/0e77010e7801?v=0.7.1)?
If I ignore this condition, I match the state root result from all the fuzzed blocks (around 7,000 so far). I updated the vinwolf-target binaries in [my repo](https://github.com/bloppan/conformance_testing) [edited]
  ‚Ü≥ 2025-07-29 13:21 aang114: > Just released a new version: https://github.com/jamzig/conformance-releases
> 
> Fuzzer genesis state now begins with authentication queues filled with 0x0 which should match your expected output.


Boy Maas | JamZig: Gossamer-Jam passes it now as well. Thanks 
2025-07-21 18:54 emielsebastiaan: What‚Äôs the plan for JAM and Kusama?

With Referendum 682, Polkadot governance signaled support for a future where the Polkadot relay chain is replaced by JAM. (https://polkadot.polkassembly.io/referenda/682)

In the JAM Implementers‚Äô Prize, milestone 3 refers to achieving ‚ÄúKusama performance‚Äù‚Äîwhich, if memory serves, has informally been described as around 50% of Polkadot‚Äôs performance (though I‚Äôm not sure who first coined that or where it was stated).

However, as far as I can tell, there‚Äôs been no explicit discussion‚Äîlet alone a referendum‚Äîabout what happens to the Kusama relay chain with regard to JAM. Unlike Polkadot, Kusama has not had a 682-style governance decision to define its path in a JAM future.

Personally, I‚Äôve always assumed we‚Äôd see a first JAM instance for Kusama, followed by a second for Polkadot‚Äîeach fully sovereign, each with its own independent validator set.

Of course, this ultimately falls to Kusama OpenGov to decide, nevertheless what are the possible paths forward for Kusama?

1. A fully sovereign Kusama/JAM chain with its own validator set. 
2. Kusama has a separate ParachainsService (or similar) on Polkadot/JAM (inspired by Oliver‚Äôs post: https://x.com/olivertaleyazdi/status/1947043501268455559?s=46&t=ThX7Y87rr1MIKyk6af4OXg)
3. Some eventual hybrid arrangement as part of the JAM Grid
4. Or something wild‚Äîbeyond what I can currently imagine

I‚Äôd love to hear ideas. üí° 
2025-07-21 20:43 gav: Yes, the performance nomenclature was a little premature. In my more recent writings I‚Äôve avoided using the name Kusama for this meaning. 
2025-07-21 20:46 gav: Kusama could reasonably switch to JAM first; this would likely be quite helpful to reduce risk for Polkadot and could presumably happen prior to the completion of the formal audit. 
2025-07-21 20:48 gav: Of course it‚Äôs OpenGov which should decide in the end. And it doesn‚Äôt much help with the greater problem that JAM will likely be ready before the parachains service logic is completed and all tooling ready for the transition. 
2025-07-21 20:50 gav: A combined JAM with both Polkadot and Kusama sharing a validator set is an interesting proposition but inevitably raises questions about the staking tokenomics for such a network. JAM Grid doesn‚Äôt help here (even if it were ready) since that‚Äôs only about scaling up beyond a single JAM instance - it doesn‚Äôt help with consolidating two token economies. 
2025-07-21 21:03 ascriv: A dot/ksm merger/acquisition would be a great proof of concept and could optimistically be replicated between dot and other economies in the future 
2025-07-21 21:14 ascriv: JAM should theoretically be general enough to support hosting a service created just for onboarding all projects on any potential acquired L1, no? 
2025-07-21 21:16 ascriv: And then do a ‚Äústock-for-stock‚Äù transaction for all stakeholders funded by treasury. Or something 
2025-07-21 21:16 emilkietzman: Was it ever under consideration, that Kusama becomes not only a canary network around Polkadot but for the whole JAM protocol - since it‚Äôs going heavy on ZK technology and could test/be early on JAM ZK-rollups and Services?
2025-07-21 21:17 gav: If you‚Äôre considering it, then it‚Äôs under consideration:P
2025-07-21 21:18 gav: > <@ascriv:matrix.org> And then do a ‚Äústock-for-stock‚Äù transaction for all stakeholders funded by treasury. Or something 

This probably doesn‚Äôt work since it disregards dramatic differences in liquidity. 
2025-07-21 21:19 gav: > <@ascriv:matrix.org> JAM should theoretically be general enough to support hosting a service created just for onboarding all projects on any potential acquired L1, no? 

An interesting query. It depends on the L1 - JAM could not onboard itself. 
2025-07-21 21:22 gav: Overall, there‚Äôs a lot to be considered with crypto M&A. Ultimately this stuff is political. Unfortunately it appears to be a widespread belief that being the sole currency used to account value in staking for the provision of security is a privilege not to be shared. 
2025-07-21 21:25 gav: Personally I think such a view is narrow-minded and short-term and that this technology will only reach its full potential when the forces of token maximalism relent to mutually-beneficial cooperation over such things as provision of security. 
2025-07-22 13:30 emielsebastiaan: As JAM implementors, we‚Äôre allowed to have strong opinions‚Äîand personally, I believe it‚Äôs beneficial to have as many independent (sovereign) JAM implementations as possible.

So the question is: are there any compelling reasons not to want Kusama to follow a similar upgrade path to Polkadot? If we can‚Äôt identify any, then perhaps it‚Äôs time to set things in motion and encourage Kusama Governance to formally request that the Fellowship chart a parallel JAM transition for Kusama.
2025-07-22 13:36 emielsebastiaan: If M&A is a path to take (at all) this can also be taken after both JAM rollouts. Ie some eventual future discussion. 
2025-07-22 13:38 emielsebastiaan: If alignment between the two networks is a concern both treasuries could have a token swap giving them an equal voice in each others‚Äô governance. [edited]
2025-07-22 13:43 emielsebastiaan: One more idea regarding alignment is for both economies to have highly divergent issuance policies. Polkadot seems to be on the tight end. Kusama could take the opposite end of the spectrum. 
2025-07-22 18:29 danicuki: Is there any existing test vector with:

 1 - a "refinable" work package bundle (wp with import segments and extrinsics)
 2 - expected correct work report and segment exports

If anyone already produced such vector, would be very useful to test our refine implementation.
2025-07-23 08:57 ascriv: I think there is mutual benefit to merging economies which outweighs the benefits of having an entire separate 'test' economy. Sovereignty is important of course and I feel services have a significant degree of sovereignty even though they all share the same security [edited]
2025-07-23 08:59 ascriv: kusama must consent to any merge at the end of the day of course
2025-07-23 08:59 gav: Indeed. Sovereignty is more likely compromised from too little overall security than as a result of pooling security costs.
2025-07-23 09:00 gav: Probably pride will prevent this stuff from happening until it's too painful not to :/
2025-07-23 09:03 gav: JAM doesn't care about how validators are selected, so if there's a sensible way to combine two (or more) tokens into the same staking economy, JAM won't make an issue. Similarly with cores; JAM doesn't care how they're allocated. Indeed as of 0.7 series, individual services can actually own JAM cores and decide themselves how to allocate them. This could facilitate the sharing of a single JAM between multiple sub-economies. [edited]
2025-07-23 09:04 gav: The trickier thing is the tokens used for storage deposits (currently that which is represented in the balance of service accounts). It's totally unclear if these could work with multiple tokens. After consideration, I suspect there really must only be a single storage token, ideally with a fixed supply and no other use. [edited]
2025-07-23 09:07 gav: As of 0.7 series, services can have a gratis storage allocation at least, which can help manage certain cases of a shared economy, but the need for a single storage-deposit token stands. [edited]
2025-07-23 09:12 ascriv: perhaps we can plan on two services, one for polkadot parachains one for kusama parachains? ksm used within the kusama service and dot within the polkadot service
2025-07-23 09:13 ascriv: except only dot will be used for storage deposits, e.g.
2025-07-23 09:15 emielsebastiaan: Would the following approach make sense?
	1.	An independent Kusama/Jam launch (parallel to Polkadot/Jam) with its own validator set.
	2.	A not too distant future with a JAM-grid of two in which Kusama/Jam outsources only its security to Polkadot/Jam and keeps KSM as its storage token? [edited]
2025-07-23 09:22 rusticcottage: As a Polkadot & Kusama governance participant, I would like to understand that perspective better. The pride point in particular, so we can try to address it properly. I do understand some difficult decisions will soon need to be made, therefore the more we (governance participants) have time to exchange around the subject, the higher quality our governance decisions will hopefully be.
2025-07-23 09:24 emielsebastiaan: >> As a Polkadot & Kusama governance participant, I ...‚Ä®
I believe we are at the stage of exploring feasible ideas more than making decisions here. [edited]
2025-07-23 09:32 rusticcottage: I understand that. In my opinion good governance stems from good understanding. If there is a concern around pride preventing the best outcome in a timely manner, it may be possible to handle this through a quality narrative to counters that potential reaction. Only really works if the governance participants kind of have enough time to warm up to a paradigm shifting idea. Anyway, I'll leave it at that, thanks for any feedback.
2025-07-23 09:36 emielsebastiaan: I don‚Äôt know if the ‚Äòpride‚Äô remark was meant to reflect Kusama/Polkadot alignment/relations or broader blockchain industry alignment/relations. 
2025-07-23 09:59 emielsebastiaan: Is there a risk that Kusama‚Äôs economy cannot adequately support an independent JAM?
2025-07-23 12:14 gav: I'd say at this point it's beyond risk and pretty much a given, at least with the standard params. [edited]
2025-07-23 12:15 gav: Assuming validator nodes cost a bare minimum of ~$3k/month to run, it would cost $3m/month, $36m/year. Bare minimum, assuming stakers otherwise got zero rewards.
2025-07-23 12:17 gav: Kusama's present mcap is $280m, so it would need to inflate at close to 10% annually to achieve this with the requirement that the price didn't go down.
2025-07-23 12:18 gav: It's unclear if $3k is even realistic for running a node; I budgeted $5k for Polkadot and it's the same job with the same hardware and software. [edited]
2025-07-23 12:18 gav: It's certainly unrealistic to assume stakers will stake for nothing. And without them, there's no (economic) security.
2025-07-23 12:19 gav: > A not too distant future with a JAM-grid

Not especially realistic.
2025-07-23 12:21 gav: In any case, it's far from clear that a JAM core, sold at the breakeven price of $15-30k/month baseline security costs, could clear 1023 units. Polkadot certainly clears a lot less today and at a lower price point. [edited]
2025-07-23 12:21 gav: We certainly don't need a Grid until we cannot serve the market with a single JAM.
2025-07-23 12:23 gav: So for now I would focus much less on Grid (which remains a future scaling route) and much more on a) lowering marginal price for a core; b) finding models for allowing multiple interests to cohabit the same JAM; and c) making cores as useful as possible with bridges, SDK, ... [edited]
2025-07-23 12:40 oliver.tale-yazdi: Yea 341 cores is possibly also way too much for Kusama. We do have the smaller config presets for testing, maybe it could use a smaller instance if it does not want to join the Polkadot JAM chain? [edited]
2025-07-23 13:03 roysingh8368: 
2025-07-23 13:09 roysingh8368: Hey team,

I'm working on the Safrole simulation, specifically with the tiny/enact-epoch-change-with-no-tickets-4.json test vector, and I'm consistently seeing a mismatch in the gamma_s output in the post_state.

I've already implemented two key fixes based on the spec (Equations 6.23, 6.24, and 6.26):

Corrected F function: The fallback F function now canonically sorts the validator keys (kappa) before selecting proposers. This ensures deterministic selection, as implied by the spec for operations on sets of keys.

Correct Entropy for F: I'm now passing currentState.eta[2] (which is preState.eta[1] after epoch rotation) as the entropy source to the F function, as required by the Œ∑ 
2
‚Ä≤
‚Äã
  in Equation 6.24.

Despite these changes, my generated gamma_s still differs from the test vector's expected gamma_s. It seems like there might be a subtle difference in how the test vector generates this sequence, possibly related to:

The exact set of kappa keys being used for F.

A nuance in the cryptographic operations within F (e.g., hash function parameters, how the index is derived from the hash).

Could someone with knowledge of the test vector generation logic for this specific case take a look?
2025-07-23 17:37 jimboj21: Question on gas cost calculations for traces: For host calls does the inst cost get added to the host call cost? Like 1 gas for ecalli instruction then 10 for the call itself, so 11 total? Or is it just 10 total?
2025-07-23 17:40 jimboj21: For context, I pass all traces for 0.6.6 except I have an issue with gas calculations, so am investigating where I am off.
  ‚Ü≥ 2025-07-23 18:11 sourabhniyogi: 11 total except for LOG (which is just 1 for the ecalli) and TRANSFER (which has an extra component)
  ‚Ü≥ 2025-07-23 18:12 jimboj21: okay yup yup cool that makes sense. Just wanted to double check that
  ‚Ü≥ 2025-07-23 18:12 jimboj21: thank you!
2025-07-23 18:06 jimboj21: This would be particularly interesting for log, since it costs 0. but executing ecalli would mean it costs 1 and isnt free. That or it is free meaning that instructions for real host calls cost 0 but the host call cost is 10
2025-07-23 18:09 jimboj21: at least according to GP 0.6.7 (ik isnt the version im talking about, but since it has gas costs as non 0 thats what im referencing here) ecalli costs 1. So then logging via a host call is not free right it costs 1?
2025-07-24 04:15 luke_f: Question about Network library and clean room rules:

tl;dr
Another implementors team (JamBrains) has forked a network library we both use and fixed an issue we also need to fix. Is it OK to use their fork?

Long version:
Both us  in Jamixir and JamBrains use [Quicer](https://github.com/emqx/quic) library for QUIC protocol binding into Elixir

This makes sense because this library is pretty much the only offering for this binding in Erlang/Elixir.

Recently, I have become aware of shortcomings of this lib, for example, it is impossible to require the client to send certificates without said certificates being validated against a CA on the server side
which does not fit into our use case. 

I was about to fork the library and at the same time open an issue,
then I saw JamBrains has opened an [issue](https://github.com/emqx/quic/issues/332) about this more than 6 months ago, from the issue it was clear that they already solved this problem (possibly other issues that I did not encounter yet)

So, since networking libraries, afaik, are outside the clean room rules. Is it OK to use their fork?

Thanks




2025-07-24 05:47 gav: Yes. 
2025-07-24 05:48 gav: Exactly for the reason you state. Networking is outside of cleanroom rules. 
2025-07-24 07:15 luke_f: Thanks
never hurts to make sure :)
2025-07-24 11:58 oliver.tale-yazdi: Yea its fine from our side, thanks for asking üòÑ
2025-07-24 13:12 jaymansfield: Had to push enhancements to my languages open source quic library as well (ed25519 support). Seems JAM teams are not just building a new protocol, we‚Äôre also enhancing quic transport for everyone üëçüèª [edited]
2025-07-24 14:51 olanod: > <@oliver.tale-yazdi:parity.io> Yea 341 cores is possibly also way too much for Kusama. We do have the smaller config presets for testing, maybe it could use a smaller instance if it does not want to join the Polkadot JAM chain?

If Kusama rolls its own JAM it certainly doesn't need to go full power, if 1 core alone can handle our current(even mid-term) needs it seems wasteful to have even more, even current set up could use a shrinkage, too many validators for such a small economy.

Even as a Kusamaxi I'm more in favor of some form of merger, it will take a long while until there's enough demand in the world to need more than 1 JAM instance, I mentioned a while back in the forum about the possibility of JAM launching first with Kusama, give implementers and services the chance to launch early and let Polkadot join later when the dust has settled. With JAM reaching 1.0 the canary will be out of a job as an experimental ground, the innovation will be at the services level, there will be both experimental and mature stuff running on the same JAM. 
It would be good to find a way for JAM to be very token agnostic and host multiple economies, perhaps start with a neutral bootstrap (JAM?) token while the required economic machinery(including bridges) is set in place to then allow any token be used to power JAM, who knows, maybe BTC ends up used to pay for storage ;P
2025-07-24 15:06 ascriv: as far as i understand, JAM's token is represented by the service account balances, so it doesn't really know what dot or btc or whatever are. the plan i think is to make a bootstrap service account, give it a balance of 3.1415926..*10^9, and then somehow distribute them to match how DOT is currently distributed [edited]
2025-07-24 15:07 ascriv: i'm not sure what it would look like to also accept another token for gas and storage and whatever service account balances are used for
2025-07-25 05:38 gav: As I said, the storage deposit token economics most naturally favour a token with limited cap and which is not used for anything else.
2025-07-25 05:38 gav: This is because the storage capacity of a JAM has a fixed upper limit and by equating this to a token we benefit from market economics for its pricing. [edited]
2025-07-25 05:40 gav: Tts supply is fixed so that when all is used as storage deposit JAM is at full capacity. This ensures that JAM can never exceed capacity and that as it gets close, the market dispenses storage to those most willing to pay for it. [edited]
2025-07-25 05:41 gav: It is best not used for anything else because this would effective reduce supply (as the token gets deployed elsewhere in its economy) and mean that a portion of JAM's storage capacity goes unused. [edited]
2025-07-25 05:46 gav: For JAM there are really three points where tokens could potentially be utilised - staking in order to become a validator, core-procurement and storage deposits. In Polkadot, the DOT token is used exclusively for all three, in Kusama it's KSM used for all three. Any combination of the two would necessarily mean some form of allocation or sharing these economic segments. Theoretically the tokens themselves could be merged, but this seems to be an extremely political, not technical, proposition so I don't find it especially viable to reason about. [edited]
2025-07-25 05:47 gav: Now, JAM has a clever ability to allow cores themselves to be owned by a service, implying that a Polkadot service could reasonably *own* some number of cores (and sell them for DOT) whereas a Kusama service could own some (other?) number of cores and (and sell them for KSM). 
2025-07-25 05:48 gav: So sharing the core-procurement part of the economy isn't especially hard to imagine.
2025-07-25 05:49 gav: Staking has two components - a) placing (potentially slashable) value under bond in order to become elected; and b) reward payments. For the first component it seems reasonable to allow either of the "native" tokens to be used. [edited]
2025-07-25 05:53 gav: Longer-term, as I mentioned in my summit presentation this year, I believe the rewards must become more-or-less in line with receipts from usage fees, potentially with a market-acceptable short-fall to be made up with inflation (though I'd question whether it is truly realistic for any token economy to rely on inflation as a means of preserving itself in the long-term - token economies don't have the force of arms and arbitrary tax requirements which fiat economies do which I believe could be a critical difference).
2025-07-25 05:54 gav: With two independent economies sharing the benefits of security (core-provision), one presumes that the costs must be similarly shared, and it is unclear how this could work. However my feelings are that it's probably just a case of negotiating some long-term price point for core-ownership and ensuring all native tokens respect it. [edited]
2025-07-25 05:55 emilkietzman: After proof of Personhood if 55-60% DOT staked won‚Äôt be the ideal, but like 30% - should we launch a huge DeFi campaign with initiatives so people don‚Äôt go with them at start?
2025-07-25 05:57 gav: Yes, this is a very interesting point. The concept of value-representation-exclusivity as utility.
2025-07-25 05:58 gav: Personally, I believe it is an over-played card. 
2025-07-25 05:59 emielsebastiaan: ‚ÄúShared security‚Äù-burden by two (or many more) token economies. Cool üòé 
2025-07-25 06:01 gav: If we can use PoP voting to avert the need for nominations (and their rewards) and validator rewards can be kept minimal (perhaps through highly optimised deployment and a second tier of author-validators to ensure there's a ready supply of nodes), then it would imply security costs could be minimal - far less than today's ~$500m. This would then imply comparatively little costs on to the token-economy or economies sharing this security, then implying far less of a need to inflate (in the perfect scenario, no need to inflate at all). [edited]
2025-07-25 06:10 gav: But yes, I understand that staking capital is a "utility" for staking tokens. In reality it's not a utility but merely an attraction for token-holders, effectively allowing them to be paid in kind at the cost of market participants who suffer relative dilution. It only works as long as there are enough traders who are willing to pay the cost of dilution for swift market entry/exit (or using other aspects of the token, if there are any). If the number of those non-staking participants who are suffering this baseline cost dwindles, then the price drops as they exit. Assuming max staking rewards are fixed (in DOT they even reduce as there become too many stakers), then the return rate reduces, limiting the potential for staking to soak up extra supply. Furthermore, this dilution trick only works if the capital keeps its perceived value. If participants are not confident that their holdings will retain value while staked, then they will exit also, leaving only those who would hold anyway ("true believers" ü§≠). [edited]
2025-07-25 06:11 gav: Basically, diluting non-stakers isn't free money; it's a means of cashing out market confidence. Eventually that confidence will run out and the trick won't work any more. Unfortunately if you talk to some economists, even those quite close to Polkadot's home, they act as though it is, quoting the dilution in fiat economies as an accepted model which can be drawn upon here. [edited]
2025-07-25 06:14 gav: I don't know about "huge DeFi campaign"s, but establishing a token as more than just a means of diluting one group of market participants to inflate the balance of others seems sensible. [edited]
2025-07-25 06:19 gav: Yes. It seems to me that this, in some form or another, is where things must ultimately go.
2025-07-25 06:24 ascriv: > <@gav:polkadot.io> We don't want it used for anything else because this will effective reduce supply (as the token gets deployed elsewhere in its economy) and mean that a portion of JAM's storage capacity goes unused.

This seems to imply we should have a token just for storage? Since dot has utility other than paying for storage 
2025-07-25 07:05 olanod: So I take it that Kusama and Polkadot sharing the same JAM home is not the worst idea? Sharing the security burden among different economies and paying for coretime with different tokens seem doable so the question remains, what single token is used for storage deposits. Perhaps Sourabh's idea of [KSM turn into JAM token](<https://forum.polkadot.network/t/introducing-a-new-jam-token/13029/21>) is also not the worst idea?

Anyways it seems like Kusama could start deciding whether it wants to adopt JAM(a small configuration initially?), Polkadot can later run another poll with the community to decide if it joins the same JAM or spins up a new one.
2025-07-25 07:54 emielsebastiaan: If I understand correctly, JAM has three independent economic activities:

1. Storage Economy | With an independent storage token for its sovereign space. JAM introduces an independent storage token, effectively creating a sovereign economic zone where anyone or anything can own a portion of JAM's sovereign space. This space consists of JAM‚Äôs scarce storage capacity for code (sovereign services and their preimages) and its sovereign consensus state (storage items).
2. Core Allocation Economy | With generalized economic agents (cores): JAM includes generalized economic agents‚Äîits cores‚Äîthat can perform arbitrary computations. These cores are allocated through a core allocation economy, allowing them to be temporarily ‚Äúhired‚Äù to perform work for a defined period.
3. Staking economy for hardware & staking | JAM requires significant hardware infrastructure, with operational costs of approximately $5,000 per node per month (~$60M/year). Initially, these costs must be subsidized by the staking economy until JAM runs at capacity and its core allocation economy becomes fully active.
4. A potential fourth I thought about initially is the DA storage activity, but after further study this is really only indirectly bound by network bandwidth. This 2PB constraint is not a scarcity but design implication.

Benefits of the Three-Way Decoupling
This decoupling ensures JAM remains accessible and neutral, avoiding alignment with any single user or stakeholder group. 
Validators share the financial burden of hardware and operational expenses through the staking economy.
For instance, if both Polkadot and Kusama participate in the staking economy, they could share the $60M/year expense (e.g., proportionally based on market capitalization or another agreed-upon mechanism or metric).
Sovereign services that own cores (e.g., ‚Äúgratis‚Äù in the GP-0.7 range) can then allocate computational resources to their users. Polkadot for its parachain services and Kusama for its parachain services.

Why I Love This Model
If two token economies can coexist within this model, many more can as well, creating a truly open and permissionless ‚Äúworld computer‚Äù substrate.
It also scales seamlessly with JAM Grid: two or more sovereign JAMs, each with its own independent storage token and sovereign space, but sharing a broader staking economy. As these independent storage token economies grow and reach capacity, we can expect migration and optimization, where services move to whichever JAM offers the best conditions for their operations.

Potential PR Challenge
One possible concern is perception: some in the Polkadot and Kusama ecosystems might initially react with a tribal mindset (something I also felt at first I confess). It may take time to fully articulate the benefits, address emotional responses, and foster a constructive conversation around this vision.
2025-07-25 08:26 gav: Indeed.
2025-07-25 08:27 emielsebastiaan: ‚ÄúJAM is Space for Sovereign Digital Existence.‚Äù
2025-07-25 08:40 gav: I find it an unlikely contingency that DOT holders would willingly join a network so predisposed to another token.
2025-07-25 08:40 gav: I think realistically if KSM launches a JAM with its own storage token it'll forever be on its own.
2025-07-25 08:44 gav: I suspect that the only means of delivering a JAM shared between multiple token economies would be by appealing to the twin drivers of some fair economic disposition (where no founding token economy got a better deal than any other) *and* an improvement in individual prospects (where all founding tokens can see they would do better than if they stayed isolated).
2025-07-25 08:45 gav: But this is all conjecture; even if there are good arguments, as Emiel points out, there would still be an uphill struggle to get the right PR. [edited]
2025-07-25 09:08 olanod: > <@gav:polkadot.io> I find it an unlikely contingency that DOT holders would willingly join a network so predisposed to another token.

It's likely and I'm biased because I'm a KSM holder, not DOT. But I still think it's a sensible option. The 2 economies are very intertwined, if one does well so does the other(usually), Kusama would set up JAM first using KSM as the storage token and if new economies are deployed later on the same space is better to not try to change the storage token for a new one. KSM low market cap should make it easier for Polkadot to acquire storage(KSM) ahead of time and if DOT holders don't feel they are getting a good deal Kusama could even offer a large amount(e.g. transfer ownership of the whole treasury) for free.
2025-07-25 09:08 olanod: A new JAM token might be a hard sale even if it's only used for storage deposits, it will spark heated discussions and panic just like it already happened. We can try hard to show it only as the representation of this finite "natural resource" that won't compete with DOT but it would still be confusing. Perhaps it feels less of a threat if it looks like something else, e.g. an nft-like resource, the storage could be partitioned and each shard is a tradable item that gives me X amount of storage right.
2025-07-25 09:28 gav: So the economic fact is that it doesn't make sense to amalgamate the representation of a finite resource (storage) with some other functionality (e.g. representation of staking capital or payment currency for cores); by amalgamating you either risk systemic overuse of resources (dangerous for the system), a broken market or systemic underuse of resources (compromising the system's scalability). Or all three. [edited]
2025-07-25 09:30 gav: It's a sad reflection when sentiment is at a point where technical optimality (or even viability) is expected to be sacrificed in the name of maximalism.
2025-07-25 09:31 gav: This is not limited to JAM; Polkadot (and Kusama) already suffers from this - arbitrary existential deposits, often cited to me as a comparative failing of Polkadot - are a direct consequence of this amalgamation. [edited]
2025-07-25 09:36 gav: The storage-deposit economy is likely to be tiny - though it uses up some supply, I find it hard to imagine that Polkadot's ED model contributes (positively) more than a rounding error to its overall economics. However, I expect that because of the sub-optimally high deposit requirements (indeed dramatically so) in usage of not just accounts but things like proxies, that _not_ having a separate token (which would give users optimal pricing) undermines utility and indirectly imposes a far more substantial negative pressure on DOT. [edited]
2025-07-25 09:42 ascriv: Is it similarly suboptimal to be using dot for both paying for cores and staking? Should we strive for 1-1 mapping functionality->token? Ignoring maximalism 
2025-07-25 09:43 gav: Well, the question is really whether the underlying tokenomics of one compromise the ability to do the other.
2025-07-25 09:44 gav: E.g. a currency might just as well be used for purchasing bread as for purchasing a house.
2025-07-25 09:46 gav: I would argue that the procurement of cores is really just a payment function and perfectly fine to be done in any currency. Of course depending on what the system wanted to do with the proceeds, it might use a DEX soon after if the currency was not one it wanted to hold or burn. But given that it is economically equivalent to having the procurer hold their preferred currency and exchange it for the sale just-in-time, there is no especially strong argument to force core sales to be one currency or another. [edited]
2025-07-25 09:46 emilkietzman: Can‚Äôt this be done with the new decentralized stablecoin from Polkadot?
2025-07-25 09:48 gav: Staking rewards fall into the same category - it's just payments.
2025-07-25 09:51 gav: Staking capital is arguably a little different for two reasons:

- Staking is an important security function of the system since it controls who is selected as a validator. Therefore we want to ensure that any token which can be used for staking cannot reasonably be minted, controlled or blocked by a third-party. This precludes centralised stablecoins, and coins whose underlying ownership distribution is murky. That, unfortunately, means a whole lot of crypto.  Furthermore even bridged coins are problematic since this will subject the security of the validator set to the security limits of the bridge, which can will typically be a lot lower than the primary consensus machine.
- Staking involves holding tokens, effectively reducing the supply in circulation and, all other things equal, driving up price. It can thus be seen as a privilege to bestow on only tokens which as in some way well-aligned to the ideals of the system. [edited]
2025-07-25 09:56 ascriv: This kind of brings into question the utility of dot or ksm if there‚Äôs no reason to force core purchasing or staking to be in any particular token [edited]
2025-07-25 09:57 gav: Taking these two together, tokens used for the staking capital of a JAM must surely:

- Have their issuance logic be totally algorithmic and with no privileged parties.
- Have said logic be validated by the JAM for whose staking they be used.
- Support the need to cover their JAM's security costs, including through dilution as necessary. [edited]
2025-07-25 09:59 gav: In the case of a single native token on a JAM used for staking, all three are true. [edited]
2025-07-25 10:01 gav: If the stablecoin is robust enough, then yes I believe so.
2025-07-25 10:26 ascriv: If we actually have a robust decentralized jam native stablecoin, why have dot or ksm at all? Unless they somehow power the stablecoin in a way I don‚Äôt understand 
2025-07-25 10:27 ascriv: If true it seems to capture the upside a capitalist is incentivized not to own tokens but to own and rent out coretime itself (?)  [edited]
2025-07-25 12:08 gav: All decentralised stablecoin designs, to be best of my knowledge, require at least one other token to construe their underlying value or measure their value against.
2025-07-25 13:55 emielsebastiaan: Formatting issues on editing see below. üí©  [edited]
2025-07-25 14:05 emielsebastiaan: By hard fork enactment of JAM Editoral Board Governance (protocol over network) and general purposeness, openness, permissionlessness and accessibility as broadest and inclusive general value system, sovereignty of JAMs for their first class citizens (services / autonomous software) is best guaranteed. [edited]
2025-07-25 14:09 emielsebastiaan: So is revisiting alignment of DOT with JAM good? I‚Äôd say yes. But Polkadot Governance needs to make a choice on its fate and start believing in what it is capable of - and capitalizing on all the hard work that has been put into Polkadot over the past 8 years. [edited]
2025-07-25 14:28 emielsebastiaan: > Staking involves holding tokens, effectively reducing the supply in circulation and, all other things equal, driving up price. It can thus be seen as a privilege to bestow on only tokens which as in some way well-aligned to the ideals of the system.

When it comes to storage tokens for individual JAMs within the eventual JAM-grid (with its shared security and multi-stakeholder economic burden sharing), I don‚Äôt see them as particularly interesting long term.

While a storage token for a single JAM might be scarce in the short term‚Äîpotentially encouraging hoarding‚Äîthe reality is that a JAM costs around $60M/year to operate and does not justify itself until it generates at least that much in revenue.

Only after achieving break-even does it make sense to deploy another JAM, thereby expanding the grid. This additional capacity would increase storage availability and drive down the price of sovereign software space, ultimately reducing the average overall price of storage tokens across the network. 

Autonomous software, acting out of its own microeconomic self-interest, will naturally migrate, and storage hoarding will eventually disappear.

The staking tokens that participate in JAM‚Äôs greater competitive staking economy that align best with JAM‚Äôs values will accrue most value of all tokens in these economies.

Polkadot (and Kusama) are well positioned to emerge as leaders in this future competitive landscape.

I see this insight as a call to action for both Polkadot and Kusama Governance.
2025-07-25 14:29 emielsebastiaan: By hard fork enactment of JAM Editoral Board Governance (protocol over network) and general purposeness, openness, permissionlessness and accessibility as broadest and inclusive general value system, sovereignty of JAMs for their first class citizens (services / autonomous software) is best guaranteed.
2025-07-25 14:29 emielsebastiaan: So is revisiting alignment of DOT with JAM good? I‚Äôd say yes. But Polkadot Governance needs to make a choice on its fate and start believing in what it is capable of - and capitalizing on all the hard work that has been put into Polkadot over the past 8 years. [edited]
2025-07-25 15:01 emielsebastiaan: Although the stable coin discussion is interesting it is primarily a tool at this point to drive down the cost of running a JAM (by decoupling from volatile tokens). 

Which is warranted by the actual expenses happening in meat space. It is mostly a discussion on getting a stable coin design with the right properties emphasizing on sovereignty. Ie where is the stable coin most sovereign. This is also in the interest of both JAM and DOT (and KSM). How it is collateralized is a secondary concern. 
2025-07-25 15:07 emielsebastiaan: (Polkadot) OpenGov does not provide the same level of sovereignty as JAM Editorial Board Governance and its hard fork friction for enactment of protocol changes.
If any multichain future or broader Sovereign Digital Future is valued at all even Polkadot should (hopefully or eventually) see the value proposition of this. [edited]
2025-07-25 15:09 emielsebastiaan: This is the discussion we all should be having if you ask me.
Trust me I am vested and I am trying to force myself to see the bigger picture. 

End of rant. [edited]
2025-07-25 15:22 emielsebastiaan: Polkadot should not worry about an comparatively insignificant storage token(s). ‚Ä®‚Ä®Polkadot should not worry about competition in a staking economy.‚Ä®‚Ä®Polkadot should have confidence in its ability to be a leader in this competitive game. Any other ecosystem joining the JAM substrate will benefit from cross ecosystem interoperability just like free trade (economics) has a Nash equilibrium over autarky. [edited]
2025-07-25 15:43 emielsebastiaan: I welcome a discussion with stakeholders with different hats on to discover differences in value systems, beliefs and interests and a start of a negotiation for a symbiotic future relationship.‚Ä®‚Ä®I say this with different hats on: Polkadot Citizen, Kusama Citizen, JAM Implementor, Chief Investment Officer, Ideologist, Futurist, Engineer, Economist, Technologist & Human Being. [edited]
2025-07-25 18:54 sourabhniyogi: Can we get a polkajam release at 0.6.7 or 0.7.0 next week ... or have an estimate of when can hope for a release in August?  I checked the nightly release just now and it still shows 0.6.6 as in

```
./polkajam --version
polkajam 0.1.23
GP 0.6.6
```

We are ready now (if we go back to GP 0.6.6, or wait a bit) to compare our implementations recompiler timing and work reports of work package execution against  "--pvm-backend compiler".  This would be with work packages that spend 2-3 billion gas in 2-3s, where our PVM recompiler works on ~40 "numerical recipes in C" type programs up to the allocated refine gas limit and on random payloads (there are many others which run out of heap or maybe stack).

We can report back relative timing within the same testnet hardware on random payloads and are eager to compare recompiler performance on the same work packages compared to polkajam. [edited]
2025-07-25 19:28 davxy: 0.6.7 is almost ready. We'll ship the client and test vectors very soon [edited]
2025-07-26 00:36 gav: Did you try porting your "numerical recipes in C" algorithms to Solidity? If you already have a framework for PVM benchmarking and gas-profiling, then it could be interesting to reuse them for EVM gas profiling.
2025-07-26 00:37 gav: It could help understand how PVM gas compares to EVM gas.
2025-07-26 00:38 gav: (And potentially other systems' gas also - Solana's SVM and Near's Wasm, for example)
2025-07-26 00:39 gav: The GP only has pretty vague comparisons made last year on the basis of relatively little data. It's always nice to have more clarity.
2025-07-26 00:47 sourabhniyogi: We will use our JAM implementation vs `revmc` to get started on that finally for these -- it looks easy to dive in and collect this data! [edited]
2025-07-26 01:00 sourabhniyogi: https://watch.protocol.berlin/65a90bf47932ebe436ba9351/watch?session=68553b9a90bd41297b490a51
2025-07-26 02:06 gav: Some interesting talks at that conference.
2025-07-27 07:13 shunsukewatanabe: 
2025-07-27 13:20 dhruv245: Hello Everyone, Is there any ETA for the submission openings?
2025-07-27 16:27 danicuki: Is there any doc explaining how to generate those keys based on the seed?
https://docs.jamcha.in/basics/dev-accounts

I tried `subkey` but results differ. Also, the BLS key is not present in those specs. Aren't they being used anymore? 
2025-07-27 17:05 gav: > <@dhruv245:matrix.org> Hello Everyone, Is there any ETA for the submission openings?

I‚Äôm happy for trams to be submitting implementations of the most recent published GP at the time of submission. That said I think it‚Äôs probably only sensible to be submitting once we have test vectors with 0.7.1 data. 
2025-07-27 17:05 gav: We‚Äôll discuss it this week. 
2025-07-27 17:09 oliver.tale-yazdi: The JIP 5 is linked at the top of the page üòÑ https://github.com/polkadot-fellows/JIPs/pull/2 If you find discrepancies then please report them
2025-07-27 17:15 danicuki: I don't see any discrepancy. I just couldn't figure out how these keys were generated. The key generator I tried here don't return the same priv / pub keys using the same seeds. e.g. for bandersnatch, we are using the ark\_vrf lib:

```
use ark_vrf::{reexports::ark_ff::PrimeField, ScalarField, Secret};
use crate::types::Bandersnatch as S;

fn generate_secret_from_seed(seed: Vec<u8>) -> NifResult<(SecretBridge<S>, PublicBridge<S>)> {
    let secret = Secret::from_seed(&seed);
    let public = secret.public();
    Ok((secret.into(), public.into()))
}
```

Eg: how do I get the key
seed: 0x0000000000000000000000000000000000000000000000000000000000000000
ed25519_secret_seed: 0x996542becdf1e78278dc795679c825faca2e9ed2bf101bf3c4a236d3ed79cf59
 [edited]
2025-07-27 22:51 clearloop: what about the testnet, will work package related stuffs, network + VM, extrinsic, data layer (segments) being required for joining the testnet, hope there will be sort of pre-requirements /checking list for joining the testnet that we can prepare for it more specifically ! [edited]
2025-07-29 18:05 davxy: I'd like to start sharing some results from our fuzzer against public targets developed by other teams.

I'll be publishing a few of the failing traces in the [jam-stuff](https://github.com/davxy/jam-stuff/tree/main/fuzz-reports/) repository.  
As you can imagine, I won't be doing deep triage on each individual bug - especially because **this effort is not (yet) part of the official implementation audits** - debugging every implementation could easily become a full-time job üôÇ.  
That said, I‚Äôm happy to help where I can (e.g., share reports, PVM traces, etc.).

Each report includes:
- The step that caused the target to produce a different root compared to the expected one.
- The step immediately before that (or genesis, if the failure happened on the first block), since some implementations may find useful to have the previous block header on initialization.
- A textual report showing the state diff between the fuzzer and the target, plus some extra info.

For now, I‚Äôve run the fuzzer against **jampy**, **vinwolf**, and **jamzig**.  
If other teams want me to run the fuzzer against their target, just share a ready to use binary in a repo.

The folder name for each report is generated from the `PeerInfo` your target shares with the fuzzer during the handshake.

For any discussion and improvement, please open an issue in the repository.  
We can have one issue per implementation to keep things organized. I'll try to keep up - but no guarantees for quick sync responses üôÇ [edited]
2025-07-29 18:06 jaymansfield: Which GP version is it targeting?
2025-07-29 18:06 davxy: Oh, 0.6.6 for now. We'll be ready for 0.6.7 stuff this week [edited]
2025-07-29 18:12 jaymansfield: Ok thanks. Can share a JavaJAM 0.6.7 build with fuzzer support once you are ready I can push it out anytime. Have too many changes incorporated to go back to 0.6.6 for now. 
2025-07-29 18:13 ascriv: I think it makes sense to have publish the fuzzer binary to help with iteration speed, what do you think @davxy ?
2025-07-29 18:17 davxy: Since no one wants to lose their mind over this, I think it‚Äôs a sensible idea. I‚Äôll bring it up with the team this week
2025-07-29 18:28 sourabhniyogi: If we can jump from 0.6.7 to 0.7.1 and skip over 0.7.0 (and make a habit of skipping like this), I think it will save a lot of us a lot of work.
2025-07-29 18:31 sourabhniyogi: Having the polkajam binary massively improved our iteration speed and got us to work report correctness (in the sense of matching thus guaranteeding) in ways I don't think would have been possible without it.  Having the fuzzer binary published alongside it will do the same, probably.  We can also publish our own fuzzer binary .. once we have 0.6.7 polkajam alignment and traces alignment. [edited]
2025-07-29 21:09 sourabhniyogi: Yes, pls share your 0.6.7 build with fuzzer support [we are in the same state] and if you can, your 0.6.7 traces -- we'll do the same and if we can, do a "fuzz-reports" output in the same style as davxy 's report!
  ‚Ü≥ 2025-07-30 01:52 jaymansfield: I pushed a new set of traces for 0.6.7 here https://github.com/javajamio/javajam-trace
  ‚Ü≥ 2025-07-30 01:53 jaymansfield: and a new JavaJAM build for 0.6.7 https://github.com/javajamio/javajam-releases
  ‚Ü≥ 2025-07-30 13:44 danicuki: here is ours: https://github.com/jamixir/jamixir-releases
  ‚Ü≥ 2025-07-30 18:13 mkchung: ```
11:08:25.356 [error] [ALICE] ‚ùå Failed to generate TLS identity bundle: {:certificate_creation_failed, ""}

11:08:25.356 [info] [ALICE] üé≠ Starting as validator

11:08:25.508 [info] [ALICE] üîß Running in fuzzer environment

11:09:29.028 [info] [ALICE] New fuzzer  connected

11:09:29.031 [info] [ALICE] Peer info: name=jam-duna-fuzzer-v0.1, version=0.6.7, protocol=0.6.7

11:09:29.032 [error] Task #PID<0.203.0> started from #PID<0.202.0> terminating
** (UndefinedFunctionError) function Mix.Project.config/0 is undefined (module Mix.Project is not available)
    Mix.Project.config()
    (jamixir 0.6.7) lib/meta.ex:2: Jamixir.Meta.app_version/0
    (jamixir 0.6.7) lib/fuzzer/service.ex:95: Jamixir.Fuzzer.Service.send_peer_info/1
    (jamixir 0.6.7) lib/fuzzer/service.ex:37: Jamixir.Fuzzer.Service.handle_client/2
    (elixir 1.17.2) lib/task/supervised.ex:101: Task.Supervised.invoke_mfa/2
Function: #Function<0.18238596/0 in Jamixir.Fuzzer.Service.loop_acceptor/2>
    Args: []

```
danicuki | Jamixir : I think we got errors right after connecting to jamixir
  ‚Ü≥ 2025-07-31 10:06 danicuki: Thanks for reporting. Just fixed the issue. Could you please retry with the latest updated 0.6.7.tar.gz file? [edited]
  ‚Ü≥ 2025-07-31 18:15 mkchung: 
Pulled the latest build. but still have issues with handshake
```
2025/07/31 11:00:09 Handshake failed before test run: failed to jam-decode data for tag 0: [Error From Codec Decode]data length insufficient for string character , type: string, name: Name, tag: name
```
you can find more detail here: https://gist.github.com/mkchungs/c623db06b9dd520c3cd37a670258469f. 
2025-07-30 18:16 advatar: Does anyone have a full implementation of 0.7.1 up and running?
2025-07-30 19:08 sourabhniyogi: Jason | JavaJAM: We successfully passed your 0.6.7 traces [here](https://github.com/javajamio/javajam-trace/tree/5297d62c8634017151acbf36d1ad65d81d5b0465/stf/state_transitions) happily, thank you for posting.  Everyone else, if you're hungry for 0.6.7 traces vectors, recommend you check them out!
2025-07-30 20:49 advatar: No?
2025-07-31 09:18 anish1222: Screenshot 2025-07-31 at 2.48.28‚ÄØPM.png
2025-07-31 09:19 anish1222: mail: harpreet@techsteck.com
2025-07-31 09:21 anish1222: when i am doing KYC i am getting this error why?
and how can i complete KYC now? kindly help
  ‚Ü≥ 2025-07-31 09:25 david: Thanks for bringing this up. Let me share your contact information with the team at the foundation that is handling KYC.   
  ‚Ü≥ 2025-07-31 15:22 keegan: Hey guys, I can help with this. Did you submit a JAM delivery recently or what's the reason for KYC?
  ‚Ü≥ 2025-08-01 11:10 anish1222: Screenshot 2025-08-01 at 4.40.01‚ÄØPM.png
  ‚Ü≥ 2025-08-01 11:11 anish1222: while i am completing KYC i am getting that error
  ‚Ü≥ 2025-08-01 13:40 keegan: thx Anish Gajbhare our compliance team will reach out to you via email.
2025-07-31 09:43 sukhdev123: Screenshot 2025-07-31 at 3.11.49 PM.png
2025-07-31 09:43 sukhdev123: mail:9664sukhdevsingh@gmail.com
2025-07-31 09:44 sukhdev123: During KYC I'm getting this error?
  ‚Ü≥ 2025-07-31 10:46 david: I will also share it internally with the team. 
  ‚Ü≥ 2025-07-31 15:22 keegan: Hey guys, I can help with this. Did you submit a JAM delivery recently or what's the reason for KYC?
  ‚Ü≥ 2025-08-02 06:53 sukhdev123: Yes,I need KYC for Submit a Jam delivery.
  ‚Ü≥ 2025-08-02 06:55 sukhdev123: Thank you so much
  ‚Ü≥ 2025-08-06 05:54 sukhdev123: Screenshot 2025-08-06 at 11.23.26 AM.png
  ‚Ü≥ 2025-08-06 05:57 sukhdev123: KYB link is not working i need to do KYB .How can i do?My entire team doing KYB .Link is not working anymore help me with this.

1. one team member is sufficient for KYB or entire team has to do KYB? 

  ‚Ü≥ 2025-08-06 14:25 keegan: Sukhdev Singh: that appears to be the wrong link, can you try with https://in.sumsub.com/websdk/p/uni_6eVGNmoJ83HVovnN
  ‚Ü≥ 2025-08-06 14:25 keegan: KYB is for the legal entity, but yes all members need to do KYC as part of it.
  ‚Ü≥ 2025-08-06 14:26 keegan: If that doesn't work feel free to email compliance@web3.foundation
2025-07-31 11:02 roysingh8368: Hi everyone,

I'm currently working on the Bandersnatch VRF and encountering an issue during the ticket verification process. The extrinsic is failing, and I'm having trouble pinpoint where exactly the problem lies.

Specifically, I'm following Equation 6.29 from the GreyPaper and attempting to verify against the gamma_z ring root of Bandersnatch. However, the verification fails, and I'm not sure where the discrepancy is.

Could someone with experience in Bandersnatch VRF help me debug this? Here‚Äôs what I‚Äôve tried so far:

Confirmed the input parameters (e.g., public key, challenge, response) are correctly formatted.

Ensured the gamma_z derivation aligns with the spec.

Any insights or pointers would be greatly appreciated!

2025-07-31 11:03 advatar: Is there some place where I can see which implementations are being worked on and their current protocol version?
2025-07-31 11:30 rustybot: > <@advatar:matrix.org> Is there some place where I can see which implementations are being worked on and their current protocol version?

Whould be nice to have this info here https://jamcha.in/clients
  ‚Ü≥ 2025-07-31 11:51 oliver.tale-yazdi: The original idea was to have Milestones in there, but so far everybody was on zero so it is not show.  
The information is pulled from here https://graypaper.com/clients/json , (which does contain the milestones) so you can probably propose in that repo to add the GP version here https://github.com/w3f-webops/graypaper-website/blob/b870e97491b92302383e1a3085e23d3ebed5a991/src/data/types.ts#L61
  ‚Ü≥ 2025-07-31 11:52 oliver.tale-yazdi: Then I can change the rendering to include the GP version as well
  ‚Ü≥ 2025-07-31 11:53 oliver.tale-yazdi: Or we go by a different convention where it just scans a public GitHub repo per project where each project can set its version (like the conformance-release repos that some teams already maintain)
  ‚Ü≥ 2025-07-31 11:53 oliver.tale-yazdi: That would probably be less friction and more up-to-date
2025-07-31 11:32 roysingh8368: > <@roysingh8368:matrix.org> Hi everyone,
> 
> I'm currently working on the Bandersnatch VRF and encountering an issue during the ticket verification process. The extrinsic is failing, and I'm having trouble pinpoint where exactly the problem lies.
> 
> Specifically, I'm following Equation 6.29 from the GreyPaper and attempting to verify against the gamma_z ring root of Bandersnatch. However, the verification fails, and I'm not sure where the discrepancy is.
> 
> Could someone with experience in Bandersnatch VRF help me debug this? Here‚Äôs what I‚Äôve tried so far:
> 
> Confirmed the input parameters (e.g., public key, challenge, response) are correctly formatted.
> 
> Ensured the gamma_z derivation aligns with the spec.
> 
> Any insights or pointers would be greatly appreciated!

can anybody help me with this as i'm stuck now.
2025-07-31 12:18 rustybot: > <@roysingh8368:matrix.org> can anybody help me with this as i'm stuck now.

Have you tried to follow the example here: https://github.com/davxy/bandersnatch-vrf-spec/tree/main/assets/example ?
2025-07-31 12:49 danicuki: You have to run something like:
RingVrf.ring\_vrf\_verify(epoch\_root, context, "", ticket\_signature)

context is \<\<$jam\_ticket\_seal + eta2' + attempt>> [edited]
2025-07-31 12:52 danicuki: I just created a PR to add some  JAM related data to the  ElectricCapital Developer Report (https://www.developerreport.com/). This report methodology required that every team self claim their participation into specific Ecosystems. It is a very weak methodology, but still this is a reference report for the industry. I noticed many missing Polkadot repos in the list - including the Graypaper repo. I strongly suggest that all JAM teams make PRs like this one to make sure we appear strong in the next report that comes out by the end of the year. https://github.com/electric-capital/crypto-ecosystems/pull/2088
2025-07-31 15:02 ascriv: That would have helped me a lot a few months ago‚Ä¶.. ü§¶‚Äç‚ôÇÔ∏è [edited]
2025-07-31 22:23 shwchg: hey David Emett
I saw your binary version is updated to 0.6.7
and we found that our protocol\_parameters length mismatch (we are 136 and you are 134) [edited]
2025-07-31 22:28 shwchg: and found this when we were running `polkajam-testnet`
```
node1: 2025-07-31 20:56:54 main ERROR jam_cli  Error: Chain error: VmEngine(EngineInitializationFailed(Error(Owned("failed to create a worker process (0 already exist): failed to fetch the userfaultfd from the child process: recvfd failed: received zero bytes (root cause: failed to create an userfaultfd: userfaultfd (errno = 1 (EPERM)))"))))
node0: 2025-07-31 20:56:54 main ERROR jam_cli  Error: Chain error: VmEngine(EngineInitializationFailed(Error(Owned("failed to create a worker process (0 already exist): failed to fetch the userfaultfd from the child process: recvfd failed: received zero bytes (root cause: failed to create an userfaultfd: userfaultfd (errno = 1 (EPERM)))"))))
node4: 2025-07-31 20:56:54 main ERROR jam_cli  Error: Chain error: VmEngine(EngineInitializationFailed(Error(Owned("failed to create a worker process (0 already exist): failed to fetch the userfaultfd from the child process: recvfd failed: received zero bytes (root cause: failed to create an userfaultfd: userfaultfd (errno = 1 (EPERM)))"))))
```
2025-07-31 23:43 olanod: Hi there! hoping to gather some feedback/thoughts on this early stage idea of [**Kunekt** a JAM-native real-time collaboration protocol](https://forum.polkadot.network/t/kunekt-jam-native-real-time-collaboration-protocol/14153). Our team that focuses on building tech to on-boarding real-world organizations as DAOs, in the pre-JAM era we (ab)use the Matrix protocol as part of our stack to give orgs the ability to store encrypted private data, collaborate and do off-chain computation. I believe JAM can evolve our stack and remove the need for our Matrix dependency with a protocol like Kunekt to serve most needs for collaboration and privacy of organizations, it would be a protocol that I hope compliments well other JAM services like parachains instead of competing with them :)
2025-08-01 03:51 gav: Yes, definitely. 
2025-08-01 03:51 gav: Just the sort of thing which we should be exploring. 
2025-08-01 03:59 gav: While Kusama governance has not yet made an decision wrt JAM, it occurs to me that one way forward (assuming Kusama and Polkadot do not cohabit) would be to have Kusama run a smaller JAM (perhaps just 32-core) with shorter block time, perhaps as short as 1 second depending on the results of Toaster experiments. Such a small JAM will reduce overall validator costs (assuming $4k/node and PoP-based nomination with a modest lottery, the issuance-based fallback would only need to be around $6m/year, offset by core rental). The lower blocktime would result in lesser data throughput between WPs and between refine/accumulate, but obvious lowers latency dramatically. 
2025-08-01 06:41 emielsebastiaan: How many individuals do you need onboarded to PoP in order for such nominations to work effectively/securely?
2025-08-01 06:43 emielsebastiaan: I can imagine such number would be lower for Kusama than for Polkadot in a non-cohabit scenario. 
2025-08-01 06:44 gav: Difficult to say, but the purpose is to ensure that of the validators elected no more than 1/3 are well-aligned.
2025-08-01 06:45 gav: Probably approximately the same number as the number of nominator accounts would be a vaguely sensible rule of thumb to start with.
2025-08-01 06:50 emielsebastiaan: Benefit of this scenario would be divergence between KusamaJam & PolkadotJam on the speed/resilience trade-off. And it would negate the controversy of sharing the staking economy (at the cost of burden sharing of infrastructure cost). 
2025-08-01 06:51 gav: Yes. There are almost certainly some applications which make much more sense under much faster state resolution (and with it, finality). [edited]
2025-08-01 06:55 gav: But faster state resolution necessarily comes at a cost of reducing overall internal data transfers; there may be some way of mitigating against this to some degree (see [Slipstream](https://github.com/gavofyork/graypaper/issues/322)), but I wouldn't expect it to deliver quite the same level of performance as just having larger block-times. [edited]
2025-08-01 06:56 emielsebastiaan: Would a future upgrade path to a shared staking economy still be possible with this scenario? Ie commoditized node infrastructure? With a Grid? Eg Heterogeneous Jam Grid.  [edited]
2025-08-01 06:58 ascriv: If we‚Äôre going to have two jam instances from the start, can we suppose that for jam implementors the additional maintenance would be negligible? The differences being essentially parameters   [edited]
2025-08-01 07:02 gav: I wouldn't say definitely not ever, but certainly if there are differing parameters it will make the Grid protocol more difficult.
2025-08-01 07:03 gav: Generally, the Grid should be considered as a means of scaling up a single JAM, rather than a means of joining two independent JAMs and their token economies.
2025-08-01 07:04 gav: A single JAM can (on paper at least) process so much more stuff than existing networks that existence of the Grid isn't going to change anything.
2025-08-01 07:04 gav: What matters is the economics.
2025-08-01 07:05 gav: And as yet there isn't an uncontroversial way forward on that (though I'd hope that discussion still proceeds in the hope of finding consensus over a win-win scenario). [edited]
2025-08-01 07:15 davxy: > <@shwchg:matrix.org> hey David Emett 
> I saw binary version is updated to 0.6.7
> and we found that our protocol_parameters length mismatch (we are 136 and you are 134)

If I'm not wrong, the correct encoded size should be 134 bytes (based on the sum derived from the `fetch_params` expression).  
Also, keep in mind that we're using version `0.7.x` for this, as noted somewhere at the time.  
An older `vector` release was incorrectly encoding it as 136 bytes, but that issue has been fixed.
2025-08-01 07:53 emielsebastiaan: This seems like a very interesting direction. Divergence between Polkadot & Kusama on the infrastructure layer on the latency/size tradeoff creates a overall increase for the design space on the combined application layer, albeit at the cost of coherence between these two infrastructure layers. It would allow Polkadot and Kusama to further differentiate and distinctly market themselves to the world. 
2025-08-01 08:06 ascriv: It feels like if we go this direction we are inevitably going to have a world with many different jam instances with different tradeoffs. I guess this is probably inevitable anyway 
2025-08-01 08:07 ascriv: One-size-fits-all jam instance sounds great but probably isn‚Äôt realistic  
2025-08-01 08:14 emielsebastiaan: Re: What really matters is the economics.

Staking on Kusama has 10,669 active nominations (Polkadot 21,266 btw).

So (speculating), a Proof of Personhood (PoP) system with around 10,000 participants should be enough to drastically lower Kusama‚Äôs costs.
This number of onboarded individuals seems like a reasonable objective for PoP (perhaps with some one time incentive to onboard).
Costs: $4,000 per node per month √ó 12 months √ó 32 cores √ó 3 guarantors = $4.6 million per year.
Gavin mentions costs of $6 million per year, which likely includes an extra $1.4 million to annually compensate nominators.

With a Kusama market cap of $250 million, this translates to a worst case inflation rate of 2.4% (given assumptions).
Assuming no protocol revenue which is a worst case.
Assuming no change in marketcap which can be mitigated by stable coin payments (governance planning/budget and treasury management). [edited]
2025-08-01 08:27 gav: > Gavin mentions costs of $6 million per year, which likely includes an extra $1.4 million to annually compensate nominators.

Indeed - there needs to be some incentive for randomers to vote (and ideally sensibly). [edited]
2025-08-01 08:28 gav: With 10,000 people voting and a budget of $1.4m/year we can afford to provide an average of $140 per person per year - this is pretty substantial.
2025-08-01 08:34 olanod: > <@gav:polkadot.io> While Kusama governance has not yet made an decision wrt JAM, it occurs to me that one way forward (assuming Kusama and Polkadot do not cohabit) would be to have Kusama run a smaller JAM (perhaps just 32-core) with shorter block time, perhaps as short as 1 second depending on the results of Toaster experiments. Such a small JAM will reduce overall validator costs (assuming $4k/node and PoP-based nomination with a modest lottery, the issuance-based fallback would only need to be around $6m/year, offset by core rental). The lower blocktime would result in lesser data throughput between WPs and between refine/accumulate, but obvious lowers latency dramatically.

It's interesting having a smaller and faster JAM for Kusama, for Kunekt it would be useful although it should work with the standard longer block time configuration as peers still can send each other CRDT udates in real time and the raft elected leader would sync with  the on JAM coordinator at whatever frequency is required as for simple use cases the JAM peer acts more like a remote git repository, but sure for anything triggering on-chain transactions a faster low latency JAM would be ideal at the expense of lower throughput, but anyway I'm assuming a smaller faster JAM would still be a powerhouse that can serve quite a lot of traffic no?

It's good that Kusama didn't rush to make a decision on JAM, as I'm the one that started the topic of making Kusama and Polkadot share the same JAM instance and after the discussion of sharing the security burden between two or more economies which is great, I think now is a good time to bring the JAM topic to Kusama's governance so I'll propose two simultaneous WFC refs with two interesting paths Kusama could take:

- Implement an independent lighter/faster JAM with KSM as the main/only token driving its economy.
- Implement JAM with the "standard configurations", have a new "JAM storage token" with fixed supply to represent the finite storage as an independent resource so the chain is not biased towards KSM allowing other economies like DOT's to share the same space and security burden in the future.
2025-08-01 08:36 olanod: 10K participants is totally doable and we might even have the incentive already. Say we use something like Bloque's on-going initiative to [on-board 20K users with debit cards](https://kusama.subsquare.io/referenda/568), those users might be do PoP without even realizing, we work close with Bloque and there's still some room to for example bundle some specialized java applet in the cards in case it's needed for PoP [edited]
2025-08-01 08:40 emielsebastiaan: Any particular reason you chose $4000/month/node for Kusama, while previous estimations were lower for Kusama and higher for Polkadot. Is this just a new estimate or are there inherent differences in cost depending on Jam size? [edited]
2025-08-01 08:44 ascriv: Should we not consider the downsides of a split economy, split mindshare, split devs, split marketing etc when we are so similarly aligned at least technically speaking?
2025-08-01 08:45 ascriv: Are the benefits of having two differently parameterized instances worth these tradeoffs?
2025-08-01 08:45 ascriv: Putting bagholder interests aside 
2025-08-01 08:46 gav: > those users might be do PoP without even realizing

Highly highly unlikely.
  ‚Ü≥ 2025-08-01 09:07 olanod: "might" üòÖ ... would need to get creative(my favorite part) with the on-boarding to make it as painless as possible but if people are already willing to do KYC they might do other kinds of ceremonies. e.g. most of those initial card recipients will be clustered in 1 city, what if they receive an extra keychain gift that is a relatively inexpensive LoRa device that can talk with a city hub over long distances and  do PoP ceremony ala Encointer or similar but more seamless and scalable? ... just a random idea ;)
  ‚Ü≥ 2025-08-01 09:09 gav: As long as it's possible your population is not fully inducted (and you can't control/track your population borders and any new entrants individually) then generally PoP cannot be a one-off thing. [edited]
  ‚Ü≥ 2025-08-01 09:10 gav: The only reason existing systems do this is because they rely on appealing to authorities who do impose such restrictions/requirements on their sub-populations. Be we cannot reasonably rely on such authorities since it would undermine security to the arbitrariness of a single jurisdiction.
  ‚Ü≥ 2025-08-01 09:11 gav: In reality any non-invasive PoP would need to be done both regularly and in a globally synchronised manner to ensure the same individual did not re-induct themselves.
  ‚Ü≥ 2025-08-01 09:13 gav: Invasive DIMs, such as proof-of-ink, can be one-off or at least a highly infrequent revalidation. [edited]
  ‚Ü≥ 2025-08-01 09:13 gav: That's the trade-off here.
  ‚Ü≥ 2025-08-01 09:14 gav: Either way the individual is going to know.
  ‚Ü≥ 2025-08-01 09:21 olanod: sure, they can know but it doesn't have to be a painful process, they can initially see it as, oh cool! the card comes with a membership to some special club or something. I prefer the non invasive approaches, that's why I like the Encointer approach but I think we need a better version of it, an "automated Encointer" with the help of some specialized hardware, I'm not tattooing but I'd carry some token or something. It would still be an on-going thing as the LoRa based protocol would constantly challenge me but I don't need to do much other than keep the device powered. 
  ‚Ü≥ 2025-08-01 09:29 gav: If you can think of a means of doing that *universally* (Encointer fails here) without being invasive and without regular temporally-synchronised gatherings, you should write it up and publish.
  ‚Ü≥ 2025-08-01 09:30 gav: In fact, I have found that it's an extremely hard problem. 
  ‚Ü≥ 2025-08-01 09:32 gav: Perhaps not "painful" exactly, but I believe it will necessarily place a burden of proof on the individual. [edited]
  ‚Ü≥ 2025-08-01 09:33 gav: I've seen a number of PoP methods over the years. Most are totally flawed, based around appeal-to-authority and unsuitable for this usage. Only Idena's method looked reasonably secure and universal but even this requires a form of regular temporally-synchronised gatherings. [edited]
  ‚Ü≥ 2025-08-01 09:35 gav: >  I'd carry some token or something

Good for you but I've no idea why you think it would help here.
  ‚Ü≥ 2025-08-01 09:35 gav: > I don't need to do much other than keep the device powered

Sounds like you're talking about proof-of-device. Anything involving proof-of-personhood would necessarily require some human interaction. The clue is in the term: _personhood_. [edited]
  ‚Ü≥ 2025-08-01 10:20 olanod: fair point, but the device alone is not the thing identifies me (bare with me as I'm just brainstorming on the fly and I might brainfart some nonsense), I would still attend some main ceremonies but they are virtual, e.g. in a kunekt powered chat/interactive session I prove I'm human with some fun challenges that might involve other human participants or just solving a series of captchas. The LoRa device component that is simultaneously connected to my phone via BLE is there mostly to attest my location but the protocol could be more complicated(we can learn something from helium network), the thing is, I can be comfortably attend the ceremony few kilometers away from the nearest hub that is running the virtual gathering(in latam with security issues I wouldn't like predictably attending the same physical space with a bunch of strangers). 
The device(paired to the phone?) can participate on a second kind of non-interactive automated ceremony that is celebrated more often(daily/hourly/all the time?) as an extra measure and mostly to not require my participation in the main ceremonies as often.
  ‚Ü≥ 2025-08-01 10:57 olanod: I was skimming over Idena's approach and ceremony, it looks interesting, I think what I mention is a mix of that and the geo component of Encointer. Ceremonies with good UX, the right incentive and without having to be very regular shouldn't be a downside it can actually become something people look forward to.
  ‚Ü≥ 2025-08-02 01:26 gav: I don‚Äôt know of any trustless device. I certainly don‚Äôt know of one which can deliver its GPS coordinates to a public network in a trustless manner such that any observer can believe them. I see little point for any continuous device proof and cannot see how it is any way effective at reducing the rate of actual proof of personhood.  [edited]
  ‚Ü≥ 2025-08-02 17:36 olanod: Thinking better yeah I don't see much benefit for the continuous device proof, but there's a reason I started to consider the device thing, I still think it has its place in the picture ;)

Idena and Encointer's premise of _one human cannot be in two places at the same time_ is a good starting point, regular temporally-synchronised gatherings are not ideal but might not be the worst thing. I see some pros and cons with their approaches,
-Idena challenges(FLIP) can be solved anywhere in the world, there's no need to move but the ceremony taking place at the same time everywhere means some parts of the world won't be lucky with the time, also I'd argue that AI might be advanced enough nowadays to solve their FLIPs and can it handle millions of people at the same time?

- Encointer is more flexible with the time to accommodate people in different timezones, showing up in a physical place also proves your location, but it's hard to scale that kind of ceremonies(and I still think it can be dangerous for participants).

Now the device thing to try to make things a bit better. Borrowing from Helium [proof of coverage](https://docs.helium.com/iot/proof-of-coverage/#why-proof-of-coverage), we can use the Long Range radio to proof location(no GPS, no need to trust the device, just solve an automated challenge)

> - RF has limited physical propagation and, therefore, distance.
> - The strength of a received RF signal is inversely proportional to the square of the distance from the transmitter.
> - RF travels at the speed of Light with (effectively) no latency.

We can use physical hubs with well known locations elected via governance to be the "challengers" that expect swift responses and coordinate the ceremonies(e.g. the Web3 Outposts). The device solving a challenge via radio marks the start of the time sensitive ceremony that could use JAM Kunekt's realtime collaboration properties to have more robust(and more fun) forms of verification. Idena also has the concept of different levels of "humanness", older participants who have gone through several ceremonies can afford to miss some, so given that we are proving the location and a device solving an automated challenge is better that not attending a ceremony, I'd say there's room for relaxing the frequency or ratio of attendance. Some participants with track record humanness can also help expand the coverage of the hub. Devices should also be relatively cheap(e.g. 10 - 50 USD dev boards[¬π](https://lilygo.cc/products/t-watch-s3)[¬≤](https://www.seeedstudio.com/Wio-SX1262-with-XIAO-ESP32S3-p-5982.html)[¬≥](https://lilygo.cc/products/t-beam-supreme-meshtastic)), more affordable that a tattoo? [edited]
  ‚Ü≥ 2025-08-02 17:37 olanod: pop+lora.png
  ‚Ü≥ 2025-08-03 03:27 gav: > AI might be advanced enough nowadays to solve their FLIPs and can it handle millions of people at the same time?

Always a concern with remote PoP. [edited]
  ‚Ü≥ 2025-08-03 03:27 gav: > showing up in a physical place also proves your location, but it's hard to scale that kind of ceremonies

Agreed, but ultimately I fear that it will come to either to this or something more invasive (e.g. proof-of-ink). [edited]
  ‚Ü≥ 2025-08-03 03:28 gav: > We can use physical hubs with well known locations elected via governance to be the "challengers" that expect swift responses and coordinate the ceremonies

All this does is introduce a new governmental authority.
  ‚Ü≥ 2025-08-03 03:29 gav: This is not what I believe is helpful to the world, and certainly not what I would wish to spend my time, stress-levels and resources on. [edited]
  ‚Ü≥ 2025-08-03 03:30 gav: All participants in any Web3 system must be unprivileged; barriers to entry must be zero.
  ‚Ü≥ 2025-08-03 03:32 gav: If it then becomes hub-controllers who create the challenge and attest to location (and through that, personhood) and that the barriers to entry for a hub-controller are basically $$$ to purchase land/property, then you've just created the basis for a feudal society, with princelings basically awarding digital passports to their local peasantry. [edited]
  ‚Ü≥ 2025-08-03 03:33 gav: Now there are plenty of tech bros out there who see a feudal society (with tech bro kings sitting at the top) as some sort of thing to aim for, but as I said it's really not what I'm wanting to spend time on.
  ‚Ü≥ 2025-08-03 03:35 gav: This is part of a wider issue with the challenge-based approach: who sets the challenge and who verifies it?
  ‚Ü≥ 2025-08-03 03:36 gav: You cannot generally assume a perfect "challenge oracle". If it comes down to "trusted parties" setting a challenge and/or determining the correct answer, then you're back to feudalism.
  ‚Ü≥ 2025-08-03 03:38 gav: Idena was interesting due to the challenges being both settable and veriifiable in a transparent and decentralised manner. Bitcoin's PoW has the same properties but is obviously a device challenge rather than ostensibly human. [edited]
  ‚Ü≥ 2025-08-03 03:43 gav: Specialist devices/tech are generally not a silver bullet since they are neither transparent nor robust. (The latter becomes an issue when it becomes critical equipment for a semi-centralised "hub" to help attest to its peasantry.) [edited]
  ‚Ü≥ 2025-08-03 03:54 gav: From the linked site: 
  ‚Ü≥ 2025-08-03 03:54 gav: image.png
  ‚Ü≥ 2025-08-03 03:55 gav: üòÇ
  ‚Ü≥ 2025-08-03 03:55 gav: Anyway, I can't see anything in the linked docs which comes across as in any way robust or reliable. [edited]
  ‚Ü≥ 2025-08-03 03:56 gav: Quite the opposite; the broad vibe seems to be "attacks are getting more sophisticated so we're increasing the protocol's complexity".
  ‚Ü≥ 2025-08-03 08:56 olanod: I'm still not tattooing or getting a chip (also many people in the most populated areas of the world where the topic might still be a taboo(China?)), so I do wish to spend more of my time and "resources" on this as it is important üòÖ
PoP is indeed hard, it would be nice to solve it in a simple, elegant way but then it wouldn't be a hard problem, so it might be unavoidable for protocols that address the issue(the usable non-invasive ones at least) to grow in complexity without being able to guarantee 100% their effectiveness, society still functions despite fake passports, is it Ok to settle with almost perfect?(SLA of 99.999%)
  ‚Ü≥ 2025-08-03 08:56 olanod: > All this does is introduce a new governmental authority.

Ok then no hubs, lighter permissionless nests or the birdies alone might be enough, I think it's a bit extreme to think it would introduce some form of feudalism. Opening a new location might require an in-person gathering first with an emissary from an already established community but later those first attendants can become nests/relayers that can be as simple as gathering in a park around a (illegally installedüòà) device bound to a pole or a tree[*](https://www.seeedstudio.com/SenseCAP-Solar-Node-P1-Pro-for-Meshtastic-LoRa-p-6412.html).
  ‚Ü≥ 2025-08-03 08:56 olanod: > This is part of a wider issue with the challenge-based approach: who sets the challenge and who verifies

Challenges can come from an on-chain source, e.g. our passkey verification solution in pallet-pass checks a challenge that comes from recent block hash data, it's something public clients can get in different ways. Something like:
  ‚Ü≥ 2025-08-03 08:57 olanod: out.png
  ‚Ü≥ 2025-08-03 09:08 gav: > <@olanod:virto.community> I'm still not tattooing or getting a chip (also many people in the most populated areas of the world where the topic might still be a taboo(China?)), so I do wish to spend more of my time and "resources" on this as it is important üòÖ
> PoP is indeed hard, it would be nice to solve it in a simple, elegant way but then it wouldn't be a hard problem, so it might be unavoidable for protocols that address the issue(the usable non-invasive ones at least) to grow in complexity without being able to guarantee 100% their effectiveness, society still functions despite fake passports, is it Ok to settle with almost perfect?(SLA of 99.999%)

Don‚Äôt know if you‚Äôve noticed, but society doesn‚Äôt actually function that well any more. Passports kinda work well enough but they presume a trusted network of benevolent trusted issuing authorities, and are massively helped by physical control over the borders of these borders, state violence against rule-breakers, a total lack of personal privacy and various physical requirements (like running passport offices, requiring people to turn up there for biometrics etc). 
  ‚Ü≥ 2025-08-03 09:08 olanod: Anyway, there might be plenty of questions left and things to consider to further polish this kind of solution, it will require a good amount of iteration and prototyping, but the challenges left seem to be workable and worth a try, wdyt? I already start imagining ways to make a game that is more fun and robust, or even considerations for the firmware to allow the protocol to evolve with OTA updates fetched directly from JAM, parachain runtime style, we don't need trust hardware more than we trust an AMD/Intel processor. [edited]
  ‚Ü≥ 2025-08-03 09:12 gav: Then I don‚Äôt see how this can help prove personhood. [edited]
  ‚Ü≥ 2025-08-03 09:15 gav: > <@olanod:virto.community> > All this does is introduce a new governmental authority.
> 
> Ok then no hubs, lighter permissionless nests or the birdies alone might be enough, I think it's a bit extreme to think it would introduce some form of feudalism. Opening a new location might require an in-person gathering first with an emissary from an already established community but later those first attendants can become nests/relayers that can be as simple as gathering in a park around a (illegally installedüòà) device bound to a pole or a tree[*](https://www.seeedstudio.com/SenseCAP-Solar-Node-P1-Pro-for-Meshtastic-LoRa-p-6412.html).

The devil is in the detail. On the face of it this doesn‚Äôt sound especially robust against a determined attacker.
  ‚Ü≥ 2025-08-03 09:19 olanod: The personhood comes from the game where the device would play an active role, e.g. the user submits the time sensitive answers on its own but also the device sends "stuff" via the nest, JAM might expect the user and device answers to be found in the same 1sec block or something like that. The initial challenge of the diagram is just the way to get the key to the game room 
  ‚Ü≥ 2025-08-03 09:24 gav: Again, anything at all reliant on device is irrelevant and will not help secure PoP - indeed it could even result in undermining the real mechanism over time. If you‚Äôre going to rely on devices and trusted parties, you can just use worldcoin - it‚Äôs way easier.  [edited]
  ‚Ü≥ 2025-08-03 10:16 olanod: > we don't need trust hardware more than we trust an AMD/Intel processor.

Maybe I'm not seeing it, but it still looks solvable, firmware would come directly from the network and anything produced by the device could be verified. I'm fully on-board with not trusting hardware and I wouldn't try to build something that requires a specific vendor much less closed software, I'm Stallman level of "freedom obsession", so the solution surly would need to meet the required trustlessness criteria. [edited]
  ‚Ü≥ 2025-08-03 10:16 olanod: 

I get good pointers from the conversation, thanks the brainstorming session üôè I'll try to mature more the concept and later see if Kusama has appetite to support this kind of solution.
2025-08-01 08:46 gav: Economically strong PoP is hard.
2025-08-01 08:46 gav: Users will realise.
2025-08-01 08:47 gav: My estimation is actually $5k/month, given that running a node must be assumed to be a pretty hard-core thing to be doing and keeping an eye on. I figured that Kusama can probably skimp a bit. [edited]
2025-08-01 08:48 gav: It's not about node costs (which are high given the hardware requirements, but not super bad), but more the personnel/stress costs, and the fact that if done right then there isn't the usual node-farming which can spread costs over a large number of machines.
2025-08-01 08:49 gav: Unclear, but quite possible.
2025-08-01 08:49 emielsebastiaan: The calculation seems to omit the fixed fiat reward of 3% you mentioned at Web3 Summit for capital at stake. I.e. taxes or opportunity cost. [edited]
2025-08-01 08:49 emielsebastiaan: image.png
2025-08-01 09:07 emielsebastiaan: At a market cap of $250M and 50% stake target percentage (stake capital / total issuance) it would be an additional $3.75M/year for Kusama (with the same assumptions as before).‚Ä®So we then get to ~$10M/year for Kusama which is 4% inflation worst case (same assumptions). [edited]
2025-08-01 09:12 gav: Those are my near-term (non-PoP-based) thoughts.
2025-08-01 09:18 gav: With PoP then that 3% can be reduced since we're basically just paying validators for their trouble and incentivising voters to vote.
2025-08-01 09:19 emielsebastiaan: Ahh got it. Thx. 
1. You mention validators themselves would need stake. Is this the ‚Äòown stake‚Äô the current staking system has?
2. How much stake would a validator be required to have? 
3. Or would this be part of some game of getting pop votes? 
2025-08-01 09:19 emielsebastiaan: image.png
2025-08-01 09:39 gav: 1. Yes, we'd need to introduce a more improved validator gating, with PoP (though perhaps some allowance of running multiple nodes albeit at a reduced revenue), identity attestation (governance-backed KYC, probably delivered via PoP) and a "here I am" video. This would be in addition to a basic slashable stake to give baseline expectation that the node will be up and running. [edited]
2025-08-01 09:40 gav: 2. Unclear, but not *that* much. Maybe a few grand.
2025-08-01 09:40 gav: 3. Yes, you'd be elected via voting.
2025-08-01 09:41 emielsebastiaan: Staking design itself is probably off scope for this channel. I now understand the $6M/year. üí™üèª This is a hygiene threshold for considering KusamaJam with fixed cost (currently ~2.4% KSM inflation) which is totally acceptable. [edited]
2025-08-01 09:50 emielsebastiaan: Banning node operators from (being voted into) the validator set for bad behavior would further solve current validator centralization by limiting the number of validators per individual (pop), correct? Thus increasing nakamoto coefficient compared to the current staking design. [edited]
2025-08-01 10:36 emielsebastiaan: > But faster state resolution necessarily comes at a cost of reducing overall internal data transfers.

1. Is this a bandwidth tradeoff? 
2. Given equal amount of hard disk space for node operators for a 341 core configuration (Polkadot) and a 32 core configuration (Kusama) would this imply a potential larger consensus (accumulate) state for the 32 core configuration in contrast to the 341 core configuration? Ie implied by smaller worst case data availability size for the former?
3. Is there a real benefit of having a larger consensus (accumulate) state?
2025-08-01 10:49 sourabhniyogi: We tally 136 in GP 0.6.7 and 138 in 0.7.0 [here](https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=1275042738#gid=1275042738) -- I can't figure out how to get to 134, can you take a look at your "fetch\_params"?.   The goal is to get polkajam connectivity with "tiny" in some nightly release using our spec containing "tiny" params. [edited]
2025-08-01 10:50 sourabhniyogi: 
2025-08-01 11:06 rustybot: > <@sourabhniyogi:matrix.org> We tally 136 in GP 0.6.7 and 138 in 0.7.0 [here](https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=1275042738#gid=1275042738) -- I can't figure out to get 134, can you take a look at your "fetch_params"?.   The goal is to get polkajam connectivity with "tiny" in some nightly release using our spec containing "tiny" params.

As I said we're usong the struct introduced in 0.7.
your picture is not compliant witg 0.7. E.g. I see you don't have N and you have S (which has been removed). Please double check your table
2025-08-01 11:13 rustybot: Doing the sums of the fields you have 8x7 + 4x13 + 2x13 = 134. but pls double check as I'm ooo in a not very focused situation LOL [edited]
2025-08-01 11:22 sourabhniyogi: image.png
2025-08-01 11:23 sourabhniyogi: Ok Thanks for the 0.7 clarification, now its 134 =). Is there anything else in polkajam 0.6.7 binary that is actually 0.7.0 functionality besides this protocol parameter detail?   [edited]
2025-08-01 11:32 rustybot: Nothing that I'm aware of
2025-08-01 17:36 davxy: 0.6.7 test vectors are ready. Please try them and share your feedback
https://github.com/davxy/jam-test-vectors/pull/87
2025-08-01 22:32 advatar: @gav:polkadot.ioThe guarantee/assure/audit/judge pipeline in JAM is a fascinating approach to secure in-core execution. I‚Äôm particularly interested in how it balances economic security vs. liveness. For example, the protocol assigns ~3 validators per core to guarantee and later audit each work-package  This yields great scalability, but in theory a colluding group could try to slip in a bad state transition if they control a core‚Äôs validator subset briefly. Of course, the odds are kept low by random rotation and the heavy slashing penalties if caught. My question is: have you considered enhancing this with any cryptographic verification in the future - e.g. incorporating succinct proofs for particularly critical services or as a backstop to the audit game? JAM currently opts for crypto-economic honesty over ZK proofs (which you note helps maintain state coherence) , but as proving technology improves, it might complement the audit phase well, reducing the need to re-execute everything even in a semi-coherent model. 

2025-08-02 01:21 gav: Before you casually suggest the possibility (‚Äúin theory‚Äù) of JAM being insecure, I would suggest you read the Elves paper. It is referenced in the GP.  [edited]
2025-08-02 01:22 gav: If you want the latest information on using ZK as an alternative to Elves in JAM, see my latest talk at the Web3 Summit.  [edited]
2025-08-02 01:23 gav: Bottom line: it‚Äôs not going to be commercially comparable for some years yet. 
2025-08-02 10:35 philip.poloczek: 
2025-08-02 19:43 sourabhniyogi: Here are all the factors of 4104 below Polkadot's C=341:
```
2, 3, 4, 6, 8, 9, 12, 18, 19, 24, 27, 36, 38, 54, 57, 72, 76, 108, 114, 152, 171, 216, 228
```

What are technical reasons why 2-3 hard forks can't be planned within the above set of core numbers?

36 =x2=> 72 =x3=> 228 
36 =x3=> 108 =x2=> 228


2025-08-03 03:25 gav: The GP generally assumes a fixed V/C from block to block. There are no fundamental technical reasons why the protocol could not be changed to allow these to mutate over time (indeed there's [an issue](https://github.com/gavofyork/graypaper/issues/324) in the GP repo already) but those changes would be needed to manage the transition. I haven't taken a deep look yet, but the places where V and C are assumed constant are going to be mostly in validator set rotation, validator statistics and the core pipeline.
2025-08-03 09:09 gav: As i said, any trust in hardware would be unacceptable to me as someone who wants to build a system resilient to state-level attack.  [edited]
2025-08-03 09:09 gav: And personally unless you‚Äôre actually building something transparently trustless I really don‚Äôt see the point. 
2025-08-03 09:23 gav: 
2025-08-05 09:29 ascriv: Can I request that polkajam releases 7.0.0 and onwards align 1-1 with GP versions (not mixed)? It makes alignment with all other implementations much easier  [edited]
2025-08-05 09:34 ascriv: > <@davxy:matrix.org> Since no one wants to lose their mind over this, I think it‚Äôs a sensible idea. I‚Äôll bring it up with the team this week

Also, any word on fuzzer binaries?
2025-08-05 11:42 davxy: > <@ascriv:matrix.org> Can I request that polkajam releases 7.0.0 and onwards align 1-1 with GP versions? It makes alignment with all other implementations much easier 

Version 0.7.0 will be released soon.
Polkajam is typically released alongside the corresponding test vectors. Right now, we're gathering feedback on the 0.6.7 vectors, which teams have only recently started processing successfully.
We'll let those vectors mature for a bit longer before moving on to 0.7.0, which is already prepared (given that the changes from 0.6.7 are minimal)
2025-08-05 11:46 davxy: We're currently collecting reports here: https://github.com/davxy/jam-stuff/tree/main/fuzz-reports

If you have a binary you'd like us to fuzz, please open an issue there and include a link to it.
At the moment, we're prepared to fuzz 0.6.7 implementations [edited]
  ‚Ü≥ 2025-08-05 11:51 jaymansfield: JavaJAM is ready for 0.6.7 fuzzing: https://github.com/javajamio/javajam-releases
2025-08-05 11:47 ascriv: Thank you. Are there plans to release the fuzzer as a binary for us to test ourselves?
2025-08-05 11:48 ascriv: And regarding this I meant it would be ideal for the polkajam version Y to have same behavior as GP version Y. For the past couple releases this hasn‚Äôt been the case [edited]
2025-08-05 12:22 davxy: I see what you mean, and indeed that is the ideal.

The fuzzer and tooling shipped by the PolkaJam team are, as you'd expect, based directly on the PolkaJam sources. If a future GP version change (intentional or not) slips in, we usually keep it.
We  **generally** don't:

- maintain a separate fork for the tooling
- revert the main branch just because of future feature inclusions

We do try to stay disciplined, BTW :-) [edited]
2025-08-05 12:23 davxy: The fuzzer is stabilizing. I imagine we could share the binary once we hit 0.7.  
WDYT gav ?


2025-08-05 12:25 davxy: This naturally lets the teams iterate faster and ensures we're not the bottleneck
2025-08-06 16:16 olanod: Sharing here the two Wish For Change proposals in Kusama about how to proceed with JAM.

- [Option A](https://kusama.subsquare.io/referenda/573) - **Lightweight and independent**
- [Option B](https://kusama.subsquare.io/referenda/574) - **Full power and Polkadot friendly**

My *wishing budget* went on OptA, anyone feel free to place decision deposit for OptB. 
The context is mostly quotes from this chat, gav and Emiel let me know if I(the AI) have misquoted you or if extra context should be provided.
2025-08-06 17:53 danicuki: We have a doubt about the state serialization:
do we need to prefix each KeyValue item with its size? 
2025-08-06 19:05 davxy: No. Perhaps the confusion lies in the interpretation of the ASN.1 `SEQUENCE` keyword.

In ASN.1:

- `SEQUENCE` is conceptually equivalent to a `struct`; it represents an ordered collection of typed fields.

- A *variable-length vector* of elements of type `T` is written as:

  `SEQUENCE OF T`  
  This form includes a length prefix.

- A *fixed-length vector* of `T` with size `N` is written as:

  `SEQUENCE (SIZE(N)) OF T`  
  This form does **not** include a length prefix.

- A *variable-length byte array* is written as:

  `OCTET STRING`  
  This is effectively a shorthand for `SEQUENCE OF U8` and includes a length prefix.

- A *fixed-length byte array* is written as:

  `OCTET STRING (SIZE(N))`  
  This is equivalent to `SEQUENCE (SIZE(N)) OF OCTET`, and does **not** include a length prefix.

For context for the other readers, see the protocol message syntax:  
https://github.com/davxy/jam-stuff/tree/main/fuzz-proto#protocol-messages and the syntax for all the jam protocol types: https://github.com/davxy/jam-test-vectors/blob/master/lib/jam-types.asn [edited]
2025-08-06 19:32 emielsebastiaan: Daniel: It‚Äôs always a little weird seeing one‚Äôs words twisted by missing context. I would not have proposed option B. [edited]
2025-08-07 03:54 gav: Daniel, please do not publish an AI-twisted version of my words that you yourself would not assert full accountability for. This is extremely bad form. [edited]
2025-08-07 03:58 gav: > "Assuming validator nodes cost a bare minimum of ~$3k/month to run, it would cost $3m/month, $36m/year" for full configuration, but "Kusama could reasonably... have Kusama run a smaller JAM (perhaps just 32-core)" - Gavin Wood

Please give a reference to this quote.
2025-08-07 04:47 olanod: Alright, my bad, I checked some of the quotes and looks god on the surface but perhaps it's better without the quoting. The main idea that I wrote on the remarks remains, Opt.A: light, fast, cheaper, independent configuration. OptB: Standard params, non-biased towards KSM, and crossing fingers that Polkadot joins later to share security costs. We can always have an option C if there's something fundamentally wrong with the other two.
2025-08-07 04:54 gav: Daniel, I choose my words here carefully. What you did is despicable and dishonourable. 
2025-08-07 04:55 gav: You made a false quote of me and published it in a highly central community space as the truth.  
2025-08-07 04:56 gav: If you foolishly entrust my reputation to AI, you can count my support for you at an end. 
2025-08-07 04:57 olanod: Knowing AI is as quirky as it is my first reaction was to share it here. Sorry to hear you feel that way, I'll be a better human next time üôè
2025-08-07 04:58 gav: YOU posted that, not the AI. Man the fuck up. 
2025-08-07 04:58 gav: I trust this is mere foolishness and not malice, so I will give you a second chance. If you value your honour and my company, never ever use AI to speak for anyone other than yourself. 
2025-08-07 05:06 gav: Publishing lies and asking the victim to fact-check is *at best* ignorant and lazy. 
2025-08-07 05:07 olanod:  No lazy AI quoting, lesson learned for life ü´° [edited]
2025-08-07 05:08 gav: Good ü´°
2025-08-07 21:16 shimonchick: Hey everyone. I am trying to reproduce the Altnames. Reading the Graypaper they seem to start with "$" and the alphabet seems to include $ in the start. I cannot see that behavior in the dev-config or in polkajam. Also are they based on the ed25519 public key or the bandersnatch one.  Thoughts are appreciated [edited]
2025-08-07 21:19 dave: $xyz just means the ASCII string "xyz", the $ is part of the notation. This ought to be covered in the notation section at the start of the paper, but I can't find it so possibly it is missing.
2025-08-07 23:46 sourabhniyogi: ```
# bin/polkajam --version
polkajam 0.1.24
GP 0.6.7
# bin/polkajam-testnet
testnet: Working directory: /tmp/testnet-PGBe0P
node0: 2025-08-07 23:46:25 main INFO jam_node  Chain ID: dev
node0: 2025-08-07 23:46:25 main INFO jam_node  Config dir: /tmp/testnet-PGBe0P/node0/conf/dev
node0: 2025-08-07 23:46:25 main INFO jam_node  Data dir: /tmp/testnet-PGBe0P/node0/data/dev
node1: 2025-08-07 23:46:25 main INFO jam_node  Chain ID: dev
node1: 2025-08-07 23:46:25 main INFO jam_node  Config dir: /tmp/testnet-PGBe0P/node1/conf/dev
node1: 2025-08-07 23:46:25 main INFO jam_node  Data dir: /tmp/testnet-PGBe0P/node1/data/dev
node2: 2025-08-07 23:46:25 main INFO jam_node  Chain ID: dev
node2: 2025-08-07 23:46:25 main INFO jam_node  Config dir: /tmp/testnet-PGBe0P/node2/conf/dev
node2: 2025-08-07 23:46:25 main INFO jam_node  Data dir: /tmp/testnet-PGBe0P/node2/data/dev
node3: 2025-08-07 23:46:25 main INFO jam_node  Chain ID: dev
node3: 2025-08-07 23:46:25 main INFO jam_node  Config dir: /tmp/testnet-PGBe0P/node3/conf/dev
node3: 2025-08-07 23:46:25 main INFO jam_node  Data dir: /tmp/testnet-PGBe0P/node3/data/dev
node4: 2025-08-07 23:46:25 main INFO jam_node  Chain ID: dev
node4: 2025-08-07 23:46:25 main INFO jam_node  Config dir: /tmp/testnet-PGBe0P/node4/conf/dev
node4: 2025-08-07 23:46:25 main INFO jam_node  Data dir: /tmp/testnet-PGBe0P/node4/data/dev
node5: 2025-08-07 23:46:25 main INFO jam_node  Chain ID: dev
node5: 2025-08-07 23:46:25 main INFO jam_node  Config dir: /tmp/testnet-PGBe0P/node5/conf/dev
node5: 2025-08-07 23:46:25 main INFO jam_node  Data dir: /tmp/testnet-PGBe0P/node5/data/dev
node0: 2025-08-07 23:46:25 main INFO jam_node::chain  Reading state...
node2: 2025-08-07 23:46:25 main INFO jam_node::chain  Reading state...
node3: 2025-08-07 23:46:25 main INFO jam_node::chain  Reading state...
node1: 2025-08-07 23:46:25 main INFO jam_node::chain  Reading state...
node5: 2025-08-07 23:46:25 main INFO jam_node::chain  Reading state...
node4: 2025-08-07 23:46:25 main INFO jam_node::chain  Reading state...
node0: 2025-08-07 23:46:26 main ERROR jam_cli  Error: Chain error: VmEngine(EngineInitializationFailed(Error(Owned("failed to create a worker process (0 already exist): failed to fetch the userfaultfd from the child process: recvfd failed: received zero bytes (root cause: failed to create an userfaultfd: userfaultfd (errno = 1 (EPERM)))"))))
Error: node0 exited abnormally: exit code 1
``` [edited]
2025-08-07 23:47 dave: `sudo sysctl -w vm.unprivileged_userfaultfd=1`
2025-08-07 23:47 sourabhniyogi: Thank you that worked! [edited]
2025-08-08 19:22 sourabhniyogi: Alright David Emett : We got our "numerical recipes in C" battery of tests to match up work report hashes for a couple dozen work packages with different recipes and want to know how to compare polkajam refine executions (with 100M-2B gas) with ms level accuracy -- can you advise on how we should do this accurately?

We turned on `RUST_LOG=polkavm=trace` (where I thought there was some PVM refine execution timing info but I could be hallucinating =) ) and can't find anything, and its "second level accuracy" rather than "millisecond level accuracy"

Also, since we want to actually go up to 2B gas (2s or more) is there some "too much refine gas" limit outside of GP we should know about [when we use 2B or more we hit a "too much refine gas" error from polkajam]?
2025-08-08 19:28 dave: If you want something now, I believe there is a log message which includes the amount of time taken to execute refine. You need log level debug with target chain-core AFAICT. Longer term the telemetry stuff will expose refine timing and more. I've got that mostly implemented in PolkaJam now, but it's not on the main branch yet and so it is not included in the nightly builds. Hopefully that will change in the next couple of weeks.
  ‚Ü≥ 2025-08-08 20:28 sourabhniyogi: Found it -- thank you!

```
2025-08-08 20:27:49 tokio-runtime-worker DEBUG chain-core  Refine OK with result: Ok("") using 698 gas, took 475.496963ms
```
  ‚Ü≥ 2025-08-08 20:44 sourabhniyogi: So we see the first comparisons and believe polkajam should be able to process at 1B gas/second, but we're seeing performance far less than that -- how can we get the totally optimal performance out of polkajam to do an apples-to-apples comparison of polkajam vs our jam implementation:
```
polkajam-3.log:2025-08-08 20:37:08 tokio-runtime-worker DEBUG chain-core  Refine OK with result: Ok(0x1821201f) using 95211247 gas, took 1.057200902s
polkajam-3.log:2025-08-08 20:37:27 tokio-runtime-worker DEBUG chain-core  Refine OK with result: Ok(0x31252724221f) using 178149455 gas, took 1.838010218s
polkajam-3.log:2025-08-08 20:37:46 tokio-runtime-worker DEBUG chain-core  Refine OK with result: Ok(0x1c21182531240920) using 191725861 gas, took 3.215107299s
```
We are currently running with:
```
@for i in 0 1 2 3 4; do \
                RUST_LOG=chain-core=debug bin/polkajam  --chain chainspecs/jamduna-spec.json run --pvm-backend compiler --temp --dev-validator $$i --rpc-port=$$((19800 + $$i)) >logs/polkajam-$$i.log 2>&1 & \
        done
```
What does "using 95211247 gas, took 1.057200902s" refer to exactly, like what is the start and what is the end of that measurement?

Our current measurement is

```
=== VM recompiler Execution Summary (service algo, 50832 bytes, refineGasUsed 95211247)===
Phase            Duration       Percent
Initialization   42¬µs             0.01%
StandardInit     10.695ms         3.30%
Compile          55.985ms        17.26%
Execution        257.550ms       79.38%
Total            324.447ms   
```
with the 6th node being our jam implementation, surely with different methodology -- can you advise?
  ‚Ü≥ 2025-08-08 20:52 dave: It measures across load+compile+execute, so should be comparable to your total. If you're seeing poor performance it's likely in the integration of PolkaVM with PolkaJam or in some hostcall implementation; while I believe PolkaVM is well-optimised at this point, we haven't spent much time optimising PolkaJam. There are many places where the code is not very efficient. If you want a good benchmark for your recompiler I would suggest using PolkaVM standalone for now [edited]
  ‚Ü≥ 2025-08-08 21:03 sourabhniyogi: Ok!  How do we invoke PolkaVM standalone with a work package (or work package bundle)?  Can we just get the Compile + Execute part timing instead, without any loading? 

Jan Bujak  Can you chime in on the exact recipe for doing this?  We'd like to know if we're at 50% or 70% or 100% of PolkaVM performance (in the sense of M3 vs M4) after a summer of opcode optimization =) [edited]
  ‚Ü≥ 2025-08-08 21:06 dave: That is not possible, but in any case wouldn't give different results -- it would still be using the PolkaJam hostcall impls etc, some of which are quite inefficient at the moment. It is possible to run eg doom on PolkaVM directly, without any JAM stuff involved. IDK any more details.
  ‚Ü≥ 2025-08-08 21:24 sourabhniyogi: For our test workpackages [and accumulates], these "numerical recipes in C" payloads are doing "pure" execution without any host function calls except "log" (which we can eliminate).  These + doom work packages (that also doesn't do any host function calls) can support everyone doing apples-to-apples comparisons.  How else can we know if teams are at M3 vs M4 performance? 
  ‚Ü≥ 2025-08-08 21:26 dave: You can't know, because the performance requirements aren't even defined yet
2025-08-08 20:38 ge0321: Hi Dr. Wood,

I‚Äôve been following the discussions around a potential DOT supply cap, especially the community-driven models being explored following the OpenGov RFP. A 2.1B max supply seems to have strong support and may eventually go to a vote.

I was wondering:

Is it technically feasible to implement a fixed supply cap like 2.1B within JAM?

If so, how would this be enforced. Would it require changes at the core runtime level?

Some community members have said that once this is enshrined in JAM, any future changes would require a hard fork. Is that correct?

I‚Äôve looked through the JAM Gray Paper but haven‚Äôt found a section that addresses supply mechanics directly, or I may have missed it somewhere. Is this something planned for a future revision?

Appreciate your time and all the work you continue to do.
2025-08-08 20:43 emilkietzman: ima_ce00723.jpeg
2025-08-08 20:43 emilkietzman: 
2025-08-09 08:02 davxy: Anyone else want a little fuzz action?

https://github.com/davxy/jam-conformance/issues
2025-08-09 09:32 boymaas: Yes! Let me prepare the 0.6.7 ü§†
2025-08-09 10:10 boymaas: Uploaded a new version ready for some fuzzing action ü§û which passes all the v0.6.7 testvectors: https://github.com/jamzig/conformance-releases [edited]
2025-08-09 14:11 sourabhniyogi: Cool, thank you for leading the way and getting our juices flowing --  can we get the 0.6.7 fuzzer binary posted please?   
2025-08-11 11:54 dvladco: Hi davxy,

we are struggling to pass some accumulation test vectors. The actual accumulate gas used is 2 less than expected for the test vectors bellow. I checked the `Gas Costs` section from the readme and it aligns with our implementation. Is it possible that 2 instructions are not being called? Can you provide more info maybe some traces from the vm or point us in the right direction, or maybe you have some intuition what could be wrong.

These are the failing tests: (`accumulate_ready_queued_reports-1 gas 15014 instead of 15016, enqueue_and_unlock_chain-3 5618 -> 5620, enqueue_and_unlock_simple-2 5659 -> 5661, enqueue_and_unlock_with_sr_lookup-2 5612 -> 5614, process_one_immediate_report-1 4290 -> 4292, queues_are_shifted-1 4290 -> 4292, ready_queue_editing-2 4301 -> 4303, same_code_different_services-1 4256 -> 4258`)

Is anyone else having this issue as well? [edited]
2025-08-11 16:18 clearloop: if it is possible introducing a wild range of trace tests for `0.6.7`, not limited by storage and preimages? for example generating 100 traces with the current fuzzing mechanism for us to work on ( if introducing a fuzzer binary is overkilling atm )

I just updated our fuzzer today and tried on sort of reports in the repo, unfortunately, we failed on the cases reported from other teams as well üòÇ  it seems the workflow can be more efficient once we have more trace tests before testing with the fuzzer given that there is no team can process more than 4 blocks atm [edited]
2025-08-11 16:54 ascriv: the binary should be released soon which will improve efficiency a lot
2025-08-11 16:55 ascriv: i imagine that would be easier than making a better trace distribution, but not sure
2025-08-11 17:27 davxy: Some teams fail after more uncharted hostcalls (i.e., not covered by the static traces and test vectors). Most of them pass simple fuzzing for storage R/W, preimage provisioning, safrole. etc

We're adding more and more host calls and tricks trying to break targets, and it‚Äôs being updated very frequently (still in alpha). That said, I think we can share the binary to **increase the current bus factor**.

Bit I can‚Äôt make this decision alone. I‚Äôll try to discuss it with the team tomorrow
2025-08-11 17:32 davxy: One additional interesting topic to discuss is: do we expect implementers to support "simple" forks?  

The fuzzer can be instructed to generate *N* mutants of certain blocks and attempt to import them before importing the original block. The next block is always built over the original - meaning even if a mutant is imported successfully, that fork is always discarded.  

I expect this scenario to be allowed for fuzz testing, as it leads to way more interesting results. In fact, I‚Äôve noticed that most implementations fail under these conditions.
2025-08-11 17:36 davxy: Perhaps if an implementation doesn‚Äôt support forks yet, then given *X* blocks with the same parent, I can send the `SetState` message *X* times to the target (once before importing each of the alternatives) - effectively resetting the state each time.
2025-08-11 17:37 davxy: I need to check if forks managent are expected for M1
2025-08-11 17:38 ascriv: yeah seems like a question for those who are awarding the prizes, not the implementors, imo. but let us know when you do
2025-08-11 18:11 davxy: Actually, it might be simpler than that. You don't need to support "true" arbitrary forking for the fuzzer to work.

The closest you need to get to forking is receiving a block with the same parent as the one just imported (trivial forking :-)). In that case, you simply restore the previous state by discarding the last posterior state ( the original block will be always provided as the last one).

This should be easier to implement since you only need to keep one snapshot around, rather than managing full forking. I think this is both reasonable and necessary for effective fuzzing.

I'll discuss this topic as well. [edited]
2025-08-11 18:33 davxy: AFAIK, most of the active teams are now passing the test vectors and are aligned on gas consumption. I can share a couple of PVM traces for the vectors if that helps [edited]
  ‚Ü≥ 2025-08-12 08:25 dvladco: If you can this will help us tremendously, we could check instruction by instruction and see where we are off, thank you üôè 
  ‚Ü≥ 2025-08-12 10:57 vinsystems: I have the same problem of a 2 gas unit difference, but in test vectors different from yours. In enqueue_and_unlock_chain-3 I can correctly calculate the gas used. I have uploaded a [log of the traces](https://gist.github.com/bloppan/950f29173670473ff900a367800fbffa) instruction by instruction in case it helps you. Could you please share a log of traces from the enqueue_and_unlock_chain-4 test?
  ‚Ü≥ 2025-08-12 11:34 dvladco: these are my traces for `enqueue_and_unlock_chain_wraps-2` one of the tests that is passing: https://gist.github.com/danielvladco/e9d33e2448feb68fc9514c22afd15b70
  ‚Ü≥ 2025-08-12 11:55 dvladco: nevermind I was looking at the wrong test sorry for that
  ‚Ü≥ 2025-08-12 11:56 dvladco: here are the traces for the enqueue_and_unlock_chain-4 https://gist.github.com/danielvladco/4e1bd0bec146a4ddb6ed0b0c31e57bd8
  ‚Ü≥ 2025-08-12 13:51 dvladco: I have found the issue, the problem was that the write host call was returning the wrong result
  ‚Ü≥ 2025-08-12 15:12 vinsystems: Nice! In my case the problem was in my test module. I wasn't saving properly the storage keys
2025-08-11 19:48 dhruv245: Hi, Is there an ETA for when milestone submissions will open?
2025-08-12 06:53 ascriv: > <@gav:polkadot.io> 0.7.0 is where I would be happy to accept M1 submissions. 

From gav a while ago^. So I guess what‚Äôs left is polkajam to get to 0.7.0 and complete the fuzzer (and fuzzer binary), and then teams can start submitting their 0.7.0 jam binaries which clear the fuzzing
2025-08-12 06:53 ascriv: so probably quite soon
2025-08-12 11:38 roysingh8368: Hello team,

I'm now focusing on integration testing for my JAM node. I'm looking for a specific type of test vector: a single, complex block payload designed to test the interactions between multiple components of the state transition function at once.

For example, a block that includes a mix of extrinsics like ticket submissions, work-report guarantees, availability assurances, and disputes, which would trigger a complex accumulation phase. The goal is to validate the entire workflow as a whole on an isolated node.

Does anyone have or know of a canonical integration test case like this? or if it already available in the Jam-test-vector . 
  ‚Ü≥ 2025-08-12 13:25 roysingh8368: davxy:
2025-08-12 11:38 dvladco: 
2025-08-12 11:55 anish1222: i am also wanted the same thing full test payload for my node [edited]
2025-08-12 19:22 rustybot: 
2025-08-12 19:31 rustybot: For simpler scenarios, we provide traces in the test vectors [repository](https://github.com/davxy/jam-test-vectors/tree/master/traces).  
More involved (though still not very complex) scenarios are currently tested using the fuzzer. You may eventually want to implement the target side of the fuzzer [protocol](https://github.com/davxy/jam-conformance/tree/main/fuzz-proto) [edited]
2025-08-13 15:15 decentration: should the M1 submission be based on 0.7.0 or should we continue focussing on the latest release (>0.7.1) before submitting
2025-08-14 05:31 shimonchick: Also on Rules 14 -16: What is considered timely fashion and which network should messages be placed on? Is a simple public mapping from timestamp to commit hash sufficient, or do we care about other info for a specific implementation on-chain?
2025-08-14 05:31 shimonchick: telegram-cloud-photo-size-4-5823655781847911928-y.jpg
2025-08-14 06:45 dakkk: maybe polkadot? üòÇ  the timestamping means you put the commit hash in a block (via extrinsic, opreturn or wathever), the timestamp is the block timestamp
2025-08-14 06:47 dakkk: the "timely fashion" is once a week for me
2025-08-14 07:00 ascriv: I just have a private github repo, presumably that‚Äôs ok. I figured the ‚Äúin private‚Äù meant like off GitHub even  
2025-08-14 07:01 dakkk: it's ok to have a private repo, but you should also have a timestamped history
2025-08-14 07:07 ascriv: Hmm I don‚Äôt have that... But there must be another way for people in my position to verify they wrote the code organically? The timestamps are on GH‚Äôs servers they‚Äôre just not public 
2025-08-14 07:08 jan: Git commit timestamps are not reliable; they can be edited at will. [edited]
2025-08-14 07:09 xlchen: github pr should be fine? their timestamp cannot be edited
2025-08-14 07:09 ascriv: I mostly committed directly to main :/
2025-08-14 07:09 dakkk: you can fake them if you want; that's why they're requesting a public timestamp
2025-08-14 07:10 ascriv: Is there anything I can do to still be eligible for m1?
2025-08-14 07:14 jan: No idea; I would look through the Github API and see if there's a way to perhaps fetch unfakeable timestamps or something like that. Like, I can see with a cursory look that they do have an events API which apparently has timestamps telling you when commits were pushed? https://docs.github.com/en/rest/activity/events?apiVersion=2022-11-28
2025-08-14 07:15 jan: But whether W3F will accept this in lieu of rule 16 (assuming these are actually unfakeable) - I have no idea. You need to clarify with them. [edited]
2025-08-14 08:07 dakkk: maybe you only have to do an 8 hours oral exam with gav about the graypaper and your code üòÅ
2025-08-14 10:17 decentration: will the fuzzer (eventually) be supporting >0.7.1 for M1? or should we stick to passing 0.7.0. just want to know what i should prioritise for davxy 
2025-08-14 10:23 oliver.tale-yazdi: You can use this in CI to remark every master commit, we used that from the beginning: https://github.com/JamBrains/remark-commit
2025-08-14 10:42 davxy: The fuzzer will eventually support version 0.7.1 (as will polkajam).

At the moment, we are fuzzing 0.6.7\* (\*with some deviations, see [here](https://github.com/davxy/jam-test-vectors/pull/87)).

We plan to switch to 0.7.0 as soon as at least one team can be fuzzed for a few seconds without deviating from the fuzzer's expectations or crashing :-)

**For now, my advice to all teams:**

If you have a 0.6.7 (or 0.7.0) implementation:

- Propose it [here](https://github.com/davxy/jam-conformance/issues)
- Try the other teams' published traces to see if you pass where they fail  (I'm going to create an `archive` folder)
- Follow updates [here](https://github.com/davxy/jam-conformance?tab=readme-ov-file#latest-updates) [edited]
2025-08-14 10:47 davxy: **About the fuzzer binary release:**  

We discussed this internally, and we have decided not to share it yet to avoid biasing implementations toward the fuzzer's results.  
The fuzzer is **not** and will never be a reference implementation. When it detects a difference, it is more productive to discuss it openly so we can verify the correct behavior together. Otherwise, teams might end up matching the fuzzer's quirks rather than the gray paper.  

As more teams join, we probably expose the fuzzer in a rate-limited way (e.g. a web service), with failures reported to us and made public on GitHub for community inspection.

We also encourage teams to write their own fuzzer implementations, not just the target.  
This is not mandatory for M1, but it can help having more robust implementations

2025-08-14 23:52 charliewinston14: Hi Jan Bujak , I'm reading your talk_recomp.pdf and had a question. Do you generate the assembly for the entire program blob and run it, or do you go basic block by basic block? Is there a strategy there?
  ‚Ü≥ 2025-08-14 23:53 jan: I translate the whole program once in one go.
  ‚Ü≥ 2025-08-15 23:50 sourabhniyogi: image.png
  ‚Ü≥ 2025-08-15 23:56 sourabhniyogi: Jan Bujak: We were able to achieve very similar performance in a refine with a parent-child setup of "game of life" in 5 polkajam + 1 jamduna tiny testnet (using the full range of machine/pages/poke/invoke/peek/export) -- we believe the numbers were more similar than our "numerical recipes" because we limited our host log calls (100) to an absolute minimum.  

We took the data measurements with 
```
2025-08-15 19:39:25 tokio-runtime-worker DEBUG chain-core  Refine OK with result: Ok("") using 73579 gas, took 18.903349ms
```

We had though this included a JIT compilation + execution but is the reported "took __ ms" 
(a) an AOT compile time + execution (which is what we have now)
or 
(b) just the execution alone
?

We'd love to redo this experiment with "picoalloc" [here](https://github.com/koute/picoalloc) (and get 100% JAM ready "doom work packages") -- can you advise how to jump into the middle of this?

  ‚Ü≥ 2025-08-16 00:03 dave: That time includes loading and compilation. There is a compilation cache though so in practice it sometimes doesn't really include compilation
  ‚Ü≥ 2025-08-17 14:31 clearloop: if the pvm format contains function layout that we can try JIT given the refine invocation starts at pc=0 and accumulate starts at pc=5
  ‚Ü≥ 2025-08-17 14:32 clearloop: also, since refine is running offchain and accumulate is on chain, why don't we split them into two binaries, or we can simply try to compile the binary into two functions

- refine -> path(pc=0)
- accumulate -> path(pc=5) [edited]
2025-08-15 02:45 sourabhniyogi: If you are hungry for a fuzzer binary, we published ours here:

 https://github.com/jam-duna/jamtestnet/releases/tag/v0.6.7.15

along with our fuzzer target, which can dump out PVM traces with a "--pvm-logging debug" input.  If you're looking to get your fuzzer target built (after passing the 0.6.7 traces) or are stuck on some fuzzer target and need a PVM trace log, this should help you.  Would be great to have all fuzzer targets have a kind of "--pvm-logging" feature so we can get ourselves unstuck as well. [edited]
2025-08-15 03:45 davxy: What features does the fuzzer support?  
For example: invalid blocks via white-box mutations, random bit flips, types of host calls it can trigger, skip slots etc.  

It would be useful to have a list of these published somewhere.  
We can share ours as we go, in the form of a task list, since we have not yet implemented all our ideas. [edited]
2025-08-15 05:19 sourabhniyogi: Only "invalid blocks via white-box mutations" for your major stf { safrole, reports, assurances } errors (not disputes or preimages), which in the end was around 3 dozen or so.  We'll try everyone's fuzzer target with this simple fuzzer over the next couple of weeks as teams pass your 0.6.7 to see if it actually finds issues, also using the challenging jam-conformance "archive" as a source test bank.   [edited]
2025-08-15 05:23 sourabhniyogi: image.png
2025-08-15 05:23 sourabhniyogi: That's the scope of what we attempted to do.
2025-08-15 05:24 sourabhniyogi: Having a task list and having different teams do different parts is a wonderful idea.
2025-08-15 05:24 ascriv: R.E. The timestamped commit hashes, seems my interpretation aligns with gav‚Äôs: only required if you‚Äôre not on GitHub or similar. I will still add them going forward anyway (OTS seems good for this) but if anyone else hasn‚Äôt been putting commit hashes on a blockchain, but still used GitHub, should be fine  [edited]
2025-08-15 19:55 sourabhniyogi: We would be most keen to extend your fuzzer / target protocol to support refining (and fuzzing refine-specific host functions machine/peek/poke/invoke/pages/historical\_lookup deeply), adapting it to invoke refine like CE134 here 

```
--> Work Package Bundle ++ Core Index ++ Segment Root Mappings ++ Timeslot
<-- Work Report
```

If you write up your precise design, we (all teams) can publish our fuzzer+target according to spec so we win basic coverage on "the other half".   I'm sure you'll have an even better fuzzer as follow up, but its clear this fuzzer protocol is easier for teams to get in the middle of relative to all of JAMNP and forces attacking availability specifiers head on. [edited]
  ‚Ü≥ 2025-08-16 02:01 clearloop: curious about when you testing your refine logic, which jam-pvm-comon ur using, we had a fork at 0.6.6 but it's currently not ideal to me updating it to 0.6.7 since it will make our fork contains more and more diff with the official one
  ‚Ü≥ 2025-08-16 02:56 sourabhniyogi: We are not using jam-pvm-common but polkatool 

https://github.com/colorfulnotion/polkavm/blob/dev/services/algo/src/main.rs#L5006
https://github.com/colorfulnotion/polkavm/blob/dev/services/algo/src/main.rs#L5049

Cost: we have to update the [parse_{refine/accumulate}_args](https://github.com/colorfulnotion/polkavm/blob/dev/services/utils/src/functions.rs) as the codec details changes ourselves, which pretty much happens like every version ;)
Benefits: by eliminating using the "official" abstraction we are more in control and don't have to wonder if its the abstractions fault or ours when Bad Things Happen -- its always our fault =)!
2025-08-18 09:02 aang114: Hi @davxy and everybody else, I noticed that in GP 0.6.7 that the **service's storage dictionary's keys** are **blobs** now instead of **hashes** (https://github.com/gavofyork/graypaper/pull/406). Therefore, may I please enquire, when we deserialize the entire state - how are we expected to calculate the service's minimum/threshold balance (https://graypaper.fluffylabs.dev/#/7e6ff6a/117b01117b01?v=0.6.7)? Since now we need the **blob's length**, but there doesn't seem to be any way of deserializing the blob's length from the 31-byte state key. Thanks [edited]
2025-08-18 09:04 luke_jamixir: I'm wondering the same thing. Especially in the context of fuzzing 
2025-08-18 09:43 dave: You are not expected to deserialize the entire state. In the case of the threshold balance this is explicitly stored alongside other account info and is expected to be updated incrementally as relevant state changes are made.
2025-08-18 10:39 ascriv: FWIW, threshold balance doesn‚Äôt have to be stored, my impl derives it from total items used , total octets used, etc on the fly 
2025-08-18 10:39 ascriv: But total octets used and total items used , yes I believe they must be kept track of and maintained 
2025-08-18 12:26 dave: > <@ascriv:matrix.org> But total octets used and total items used , yes I believe they must be kept track of and maintained 

Yes, sorry. This is accurate.
2025-08-18 16:21 davxy: The latest batch contains **highly controversial reports** ,  either we‚Äôre making a serious mistake,  
or perhaps many people have overlooked something. Most of the failures involve host calls with malicious arguments.  

I‚Äôll be digging into these as well.  

Have fun :-)  

https://github.com/davxy/jam-conformance/tree/main/fuzz-reports

2025-08-18 16:22 dakkk: > <@davxy:matrix.org> The latest batch contains **highly controversial reports** ,  either we‚Äôre making a serious mistake,  
> or perhaps many people have overlooked something. Most of the failures involve host calls with malicious arguments.  
> 
> I‚Äôll be digging into these as well.  
> 
> Have fun :-)  
> 
> https://github.com/davxy/jam-conformance/tree/main/fuzz-reports
> 

Any time estimation for 0.7.0 traces?
2025-08-18 16:26 davxy: TBH, we already have it. It's just going through the review process. Hopefully by next week.
2025-08-18 16:31 dakkk: > <@davxy:matrix.org> TBH, we already have it. It's just going through the review process. Hopefully by next week.

Awesome üëç
2025-08-18 16:32 ascriv: üíÄ
2025-08-18 16:34 ascriv: my guess is page fault stuff
2025-08-18 16:34 ascriv: but idk hm
2025-08-18 16:37 ascriv: actually my diffs are minor. basically just gas used in service stats. will look now
2025-08-18 16:47 ascriv: @davxy can you double check if the gas used for service index 3202820706 in test 1755531322 is expected to be 0? I have a similar concern for most other tests in that set too [edited]
2025-08-18 17:29 davxy: I expect (hope) that most of these issues share the same root cause.  
If anyone finds any interesting updates, please note them in the GitHub issue.  
I won't be able to look into this until Wednesday
2025-08-18 19:18 jaymansfield: It almost looks like polkajam may skip accumulation if the refine result is BAD. I can't seem to find anything in the GP suggesting to do this though so my conclusion may be wrong but that's my first guess. There are 6 traces that follow this pattern. [edited]
2025-08-19 07:07 davxy: We have gas accounting issues, so most traces in the last batch should be ignored ([NEWS](https://github.com/davxy/jam-conformance/blob/main/NEWS.md))
2025-08-19 11:53 sourabhniyogi: It appears necessary to take a stand on when and whether gas accounting should be done 1 instruction at a time (interpreter start) vs basic block at a time (recompiler end), and what to do in the `gas` host function call given it may appear anywhere in a basic block.
2025-08-19 12:09 jan: The GP is pretty clear in this regard. Currently handling gas one-instruction-at-a-time is correct. The final gas cost model will most certainly be basic block at a time.
2025-08-19 16:01 sourabhniyogi: Since we're now actually trying to conform to 0.6.7 and navigate to 0.7.1 to 1.0, it is likely useful to specify that starting at version { ... } of GP, it will switch from one to the other.  Implementers will set up flags etc. to coordinate conformance to one-instruction-at-a-time vs basic block at a time in expectation of this eventuality.  What is the reason to delay the switch any further?
2025-08-19 16:47 sourabhniyogi: The "32 core Kusama JAM" https://kusama.polkassembly.io/referenda/573 is basically passing tomorrow.  Can we get the byte level protocol specs for this?  The Toaster can fit 10 Kusama JAMs.  Can we call this "medium" relative to "tiny" and "full"?
2025-08-19 16:50 davxy: The gas issue should be fixed. Some new traces+reports submitted.
https://github.com/davxy/jam-conformance/tree/main/fuzz-reports
2025-08-19 20:02 rustybot: How about creating a public channel for inter-team discussions on test vectors, conformance, and reports? This room works, but it's broad and sometimes includes off-topic or non-technical chats. A dedicated channel could help keep technical exchanges easier to follow.
edit: technical exchanges only about conformance [edited]
2025-08-19 20:06 rustybot: The GP room isn't an ideal fit either, since it‚Äôs more focused on GP improvements and editing
2025-08-19 22:27 sourabhniyogi: We have an JAM Implementers DAO #implementers room in Discord [here](https://discord.gg/mu7VCQHwpc)  (created by + managed by Kyrylo Pisariev | Gossamer | CS  ) , and a Matrix room ( originally created by me, abandoned in favor of the former, but can be resurrected specifically for conformance).  We tend to talk more if there are 10x fewer people, but both rooms are/were pretty quiet -- but maybe with jam-conformance and davxy keeping us on our toes we will naturally need to communicate more quickly.   

The key requirement, as most of us know, is that whatever is discussed is open to all and the past is archived so everyone new can access it (even AI agents).   I think someone set up an archive for the discord room, not sure if they succeeded (share link if so?).   This room is very well archived already.  

2025-08-20 01:30 cisco: The fluffylabs team created an amazing website that searches on the paper, matrix rooms and the jam implementers discord: https://search.fluffylabs.dev/
2025-08-20 03:25 ascriv: Maybe we can just have a new issue in the jam-conformance repo just for general discussion?
2025-08-20 03:28 clearloop: I remember gh has the discussion feature by default, just need to open in the repo settings, for example https://github.com/spacejamapp/specjam/discussions [edited]
2025-08-20 06:16 anish1222: can you explain what are the key value pairs in the traces-> safrole test vectors?????

"pre_state": {
        "state_root": "0x87895c582222f62827fabcc4b59c61163b767752a3818fbd89e0356001dfe627",
        "keyvals": [
            {
                "key": "0x004700b0000000000b0cce53c35439dfe73087b1439c846b5ff0b18ec0052e",
                "value": "0x0100000000"
            },
            {
                "key": "0x00dd00ba00010000cced2ebcc7a238699d0973f70cc6f6772e084efaf9d26f",
                "value": "0x0100000000"
            },


2025-08-20 06:20 ascriv: This is the encoding of the full state as described in the state serialization section of the gray paper 
2025-08-20 06:21 ascriv: In particular this is the state before the block in that test vector was imported (pre_state)
2025-08-20 06:25 davxy: https://github.com/davxy/jam-conformance/discussions
2025-08-20 12:25 rossbulat: Good day all, 
Could someone please share a discord link for the DAO please, in relation to getting feedback for a proposal.
Thanks in advance,
2025-08-20 12:26 oliver.tale-yazdi: There is one top here, https://docs.jamcha.in/ i think it should still work 
  ‚Ü≥ 2025-08-20 12:27 rossbulat: Thanks!
2025-08-20 12:26 cisco: Latest version of the JAM SDK (0.1.22) is not in line with 0.6.7, right? Is there going to be one?
2025-08-20 12:33 cisco: I'd love to use it to test custom services on our client
2025-08-20 12:47 clearloop: I think the answer is no, hope we can have it at `0.7.1`
2025-08-20 14:18 tomusdrw: > <@anish1222:matrix.org> can you explain what are the key value pairs in the traces-> safrole test vectors?????
> 
> "pre_state": {
>         "state_root": "0x87895c582222f62827fabcc4b59c61163b767752a3818fbd89e0356001dfe627",
>         "keyvals": [
>             {
>                 "key": "0x004700b0000000000b0cce53c35439dfe73087b1439c846b5ff0b18ec0052e",
>                 "value": "0x0100000000"
>             },
>             {
>                 "key": "0x00dd00ba00010000cced2ebcc7a238699d0973f70cc6f6772e084efaf9d26f",
>                 "value": "0x0100000000"
>             },
> 
> 

We've made a small tool to decode these kind of test files. You can check it out here: https://state.fluffylabs.dev
2025-08-20 18:44 sourabhniyogi: New "JAM Conformance" room (public, unencrypted) -- https://matrix.to/#/#jam-conformance:matrix.org -- meant for volatile discussions around fuzzer/targets related to https://github.com/davxy/jam-conformance/issues 
2025-08-21 16:56 dakkk: is someone still passing pvm tests from koute after updating to >= 0.6.7?
2025-08-22 06:22 dakkk: I do it either, but I think A.19 may be missing a boundary check
2025-08-24 06:12 olanod: Heads up! The Kusama community has voted for the first JAM implementation to be ["Lightweight and independent"](https://kusama.subsquare.io/referenda/573). üê¶‚Äç‚¨õ
There's still a long way to go but it would be interesting to start thinking about the implications and requirements for such configuraron with only 32 cores for 1sec block production, perhaps different recommended configurations can be named as appendixes in the gray paper?
  ‚Ü≥ 2025-08-24 19:03 bkchr: Personally I don't see any value in this. Especially as we could think about combining polkadot and kusama into one instance to get more usage. 
  ‚Ü≥ 2025-08-24 19:03 bkchr: Just decreasing the block time to 1sec is not really that useful? 
  ‚Ü≥ 2025-08-24 19:04 bkchr: Yes you get faster finality. But also without changes to the protocol you need to split up work packages etc. 
  ‚Ü≥ 2025-08-24 19:38 emielsebastiaan: Basti.await: I think the context for this proposal comes from a discussion we had in this channel a few weeks ago. Gavin outlined how JAM could support 1-second blocks, along with the tradeoffs involved, and suggested some adjustments to mitigate those downsides.

‚Ä®Details ‚ÄúJAM Slipstream‚Äù: https://github.com/gavofyork/graypaper/issues/322
‚Ä® 
The feasibility of Slipstream will likely depend on Toaster testing.‚Ä® 

Please note that the slipstream issue does not explicitly mention it is for Kusama. This idea was floated by Gavin in this channel in combination with the suggestion for a smaller Jam configuration of 32 cores for Kusama.
‚Ä®
This could be a great opportunity for Kusama to differentiate itself from Polkadot by offering a truly distinct value proposition. And a merger of any kind would be (much more) difficult.
‚Ä®
It is good to know that Kusama Governance is up for this path. But tbh I seriously doubt anyone really knows what they voted for. [edited]
  ‚Ü≥ 2025-08-24 19:48 erin: i talked about this on AAG a couple weeks ago, please let me know if anything I said here was wrong: 

https://youtu.be/I6dvP6ef5TQ?list=PLtyd7v_I7PGkXbJmKojrZ1KXwspR1JkpV&t=427
  ‚Ü≥ 2025-08-24 19:58 emielsebastiaan: erin: I think you explained it well. Perhaps the slipstream issue addresses some of Basti‚Äôs concerns. 
  ‚Ü≥ 2025-08-24 20:06 bkchr: Yeah I know this slipstream idea. Not sure if I read it here, but I remember Gav talking about it 
  ‚Ü≥ 2025-08-24 20:08 bkchr: In the current form this is not really sure it will work and if it would work, bringing it to Polkadot itself would probably be applied to polkadot as well, because faster finality is always better 
  ‚Ü≥ 2025-08-24 20:09 erin: yeah but we then lose a lot of cores. so my take is we just "cover our bases" so to speak
  ‚Ü≥ 2025-08-24 20:09 erin: i was hesitant to endorse it without the test data to back it up but it was being voted on so i felt i kinda had to
  ‚Ü≥ 2025-08-24 20:12 bkchr: > <@erin:parity.io> yeah but we then lose a lot of cores. so my take is we just "cover our bases" so to speak

Why would we loose cores? 
  ‚Ü≥ 2025-08-24 20:14 erin: as per gav: "The lower blocktime would result in lesser data throughput between WPs and between refine/accumulate, but obvious lowers latency dramatically."

https://matrix.to/#/!wBOJlzaOULZOALhaRh:polkadot.io/$Tln31n68BTM4B8Y6AUWDswwWBlag0UPW7Rib9SGdILU?via=polkadot.io&via=matrix.org&via=parity.io
  ‚Ü≥ 2025-08-24 20:18 erin: my understanding then is that fewer cores would keep the throughput higher and also reduce the cost of running the network at the same time but maybe I'm wrong
  ‚Ü≥ 2025-08-24 21:11 emielsebastiaan: Well the Kusama ‚Äòwish for change‚Äô referendum was premature for sure.

I can only speculate on reasons why Gavin floated the idea of Slipstream for Kusama in particular. It might suggest there is a compelling reason this would work for Kusama better than for Polkadot (ie with fewer cores). ü§∑üèø

In general I really like Shawn‚Äôs presentation on the renewed concepts of World Computer. Source: https://youtu.be/9tFyfYkorCw?si=FCVZX4y8IOwTRFi-

I have come to share Shawn‚Äôs view that there will be many world computers with different designs. When I first saw this presentation I thought he meant different designs between the ecosystems. But I can also imagine there will be different JAM configurations which may not be fully compatible due to tradeoffs while at the same time these configurations might serve entirely different use cases (as Gavin alluded to in this channel).

It would not be a bad future for both Polkadot and Kusama to diverge paths by each having a distinct Jam configuration (#cores & coherence interval) and thus both having a unique proposition.

I am eager to learn more about these tradeoffs. [edited]
2025-08-24 23:20 sourabhniyogi: image.png
2025-08-24 23:25 sourabhniyogi: 1s blocktimes, 5x faster finality combined with PolkaVM recompilation (which we have seen has 1B gas/s firsthand) and "continuation" powers ... super excited about Kusama JAM.  Can we pick more protocol parameters for this now Daniel ?
2025-08-25 11:04 gav: It wasn‚Äôt made particularly clear in the WFC but such different parameters imply a fairly different approach to its parachains. 1s block times will inevitably mean quite a lot less per-block throughput; depending on the nature of the chain‚Äôs logic, perhaps even more than 10x.
2025-08-25 12:05 qinwenwang: We have finished our grant project, prototype of sBPF runtime as a service on PolkaVM.
The sBPF virtual machine has been successfully ported to ‚ÄãPolkaVM, enabling seamless execution of Solana-native programs within the Polkadot ecosystem.
You can review the details of the project, its scope, and final implementation in the application document here:
https://github.com/w3f/Grant-Milestone-Delivery/blob/master/evaluations/lollipop-m1.md
2025-08-25 12:07 olanod: > <@gav:polkadot.io> It wasn‚Äôt made particularly clear in the WFC but such different parameters imply a fairly different approach to its parachains. 1s block times will inevitably mean quite a lot less per-block throughput; depending on the nature of the chain‚Äôs logic, perhaps even more than 10x.

Do you think it can be so different that the relevant parachain service or collator node + runtime would need to be different from Polkadot's or is it something that Substrate+Cumulus+FRAME and parachain service can handle with a few config changes?

If its from the perspective of managing parachain team's expectations I think we should be fine as the average core usage across all 140 cores is 0% üòÖ
2025-08-25 17:13 gav: Fair enough - in any case if parachains wanted greater throughput it would be possible by a move to Polkadot. 
2025-08-25 19:33 sourabhniyogi: Very cool, love it qinwen@Lollipop !  Have you run your accumulate on Polkajam (or another teams JAM implementation) of the sbpf "Service" with refined work packages?

Do you have plans to develop the refine+accumulate design of the PoC  [here](https://github.com/LollipopHQ/sbpf-on-polkavm/blob/main/sbpf-jam/src/main.rs#L32-L47) further to use host functions read/write/etc vs import/export/etc.?

Because you can't do that much with 10MM gas (G\_A) but can do a LOT in 5B  (G\_R) https://graypaper.fluffylabs.dev/#/1c979cb/444400444400?v=0.7.1 the central problem is how to combine the stateless refine and the stateful accumulate together with work reports and loop back in a "sBPF" service.     We'd love to test out some work packages involving this "sBPF" service this fall and chart a course for really high performance execution on both sides (with accurate gas accounting). [edited]
2025-08-26 17:29 bmaas: > <@qinwenwang:matrix.org> We have finished our grant project, prototype of sBPF runtime as a service on PolkaVM.
> The sBPF virtual machine has been successfully ported to ‚ÄãPolkaVM, enabling seamless execution of Solana-native programs within the Polkadot ecosystem.
> You can review the details of the project, its scope, and final implementation in the application document here:
> https://github.com/w3f/Grant-Milestone-Delivery/blob/master/evaluations/lollipop-m1.md

Great to see this! I‚Äôm with the Polana team and will take a closer look in the coming days. Really cool to see lollipop working on this too. 
2025-08-27 09:49 gav: We've had a wide range of speeds of implementations submitted for fuzzing. Some are as much as 100x slower than others at importing blocks. Do note that all implementations will be judged through our fuzzing suite and can expect to need the same number of imported blocks for the W3F (and by extension, probably, the Fellowship) to sign off on conformance. Practically speaking, if implementation A is 100x slower than implementation B, then even if they're both totally conformant, if B takes 4 weeks to fuzz to our expected level of confidence, A could take as much as 8 years before passing M1. [edited]
2025-08-27 10:39 qinwenwang: > <@sourabhniyogi:matrix.org> Very cool, love it qinwen@Lollipop !  Have you run your accumulate on Polkajam (or another teams JAM implementation) of the sbpf "Service" with refined work packages?
> 
> Do you have plans to develop the refine+accumulate design of the PoC  [here](https://github.com/LollipopHQ/sbpf-on-polkavm/blob/main/sbpf-jam/src/main.rs#L32-L47) further to use host functions read/write/etc vs import/export/etc.?
> 
> Because you can't do that much with 10MM gas (G\_A) but can do a LOT in 5B  (G\_R) https://graypaper.fluffylabs.dev/#/1c979cb/444400444400?v=0.7.1 the central problem is how to combine the stateless refine and the stateful accumulate together with work reports and loop back in a "sBPF" service.     We'd love to test out some work packages involving this "sBPF" service this fall and chart a course for really high performance execution on both sides (with accurate gas accounting).

Thanks for the thoughtful feedback - really appreciate the depth here.

We haven't run accumulate on Polkajam or other JAM implementations, as we don't think that environment gives particularly meaningful signals in its current form. It requires further refinement before a full launch. Instead, our focus has been on isolating the refine/accumulate interaction itself and validating how the sBPF "service" pattern could evolve with richer host functions.

We absolutely agree that the core challenge is bridging stateless refine with stateful accumulate in a way that loops back cleanly with work reports. 

We'd love to stay in sync as you start experimenting this fall and happy to share early designs and compare approaches so we can chart a path toward high-performance execution with solid gas accounting.
  ‚Ü≥ 2025-08-27 13:15 boymaas: Great achievement and progress! I understand this is a complicated problem, and we have experienced similar challenges. We are now at Solana CPI with the Polana Project. And there is till much to do. If there is anything we can assist you with, please let us know. https://x.com/andyjsbell/status/1942628582699983189
2025-08-27 11:21 subotic: To not make the M1 conformance testing a multi-year endeavor, would it then make sense to (I) make the fuzzer public and (II) have already for M1 some (minimal) expectations of speed, e.g., x amount of imported blocks per hour and fuzzer running without crashing for x amount of days? Then teams should only really submit, if those criteria are met.
2025-08-27 11:36 jan: There isn't really anything that prevents us from having a public, community JAM fuzzer. Create a shared repository with a fuzzing harness, have everyone contribute, integrate everyone's implementations there and just let it rip.

I have to agree that it makes sense to keep the fuzzer that'll be used for JAM prize conformance testing private, because the objective here is not "pass the fuzzer checks", but "write an implementation according to the GP". Consider two potential scenarios here:

1) The fuzzer is public. You've ran your implementation against it, fixed all of the issues, and everything passes.
2) The fuzzer is private. Everything passes without you testing your implementation against the fuzzer.

Which case has the higher chance of your implementation being correct? The one where you've fixed the issues in response to fuzzer finding them and stopped once everything passed? Or the one where you've meticulously crosschecked your code against the GP, fixed the bugs based on that, and because of that the fuzzer didn't find anything in the first place?

Of course there are no true guarantees either way, but the point here is to push people into submitting implementations which are of as high quality as possible.
2025-08-27 11:57 ascriv: I like the idea of hosting the fuzzer somewhere, so that it‚Äôs private but also removes the bottleneck. But if the dev time to make this secure etc is too much then nbd for me  [edited]
2025-08-27 11:58 dakkk: A middle way could be a remote hosted fuzzer with an usage quota for every team
2025-08-27 12:14 gav: Indeed, our fuzzer will not be made public for the reason previously given by davxy afk -> 28 Aug and in any case the by which fuzzing would complete is just a function of the impl's block import. I'd be interested to know why you'd think making the fuzzer executable public would help with anything beyond allowing teams to the milestone tests more quickly.
2025-08-27 12:16 gav: Well, no. The point, as Jan Bujak took the effort to point out very clearly, is to get implementation compliant with the GP, not which merely "pass the fuzzer". The fuzzer will necessarily be imperfect. Unfortunately there's no easy way, at present, to write a suite of tests such that all logical paths of the GP are covered. If we allowed the fuzzer to be used freely it would be just the same as providing the executable freely. [edited]
2025-08-27 12:18 gav: Yes, this is likely what we'll  move towards. We are finding that some teams are relying far too heavily on the fuzzer to direct their implementation and are thus unlikely to be "GP literate".
2025-08-27 12:20 gav: Most likely, we will move to a rate-limited round-robin queue system for "pre-submission" fuzzing.
2025-08-27 12:21 gav: Implementations which are sufficiently GP-compliant will end up getting more time on such a system; those that are relatively flakey will get little as they bomb out and get pushed to the back of the queue.
2025-08-27 12:22 gav: An implementation which completes this initial fuzzing may then be submitted for the full M1 fuzzing which will be a much longer affair.
2025-08-27 12:30 gav: Since different fuzzers (especially if clean-room implemented) will necessarily test different aspects of compliance I'm very keen to invite teams to write their own fuzzer or contribute to one bug public fuzzer.
2025-08-27 12:30 gav: Such an endeavour would allow "fuzzer-directed development" without compromising our compliance test framework.
2025-08-27 12:41 clearloop: curious about if there are sort of fuzzers in polkadot / substrate that we can learn from, as for the parts out of 'runtime' (M1), we are pretty limited by the version of jam-pvm-common that we can't build up-to-date programs for testing the latest GP, on the other handle, building our own sdks takes time and duplicates with the exists one
2025-08-27 12:43 gav: Duplication is nothing to be afraid of! [edited]
2025-08-27 12:44 gav: It builds understanding, creates competition and pushes down barriers to entry.
2025-08-27 12:44 gav: Embrace duplication!
2025-08-27 12:45 gav: As Jan Bujak wrote, create a fuzzer harness (this is trivial) then invite teams to contribute modules which construct blocks for it.
2025-08-27 12:46 gav: There's really nothing difficult here and creating those fuzzing modules helps further ones own understanding of the GP.
2025-08-27 12:48 gav: Of course you can also just rely on your own reading of the GP; like writing documentation and unit tests, writing a fuzzer for your impl is not a requirement for M1, but it might help you get across the finish line! [edited]
2025-08-27 13:26 oliver.tale-yazdi: JamBrains is working on an alternative service SDK in C. We can run our [example service](https://github.com/JamBrains/polkavm-examples/blob/871f061c6f52a9f14bf9a92362f35248da5652c0/lang-c/main.c) with 0.6.7 currently. It uses the standard-lib from the Polkaports repo *musl* in combination with *Picoalloc*, both thanks to Jan üôè  
The API looks like [this](https://github.com/JamBrains/polkavm-examples/blob/871f061c6f52a9f14bf9a92362f35248da5652c0/lang-c/jb_service.h). The plan is to make one dummy service for fuzz testing that tests all HostCall x EntryPoint combinations with all arguments. Then later on it should be usable as low level SDK to write bindings for other languages or port existing software.
2025-08-27 13:28 oliver.tale-yazdi: Without being called out; I assume that the implementation I'm working on is probably one of the slowest (if not the slowest).  
Currently the Fuzzing is purely single-threaded. Would it be possible to run the fuzzer target multiple times in parallel to speed this up? Alternatively we could also alter the fuzzing protocol to allow to import multiple blocks in parallel.  
This could help implementations that are not yet parallelising their STF [edited]
2025-08-27 13:35 davxy: Personally I prefer to not complicate the fuzzer protocol. I have some changes in mind, but not about this. Perhaps it is sufficient to run N fuzzers in parallel to obtain the same throughput
2025-08-27 13:36 dakkk: > <@oliver.tale-yazdi:parity.io> Without being called out; I assume that the implementation I'm working on is probably one of the slowest (if not the slowest).  
> Currently the Fuzzing is purely single-threaded. Would it be possible to run the fuzzer target multiple times in parallel to speed this up? Alternatively we could also alter the fuzzing protocol to allow to import multiple blocks in parallel.  
> This could help implementations that are not yet parallelising their STF

You can parallelize the accumulation function, this would speed It up a lot
2025-08-27 13:52 oliver.tale-yazdi: Maybe it would be possible to publish a speed score to know which team has to optimize? (could also be told in private to them if its too embarrassing üòÜ)
2025-08-27 14:31 gav: I think a speed score (blocks/second) should be manageable (davxy afk -> 28 Aug ?)
2025-08-27 14:57 davxy: Yes we can share this info within the report. I'll propose an extension to the fuzzer proto for public review soon
2025-08-27 15:05 subotic: My reasoning was to lessen the load on your side. But I now understand, that it is not a good idea to make the official fuzzer public and that it is actually better for us to write our own.
2025-08-27 17:56 emielsebastiaan: Gav, is it a educated guess that exhaustive conformance fuzzing will take 1 full month on one of the fastest implementations to get to a sufficiently high confidence level? 

E.g. PolkaJAM, including a recompiler and one instance sequential fuzzer? [edited]
2025-08-27 18:25 gav: I certainly hope not. I think realistically for a fast impl we‚Äôd expect a day or two.
2025-08-27 18:26 gav: I‚Äôd hope slow implementations can get to be no more than 20x slower. 
2025-08-27 18:28 gav: Of course to get to M3 they‚Äôd need to be substantially faster than that so any low-hanging optimisation work to get M1 submission working reasonably fast probably wouldn‚Äôt be wasted effort.  [edited]
2025-08-27 18:28 emielsebastiaan: The eight years you used was to make a point for sure. üòù I guess it worked. Thx. 
2025-08-27 18:30 gav: Indeed - it was more to say that even for M1 there is a practical limit to how slow implementations can be and still pass our conformance tests.  [edited]
2025-08-27 18:30 clearloop: for the block time of 6secs (expected PVM performance + network traffic + general runtime transition, etc), if there is research about how much time node takes on importing/executing blocks can make sure they keep alive in the protocol [edited]
2025-08-27 18:35 jan: Requiring a recompiler for M1 might not necessarily be fair (I know not everyone even plans to have a recompiler), but we might need *at least* people to submit reasonably fast interpreters. It's possible even polkajam will be (at least partially) fuzzed with an interpreter, since our recompiler currently doesn't support the per-instruction gas cost model that's in the GP right now (and I have no plans of adding this to the recompiler, since the final gas cost model will 100% be block-based, which is what our recompiler has always implemented).
2025-08-27 18:38 gav: A recompiler should certainly not be needed. 
2025-08-27 18:42 jaymansfield: Does the fuzzer support aarch64? JavaJAM has a recompiler but its been disabled for fuzzing since it only supports ARM64 at the moment. 
2025-08-27 18:44 sourabhniyogi: I really would love it if we had a fuzzer protocol that didn't involve publishing fuzzer target binaries but simply having urls that accepted the same traces and just responded with stateroots or some http 4xx error code.  With N teams, there are just N urls, and its easier for everyone to deal with.  Oliver Tale-Yazdi - OOO (back next week) had some API doc for this in like Feb/Mar that probably is very easy for almost all of us to execute on.  Then the binaries-way is what would have to be the real thing.   Is this reasonable?


2025-08-27 18:44 jan: Only for the later performance-related milestones a recompiler will be pretty much required. For those we might even release an official testing harness instead of keeping it private like for the M1 (at least for the PVM parts), since the main portion of what it will be testing is purely measuring performance so it will be a lot easier to test than for M1. [edited]
2025-08-27 18:45 jan: You're free to have an Aarch64 backend (and we encourage it), but we'll always be testing on AMD64 (since that's what the toaster runs).
2025-08-27 18:47 tomusdrw: Sorry if it's a dumb question, but I'm genuinely curious. AFAIU the fuzzer needs coverage data to produce more interesting inputs (i.e. inputs that have a combination of conditional branches hits). Given that there are only binaries, I assume that PolkaJAM is used as fuzzer coverage source. So I wonder if fuzzing (sequentially) X different implementations is really making any difference? Doesn't it mean we are just fuzzing PolkaJAM X times (possibly covering the same cases)? Couldn't we just generate terabytes of test cases instead and make sure that all implementations pass them?
Some ballpark estimates: 10blocks/s \* 3600 \* 24 \* 7 \* 4 = 24M blocks for 4 weeks of fuzzing, with avg 0.5MB/block that's 12TB of data. 20TB disk is $500 - and the data could even be mailed instead of fetched. [edited]
2025-08-27 18:51 oliver.tale-yazdi: Its still online, but I did not test it recently for conformance. You just post a JSON test file with  `pre_state`, `block` and `post_state` to it and it either returns code 2xx or 5xx.  
You can play around with it [here](https://dev.jamcha.in/#/Functions/Gm.OpenApiWeb.FunctionsController.check_stf_safrole) from the browser. I guess alternatively it could be changed to only accept `pre_state`+`block` and return the 2xx `post_state`  or 5xx if the block was invalid. It has a [OpenAPI spec attached](https://dev.jamcha.in/api/v1/openapi), but I am quite flexible on the details of it.  
It seems to work reasonably well though, and authentication + rate-limiting is pretty natural to these kind of APIs.
2025-08-27 18:53 oliver.tale-yazdi: For any team to be usable we should probably use binary format though, to not enforce canonical JSON codecs. *Maybe* hex encoded binaries inside the JSON files are an acceptable overhead for ease-of-use; otherwise we would need a more dedicated protocol I guess
2025-08-27 18:59 sourabhniyogi: I think if you/we adjust it to the .bin form we win cross-team testing very quickly.  

We built a fuzzer and have wanted to test out all the other teams fuzzer targets, but in the end just doing 2-3 "manually" by downloading xyz is a lot of work.   With good old urls conforming to an API, its a piece of cake. [edited]
2025-08-27 19:09 oliver.tale-yazdi: I also wanted to do a compatibility matrix between all available targets and fuzzers, but did not do it yet. But I assume that using this script, it should be simple enough to start all available fuzz targets: https://github.com/davxy/jam-conformance/blob/main/scripts/target.sh  

The API approach is better when one side wants to remain private I think (but i can still do another API design iteration with binaries, to see how it goes) [edited]
2025-08-27 19:34 sourabhniyogi: Ready to publish a 0.7.0 url that receives  the ".bin" trace files according to your updated spec, and hit your url with the same.  We can have a "fuzz reports" url that streams this continuously (read a .bin file from some place or another, post it to all N enrolled teams) for everyone to admire and stress over, directly modelled after https://github.com/davxy/jam-conformance/tree/main/fuzz-reports

It really only works if people actually want to challenge each other with "hard" fuzzing.  If all we did was had a few dozen challenges from a couple of test runs, we don't find issues.

Right now our collective approach is to wait for davxy afk -> 28 Aug to give us challenges, and we enjoyed a great month meeting them (congrats all!).  Collectively we should be proactive about finding each others problems on our own.  If it helps us all "cross the finish line" faster, we should all get in the middle of the nooks and crannies and challenge each other. [edited]
2025-08-28 07:36 clearloop: hey Jan Bujak , may I ask if PVM has sort of 'function section' design, or if there is any document has deeper explanation about the 'code section', given accumulate starts from 5 and refine starts from 0 and they are sharing the same binary,  I'm thinking about compiling accumulate function and refine function separately which would speed up the compilation time a lot I believe [edited]
  ‚Ü≥ 2025-08-28 07:40 jan: There's nothing special about the dispatch table we have at the start of the code blob; it's just normal code, except purely by *convention* we put jumps there to go to actual entry points.
  ‚Ü≥ 2025-08-28 07:41 jan: You can try to lazily compile the program block by block if you want, although that probably isn't actually necessary.
  ‚Ü≥ 2025-08-28 07:45 jan: If you find that your recompilation performance is slow then this pretty much means you should optimize it *before* you try to do stuff like recompiling only parts of the program. It was explicitly designed so that it's possible to make a blazing fast recompiler, you just need to read between the lines of the GP. The GP only describes the *behavior* we want, but almost always this isn't actually how you would write an implementation that is fast, so if you're just translating formulas from the GP 1-to-1 into code then you're going to have a bad time. You need to stop and think, "okay, this is how it's supposed to behave, but how can I make this more efficient to execute?".
  ‚Ü≥ 2025-08-28 07:46 jan: I touched upon this in my recompiler talk, so if you haven't seen that you should watch it. [edited]
  ‚Ü≥ 2025-08-28 07:50 clearloop: yes I just had a big refactor on the interfaces these days XD for deprecating the GP formula but keeping the signatures, they are pretty useful for debugging if my implementations are GP aligned and yes seems less optimized, still carefully optimizing them PR by PR since making things work is more important than performance atm ))) [edited]
  ‚Ü≥ 2025-08-28 07:52 jan: Assuming that you're planning to go for the performance milestones, rather than keeping the same interfaces I would probably recommend you to write two completely independent implementations (one naive, and one optimized), and then just unit test or fuzz test them that they're equivalent.
  ‚Ü≥ 2025-08-28 07:52 jan: If you want the most performant code then that almost always involves an entirely different way of designing it, _including_ the interfaces. [edited]
  ‚Ü≥ 2025-08-28 07:53 clearloop: I have read the video and the PPT, straightforward talk! actually I just implemented a recompiler last days, however it is currently 10x-150x slower than my interpreter (compile + execution) ü§¶‚Äç‚ôÇÔ∏è
  ‚Ü≥ 2025-08-28 07:54 jan: For example, the "nice" way of recompiling the code might be: you first parse the code into nice data structures, then you do another pass on those data structures to emit assembly. If you want to go fast then this is not the right design - you want to emit assembly *immediately* as you're parsing the code.
  ‚Ü≥ 2025-08-28 07:55 jan: Of course you don't need to do *everything* like that, only the performance critical parts of your implementation.
  ‚Ü≥ 2025-08-28 07:55 jan: The less performance-critical something is, the more you can keep nice, high level code for that part.
  ‚Ü≥ 2025-08-28 07:56 jan: First, you should benchmark compilation and execution separately.
  ‚Ü≥ 2025-08-28 07:56 jan: If you're just measuring how much time it takes end-to-end then you actually have no idea which part you need to optimize.
  ‚Ü≥ 2025-08-28 07:57 jan: In general it should be easier to get good execution performance rather than good recompilation speed.
  ‚Ü≥ 2025-08-28 07:57 jan: So for example, if your execution speed is really bad then you're doing something horribly wrong.
  ‚Ü≥ 2025-08-28 08:00 clearloop: at this point, I'm thinking about migrating sort of benchmarks of riscv to PVM, embench vs coremark, what do you think?
  ‚Ü≥ 2025-08-28 08:01 jan: You could reuse my benchmarks, then you can directly compare your PVM to PolkaVM to see where you stand: https://github.com/paritytech/polkavm/blob/master/BENCHMARKS.md
2025-08-29 16:45 sourabhniyogi: Now that we've emerged from our implementation caves,  can we post JAM-related social links (like this https://x.com/colorfulnotion/status/1961459179098358115 ) in this room that we think are RT worthy.  Not asking for memetic BS, just want to share any and all good news with the Web3 community as it happens. We're going to have a lot more good news in the next 6-12 months, and having everyone beating drums cohesively would be stellar.  

You could specify a rate limit for each person/team of like 1 per week and impose some kind of quality metric so signal-to-noise ratio remains high.  

The idea is to get organic JAM marketing directly from the people involved, and their supporters. [edited]
2025-08-29 17:17 sultanindonesia: We often miss the time we conveyed from the Timeline Roadmap that we ourselves conveyed publicly, Therefore the Polkadot Ecosystem, especially JAM, must continue to quickly increase the speed of moving forward like a Shinkansen. A disciplined team, strong determination, high dedication to achieve before the timeline, agile, tenacious, without looking at the time until the Vision is achieved then we open the bottle of Whiskey. Very much respect for Japanese Culture that should also be implemented in Polkadot. Mental Revolution is a Priority 
2025-08-31 19:51 sourabhniyogi: Since most of us are deathly afraid of flaming out of fear of being too slow (or have really large egos ü§™ü§£ ), why not just state some precise guidelines now that davxy  got almost all of us into basic "walking" shape this past few days with performance reports [here](https://github.com/davxy/jam-conformance/tree/3a1040c1c626a9739033439cf2c3402ebff674cf/fuzz-reports/0.7.0/reports/perf)

Concretely, something like:

- Your implementation should perform no slower than 10x (or 25x or 50x, you pick the number) polkajam\_int across all test groups
- Your interpreter should be able to interpret at 1MM gas/s (or 10M gas/s, 50MM gas/s, you pick the number ).

By stating this clearly, teams who are way ahead of this "should" threshold can proceed without fear on winning the M3/M4 marathon (refining Doom/.. workpackages with a recompiler) rather than an M1 sprint rankings game (which we should save for M3/M4, right?). In the end the timings are dominated by PVM accumulate execution.

Some guidelines recognizing the natural difference between compiled and interpreted languages (Set A/B vs Set C vs D) and carefully recognizing "should" (more fuzzer action!) vs "must" (hard constraint) may be order, and iterating by data.

What do you think -- does that make sense? [edited]
2025-08-31 20:07 clearloop: based on the optimizations these days, I'm also feeling confused about, when the protocol running in production, most of the operators will definitely run the implementation which has the best performance, others may maintain different nodes for the safety & diversity of the network, (and yes, implementations should at least be able to finish the required work at each timeslot), but this could be only a small part of the network, thus except the milestones, if there are plans for making our implementations more meaningful at that time for an overall insight, (yes, we can build related tools in different languages, even build services for JAM, but if there are more directions that can open our mind) [edited]
2025-08-31 20:13 davxy: For completeness of the broad discussion, I rewrite here what I already wrote in the conformance chan:

Currently (in the context of M1) the performance table is mostly meant to provide an indication of how long fuzzing should run to reach the same level of confidence across implementations. This is also to start thinking a bit more about the auditing process duration.

For example, if we take (in the screenshot shared by dakk above) PolkaJam as the baseline, and auditors require 3 days of continuous fuzzing without crashes/diffs then:

- An implementation 300x slower would require 900 days (about 2.5 years)
- If the baseline is instead 10x slower than Polkajam, the same 300x implementation would need 90 days

These numbers (fuzz duration for baseline) are speculative, but that is the point of sharing performance results at this stage: they are not about improving by few ms to climb the ranking, but about giving a tangible sense of scale for testing. [edited]
2025-08-31 20:14 erin: I will be releasing an auto-updating dashboard tomorrow including estimated fuzzing times based on current performance metrics.
2025-08-31 20:37 emielsebastiaan: In general I feel teams should get some time to process the NEW secondary performance objectives. Ie the low hanging fruits such as basic parallelisms. Additionally I hope some reasonable consideration can be given to the language group or even language in assigning fuzzer-time ranking given equal conformance. 
2025-08-31 20:39 gav: I‚Äôm not sure how these could be considered ‚ÄúNEW‚Äù. 
2025-08-31 20:40 gav: Fuzzing has been explicitly stated as one of our means of determining conformance for some time now.  [edited]
2025-08-31 20:41 gav: I‚Äôm open to ideas about other means of very generally, objectively and effectively determining whether an impl is conformant. But failing that, it‚Äôll need to be this way. 
2025-08-31 20:41 gav: And this way implies a threshold number of iterations. 
2025-08-31 20:42 gav: Which implies that implementations which are slow will take longer to pass said conformance tests.  
2025-08-31 20:43 gav: None of this seems to me like it falls under ‚ÄúNEW‚Äù. 
2025-08-31 20:44 emielsebastiaan: We are perfectly fine with all conformant constraints (of course) and we are confident in our process. Maybe I read it wrong but I hope performance in and of itself will not impact our access to the fuzzer process (for M1). You did mention a ranking system. 
2025-08-31 20:45 gav: Please provide reference
2025-08-31 20:45 gav: Not sure what context that was mentioned in. 
2025-08-31 20:46 gav: Please note; the W3F fuzzer is not a community resource. It is a Fellowship resource to help understand whether a submission is (probably) conformant. 
2025-08-31 20:46 gav: The GP is a community resource. 
2025-08-31 20:47 gav: This chat room is a community resource. 
2025-08-31 20:47 gav: To the extent we provide informal (ie pre-submission) access to the fuzzer we do so in the hope it will be helpful. 
2025-08-31 20:48 gav: But that is not our primary goal. If you believe a fuzzer will be helpful for your development process, do create one yourself and feel free to share among teams. 
2025-08-31 20:50 emielsebastiaan: Reference:
> Implementations which are sufficiently GP-compliant will end up getting more time on such a system; those that are relatively flakey will get little as they bomb out and get pushed to the back of the queue.

I suppose it is conformance based. My bad. 
2025-08-31 20:50 gav: To the extent we provide some fuzzer service, we‚Äôll do so in a manner which we consider fair and we‚Äôll be transparent about what that is. 
2025-08-31 20:52 gav: Fairness here will be based on *our* resources used. If your impl can do more with less of our resources, it‚Äôll get a greater benefit from our service. 
2025-08-31 20:57 gav: I wouldn‚Äôt consider parallelism as a requirement for M1, nor exceptionally fast PVM. Fuzzing will centre around block import logic rather than vast amounts of PVM instructions or database I/O. PVM will be fuzzed of course, but not in the ratio which would result from a maximal PVM gas usage in each block.  [edited]
2025-08-31 20:59 gav: For M3 and M4, PVM and database I/O will matter a lot more. (Not to mention networking and Refinement which isn‚Äôt relevant for M1.) [edited]
2025-08-31 21:00 clearloop: curious about if the current performance of polkavm can be considered as M3 or M4 level?
2025-08-31 21:00 gav: Nah - we‚Äôre still optimising:)
2025-08-31 21:01 gav: When the gas figures come out, that should give some clear performance requirements.  [edited]
2025-08-31 21:02 gav: Other than that, performance will need to be sufficient to retain maximal throughput on standard hardware. 
2025-08-31 21:02 clearloop: I believe there is a limit in the current PVM format (a big single function), not sure at M3 or M4 we can take more time on this
2025-08-31 21:03 clearloop: for example, the iter related stuffs, panic handlers could be reused, and they are super big in each of the compiled modules [edited]
2025-08-31 21:11 sourabhniyogi: Thank you for clarifying -- at what milestone (and 2025 vs 2026 month guess) are are implementations refining (and authorization) going to be fuzz tested?

I really loved how every single `accumulate` host function has been tested and was improved by teams this August, and wish we were doing `refine` (and `is_authorized`) in the same way already.

Not sure if I would like to see those suddenly be part of M1 fuzzer requirement ("Refinement which isn‚Äôt relevant for M1", refinement is not "authoring" per se) ... but I really would like to end 2025 feeling that we covered it as well.

If you said it was an { M1 vs M2 vs M3 } requirement we would get { hyper focussed vs super focussed vs slightly focussed } on extending the fuzzer protocol to support refining/is\_authorizing this fall. A lot of us recompiler "m4 or die" types would take on the challenge of building great fuzzers in the style of davxy if it was an M2 thing,  throw up our hands if it was an M1 thing, or do something else (like writing M1 reports) if it was an M3 thing.   Just a guess. [edited]
2025-08-31 21:19 sourabhniyogi: I would like to know what teams should have accomplished exactly before getting access to the toaster.  Before it was (loosely) "can you do DOOM at 60fps" and now it could be precisely "can you refine DOOM work packages in your implementation + polkajam testnet" but you could also gate it with refine+auth related jam-conformance fuzzing performance, in a unofficial fuzzer way, with davxy -- or with us submitting a claim that we can do xyz in our M1 reports. [edited]
2025-09-01 07:34 gav: Toaster access should come once it‚Äôs clear that M2 is there or at least when we‚Äôre confident that M2 could pass. I‚Äôd like to start accepting M1 candidates imminently, but it‚Äôs really on [davxy](https://matrix.to/#/@davxy:matrix.org)to determine when the fuzzer is ready for prime time. 
2025-09-01 07:36 gav: M2 candidates should begin being accepted once we have the conformance tests for that. The priority is M1 testing for now. 
2025-09-01 07:54 gav: Obviously nothing stops this community from setting up their own comparator harness and get going with cross-impl refinement testing/fuzzing. 
2025-09-02 03:46 jan: Considering it's still incomplete and the spec is not at 1.0 yet - nope. There's still the new gas cost model that will be introduced (there is a high chance that it will require a competent SIMD-accelerated codepath to reach M3/M4), there could be minor changes to the instruction set to accelerate things and I still want to use more aggressive SIMD acceleration in certain places of the codebase.

For everyone wondering about M3 and M4, in general you can expect the following to be tested at M3 and M4 when it comes to PVM:

- Recompilation speed - how fast can you recompile code into native code?
- Gas cost calculation speed - how fast can you calculate the gas costs for blocks? (This will not be tested separately from the recompilation speed, but I'm explicitly mentioning it since I expect it will also be a major factor.)
- Execution performance - how fast is the code that you've recompiled?
- Gas costs conformance - is the native code you've emitted conformant with the gas cost model? The new gas cost model will be somewhat strict wrt what exact machine code you can emit to avoid denial-of-service type of attacks; for example, whatever machine code you'll emit for the PVM addition instruction will be _required_ to only have a single cycle of latency, so essentially the _only_ valid way of recompiling it will be into a single native addition instruction. The GP of course won't tell you explicitly which native instructions are conformant with given latency numbers (that would be widely out-of-scope for the GP), but once we get up to M3 I might write up an implementers' note or host another talk or something like that for people to give a little bit of guidance as to how to actually do it in practice without having a PhD in CPU microarchitecture. [edited]
2025-09-02 03:53 jan: The PVM code blob is not a single big function. It's split into basic blocks which in theory should be recompilable in isolation if that's what you want to do, so a more explicit subdivision of the code blob wouldn't necessarily help you all that much.

(Side note: of course, if someone has good ideas to speed things up/make things more efficient/simplify things without compromising on speed then I'm always happy to hear any potential ideas.) [edited]
2025-09-02 03:55 xlchen: what are the benefits to put everything into a single blob compare to one blob per entry point? (it is simpler for one)
2025-09-02 03:57 jan: Practical benefits besides simplicity? You can share code between the blobs, I suppose.
2025-09-02 04:00 jan: In general since you could most likely just cache and reuse the recompiled PVM binary based on a hash you know a priori for the toplevel services it's probably not worth splitting the blobs for each entry point.
2025-09-02 04:05 jan: But of course this doesn't apply to inner PVM. Those don't have any "official" entry points (whatever the toplevel service decides is the entry point will be the entry point), and you still need fast recompilation since for inner PVMs whatever service is invoking the inner PVM can just conjure whatever code blob it wants from wherever it wants, so near zero cost caching is not feasible there (you could do caching there if you'd calculate the hash yourself in your PVM, but considering it's possible to recompile the code faster than it is to hash it, it's not really the solution)
2025-09-02 05:25 clearloop: yes I think SIMD would help a lot! given we are generating thousands of write_bytes(addr, 4) atm for the testing programs in traces, my complaint about the program(blocks) (wait, ain't this a chain of blocks, e.g. blockchain ??) format is mainly about the compilation speed and the code size, mb concept like [wasm module](https://webassembly.github.io/spec/core/syntax/modules.html) (reduce size) or function based cache (in compiler, speed up compilation) would help if all of the programs are sharing a same 1MB block area in their binaries

and I agree with that the execution speed has more priority, since it's more hardcore in our implementations while cache stuffs are easy to be patched later then
2025-09-12 11:29 prematurata: am i wrong or someone had a ci pipeline to auto timestamp commits into polkadot? it seems i cant find it
2025-09-12 12:17 ascriv: https://github.com/JamBrains/remark-commit 
2025-09-12 12:17 ascriv: @[Oliver Tale-Yazdi] 
2025-09-12 12:23 vinsystems: It should be enough to push code to GitHub frequently, right?
2025-09-12 12:30 oliver.tale-yazdi: This was discussed many times now. The whole point is that teams need to present _unfakable timestamps_.

Just pushing commits to GitHub _does not achieve this_, since you can force push with altered timestamps and change them to arbitrary values. Using Merge Requests does achieve this (if you trust GitHub), since GitHub merge requests are queryable into the past with fixed timestamps.

Persisting the commit hashes and timestamps to a decentralizeed ledger achieves this as well without having to trust GitHub. [edited]
2025-09-12 12:31 oliver.tale-yazdi: Anyway, I am not a judge of the rules and this is my interpretation of it.
2025-09-12 12:36 vinsystems: [The repository activity](https://github.com/paritytech/polkadot-sdk/activity) shows when the code has been pushed and each one of these timestamps are unfakeable. Perhaps a judge could help us clarify this.   [edited]
2025-09-12 12:39 vinsystems: image.png
2025-09-12 12:42 oliver.tale-yazdi: I did not know this Activity feature of GitHub. Looks like that could work, yea
2025-09-12 12:56 ascriv: > <@vinsystems:matrix.org> Yes, but the activity of the repository shows when the code has been pushed and each one of these timestamps are unfakable. Perhaps a judge could help us clarify this.  

I received word from the fellowship that pushes to main, e.g. are technically not sufficient, but they will still consider my code. To be safe, just put timestamps on some blockchain
2025-09-12 12:57 ascriv: They said they will deprioritize my submission due to the extra work required for them to verify
2025-09-12 12:57 jaymansfield: GitHub workflow execution timestamps also can‚Äôt be modified if you have some type of CI setup to verify tests on merges for example. 
2025-09-12 13:05 vinsystems: Acording to the rule 15, we should be safe pushing code to Github frequently. I didn't develop all the code in main, so far I have done 30 merges on GitHub, but acording to the rule 15 I thought that it was ok to conform to the rules.  [edited]
2025-09-12 13:11 clearloop: truth, commits can be faked easily, but actions and PR histories can't
2025-09-12 13:16 ascriv: > <@vinsystems:matrix.org> Acording to the rule 15, we should be safe pushing code to Github frequently. I didn't develop all the code in main, I have done 30 merges so far on GitHub, but acording to the rule 15 I thought that it was ok to conform to the rules. 

This was also my argument as well. If you want confirmation, you can email jam@web3.foundation about your specific case. You should be fine but they might give you a similar answer 
2025-09-12 17:37 sourabhniyogi: Can you offer your thoughts on whether one or more high-performance [**PVM FFI-able libraries for JAM Implementers**](https://github.com/davxy/jam-conformance/issues/76) can reasonably be used for M1/M2 unofficial vs official fuzzing?

I drafted a `pvm.h` here https://github.com/davxy/jam-conformance/issues/76 as a solution to the  "our impl performance is Nx slower than Polkajam üòÇ"  problem (for high N üòÖ), which is very sharp for those in Set C + D, so far.  The gorgeous [JAM Conformance dashboard](https://paritytech.github.io/jam-conformance-dashboard/) got us whipped into shape real fast, along with the fear of having ridiculously long audit times =).

Many teams \[faced with the performance data pointing to slower audit times (weeks/months rather than hours/days)\] are going to want to go _hybrid_ by combining a PVM interpreter/recompiler written in a high performance language (probably C/C++/Rust) with their language.   I think some sharpening on what is an acceptable way to go hybrid would be super useful!

The "For the purpose of performance testing, a third-party PVM implementation may be used to help achieve the required performance." is already there for the "Non-PVM Validating Node Path".   So I see no reason why, especially now that we have 15+ teams happily fuzzing, we should not expose a PVM API and some high performance PVM libraries conforming to this API, between Rust (specifically what polkajam uses) and C/X86 (from those gunning for M3/M4) at least.

What do you think? [edited]
2025-09-12 17:51 dave: The web3 JAM page (https://jam.web3.foundation/) is fairly clear that an original PVM implementation is required for M1/M2. A third-party PVM implementation may only be used for MN3/MN4, to hit the required performance targets, if you are following the "non-PVM validating node path". So I think the answer is that no you can't use a third-party PVM implementation to improve your performance for M1/M2.
2025-09-12 17:56 dave: I wouldn't recommend trying to integrate a third-party PVM implementation now as I would think you could easily fall foul of the clean room requirements
2025-09-12 19:05 tomusdrw: Quote from jam.web3.foundation:

> The language set of an implementation is determined as the language in which its business logic is written. Peripheral, performance-bottleneck components of an implementation may be written in a higher-performance language without any impact on the consideration of language set. A non-exhaustive list of such components include: **PVM**, Database, Erasure, (de-)coding

Teams writing in "slow" languages, are not required to write PVM in the same language. I think the only point is that it should be original implementation for "Validating Node Path". [edited]
2025-09-12 19:26 jaymansfield: > <@tomusdrw:matrix.org> Quote from jam.web3.foundation:
> 
> > The language set of an implementation is determined as the language in which its business logic is written. Peripheral, performance-bottleneck components of an implementation may be written in a higher-performance language without any impact on the consideration of language set. A non-exhaustive list of such components include: **PVM**, Database, Erasure, (de-)coding
> 
> Teams writing in "slow" languages, are not required to write PVM in the same language. I think the only point is that it should be original implementation for "Validating Node Path".

And in some languages it isn‚Äôt even possible to execute assembly to do a built in recompiler. I ended up doing a c++ recompiler for my java implementation. 
2025-09-12 20:07 clearloop: interesting, I thought it would be into JAVA bytecode or Kotlin IR
2025-09-12 20:11 dave: Yeah your PVM impl doesn't need to be in the same language, but it does need to be _your_ implementation. It can't be a third-party implementation, at least for M1/M2.
2025-09-12 21:23 sourabhniyogi: There are now 15+ enrolled teams  that already have their own first-party PVM interpreter happily getting fuzz-reports.  The Set C/D teams happen to have slower implementations.  But I don't think there is any value in these slow PVM interpreters _except_ for the fact that _they trained us_: everyone with this JAM experience can see this was mere scaffolding for the next stage, which is to replace all of this with a high performance PVM recompiler, which can be done with third-party PVM libraries.

Re "Clean room": Multiple teams can publish a libpvm.a (or whatever) FFI with high performance PVM interpretation/recompilation in the same way they are currently publishing compiled binary fuzzer targets while ALSO satisfying clean room requirements, I assume, if these recompiler/intepreter impls aren't publishing their code (or people don't look inside them when they do).  All recompiler teams can publish a library without publishing any source anything beyond an API -- something close to pvm.h can work for both C+Rust, and I'd like to see if this can work in late 2025 rather than late 2026 or 2027.

Nearly 1.5 years has passed since rules were published.  At least for the 15+ enrolled teams who have already built a PVM interpreter, we're now _well_ beyond the _educational value of training these teams_ ... and now to the point where we can want PVM fuzzing and **performance** and **robustness** in PVM libraries instead.   I see little point in having PVM fuzzing of non-performant PVM interpreters, except to satisfy the rules.  In contrast, if the "C(++)/Rust" + "hybrid" recompiler teams provide PVM library for others, provided that the bug fixes flow to improve the robust production-grade high performant PVM libraries rather than the throwaway low performance PVM interpreters, we win something meaningfully better.

Is this actually a debate?  Am I missing how important it is to have these throwaway PVM interpreters go through some PVM fuzz process for some reason?

You can also distinguish between "unofficial" vs. "official" -- the beloved fuzzing processes are marked "unofficial", and you can still have the "official" process go through everyone's original throwaway PVM interpreter.  But if everyone's slow language implementation fuzzing goes 20-100x times faster using a library in the "unofficial" process, we should do that smarter thing, especially if it improves the end goal of having more robust more performant PVM recompilers and thus JAM implementations generally. [edited]
2025-09-13 01:12 dave: > I don't think there is any value in these slow PVM interpreters except for the fact that they trained us

You're right that there is little direct value in yet another slow PVM interpreter. The value is in the process of creating this interpreter: reading and interpreting the GP, and resolving the inevitable mismatches with other implementations. The more times this is done the more likely it is that we find all the issues in the GP, and the more likely it is that all implementations actually match the GP.

There are two reasons I said I would be careful about integrating a third-party PVM at this point:

- The PVM interface itself is likely to imply a particular interpretation of the GP. It could arguably be considered code, even if it's just function prototypes and type definitions.
- If you're integrating with say PolkaVM, you'd have to be rather careful not to look at the PolkaVM code when debugging and so on. Yes, this probably isn't a concern if you're just using a binary with no debug info.

Of course, teams following the non-PVM path will have to integrate with a third-party PVM at some point if they want to atttempt the performance milestones. In my opinion that would best be done after M1/M2.
2025-09-13 01:21 dave: FWIW I don't think we intend to make the "unofficial" fuzzing particularly fast. We really do _not_ want teams to be fixing their implementations solely based on fuzzing against PolkaJam. At the end of the day PolkaJam is just another implementation and will have its own bugs and mismatches with the GP, which we certainly don't want copied
2025-09-13 05:35 jan: > The PVM interface itself is likely to imply a particular interpretation of the GP. It could arguably be considered code, even if it's just function prototypes and type definitions.

For the PolkaVM crate specifically I'd say that looking at the public interface (i.e. most of what docs.rs show as long as you don't click on show source) should be safe to do; there isn't really much JAM-specific about it, and it's just a garden variety VM interface. The initial API was mostly based on what `wasmtime` has, and then I just introduced a slightly lower level common-sense expansion to that API that allows handling host calls and page faults without having to register callbacks, and that's mostly it. There are some types there which are for dealing with program blobs and such, but this is very minor and is similar to what we ourselves publish as part of the current JAM SDK (and even less I'd argue; PolkaVM exposes an interface to operate on `.polkavm` blobs, which is not part of the GP, while the JAM SDK includes code for JAM blobs which *are* part of the GP).
2025-09-13 05:51 jan: As far as I'm concerned people are welcome to borrow my API as long as they don't look at the implementation; it doesn't expose anything more than any other general purpose VM would or what a JAM SDK would. I explicitly try to keep it as general-purpose and not JAM-specific as I can (unlike most other PVM implementations that I've seen which are very much geared towards being JAM-only VMs), and (for various reasons) I also have a bunch of stuff that's either experimental or even subtly non-compliant with the GP, so if someone's just blindly copying without understanding the GP they will have a bad time.
2025-09-13 06:06 jan: Besides, later down the line we *will* most certainly need a common PVM API for the M3+ milestones to make PVM performance testing possible and practical. For example, we will definitely need to measure the performance of how fast people's recompilers can generate code separately from how the code executes - checking the recompilation performance is mostly a manner of checking whether it's O(n) and how fast it can go, while execution performance testing needs to verify that the performance is within what the gas cost model assumes, and thus they need to be measured separately to make this in any way reliable, and you can't do this without low level access to the PVM (lower than what just running a service on JAM provides). So as far as I'm concerned having a common PVM API will pretty much be a JAM prize *requirement*.
2025-09-13 16:05 oliver.tale-yazdi: Not sure if I follow the reasoning; what would speak against a Socket-based API like the M1 fuzzer?  
Requiring a binary ABI does restrict the use of non-native languages for code-emission.
2025-09-13 16:09 jan: An interface is an interface, and it doesn't make much difference whether it's called directly or through some sort of an indirection layer like a socket. The extra noise due to the RPC will make it more difficult to do the measurements, but probably not impossible.
2025-09-14 01:28 sourabhniyogi: Terrific, totally makes sense -- lets make this PVM API a JIP draft like super-soon!  Will take stab at it starting from the [polkavm API](https://docs.rs/polkavm/latest/polkavm/struct.RawInstance.html) and see if we can aim for what you have in mind 
2025-09-15 00:17 jam_man: Not sure if I can ask this here. But it seems appropriate.

Jay Chrawnna has stated that this new hard cap for DOT will be ‚Äúenshrined in JAM and can only be changed through a hard fork‚Äù

Could anyone explain how we enshrine something In JAM. While I understand that JAM is supposed to be a non-upgradable, fixed-parameter protocol that will host upgradable services, including hosting open-gov itself. Is there really no way for open-gov to modify any aspect of the JAM protocol?
2025-09-15 00:18 jam_man: From my understanding, JAM doesn‚Äôt even host the DOT token. It will need to be a service on JAM.
2025-09-15 00:19 xlchen: JAM host the DOT token. It is the only token hosted by JAM chain. All the balance related logic are referring to DOT (the native token) [edited]
2025-09-15 00:20 xlchen: Gav said there will be an editorial board for GP, so update of GP will go through that.
2025-09-15 00:21 xlchen: As you already said, JAM chain is not designed to be upgradable. So upgrades requires hard fork. Then the rest is just how hard fork upgrade works. i.e. social consensus.
2025-09-15 00:25 jam_man: Hm, ya that‚Äôs what I assumed.

That you could simply force a hard fork with an open-gov proposal. Which does not inherently enshrine it?

Has this concept been discussed for JAM. Can forks be forced by proposals, or will it be up to the node operators. 
2025-09-15 00:27 xlchen: what open gov can do is boot off / slash uncooperative validators [edited]
2025-09-15 00:27 xlchen: so in some way, it can be done
2025-09-15 00:38 jam_man: I see thank you. 

And now I see. The Gray paper outlines how the networks Balances (NB) are baked into consensus as 64-bit unsigned integers.

So it‚Äôs not a service at all. I assumed we would have to bring DOT over as a service. 

This is actually good to know. Thank you again. 
2025-09-17 15:20 danicuki: Will M1 submissions begin to be accepted once the fuzzer test software for 0.7.0 is complete? 
2025-09-17 17:36 sourabhniyogi: Given [Rule 21](https://jam.web3.foundation/rules) - Prizes are paid no earlier than the ratification by the Polkadot Fellowship of version 1.0 of the JAM protocol.", can someone explain (probably re-explain üòÖ) why submitting an M1 submission amidst 0.7.x => 0.9.x is useful?  

My guess is we don't have 1.0 ratification until Q4 2025 + Q1 2026 and this ratification, given 0.5 => 0.7 took the first 9 months of 2025 -- is this a good guess?
2025-09-17 17:39 danicuki: ‚òùÔ∏è
2025-09-17 18:55 sourabhniyogi: Lol -- always good to make the judge, jury and executioner happy.  But I don't see the reason why we should be in a rush to submit. 
2025-09-17 19:22 sourabhniyogi: By submitting faster, M1 prize money is not going to be paid any faster, but maybe we can feel secure / less anxious knowing that some of our sweat and tears will have been worth it -- is that it?   

I'm a little dismayed to hear that some of us cannot afford to make it out to sub0 in Buenos Aires  .. or maybe since we doing so well without even having an online meeting, we should save ourselves a couple days and [checking ticket prices...] a couple grand by not going and keep on building?  
2025-09-17 19:53 danicuki: > <@sourabhniyogi:matrix.org> By submitting faster, M1 prize money is not going to be paid any faster, but maybe we can feel secure / less anxious knowing that some of our sweat and tears will have been worth it -- is that it?   
> 
> I'm a little dismayed to hear that some of us cannot afford to make it out to sub0 in Buenos Aires  .. or maybe since we doing so well without even having an online meeting, we should save ourselves a couple days and [checking ticket prices...] a couple grand by not going and keep on building?  

I won‚Äôt be able to go to BA as well. There is gonna be a PBA JAM Course by December in Lisbon. Maybe it will be a good moment for us to meet again (before or after the PBA event), as some of JAM builders will be around anyway. 
2025-09-17 19:57 clearloop: if there is any link about this? haven't been Lisbon yet, I have applicated PBA Bali and got rejected last time ü´† [edited]
2025-09-17 20:05 sourabhniyogi: https://sub0.gg/ 
2025-09-17 20:05 sourabhniyogi: What is the PBA December link?
2025-09-17 20:09 emielsebastiaan: On the Bali Jam panel Gavin mentioned the intention to get implementation teams started with discussions on SDKs in December. I suppose he meant at or around the JAM PBA Lisbon event. It would be great to get some soft commitment on dates for planning purposes. 
2025-09-17 20:16 emielsebastiaan: https://polkadot.academy/jam/
2025-09-17 21:04 sourabhniyogi: For better or worse, this would appear to be the budget-friendly Schelling point for JAM implementers üò•
2025-09-18 01:44 ascriv: > <@sourabhniyogi:matrix.org> By submitting faster, M1 prize money is not going to be paid any faster, but maybe we can feel secure / less anxious knowing that some of our sweat and tears will have been worth it -- is that it?   
> 
> I'm a little dismayed to hear that some of us cannot afford to make it out to sub0 in Buenos Aires  .. or maybe since we doing so well without even having an online meeting, we should save ourselves a couple days and [checking ticket prices...] a couple grand by not going and keep on building?  

Why wouldn‚Äôt earlier submissions get earlier prizes?
2025-09-18 02:26 ascriv: > <@gav:polkadot.io> 0.7.0 is where I would be happy to accept M1 submissions. 

I assumed this also meant prizes would go out when the submissions are verified, not by GP 1.0. Can we get some clarification on this?
2025-09-18 11:58 gav: The reading of the rules by [sourabhniyogi](https://matrix.to/#/@sourabhniyogi:matrix.org)is accurate. The intention is to avoid depletion of the prize pot before everyone has had a reasonable chance to compete for it. 
2025-09-18 11:58 gav: However given the extended length of the project I am considering the possibility of loosening the rules. Possibly for the M1 and M2 milestones. 
2025-09-20 14:13 hitchhooker: 
2025-09-20 14:34 sourabhniyogi: We have an awesomely clear idea about M1 conformance (and increasingly good resolution about what M3/M4 is about, at least for PVM) ... but not M2 -- can you provide guidance on M2 conformance requirements so those of us who are ready \[pretty much all enrolled teams\] can spend our extra hours on that most effectively for the rest of the year?

If this can't be defined precisely because it sounds like a promise, perhaps a "soft target" proxy to focus teams works very well: "M2 conformance would be to author blocks and refine DOOM work packages with jamt alongside polkajam + another team in a tiny testnet for N hours". 

Then the rules could be loosened (without premature ratification of 1.0) in a predictable way while ensuring everyone is focused on the next 2 milestones by having soft targets for both, something like "If you can include in your M(n) report how you met the soft targets of M(n+1) and M(n+2), then ___".  This keeps implementers focussed meeting the engineering goals of the M(n) hard target while also attempting the M(n+1) and M(n+2) soft targets and sacrifices nothing on desired conformance goals of the hard target.    Does that make sense? [edited]
2025-09-20 14:57 hitchhooker: https://w3c.github.io/webtransport/#certificate-hashes

for some reason(bigtech?) webtransport decided against bidirectional authentication - "does not provide any means of authenticating the client" per spec.
does WebTransport's serverCertificateHashes work with self-signed certs on ipv6 addresses? like can chrome/firefox connect to https://\[2001:db8::1\]:4433 using cert hash verification? 

e: https://github.com/w3c/webtransport/issues/590 unresolved issue for p2p seems to be overcoming nat as usual... [edited]
2025-09-22 09:39 knight1205: Hi davxy ,

Can you please update crates for jam sdk?
Current released version is 0.1.22. I suppose it doesn't have latest changes till GP v0.7.
2025-09-22 10:09 davxy: Martin: ^
2025-09-22 12:10 dave: We're working on this. We're streamlining the publishing process and intend to update the crates much more regularly once that is done.
2025-09-25 07:10 hey_im_stas: Hey!

I've created JAM Services Examples and SDKs repo.
[Awesome JAM Service](https://github.com/DrEverr/JAM-Service-Demos)
If you working on your demos and sdks, feel free to add your repo to this list, so it's easier for future users to find you.
  ‚Ü≥ 2025-09-25 12:31 oliver.tale-yazdi: I will proably open an MR later to add the JamBrains Service SDK: https://github.com/JamBrains/service-sdk  
it was demoed at PBA
2025-09-25 10:11 roysingh8368: Hii Team can anybody tell me how can HS and HV generated , proper flow i wanted to understand in the Safrole component.  [edited]
2025-09-25 12:19 luke_jamixir: I doubt anyone is going to answer such a general question.
Your going to have to be more specific then that 
2025-10-02 17:14 clearloop: Hi there, our service sdk [jade](https://github.com/spacejamapp/jade/tree/main) is now ready to be hacked!  for the quickstart of jade

```bash
cargo install jade
jade new my-service
cd my-service
cargo test
```

for the recent releases:

- now `jade` is using dependencies from `spacejam` directly
- introduced the [system interface of SpaceVM](https://docs.rs/spacevm-sys/0.0.12-patch-1/spacevm_sys/) (both compiler and interpreter)
- I just found that I have written [a instruction table for PVM](https://pvm.spacejam.app/) months ago...feel free to check it out for fun
- [our website](https://spacejam.app/) is open sourced and updated with more links

I have prepared [2 simple issues in jade](https://github.com/spacejamapp/jade/issues) for new devs in JAM that don't know where to start, which are about

- the skill of reading graypaper
- understanding how host call works in the services
- writing service tests using `jade`

happy hacking! [edited]
2025-10-06 11:14 anish1222: Hello,

i have done with M1 and for M2 i am stuck with networking part please anyone tell me that how can i connect with another node (wanted to know the node, ) ?.. what is Jam-duna
2025-10-06 11:26 dave: The network protocol is described here: https://github.com/zdave-parity/jam-np/blob/main/simple.md [edited]
2025-10-06 11:27 dave: I think there are quite a few implementations available to test against now. Parity's implementation is available here (binary-only for now): https://github.com/paritytech/polkajam-releases
2025-10-06 19:25 davxy: > I have done with M1

What is your impl?
2025-10-06 20:22 shimonchick: is this still relevant as of GP 7.1 ? https://github.com/w3f/jamtestvectors/blob/master/trie/merkle.py
2025-10-07 07:30 arkadiy: This is an up to date version. Not sure why it is not merged yet:
https://github.com/w3f/jamtestvectors/pull/14
2025-10-07 08:23 shimonchick: thank you
2025-10-07 14:21 shimonchick: Should an M1 implementation comply with the SCALE codec test vectors if we have the GP compliant variable length encoding done? https://github.com/w3f/jamtestvectors/blob/master/codec/README.md
2025-10-07 14:44 dave: You should use davxy's fork here, sorry about the confusion: https://github.com/davxy/jam-test-vectors [edited]
2025-10-07 14:44 dave: The codec vectors there should match the GP codec
2025-10-07 19:18 shimonchick: am i missing something, or are both master and v0.7.1 of the fork also using SCALE instead of GP variable length encoding?
2025-10-07 21:19 dave: That fork should be using the GP codec. If you think there's an error in the test vectors please open an issue
2025-10-07 21:29 davxy: Both the master branch in the w3f repo and my fork should be using JAM variable-length encoding.  
Where exactly have you found the "classic" SCALE varlen encoding being used? [edited]
2025-10-08 02:25 sourabhniyogi: Any news on the dates/location for this, which is now less than 8-10 weeks from now I gather?
2025-10-08 19:56 dhruv245: Hi, is there any dates of when the submission of M1 and M2 will open. My team has completed both of them, so can I know the next steps?
2025-10-08 20:49 davxy: Hi! Could I ask what is implementation?  
Also, have you implemented the fuzzer protocol for M1?  
You can find more info here: https://github.com/davxy/jam-conformance/tree/main/fuzz-proto
2025-10-09 06:52 jan: As you may or may not know, I'm working on the new gas cost model for JAM. I'm finally at a point where I will be merging the initial implementation of the new gas cost model into PolkaVM, and updating the GP to include it.

So I'm looking for volunteers. The task is simple: commit to implement the new gas cost model in your PVM based on my draft changes to the GP in a timely manner (say, under a week), run some new test vectors I'll prepare (these will be a new kind of test vectors, and won't involve executing any code in your PVM, but only checking the calculated gas costs), and report any feedback you might have.

Note that this will *not* give you any advantage wrt the JAM prize; all of this will be public, and you will not be getting "early access" to anything; the only difference is 1) you give me a commitment to implement this quickly and give feedback, and 2) you'll be implementing something that's not in the GP (yet), so it might be unclear, scuffed, incomplete or still change in a substantial manner. The new gas cost algorithm is complex yet will be a critical part of JAM, so the whole point of this exercise is to get a third-party implementation *before* it hits the GP, so that we can iron out the issues as fast as possible.

Message me if you're interested, and once I have a draft of the GP changes (which, again - will be public; this ain't an early access program) I'll ping you with a link.
2025-10-09 11:42 hitchhooker: has jamnp-s been tested to be able to overcome chinese ISPs blocking QUIC traffic?
https://labs.apnic.net/presentations/store/2023-03-01-quic-apricot.pdf
https://www.youtube.com/watch?v=Vc9QiE1CgpE&t=3450s
2025-10-09 12:01 dave: It uses QUIC so if that is blocked it's not going to work
2025-10-10 13:27 gav: Meh - it‚Äôs base layer tech. They won‚Äôt block it forever. 
2025-10-10 13:57 hitchhooker: https://gfw.report/publications/usenixsecurity25/en/#sec:7-circumvention
seems like custom(or rfc9369) quic versioning, 65535 default port for validators would help a lot to overcome it [edited]
