# room: #jam:polkadot.io
# exported: 2025-05-23 03:31 UTC
2024-04-20 02:08 johnjiao123: 
2024-04-20 02:09 johnjiao123: 
2024-05-30 21:48 nradko: Hey everyone,
are the lectures explaining gray paper recorded and available online?
2024-05-31 10:54 gav: > <@nradko:matrix.org> Hey everyone,
> are the lectures explaining gray paper recorded and available online?

They are recorded but not online yet. Will be soon. 
2024-05-31 10:55 nradko: > <@gav:polkadot.io> They are recorded but not online yet. Will be soon.

can't wait.
2024-06-02 19:50 purpletentacle: A couple of quick questions:

- Are there any conformance tests already public? (as per rule 15)

- is FFI for external libs acceptable (e.g. crypto from a rust lib) or while libs are acceptable, they need to be native to the chosen language?

this was written in the w3f page but does not seem to be part of the rules: 
> Third-party libraries for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE), and networking (e.g. QUIC) are acceptable.


2024-06-02 20:38 gav: FFI is fine. 
2024-06-02 20:39 gav: Conformance tests are being worked on and we should be releasing the first batch in the next few weeks. 
2024-06-03 06:55 tomusdrw: Hello! Is TypeScript cude enough for set C? Or rather: does it qualify as JS?
2024-06-03 07:01 tomusdrw: Also, if I calculate correctly, in the happiest case, the maximal number of teams getting the maximal prize for each milestone in every set is ~2-3 (10M - minus extra auditing/operational costs / 5 milestones / 4 sets / 100k prize).
Hence I'm wondering is it public (maybe published already?) how many applications was there for each and every set? 
2024-06-03 12:33 purpletentacle: Is there any additional information about networking specs/protocol? I could only find that it will be based on QUIC.. but nothing more than that.. This is not critical information for the first milestones.. but it can be useful to have in mind already. Any public information or hints about this? [edited]
2024-06-04 02:02 gav: Not really - expect QUIC with Ed25519 keys. 
2024-06-04 02:03 gav: And direct connections to all other validators. 
2024-06-04 02:03 gav: Networking specs probably won’t arrive for another 2-3 months.
2024-06-04 02:08 gav: 20240604T020818Z.jpg
2024-06-04 02:10 gav: Current thinking is that validators will be well connected with each other and then have a few extra proxy nodes which also are reasonably well connected. These then connect out to the public. 
2024-06-04 03:36 xlchen: will the graypaper to cover RPC spec as well?
2024-06-04 04:15 gav: No (since it’s app specific and not related to the protocol). 
2024-06-04 04:15 gav: But there should be a fellowship RFC. 
2024-06-04 04:16 gav: It can be something implementor teams can discuss in the implementation conferences. 
2024-06-04 04:17 gav: I expect to publish 0.2.0 of the paper today. 
2024-06-04 04:17 gav: This should more or less finalize the DA system.  [edited]
2024-06-04 04:18 gav: Safrole should also be final. And the trie spec. For all three we’ll aim to have test vectors in the coming days. 
2024-06-04 04:19 gav: Block execution vectors should be ~6 weeks out. 
2024-06-04 04:20 gav: Availability system test vectors probably about the same timeline.  [edited]
2024-06-04 04:23 gav: Once we see some initial action on code from the first few teams then we’ll sort out a mini implementation conference/seminar/hackathon. 
  ↳ 2024-06-21 19:15 yikesawjeez: i like to organise usually-smallish-but-sometimes-big hackathaons online for fun, once you folks start heading that direction would love to get in touch with whoever's taking the lead on it and see how i can help if possible :)
2024-06-04 05:23 pos.digitalghost: > <@gav:polkadot.io> And direct connections to all other validators.


wonder how would this pan out in censored areas where data center IPs are blocked

2024-06-04 05:59 gav: The protocol does rely on high quality connections (400 Mbps sustained) between validators; if you’re running a validator node then you’d need to provide this level of connectivity. 
2024-06-04 06:01 gav: For regular (“full”) nodes then you’d most likely connect to the validator proxies. For work-package authors, you’d want to connect to one of three guarantors of the core for the work package. Likely that would have a different protocol, and would not receive eg block updates over it. 
2024-06-04 06:02 gav: All this networking stuff is the last thing to be finalized as it doesn’t affect the core protocol. 
2024-06-04 09:36 tomusdrw: > <@tomusdrw:matrix.org> Hello! Is TypeScript cude enough for set C? Or rather: does it qualify as JS?

^^^ @gav any comments on this one?
2024-06-04 09:41 pos.digitalghost: guess so as it’ll have to convert to js anyways
2024-06-04 09:43 gav: > <@tomusdrw:matrix.org> Hello! Is TypeScript cude enough for set C? Or rather: does it qualify as JS?

It qualifies as a major dialect of JS :)
2024-06-04 09:44 gav: > <@tomusdrw:matrix.org> Also, if I calculate correctly, in the happiest case, the maximal number of teams getting the maximal prize for each milestone in every set is ~2-3 (10M - minus extra auditing/operational costs / 5 milestones / 4 sets / 100k prize).
> Hence I'm wondering is it public (maybe published already?) how many applications was there for each and every set? 

Auditing would be paid separately to the prize fund. 
2024-06-04 09:45 gav: So it’s strictly a max of 500k DOT total (100k per milestone)
2024-06-04 09:46 gav: Gauging from interest thus far, I’d say it’s a reasonable expectation that teams delivering milestones pre-launch will be getting the full amount. 
2024-06-04 09:49 gav: But yeah, theoretically if there’s more than 20 teams delivering viable, audited implementations across the language sets pre-1.0 spec then even those in the first wave could end up with less. I’d say it’s rather an unlikely eventuality.  [edited]
2024-06-04 09:57 gav: If it’s an issue for teams then we could perhaps say that those teams who get to M1 first get prioritised for prizes if there is contention and they are at M4 or M5 at network launch. [edited]
2024-06-04 13:00 purpletentacle: > <@pos.digitalghost:matrix.org> 
> wonder how would this pan out in censored areas where data center IPs are blocked
> 

@gav It would be nice if networking is ipv6 based.. this would simplify a lot the networking, nat, etc.. given that the spec will require at least 400Mbps.. most providers will be able to support ipv6 without complaining much...
2024-06-04 21:51 gav: > <@purpletentacle:matrix.org> @gav It would be nice if networking is ipv6 based.. this would simplify a lot the networking, nat, etc.. given that the spec will require at least 400Mbps.. most providers will be able to support ipv6 without complaining much...

Yes indeed. 
2024-06-07 01:01 aedigix: > <@gav:polkadot.io> Yes indeed.

There should be support for ipv4 RPC endpoints unless RPC is outside of the scope of JAM
2024-06-07 04:01 gav: It’s essentially out of scope. 
2024-06-07 04:03 gav: There might be an RFC. But JAM usage should rely on light-clients rather than full-node+RPC. 
2024-06-10 20:37 purpletentacle: gav:  In the case of some small inconsistencies in the graypaper, would you prefer to discuss them here, or a PR in the repo is better?
2024-06-11 02:30 gav: Best to discuss in the graypaper channel rather than here but if they’re obvious corrections then a PR is fine too. 
2024-06-16 12:57 ltfschoen: it says here https://jam.web3.foundation/rules that "Clean-room implementation using the Graypaper and public implementor chat channels as the only resources.".

it is my understanding that the Graypaper chat channel is https://matrix.to/#/#graypaper:polkadot.io

where are the "public implementer" chat channels?

and is there a reason why it doesn't include the Jam chat channel here https://matrix.to/#/#jam:polkadot.io?

also, it says "Each team is only allowed to work on one implementation", but in the application form it says "What programming language(s) are you using and which language set are you applying for? e.g. "Rust, set B", so i don't understand why it's asking us "What programming language(s) are you using". is it just wanting to know if we'll be using multiple languages in the our single implementation (e.g. if we'll be doing an implementation in Rust and using FFI from Ruby and Python then we'd answer `Rust, Ruby, Python, set B`?

i was actually going to try and work on multiple implementations using multiple language sets (e.g. Rust, Swift Ruby, Python, JS/TS) in parallel as a contingency incase i got stuck and couldn't get support with one of them. after submission of our initial application form, will be possible for us to later on change what programming language(s) and language set that we'll be using for the one implementation that could be eligible for the JAM prize?
2024-06-16 20:09 sourabhniyogi: For rule 7, "Any JAM-implementation code which is viewed before or during implementation must be declared", is the following acceptable for declaration:

```
In our implementation, beyond the Graypaper, we relied on the following for either FFIs or our learning of JAM:
 1. Koute's PVM Implementation: (no FFI)
    https://github.com/koute/polkavm
 2. Ring VRF: (FFI [link](...))
    https://github.com/w3f/ring-vrf
 3. Sassafras (no FFI)
    https://github.com/paritytech/polkadot-sdk/pull/1336/
    https://github.com/polkadot-fellows/RFCs/pull/26
 4. Polkadot-SDK: Grandpa (no FFI)
    https://github.com/paritytech/polkadot-sdk/...
 5. Polkadot-SDK: Erasure Coding (FFI [link](...))
    https://github.com/paritytech/polkadot-sdk/...
```

Are all of (1)-(5) declarations actually necessary?  Do any of (1)-(5) break "clean room" expectations in some way?

If the FFI vs non-FFI boundary is made clear and what should NOT be peeked at (even for learning purposes), it will spare implementers some grief (implementing something where FFI is acceptable or preferred, peeking at something which should not be peeked at).  Can you make clear which components would ideally NOT use FFI and would ideally use FFIs?  [edited]
2024-06-16 20:49 sourabhniyogi: For rule 15, "For code developed in private, commit hashes should be placed, in a timely fashion, ..." what does "in a timely fashion" mean, e.g if we commit via system.remark via  
https://assethub-polkadot.subscan.io/extrinsic/6489450-2  on June 16 
and then again on July 16, Aug 16, Sept 16 (once a month) is that sufficient or is a higher frequency expected? [edited]
2024-06-17 03:07 ascriv: Will there be a public list of teams and their chosen programming language? I want to work on implementation but I also want not to spend a lot of time on one of the languages that has a seriously good team already on it
2024-06-17 03:07 ascriv: Could also be good for finding teams to join 
2024-06-18 03:11 gav: The only thing which really matters is the code and the ability to demonstrate that it is a reasonably independent implementation of your own. [edited]
2024-06-18 03:12 gav: Application forms are totally irrelevant.
2024-06-18 03:13 gav: The point of restricting a prize-teams to a single implementation project is: [edited]
2024-06-18 03:14 gav: - to disincentivize the submission of additional Milestone 1/2 submissions over developing an impl towards Milestones 3-5.
- to avoid getting multiple implementations with the same overall architecture and design (and bugs). [edited]
2024-06-18 03:18 gav: 1 compromises hygiene somewhat, 3 and 5 probably not since neither are compatible with GP. 2 and 4 are probably fine since they're not going to be defined in the GP. [edited]
2024-06-18 03:19 gav: Third-party libraries (FFI) for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE) and networking (e.g. QUIC) are acceptable. [edited]
2024-06-18 03:20 gav: Everything else should be properly implemented.
2024-06-18 03:21 gav: A proper Grandpa impl should be assumed to be a requirement of milestone 2 and above. This might be elevated to milestone 3, so treat it as the lowest priority feature. I haven't made this especially clear yet since it's not especially well-defined in the GP and I wouldn't expect impl teams to need it for some months to come yet. [edited]
2024-06-18 03:23 gav: > <@sourabhniyogi:matrix.org> For rule 15, "For code developed in private, commit hashes should be placed, in a timely fashion, ..." what does "in a timely fashion" mean, e.g if we commit via system.remark via  
> https://assethub-polkadot.subscan.io/extrinsic/6489450-2  on June 16 
> and then again on July 16, Aug 16, Sept 16 (once a month) is that sufficient or is a higher frequency expected?

Higher frequency
2024-06-18 03:24 gav: The point of this is to help _you_ prove that *you* wrote the code organically. [edited]
2024-06-18 03:25 gav: If you come to the Fellowship with one big commit of a working impl but the code design/arch looks similar to some other (maybe OSS) impl, then Fellowship are going to need further clear evidence that it's not just a port.
2024-06-18 03:26 gav: A Git history with credibly timestamped commit hashes are one way of helping with this.
2024-06-18 03:26 gav: If you don't provide this additional evidence then you run the risk of trouble with claiming the prize.
2024-06-18 03:27 gav: Teams which want to make their presence known can contact David at the W3F or post on here. [edited]
2024-06-18 03:28 gav: There is no requirement to pre-announce ones intention though. There is not a single prize per language: e.g. two teams writing an independent C++ impl can both claim the full prize in principle (clean room rules still apply!) [edited]
2024-06-18 03:29 gav: However, if you want to make it a bit more likely that you'll not be writing in the same language as some other team (for whatever reason), then consider selecting a less-common language. The language groupings are set with the intention of incentivising diverse impl languages. There's a single pot per grouping so that 20 teams all writing in C++ and Rust don't take the full pot. [edited]
2024-06-18 16:59 sourabhniyogi: For rule 24, "The repository must include a clear and permissive open-source license." are Business Source Licenses such as that of 
(1) Uniswap https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/LICENSE
(2) Arbitrum https://github.com/code-423n4/2024-05-arbitrum-foundation/blob/main/LICENSE.md
(3) Aave https://github.com/aave/aave-v3-core/blob/master/LICENSE.md
which mostly originate from https://mariadb.com/bsl11/ considered "clear and permissive open-source licenses"?

It may be useful to have JAM teams get a head start over TRON/BSC/... type actors with a mechanism like this:
https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/LICENSE#L18-L21 [edited]
2024-06-18 17:05 gav: Could you make this question clearer/more specific? [edited]
2024-06-18 17:19 sourabhniyogi: Sure -- for Rule 24  "The repository must include a clear and permissive open-source license." is this license acceptable:

```
Business Source License 1.1

License text copyright (c) 2017 MariaDB Corporation Ab, All Rights Reserved.
"Business Source License" is a trademark of MariaDB Corporation Ab.

-----------------------------------------------------------------------------

Parameters

Licensor:             JAM Team X

Licensed Work:        JAM X  
The Licensed Work is (c) 2024 JAM Team X

Change Date:          2029-04-19

Change License:       GNU General Public License v2.0 or later

-----------------------------------------------------------------------------

Terms

The Licensor hereby grants you the right to copy, modify, create derivative works, redistribute, and make non-production use of the Licensed Work. The Licensor may make an Additional Use Grant, above, permitting limited
production use.

Effective on the Change Date, or the fourth anniversary of the first publicly available distribution of a specific version of the Licensed Work under this License, whichever comes first, the Licensor hereby grants you rights under the terms of the Change License, and the rights granted in the paragraph above terminate.

If your use of the Licensed Work does not comply with the requirements currently in effect as described in this License, you must purchase a commercial license from the Licensor, its affiliated entities, or authorized
resellers, or you must refrain from using the Licensed Work.

All copies of the original and modified Licensed Work, and derivative works of the Licensed Work, are subject to this License. This License applies separately for each version of the Licensed Work and the Change Date may vary for each version of the Licensed Work released by Licensor.

You must conspicuously display this License on each original or modified copy of the Licensed Work. If you receive the Licensed Work in original or modified form from a third party, the terms and conditions set forth in this License apply to your use of that work.

Any use of the Licensed Work in violation of this License will automatically terminate your rights under this License for the current and all other versions of the Licensed Work.

This License does not grant you any right in any trademark or logo of Licensor or its affiliates (provided that you may use a trademark or logo of Licensor as expressly required by this License).

TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE LICENSED WORK IS PROVIDED ON AN "AS IS" BASIS. LICENSOR HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS OR IMPLIED, INCLUDING (WITHOUT LIMITATION) WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND TITLE.

MariaDB hereby grants you permission to use this License’s text to license your works, and to refer to it using the trademark "Business Source License", as long as you comply with the Covenants of Licensor below.

-----------------------------------------------------------------------------

Covenants of Licensor

In consideration of the right to use this License’s text and the "Business Source License" name and trademark, Licensor covenants to MariaDB, and to all other recipients of the licensed work to be provided by Licensor:

1. To specify as the Change License the GPL Version 2.0 or any later version, or a license that is compatible with GPL Version 2.0 or a later version, where "compatible" means that software provided under the Change License can be included in a program with software provided under GPL Version 2.0 or a later version. Licensor may specify additional Change Licenses without limitation.

2. To either: (a) specify an additional grant of rights to use that does not impose any additional restriction on the right granted in this License, as the Additional Use Grant; or (b) insert the text "None".

3. To specify a Change Date.

4. Not to modify this License in any other way.

-----------------------------------------------------------------------------

Notice

The Business Source License (this document, or the "License") is not an Open Source license. However, the Licensed Work will eventually be made available under an Open Source License, as stated in this License.
```

If not, is there a specific Change Date modification that could be acceptable? 
2024-06-18 17:21 gav: Without consulting a lawyer, no and no.  [edited]
2024-06-18 17:23 gav: The point is to ensure that any implementations are the property of the coders who deign to maintain them. The licenses should reflect that.  [edited]
2024-06-18 17:23 gav: Licenses which allow for individuals, organisations or other economic entities to retain a privilege over a code base regardless of others’ contributions do not fulfil this goal.  [edited]
2024-06-19 05:49 hitchhooker: https://i.ibb.co/z2TNfrD/toaster.png tried to draw toaster based on images and 2049 specs. looks like we around 128kw in total? 
2024-06-19 12:16 sourabhniyogi: > <@gav:polkadot.io> Safrole should also be final. And the trie spec. For all three we’ll aim to have test vectors in the coming days.

Are the test vectors for { Safrole, trie, DA system (?) } published already (if so, where?) or to be published still (if so, is there an ETA)? 
2024-06-19 12:25 tomusdrw: 
2024-06-19 13:23 gav: > <@sourabhniyogi:matrix.org> Are the test vectors for { Safrole, trie, DA system (?) } published already (if so, where?) or to be published still (if so, is there an ETA)? 

Not yet. Will notify here as soon as they’re compiled. 
2024-06-20 17:55 yikesawjeez: hey; is there a canonical resource for what all a jam client would entail? Closest thing I can find is the RFC, but i have a team working on a substrate solochain that's more-or-less what's being described in the greypaper; would love to find some more info
2024-06-21 09:57 gav: The Graypaper covers all of the main protocol elements. There’s a notable lack of spec for a full networking protocol, which doesn’t make much sense to do until the first team gets basic block importing working (Milestone 1).  [edited]
2024-06-21 09:58 gav: “More or less” isn’t especially useful and it cannot be implemented utilising Substrate as there are several design decisions in Substrate which would preclude specifically this protocol.  [edited]
  ↳ 2024-06-21 18:59 yikesawjeez: admittedly i'm mostly going off what the lead dev was telling me as opposed to being intimately familiar with the architecture myself; he seemed quite excited after listening to a podcast outlining the vision for JAM about being, presumably, at least headed in the same direciton. Would the various milestones be listed in the RFP, and would that be the best place to look if somone wanted to get involved in building/helping out with the project in general?
  ↳ 2024-06-22 04:12 gav: Yes, the milestones will be effectively fixed as we have information for the conformance and performance tests required for them. Since this is a protocol-oriented approach rather than software-oriented, we don't yet have an implementation from which a reasonably tranche of test vectors can be produced.
  ↳ 2024-06-22 04:13 gav: Until then you can assume Milestone 1, defined as a block-importer, is for the implementation of all on-chain logic in the GP, which you'll find is all sections up to and including section 12, taking into account all relevant appendices. [edited]
  ↳ 2024-06-22 04:14 gav: Sections 13 onwards deal with the off-chain logic and will be for Milestone 2 - a block author and node - which will also need the yet to be written networking spec. [edited]
2024-06-21 15:43 jimboj21: Going off the previous question, is it imagined that certain components of JAM will use parts of substrate, or will everything be written from scratch? A specific example I am thinking of is grandpa. Is it imagined that the current implementation will be used (for one of the impls) or that it will be rebuilt? 
2024-06-21 17:59 sergei_astapov: Hey everyone,

Three passionate PBA 5 alumni have chosen to build a JAM client using Scala 3 (vanilla Scala). If you're familiar with Scala and interested, feel free to DM me without hesitation!

Thanks!
2024-06-22 04:16 gav: Mostly from scratch; Substrate specifically won't be helpful. [edited]
2024-06-22 04:16 gav: Substrate is a relatively opinionated blockchain framework. It is also software, not a protocol. [edited]
2024-06-22 04:16 gav: Jam is a protocol. That essentially precludes it from being based on Substrate, which is software.
2024-06-22 04:19 gav: Grandpa is also protocol-first, so pre-existing implementations can likely be leveraged provided they are compatible with the Grandpa spec paper and the (yet to be formalised) GP-integration spec.
2024-06-22 04:24 gav: For the full payout, we'll almost certainly require a clean-room implementation of Grandpa though. Basing all node impls on a single Grandpa impl could compromise the network in case a bug were found in it.

In general, the only exceptions we can make to this rule are where the logic is extremely well-specified and understood outside of the Jam/Polkadot community, audited, and/or in heavier or more economically significant use outside of Polkadot. For this reason we can make exceptions for some of the underlying crypto/networking/math primitives which are not especially specific to Jam/Polkadot, such as EC, Ed25519, BLS, QUIC, Bandersnatch. [edited]
2024-06-22 04:28 gav: As I mention above though, implementing Grandpa should not be considered an especially high-priority job. At present the definition of milestone 2 would include it, but this might very well change to milestone 3 in due course.
2024-06-22 04:58 tomusdrw: > <@gav:polkadot.io> - to disincentivize the submission of additional Milestone 1/2 submissions over developing an impl towards Milestones 3-5.
> - to avoid getting multiple implementations with the same overall architecture and design (and bugs).

Given the objective of the "one team = one implementation" rule is to have teams focus on milestones 3-5 is it allowed to change the implementation language at some point?

I'm thinking specifically about a situation, where say, the first two milestones are completed in a less performant language (e.g. lang set C) and then the team realises there is almost no way of completing 3-5 and switch to something faster.
Obviously the prize for Milestones 1-2 wouldn't be claimed twice, the second implementation would only claim 3-5.

Would that be acceptable?
2024-06-22 05:00 gav: Totally.
2024-06-22 05:01 gav: I'd also leave open the degree to which M1 and M2 could be claimable for the second language.
2024-06-22 05:03 gav: If the two languages are different to the point that one could reasonably claim that it would be difficult for bugs and design flaws to cross the linguistic divide (e.g. functional vs procedural), then the Fellows (or failing that, W3F) could reasonably decide to award some or all of the prize anyway. [edited]
2024-06-22 05:04 gav: Ultimately, the point of the prize is to build resilience through decentralisation and diversity. The rules are (hopefully) relatively conservative in preventing loopholes which might allow teams to claim the prize without contributing to the network's resilience. But where that conservatism might be judged by the Fellowship to be counter-productive, then it might reasonably choose to award prizes regardless. [edited]
2024-06-22 05:07 gav: Obviously if a team implements in C and then "reimplements" in a C-dominated "C++", then this would not be claimable.
2024-06-22 05:08 gav: But if they implement in Haskell and implement again in a very idiomatic C++, both _might_ be claimable. All prize decisions are made at the discretion of the (non-team) Fellows. [edited]
2024-06-22 05:13 gav: Languages from different language sets and which do not share syntactic DNA would be a sensible lower-bar (required but not sufficient) for multiple prizes. [edited]
2024-06-22 19:59 purpletentacle: I think it would be unfair to the ones that get to M3-4.... to see teams that just concentrate on doing many M1s.. 
The biggest risk I see, is that performance requirements are not very clear.. and very likely Rust will set the bar for every other language...
having some guidelines on what performance (%) is acceptable below the top implementation would be useful [edited]
2024-06-22 21:17 xlchen: the bottleneck is most likely to be pvm and for production performance we most likely need to translate it to native code and run it. in that case, the language will only impact the translation phase, which should be a relatively simple thing
2024-06-22 21:17 xlchen: so the implementation language shouldn’t matter too much
2024-06-22 21:20 xlchen: but of course we can’t say for sure without an implementation 
2024-06-23 03:05 gav: > <@purpletentacle:matrix.org> I think it would be unfair to the ones that get to M3-4.... to see teams that just concentrate on doing many M1s.. 
> The biggest risk I see, is that performance requirements are not very clear.. and very likely Rust will set the bar for every other language...
> having some guidelines on what performance (%) is acceptable below the top implementation would be useful

M5 should be a pretty easy milestone to achieve after M4 for any well-engineered codebase, so that helps mitigate against bias towards "reimplementing what you know". In fact, roughly half of the actual logic is in M1 and roughly the other half in M2. M3, M4 and M5 are essentially "just" optimisations and security, so teams who repeatedly reimplemented M1 would probably be losing out. But point taken, and this is why the rules are as they are and it cannot be taken for granted that the same milestones by the same people will receive multiple rewards.
2024-06-23 03:06 gav: > having some guidelines on what performance (%) is acceptable below the top implementation would be useful

One quite likely possibility is that likely performance requirements will be set at the lower of 80% of the most performant implementation and the third-most performant implementation. It will almost certainly need to be relative to the performance of the actual implementations. Another possibility would be to be just 90% of the 3rd most performant impl. [edited]
2024-06-23 03:11 gav: Indeed, performance bottlenecks will almost certainly be database (which is designed to be held entirely in-memory anyway), PVM (designed for recompilation) and crypto/EC (designed to allow SIMD and aggregation, and for which FFI/external libraries are acceptable). Actual on-chain business logic is pretty minimal. [edited]
2024-06-23 03:17 gav: It would be up to the team to figure out how to make the performance criteria happen. For example, a JVM-based language would probably have to do the same trick as native-built language and recompile PVM to native machine language and execute natively somehow, rather than doing the naive, fully-compatible thing and recompiling into JVM.
2024-06-23 06:46 sergei_astapov: Hi all,

In graypaper pg 8,9

```
(18) β′ ≺ (H,EG,β†,C)
(28) (..., C) ≺ (EA,ρ′,δ†,χ,ι,φ)
```

I'm unable to determine what 'C' really stands for.
Please correct me if I'm mistaken, but it seems there is no definition for C in GP.
Thank you! [edited]
2024-06-23 06:47 gav: It’s the beefy commitment set. 
2024-06-23 06:47 gav: It should be mentioned in the definitions section. 
2024-06-23 06:48 gav: It’s defined at the end of the accumulation definitions. 
2024-06-23 06:48 gav: Section 14 iirc. 
2024-06-23 15:13 sourabhniyogi: For our travel budget/life, I would very much like to see the implementer's hackathon/get-together at Devcon 7 https://devcon.org/en/ in November \[like 2 days before then, the 4 days during, and then maybe 2 days after with a bunch of JAM how-is-this-really-working nitty gritty\] -- is this possible to get on a calendar?  If you mean to have a get-together earlier than that, can you let us know so we can plan our travel life/budget accordingly?

I'd like to believe around 4+ teams can get Milestone 1 in "local tests passed!" shape before this get-together and have like "hey, lets see if we can network 4 different implementations together for real" sort of hacking happening there, and get ssh-login concrete about whatever private access to standard hardware / JAM TOASTER will mean.  Then we can all feel pretty good about getting Milestone 2 by Q1 2025 and finishing Milestone 1 by the end of the year.  What do you think? [edited]
2024-06-24 02:39 gav: This seems like a good target timeline.
2024-06-24 04:11 xlchen: I created some diagrams, will love a review https://hackmd.io/0gSmXyElT2iKawymS5jJKw?view
2024-06-24 04:30 sourabhniyogi: This is super helpful (and keeps us all grounded, thank you!).  Did we miss a lecture on the Asset Hub <=> JAM connection, or is this your idea on how to keep us grounded?   I was wondering what happened to this sketch/intuition:
 https://github.com/polkadot-fellows/RFCs/blob/gav-coreplay/text/coreplay.md#scaling-a-common-use-case

  ↳ 2024-06-24 04:34 xlchen: The AssetHub part is not part of GP (so does the parachain service) but it is how I image it will be integrated and don't really see other possibilities
2024-06-24 05:32 gav: > <@xlchen:matrix.org> I created some diagrams, will love a review https://hackmd.io/0gSmXyElT2iKawymS5jJKw?view

Looks pretty accurate.  
2024-06-24 05:33 gav: I’d generally try to avoid RPC in Jam completely, and just try to push the use of one or more Smoldot-style light clients. 
2024-06-24 05:34 gav: At present there’s no prize allocated to specifically light clients, but I do expect to incentivise their creation in due course.
2024-06-24 05:41 xlchen: Users don't really need to access the JAM chain anyway so I can image we only need some RPC for operators/developers
2024-06-24 05:50 gav: Yes if it’s just about providing an FFI and if they are generally wanting to run a full node then fair enough. But a full node is not trivial to run - every 6-second block is projected to have ~3.5 seconds of PVM computing in it plus a large amount of signature verification and memory access for the DB. The blocks are big: maybe 17 MB every 6 seconds. For work package building nodes I’m not sure they’d necessarily want to be running a full node.  [edited]
2024-06-24 05:52 gav: Some will need the raw state read throughout. Many won’t: parachain collators for example probably only need to read 1 or 2 KB per block which could easily be managed by a light client and really doesn’t make sense to run a full node over.  [edited]
2024-06-24 05:53 gav: And we *really* don’t want them connecting to some random shared RPC for it.  [edited]
2024-06-24 06:00 xlchen: we could have a flag to disable most of the signature verifications and skip some other checks and only rely on grandpa/beefy instead and it will be lightweight enough for many use cases? but yeah I can totally see that majority of the nodes are light node and not much need to have rpc node/full node
2024-06-24 06:02 gav: Well you’d still need to be running 3.5s of PVM, 1M db iops and downloading 17MB every 6 seconds. 
2024-06-24 06:02 gav: Even if you skipped all the signature checks. 
2024-06-24 06:06 xlchen: right. so we still need a proper light client and some protocol for the light client to communicate with full node
2024-06-24 06:07 gav: Indeed; thankfully much of the work is already done with Smoldot. 
2024-06-24 10:57 purpletentacle: > 13. A clear Git history and public, credibly timestamped commits are necessary in order to help evidence organic code development by the team/s.

> 14. Timestamps may be by virtue of pushing code to GitHub on a timely basis.

> 15. For code developed in private, commit hashes should be placed, in a timely fashion, on a major public blockchain and readily visible on a block explorer.

Just to avoid any kind of future misunderstanding about this.

IF the project is done in GitHub, the requirement for pushing hashes into a blockchain is not necessary? Or for that to be fine, the github project needs to be made public and posted here? 
Or actually to be on the safe side, every project is expected to publish commit hashes to a blockchain every N days? [edited]
2024-06-24 13:17 gav: Fellowship will be looking for evidence that the team coded the software themselves from the GP. That it’s not a port or AI adjusted version of some other team’s software. To this extent it’s important for the teams to demonstrate an organic development process. Regular, sensibly-sized commits are one way of doing this and we assume GitHub is reasonably corruption-resistant (git alone obviously isn’t). But if you don’t want to use GitHub then make sure you credibly timestamp the commits elsewhere such as on a public blockchain.  [edited]
2024-06-24 13:18 gav: If you dump a codebase at the doorstep of the Fellowship with no way of proving that you actually coded it yourself then you run a risk of getting no prize.
2024-06-24 13:18 gav: This becomes especially important in the age of generative AI. 
2024-06-24 19:43 danicuki: I was wondering what programming language could result in the best performing implementation of JAM. 

If JAM is a CPU bound system, probably C, C++ or Rust could give me the best performance
If JAM is a I/O bound system, a language with more concurrent capabilities would be better. 

Which one would be the case? 

I am an enthusiast of Elixir, a very powerful language for concurring systems. I feel it could have a very elegant and yet performatic version of JAM 
2024-06-25 02:52 gav: Difficult to say at this stage though I can't see how there'd be any way around having PVM be recompiled into native and good optimised algorithms for EC and crypto, however these are very discrete components and with the latter two could reasonably be imported in. [edited]
2024-06-25 06:40 gav: @room The first test vectors have been merged into github.com/w3f/jamtestvectors [edited]
2024-06-25 06:41 gav: So far it's Safrole's STF with a couple of PRs open for the Merkle trie and PVM. [edited]
2024-06-25 06:41 gav: We'll work on getting vectors for the rest of the STF in the coming weeks, as well as the baseline crypto and EC. [edited]
2024-06-25 11:21 emielvanderhoek: I am looking forward to the Timeslot’s STF vectors. 😆
2024-06-27 04:56 xlchen: Screenshot 2024-06-27 at 4.56.16 PM.png
2024-06-27 04:56 xlchen: Screenshot 2024-06-27 at 4.56.31 PM.png
2024-06-27 04:56 xlchen: the order of the keys is different between GP and the test vector
2024-06-27 04:57 xlchen: https://github.com/w3f/jamtestvectors/blob/fa8699f94b2769cee5d05472072e6a5f839a57ed/safrole/safrole.asn#L35
2024-06-27 05:10 xlchen: looks like the safrole test vectors are encoded using JSON instead of the scale codec described in GP. i.e. a validator data is
```
{
                "ed25519": "0x837ce344bc9defceb0d7de7e9e9925096768b7adb4dad932e532eb6551e0ea02",
                "bandersnatch": "0xf16e5352840afb47e206b5c89f560f2611835855cf2e6ebad1acc9520a72591d",
                "bls": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                "metadata": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
            },
```
instead of bunch bytes. Will it be better to offer a variant that's using the raw bytes instead of JSON?
2024-06-27 05:10 xlchen: asking because otherwise 1) we need to implement a JSON serialization function for the types 2) need to ensure the names matching to the tests vector
2024-06-27 05:14 xlchen: and we cannot use the test vectors to test the serialization part
2024-06-27 08:11 gav: > <@xlchen:matrix.org> the order of the keys is different between GP and the test vector

Yes indeed [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)could you fix this?
2024-06-27 08:13 gav: > <@xlchen:matrix.org> looks like the safrole test vectors are encoded using JSON instead of the scale codec described in GP. i.e. a validator data is
> ```
> {
>                 "ed25519": "0x837ce344bc9defceb0d7de7e9e9925096768b7adb4dad932e532eb6551e0ea02",
>                 "bandersnatch": "0xf16e5352840afb47e206b5c89f560f2611835855cf2e6ebad1acc9520a72591d",
>                 "bls": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
>                 "metadata": "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
>             },
> ```
> instead of bunch bytes. Will it be better to offer a variant that's using the raw bytes instead of JSON?

Probably yes. I’m not against having smaller data items separately encoded (as it adds to the readability of the vectors) but in this case our primary definition is the blob, and the individual keys are just equivalence derivatives. 
2024-06-27 08:14 gav: [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)could you fix this also?
2024-06-27 15:51 davxy: Sure. I'll put the fix as part of an upcoming PR where I'll propose the vectors in two flavors: tiny (vals: 6, epoch len: 12) and prod (vals: 1023, epoch len: 600). PR very soon 🙂
2024-06-27 15:55 davxy: Ah. As you may have noticed, both metadata and bls key are placeholders. Not a big deal BTW, as they are not influencing Safole's STF
2024-06-28 06:47 kianenigma: I am trying to make sure my understanding of the semi-coherence property of JAM is correct. 

My understanding of this property is that parts of the system (i.e. *services*) that need to talk a lot with one another should be close to one another to do so without needing to deal with asynchrony. The most ideal system would then be one in which services can talk synchronously to the services that happen to execute in the same core in that time-slot, and asynchronous with those that are not.  

That being said, I believe I heard in the Singapore Graypaper lecture that the interfaces for services to communicate with one another is always asynchronous. 

If correct, we can then say that services, as the lowest level programming primitive of JAM don't enable synchronous comparability yet, but synchronous composability as described in a semi-coherent system can be built on top of them. 

This is primarily possible because of the core-model, the possibility of flexible scheduling of services in cores, and the PVM's ability to be readily paused and resumed. One example of such system is CorePlay. 

Is that a correct description of where JAM service stand in terms of synchronous composability between one another? 
2024-06-28 06:50 emielvanderhoek: Have recordings of the university lectures been made available, or if not will they be made available? 
  ↳ 2024-06-28 06:57 rtti-5220: yes, Key Pictures (creators of Behind the Code) along with The Kusamarian are recording and documenting all talks, and they will be made available after production I believe. [edited]
2024-06-28 07:12 gav: > <@kianenigma:parity.io> I am trying to make sure my understanding of the semi-coherence property of JAM is correct. 
> 
> My understanding of this property is that parts of the system (i.e. *services*) that need to talk a lot with one another should be close to one another to do so without needing to deal with asynchrony. The most ideal system would then be one in which services can talk synchronously to the services that happen to execute in the same core in that time-slot, and asynchronous with those that are not.  
> 
> That being said, I believe I heard in the Singapore Graypaper lecture that the interfaces for services to communicate with one another is always asynchronous. 
> 
> If correct, we can then say that services, as the lowest level programming primitive of JAM don't enable synchronous comparability yet, but synchronous composability as described in a semi-coherent system can be built on top of them. 
> 
> This is primarily possible because of the core-model, the possibility of flexible scheduling of services in cores, and the PVM's ability to be readily paused and resumed. One example of such system is CorePlay. 
> 
> Is that a correct description of where JAM service stand in terms of synchronous composability between one another?

Basically yes. The fact that the cores are stateless and that there's a mostly-coherent shared data lake and a fully-coherent reactor state means that there's no structural decoherence in the same way as with persistently sharded systems like the Polkadot Relay and the present direction of Eth2.
2024-06-28 07:12 gav: You can still build decoherent systems on this (the basic pre-Accords Parachains service will be an example of this). But CorePlay will (hopefully) use this model to create a coherent, performant and highly scalable platform on top.
2024-06-30 15:35 purpletentacle: > looks like the safrole test vectors are encoded using JSON instead of the scale codec described in GP

I think it makes sense to separate concerns correctly.
Otherwise, we will end up almost having something like integration tests... where the only test vector for M1 ends up being a complete block..

Moreover, some of us already implemented the JSON decoder.. because that's the way it was delivered ! ;)
Anyway, this is not a big deal at the moment.. but it would be good to have some stability on the test vectors anyway to avoid too much rework

Having said that... I would prefer if we can keep the JSON ones.. add some for encoding/decoding.. and later on, have complete ones for actual headers and blocks [edited]
2024-06-30 16:26 purpletentacle:  davxy I just saw that you have a PR with both json and scale! that's amazing 🚀
2024-06-30 18:03 sourabhniyogi: I have been bothered by the following line of questioning for the last couple of months:

- RFC 32 set a "Minimal Relay Chain"  architecture for Polkadot where the functions of relay chain would be "split off" into new system chains: Asset Hub, People, Staking, Core Time, and so forth.  The idea was that the Relay Chain REQUIRED maximal resources for validating parachains, specifically on "accumulate" computations.  In particular, the relay chain should not have anything like contracts-pallets because that would compromise on "accumulate" scalability \[to validate parachains\].  Here is your view circa October 2023:
https://github.com/polkadot-fellows/RFCs/pull/32#discussion\_r1347502727
- But then you put together JAM in the last year (and, this contracts-pallet based on PVM appears to be coming together nicely!).  JAM will have as its first really big JAM Service a Parachain Validation Service (run in-core and on-chain in refine vs accumulate run in PVM byte code), validating system chains and parachains with work items in work packages, judgements, and so on.
- Then, as Polkadot Fellows follow through on RFC 32 AND the JAM Service, there will be, in the limit, nothing left for the old relay chain to do!  It leaves a black hole as baby JAM takes over.
- Question 1: Instead of leaving the relay chain with nothing left to do, why not revert RFC 32's "splitting off" of the relay chain components and just leave some (or all) of it on the relay chain?
- Question 2: In particular, in addition to contracts-pallet being on Asset Hub, can we revisit the old relay chain getting contracts-pallet now that the JAM Parachain Validation Service model is clear?  What are the blockers other than the big one \[of how parachain validation will "switch" from Polkadot Relay Chain to the JAM Parachain Validation Service\]?
- Question 3: If you believe the above is possible, then with a functioning JAM Parachain Validation Service, then what is presently called the "Polkadot relay chain" could become a (well connected) parachain like all others, complete with smart contracts.  Problems like CEX integration to Asset Hub ... disappear, UX improvements to integrate disparate parachains are pushed off to another day while people figure out if some of these "split off" decisions from RFC 32 are better solved within a JAM Service architecture or as a parachain ... or as a smart contract on Polkadot (no longer validating anything) ... or elsewhere.  Can we revert RFC 32 now that JAM is well architected in this way?  If not, why not? [edited]
2024-06-30 23:14 danicuki: I created a YouTube Playlist with the main videos I found about JAM. Open to recommendations of  videos to include.

https://www.youtube.com/playlist?list=PLjGN96vX3BTKjLfBd5LimBuDuch-QfKPy
  ↳ 2024-07-01 09:04 tomusdrw: Getting an error that "The playlist does not exist.", could you check the link and/or permissions?
  ↳ 2024-07-01 10:42 kianenigma: same
  ↳ 2024-07-01 13:19 celadari: same
  ↳ 2024-07-01 13:55 wirednkod: Same
  ↳ 2024-07-01 15:28 philip.poloczek: Same. 😅

Anyways also can recommend the News section on graypaper.com . Although not specifically marked as videos, lot's of the recent entries are videos about JAM from gav.

https://graypaper.com/news/
  ↳ 2024-07-01 17:08 danicuki: Sorry, the playlist was private. Now it is public!
  ↳ 2024-07-01 17:09 subotic: Thanks, works now 👍️
  ↳ 2024-07-12 04:48 milawords: > <@danicuki:matrix.org> I created a YouTube Playlist with the main videos I found about JAM. Open to recommendations of  videos to include.
> 
> https://www.youtube.com/playlist?list=PLjGN96vX3BTKjLfBd5LimBuDuch-QfKPy

here is the link to the technical lecture in Singapore, which Jay recently published: https://youtu.be/QS9buJLt5jo?si=5Sh8Qc-teI-dxVJ_
  ↳ 2024-07-12 13:36 danicuki: > <@milawords:matrix.org> here is the link to the technical lecture in Singapore, which Jay recently published: https://youtu.be/QS9buJLt5jo?si=5Sh8Qc-teI-dxVJ_

Awesome!!! Just added to the Playlist. Thanks
2024-07-01 08:03 gav: JAM can be considered a follow-on protocol, or upgrade, to “Relay”.  [edited]
2024-07-01 08:04 gav: Its aim is to be fully backwards compatible. With JAM deployed, the Relay chain would be redundant and have no native currency or economy. Nothing stops validators from hard-forking and continuing to validate on the defunct chain, but they couldn't be paid unless they also forked DOT. And I'm not sure why you'd think this a sensible idea. [edited]
2024-07-01 08:07 gav: JAM is in line with the original proposal of moving extraneous functionality off the central, parachain-STF security chain (currently the Relay chain, to become the JAM chain). Indeed JAM requires this to happen as it cannot accept process transactions. [edited]
2024-07-01 08:08 gav: Polkadot Relay couldn’t become a “well-connected parachain” for exactly the same reason that hierarchical parachains are not viable right now.  [edited]
2024-07-02 10:05 darkartistry: 
2024-07-02 14:23 danicuki: Are the PBA JAM lectures already available somewhere? 
2024-07-02 14:25 rtti-5220: danicuki: the recordings are a collab between Key Pictures and The Kus, and after post-production I am sure they will be published for everyone.
2024-07-02 14:25 rtti-5220: but not yet. 
2024-07-04 02:02 xlchen: For the Safrole test vectors, it includes an error code but the value are unspecified and the README said we should ignore those values. This is a bit annoying as we need to do extra work to patch the test vectors to ignore the error code. Can we just exclude it from the test vectors? Or make it always 0. I just want to do a simple equality check
2024-07-04 02:04 xlchen: Also the test vectors repo should come with a test runner as well. As a fellowship member, how can I verify an implementation actually runs the test vectors correctly? We won't have such issue if it includes a test runner and if the tests passed for an implementation, we know for sure it actually passed.
2024-07-04 02:07 xlchen: and if we have a buildin test runner, then it can do the error code handling and it wouldn't be a concern to teams
2024-07-04 09:22 purpletentacle: hi Bryan, we are actually using the error codes and find them useful :( 
about the test runner... would that involve defining APIs for tests? It sounds that it would introduce architectural constraints to implementations at a very early stage. I think these kind of tests should be applicable at an integration level much later..
At the moment, we just add jamvectors as a submodule in our code and treat them as external data for simple unit tests..
2024-07-04 09:24 xlchen: how are you using the error codes? are the meanings defined somewhere? 
2024-07-04 09:25 xlchen: I am not sure what kind of constraints will the API introduces. The most simple way will be require some CLI interface and use stdin/stdout to pipe test cases and results
2024-07-04 09:26 xlchen: all those tests are pure functional
2024-07-04 09:27 purpletentacle: There is a very small amount of tests... so it is easy to link the error code to the failure mode described in the README
```
- [publish-tickets-no-mark-3](publish-tickets-no-mark-3.json)
  - Fail: Re-submit tickets from authority 0.
- [publish-tickets-no-mark-4](publish-tickets-no-mark-4.json)
  - Fail: Submit tickets in bad order.
- [publish-tickets-no-mark-5](publish-tickets-no-mark-5.json)
  - Fail: Submit tickets with bad ring proof.
- [publish-tickets-no-mark-7](publish-tickets-no-mark-7.json)
  - Fail: Submit a ticket while in epoch's tail.
```
2024-07-04 09:28 purpletentacle: and we can match our own error code to that in the test.. at least it is not FAIL = true/false
2024-07-04 09:28 purpletentacle: anyway, different teams can try their own approaches.. of course!
that's the beauty of having "only" the graypaper as a guide.... [edited]
2024-07-04 09:29 xlchen: in that case we should define them. as someone with C++ experience, I am scared of UB
2024-07-04 09:31 purpletentacle: well.. I don't think those have any relation to our code.. or any team's code for that matter.. those are 100% external data.. completely unrelated to implementations.
worst case, they would affect the code in your tests.
If those were to be defined.. they should be defined in the GP, right? which I find unnecessary [edited]
2024-07-04 09:32 xlchen: they can be defined in asn.1 file. there are other util types defined there as well
2024-07-04 09:33 purpletentacle: ok, if by definition you mean the test vectors ASN.1 and restrict that to only the test vectors.. welcome!
I thought you wanted this defined and standardized for all implementations at the GP level. [edited]
2024-07-04 09:36 xlchen: yeah I just want it to be written down explicitly somewhere to have some stability guarantee and reduce guess work that we need to do
2024-07-04 09:36 purpletentacle: about external testing via stdio/stdout.. sounds good! happy to help with it if there is anything to do...
actually having that as a github action would be actually cool... so we can all integrate it in our CI
that way we can keep out own unit tests.. but also everyone can provide a "test cli" to run the "jam vectors action" ..  [edited]
2024-07-04 09:47 gav: Error codes are not going to be defined in GP - way too implementation-specific. They're included in the test vectors as an aid for development only; for the purposes of determining conformance they can be collapsed into just "invalid"; implementations are not expected to be able to match the error code. [edited]
2024-07-04 09:48 gav: davxy: perhaps we should prefix the error-code field with an "\_" or something else to make clear it's not related to conformance? the only thing which should be officially there is that the posterior(s) are undefined due to invalid priors/inputs. [edited]
2024-07-04 10:25 davxy: Well for sure having error codes as an aid of "what went wrong" is useful.
But I agree that it is an implementation detail and it must not go in the GP.
So IMHO a good compromise is to:

1. (As Juan suggested) define the error codes only in the ASN.1 (as a hint to the implementer of why the test fails)
2. (As Gav suggested) make more explicit that the error code field is not related to conformance. Unfortunately `_` can't be used in standard ASN.1 LOL. But I can rename it to something like `application-specific-errno` (with a big warning that this is not specified in the GP). [edited]
2024-07-09 00:13 danicuki: > <@gav:polkadot.io> @room The first test vectors have been merged into github.com/w3f/jamtestvectors

A curiosity: how do you create these test vectors? And how can we be sure or prove they are correct?
2024-07-09 06:22 gav: They’re created with prototype implementations of the GP. If you think they’re incorrect, then raise an issue in the repo. 
2024-07-09 06:24 gav: The GP is the canonical definition of JAM. At this point the test vectors are provided as a development aid to teams. 
2024-07-09 06:24 gav: They will eventually mutate into a series of conformance tests for milestones 1 and 2. 
2024-07-09 06:26 gav: You can prove (in)correctness in the usual way. The test vectors are formal and the GP is formal - show that one does (not) follow from the other.
2024-07-09 21:17 kianenigma: I have been working on a blog post explaining JAM in short form and super high level, sharing it here to gather feedback. I have yet to improve the graphics and enhance it with animations, but the content is more or less there. I hope it can also help implementors getting just started. 

I have done my best to explain the content ground-up: each section building on top of the previous one(s), and not making too many unstated assumptions. I particularly hope to receive feedback on this, and how the story of Polkadot 1 -> 2 -> JAM can be better explained. 

https://blog.kianenigma.nl/posts/tech/demystifying-jam/
2024-07-10 12:31 darkartistry: Hi, I think for the part of coherent or non-coherent systems, based on the decision of a Timing Model (Async/Sync) can be better explain with a table break down of the combinations of the Timing Model to the Failure Model and Channel Model. For technical readers. Good read. :) Could also add some information that it is a 5-10 min read. Cause the page looked really long at the start. [edited]
  ↳ 2024-07-10 16:51 kianenigma: thanks
Timing Model to the Failure Model and Channel Model
What do yo mean by each, and what does it add to the understanding of the reader? I am not familiar with these myself and happy to add, but it has to have some added value for the reader, or else it is another keyword/terminology that they would have to be familiar with. [edited]
  ↳ 2024-07-10 16:52 kianenigma: > Could also add some information that it is a 5-10 min read.

4000 words, around 20mins for an average reader :) and indeed a lot of the page is graphs.
  ↳ 2024-07-10 23:50 darkartistry: > <@kianenigma:parity.io> thanks
> 
> > Timing Model to the Failure Model and Channel Model
> 
> What do yo mean by each, and what does it add to the understanding of the reader? I am not familiar with these myself and happy to add, but it has to add a added value for the reader, or else it is another keyword/terminology that they would have to be familiar with. 

There are decisions to be made, and they can be broken down to the combinations of type of the timing model, the type of fault tolerance and the type of agreeable failures of the message channels. I can’t remember but it was taught in a distributed systems lesson 😬🫣 I’ll try to find the lecture notes if I still have them hahahaha 
  ↳ 2024-07-10 23:51 darkartistry: I think the decisions that are to be made is what makes it “coherent” 
  ↳ 2024-07-12 04:18 darkartistry: kianenigma: the node types are classified under reliable, crash, * wild card, Byzantine. While the Channel types are Drop messages or reliable.
  ↳ 2024-07-12 04:19 darkartistry: thereby the various version of impossibility to solve some scenarios. 
2024-07-10 19:18 sourabhniyogi: Strongly Web3 talk: https://x.com/thewhiterabbitM/status/1811009553565114766
2024-07-12 17:44 dakkk: Hi, I have few question about the JAM Prize Competition:
1. Can I apply as an individual?
2. After I submit the Apply form, should I receive any feedback from the foundation? 
3. How can I know that I'm the only one working on a specific language?
4. How milestones works? After my software reaches a milestone what I'll have to do?
2024-07-12 18:31 gav: 1. The application is unimportant as far as the prize is concerned. The prize is for software. There’s no restrictions on the team behind it. 
2. No idea about this form. As I say, it’s unimportant for the prize. 
3. You can’t. But it doesn’t matter because teams need not implement in a unique language. 
4. Just publish the milestone and notify here. The Polkadot Fellows will take a look. 
2024-07-14 05:09 proxy720: Hi all! I have a question related to the one in the one above:
- Since I'm very good with niche functional languages, I'm considering entering the competition with Haskell, Elixir, OCaml, F# or Scala.
- Is it preferable to aim for the language that is more rare (the first 3), has some specific advantage over the others (Elixir)?
- There is a restriction that a team can only enter with a single language, but can one person be part of multiple teams?
2024-07-14 05:14 proxy720: - Also, I'm considering implementing only a PVM interpreter/evaluator in Coq, which would allow formal verifications for pvm programs (smart contracts). Is there a prize for something like this?
2024-07-14 07:05 gav: Rarer languages are probably going to be in the less-likely language sets (C and especially D) and thus more likely to have the full prize pot available by the time of Jam’s launch. 
2024-07-14 07:06 gav: Implementations are assumed to be clean room. If someone works on two different ones then obviously that’s no longer the case. 
2024-07-14 07:09 gav: Basically all members of the team must adhere to the rules as if they were the only one. 
2024-07-14 07:09 gav: > <@proxy720:matrix.org> - Also, I'm considering implementing only a PVM interpreter/evaluator in Coq, which would allow formal verifications for pvm programs (smart contracts). Is there a prize for something like this?

No
2024-07-15 08:55 masapr: It's hard for me to estimate the effort to get to milestone 1. to get a better feeling for this: @gav if you had to implement milestone 1 by yourself in Rust, can you tell us how many hours you would expect to have on this? 
2024-07-15 08:57 gav: Lol.
2024-07-15 08:58 gav: I really wouldn't base any of your projections on my productivity.
2024-07-15 09:16 masapr: Well, it's just a big risk to put a team on an unknown amount of work with unknown payment. If I know your estimate, I can draw my own conclusions on how that relates to our own productivity. ... Of course, we would have quite some additional effort understanding the graypaper in detail. But it would give some indication on the actual implementation effort. I understand, if you don't want to give a number. Just thought I'd ask. It would help me to know, if I should go further with this or stop right here ... 
2024-07-15 09:18 gav: The spec is published and aims to be unambiguous. For milestone 1, I think it's pretty much there, too. [edited]
2024-07-15 09:18 gav: I see little risk beyond your own expertise.
2024-07-15 09:19 gav: I suggest you look at the JAM Prize as a *prize*, not a corporate SLA.
2024-07-15 09:25 gav: For what it's worth, while pre-existing companies are 100% welcome to code up JAM and claim the prize, the structure of the prize (along with Fellowship membership and support structures) is aimed more at individuals and small unincorporated teams: Those who believe themselves capable of bringing the Graypaper to life and don't mind taking a risk on their time and talent. If you're looking for a low risk way of getting a monthly income on some blockchain engineering, it may not be the most appropriate opportunity. [edited]
2024-07-15 09:34 masapr: Fair enough. Either way, it is an investment. Also for individuals. So, it does make sense to calculate an estimate of the costs. Anyone has to do that, really. Thanks for the feedback, though. It does give me an idea.
2024-07-15 09:35 xlchen: if you just want a number, I will say 3 to 6 months
2024-07-15 09:36 masapr: > <@xlchen:matrix.org> if you just want a number, I will say 3 to 6 months

for 1 person?
2024-07-15 09:38 xlchen: yes. M1 is relatively easy when all the test vectors are out (which currently only Safrole is released and few others are WIP) as you can use the test cases to help understand GP
2024-07-15 09:38 xlchen: and it is pure functional without performance requirement 
2024-07-15 09:39 masapr: Bryan Chen | Laminar & Acala: Thank you :-)
2024-07-15 10:25 gav: > <@masapr:matrix.org> Fair enough. Either way, it is an investment. Also for individuals. So, it does make sense to calculate an estimate of the costs. Anyone has to do that, really. Thanks for the feedback, though. It does give me an idea.

I'd disagree wholeheartedly with any assertion that established businesses are anywhere near as capable of the agility, insight or risk-propensity as individuals.
2024-07-15 10:25 gav: But it's rather OT.
2024-07-15 10:26 gav: > <@masapr:matrix.org> Bryan Chen | Laminar & Acala: Thank you :-)

Lol. One person who should be no more capable of reading and assessing the GP that you or your team says casually "3 to 6 months" and somehow you think it's helpful?
2024-07-15 10:27 gav: Perhaps it might be sensible to read and understand the specification *you* want to implement (enough to make a rough estimate of how long you think it might take *you* to implement, anyway) before considering the case closed.
2024-07-15 10:28 gav: I'll put it another way: if you cannot get far enough through the paper to understand how much effort it might take you or your team to implement, perhaps that's not a great sign for things to come? Basing your predictions not on the specification of what you'd have to implement or you/your team's skills, talents and background but rather on the casual opinion of a single self-selected member of the public seems like an extraordinarily ill-considered approach. [edited]
  ↳ 2024-07-15 10:34 darkartistry: That was what was on my mind. I think the requirement is to at least first get through the paper before deciding to implement. This will be the first time I attempt to write a client from scratch. Any tips are very much welcome. :)  [edited]
2024-07-15 10:56 gav: Perhaps one point which could be clearer is the purpose of the JAM-prize: the W3F is not handing $60m+ out specifically in order to get lots of redundant code into the ecosystem. The reason for such a large prize fund is to help create a lot of experts on the protocol. Experts who understand, *inside-out*, both the strict protocol _and_ the numerous factors in creating a viable implementation. The prizes denominated in DOT, Fellowship membership and other long-term benefits and support are all there to help incentivise those experts to stick around for the long-haul whether to continue improving their implementations, to help evolve the protocol or to build atop of it. In pursuit of this, we'll take a rather sink-or-swim tactic with teams: beyond corrections and clarifications to the GP, we'll be offering no great help along the way and will expect teams to solve their own problems in their own way. It's not the fastest way of getting from A to B, but this forges a rare asset: the kind of expertise you get from innovators learning through first-principles. Furthermore, it also helps ensure an intellectually diverse ecosystem less constrained by the biases and design-decisions of a single engineering team, leading to a more resilient engineering ecosystem. [edited]
2024-07-15 11:00 gav: They say there are no Dumb Questions. Perhaps. But there are certainly Lazy Questions. If any come my way I'll mark them `LQ` and  move on. Be warned :P [edited]
2024-07-15 11:04 masapr: I'm sorry, I really didn't want to upset you. Yes, it certainly was a lazy question. But I still believe, it's a fair question. These things are hard to estimate and it's not dumb to ask the expert.
2024-07-15 11:04 gav: The point is to make *you* the expert :)
2024-07-15 11:04 gav: Without that expertise, you may find the prize difficult to collect: it's certainly the intention.
2024-07-15 11:07 prematurata: Hello, I submitted the application form for section C, specifically JavaScript. Is JavaScript vanilla required or can the code be developed in something more robust like TypeScript which is a superset of JS?
2024-07-15 11:07 gav: Major dialects are generally fine. TypeScript certainly. [edited]
2024-07-15 16:02 erkt: I know things like some crypto libs such as the RingVRF are FFI eligible. Are projects that FFI into the PVM eligible as well? Or is every impl expected to implement the PVM? 
2024-07-15 16:32 gav: Every project is expected to implement. However, since M1 and M2 do not have any performance requirements, you can get away with implementing a simple interpreter, which shouldn't take too long (Jan managed to implement it in [less than 24 hours](https://forum.polkadot.network/t/exploring-alternatives-to-wasm-for-smart-contracts/2434)). [edited]
  ↳ 2024-07-15 16:35 erkt: ack. thanks for the reply 
  ↳ 2024-07-15 16:37 gav: For M3 and M4 it'll likely need more substantial work (though the post above indicates that Jan implemented a JIT RISCV-x86 recompiler in 2 days...)
2024-07-16 09:54 dylanverstraete: Hi everyone, is there a team working on an implementation in Go? I could help out. Otherwise, who wants to start a team?
  ↳ 2024-07-16 17:10 timwu20: We the Gossamer team from ChainSafe are working on an implementation in Go
2024-07-16 10:03 darkartistry: > <@dylanverstraete:matrix.org> Hi everyone, is there a team working on an implementation in Go? I could help out. Otherwise, who wants to start a team?

Hi I’d like to work in a team. Have you read the paper ? 
2024-07-16 12:35 oliver.tale-yazdi: I create this page so that teams can be peripherally aware of each other's existence: https://jamcha.in/clients  
It should help to discover under/over-saturated language(sets) to better spread out our efforts. It is an unofficial page though, so its not at all required 😄 [edited]
  ↳ 2024-07-16 13:09 darentuzi: thanks for creating this, very helpful, submited our project
  ↳ 2024-07-16 13:28 subotic: Oliver Tale-Yazdi: thank you very much! We jam4s also just submitted our project. [edited]
2024-07-16 12:46 darentuzi: > <@dylanverstraete:matrix.org> Hi everyone, is there a team working on an implementation in Go? I could help out. Otherwise, who wants to start a team?

yeah we have a team of 5 working on it right now
2024-07-16 12:48 dylanverstraete: > <@darentuzi:matrix.org> yeah we have a team of 5 working on it right now

Alright good to hear, good luck!
2024-07-16 12:54 dakkk: > <@oliver.tale-yazdi:parity.io> I create this page so that teams can be peripherally aware of each other's existence: https://jamcha.in/clients  
> It should help to discover under/over-saturated language(sets) to better spread out our efforts. It is an unofficial page though, so its not at all required 😄

cool; I submitted mine
2024-07-16 15:00 ainhoa_a: same, submitted too, Jam jammy, thanks for the initiative!
2024-07-16 16:01 eclesiomelo: 
2024-07-16 16:03 eclesiomelo: hello everyone! I've started a zig implementation of scale-codec thinking in expand the implementation possibilities, the decoding is not fully implemented tho. Would be nice if fellow zig coders could take a look and provide feedbacks :) here's the repo https://github.com/EclesioMeloJunior/zig-scale-codec
  ↳ 2024-07-16 17:21 oliver.tale-yazdi: I'm a Zig noob, so my code is probably not good, but for whats its worth: https://github.com/ggwpez/zcale  
Either way, if you use it for JAM then maybe not look too closely as to not influence your implementation 😅
  ↳ 2024-07-16 17:25 eclesiomelo: nice!! yeah, I don't have a plan to write a client in zig atm, just supporting the zig scale codec lib would be great
2024-07-16 17:23 sourabhniyogi: Devcon 7 https://tickets.devcon.org/ went on sale  (Nov 12-15th) today -- It would be awesome to have a "JAM0" weeklong hackathon (like 9th-17th) at some venue for teams to try to pass Milestone 1 together and (with some luck) have us all trying to get our QUIC networking working with each other, fill in our knowledge gaps, have clear todos for Milestone 2.   If this is reasonable, how can people get their travel (and $599 Devcon ticket) reimbursed to such an event?  

Should this event be OpenGov or W3F funded?  What would be some good criteria to get people a $2K voucher to attend?
  ↳ 2024-07-16 17:35 tomusdrw: ❌ clean room?
  ↳ 2024-07-16 17:39 sourabhniyogi: Surely we can connect different implementations together and go through details of networking/... without sharing code and "colluding".  It appears most people are doing closed source to make "clean room" the default.  I don't see why we can't have GP discussions on a dry erase board esp for implementation interoperability
  ↳ 2024-07-16 18:13 gav: Cooperation between teams is essential but anything which goes beyond trivial misunderstandings of the graypaper should be documented, either as issues in the GP repo or as side notes of the implementation to be submitted at the time of Fellowship review. Teams should stay away from implementation specifics and definitely not be sharing code. [edited]
  ↳ 2024-07-16 18:15 gav: It's ok to ruminate on high level approaches to solve problems or optimize, it's not so ok to be looking at some other implementation's specific solution. 
  ↳ 2024-07-16 18:16 gav: What the Fellowship will be looking out for is for undeclared collusion between teams. Code which appears to be a little too similar for it to have been independently written. A big red flag would be the same bug popping up in two implementations.
  ↳ 2024-07-16 18:17 gav: But this is not to detract from the fun of getting two cleanroom impls talking to each other. Of course this is a big part of it and you mustn't feel like it's not allowed.
  ↳ 2024-07-16 18:17 gav: Just be sure to document anything which you discover alongside another team so everyone can benefit. [edited]
2024-07-16 18:09 gav: W3F will probably not arrange any official Jam presence at Devcon unless it's clear most serious implementors plan to be there anyway. There might be some co-hosting with Sub0, but it’s TBC. Definitely do want to arrange some sort of seminar conference. Of course you’re free to go to the treasury yourself.  [edited]
  ↳ 2024-07-25 17:21 sourabhniyogi: gav - off grid, slow to respond:  I think we have enough serious implementors

https://polkadot.polkassembly.io/referenda/1024

Should we be clamoring for you to give a Devcon 7 keynote on Cynical vs Optimistic Rollups ala https://x.com/TheKusamarian/status/1816413081523900683 ?   Seems like its silly to ask you to submit a talk proposal (as an OG from Devcon 0) but having the key guys mentioned in GP submit proposals { PVM, Solidity-to-PVM, ELVES, Safrole } would be appropriate, and would seal the deal.   [edited]
  ↳ 2024-07-25 17:22 sourabhniyogi: Deadline for submitting talks is July 30, which is also when tickets go on sale. [edited]
2024-07-16 19:47 sourabhniyogi: Is this reasonable? 
 https://polkadot.polkassembly.io/post/2397 
I am not sure how we could objectively know who are "serious implementors" for travel reimbursement, perhaps there is some "Block Importer" test that could be objectively or subjectively applied?   We need some protocol engineers / fellows / W3F, maybe in a 1:10 ratio to implementers for this to fly, I think.   [edited]
2024-07-17 07:41 philip.poloczek: Thanks Olivier, this is a great addition!

I'm the maintainer of the graypaper.com website. In the initial draft of the website we had an `Implementation` section like this in mind. We removed it for the launch as it was just empty.

Would it be fine for you and everyone, if I add it to the graypaper website based on the teams already collected on https://jamcha.in/clients? [edited]
2024-07-17 08:18 ainhoa_a: > <@philip.poloczek:parity.io> Thanks Olivier, this is a great addition!
> 
> I'm the maintainer of the graypaper.com website. In the initial draft of the website we had an `Implementation` section like this in mind. We removed it for the launch as it was just empty.
> 
> Would it be fine for you and everyone, if I add it to the graypaper website based on the teams already collected on https://jamcha.in/clients?

fine for us let us know if we need to submit a PR or if the info on the site is enough 
2024-07-17 10:45 oliver.tale-yazdi: > <@philip.poloczek:parity.io> Thanks Olivier, this is a great addition!
> 
> I'm the maintainer of the graypaper.com website. In the initial draft of the website we had an `Implementation` section like this in mind. We removed it for the launch as it was just empty.
> 
> Would it be fine for you and everyone, if I add it to the graypaper website based on the teams already collected on https://jamcha.in/clients?

yep sounds good, will dm
2024-07-17 13:37 gav: Here's my (unofficial) summary of the prize rules - I'll try to keep it up to date with any questions/answers in here: https://hackmd.io/@polkadot/jamprize
2024-07-17 15:54 philip.poloczek: fyi Oliver and I synced on the already submitted teams/clients for jamcha.in and now share a single source of truth for the data available on both sites:

https://jamcha.in/clients
https://graypaper.com/clients [edited]
2024-07-17 16:05 prematurata: hello, hopefully not a stupid question. about C.1.5 or Bit Sequence Encoding or (278).
variable length sequence. There is no formal definition in the bit sequence encoding so i guess that it's going to be Discriminator Encoding + bitsequenceencoding?
 [edited]
2024-07-17 17:20 gav: > <@prematurata:matrix.org> hello, hopefully not a stupid question. about C.1.5 or Bit Sequence Encoding or (278).
> variable length sequence. There is no formal definition in the bit sequence encoding so i guess that it's going to be Discriminator Encoding + bitsequenceencoding?

are you referring to this?...
2024-07-17 17:20 gav: image.png
2024-07-17 17:20 gav: b is a bit sequence - this formula provides the byte sequence which is the encoding.
2024-07-17 17:37 prematurata: Sorry yes, I am referring to that. It says that in case of variable length sequences, then the length is prefixed  as in the general case. I am not sure what the "general case" is. So I was speculating that in case of variable length, the "discriminator encoding" defined above would need to be used
2024-07-17 17:42 gav: Yeah, that sentence is a bit superfluous. 
2024-07-17 17:43 gav: There are no variable length sequences afair. 
2024-07-17 17:43 gav: And where there are I’m careful to make an explicit length prefix.  
2024-07-17 17:43 gav: So you can basically ignore it. 
2024-07-19 12:45 asmie: Hello. A quick clarification: We can use third-party libraries for cryptographic primitives, codecs, and networking. Does rule #4 (idiomatic code) apply to the external code or our work only?
2024-07-19 14:57 gav: Your work only. 
2024-07-20 13:58 sourabhniyogi: @room: JAM implementors!  If you would like to have a 4-7 day "JAM0" implementers room @ Devcon 7 (in Bangkok) where you and other serious implementers network your/our implementations together \[while following the official / unofficial Rules\], please comment here: 
  https://polkadot.polkassembly.io/post/2397 
and get listed here:
  https://jamcha.in/clients
A simple comment like this:
https://polkadot.polkassembly.io/post/2397#Zgpa0MJvU0LsDITa5kHe
from 3-4 more serious teams would be sufficient to justify getting an OpenGov-supported venue.   [edited]
2024-07-20 18:06 sisco0: I am interested at joining a C team of Jam. How could I do it? :) Thank you!
I could observe only Rust implementation at https://jamcha.in/clients [edited]
2024-07-21 07:52 gav: > <@sisco0:matrix.org> I am interested at joining a C team of Jam. How could I do it? :) Thank you!
> I could observe only Rust implementation at https://jamcha.in/clients

Perhaps you should start one:)
2024-07-22 14:25 sisco0: Thank you gav , I would set a plan for the current C implementation of Jam.
2024-07-23 12:35 sourabhniyogi: @room: JAM implementors, thank you for showing interest!  We have a quorum of JAM implementors -- I posted this accordingly: 
https://polkadot.polkassembly.io/referenda/1024  

I am coordinating with yaxun@OneBlock on securing a venue (and food arrangements) [see OpenGov Ref 897], hope we can report some good news soon.
2024-07-23 20:34 rmagon: 
2024-07-23 20:36 rmagon: Hello! I'm from the team behind airlyft & we're planning to start a client implementation but wondering what would be the best way forward in terms of the language? My first thoughts were Go, Rust, Typescript but I see we already have some implementations working on those languages. Another option would be C++. In terms of our strengths, these are the languages we feel we can make a difference with. But in terms of the prize pool, does a different language in the same set make a difference? Any suggestions? [edited]
2024-07-23 21:14 rmagon: > <@rmagon:matrix.org> Hello! I'm from the team behind airlyft & we're planning to start a client implementation but wondering what would be the best way forward in terms of the language? My first thoughts were Go, Rust, Typescript but I see we already have some implementations working on those languages. Another option would be C++. In terms of our strengths, these are the languages we feel we can make a difference with. But in terms of the prize pool, does a different language in the same set make a difference? Any suggestions?

Okay, I think I got the answer to my question. It's the Language Set which makes a difference and not the language. Right?
2024-07-25 22:55 gatesma: [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]][[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]][]]]]]]]]]][[]][[]][[][]][[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]][][][[][][][][][][][][][][][][][][][][][][][][][][][][][][][][]=][
2024-07-25 22:55 gatesma: [][][][][][][][]
2024-07-25 23:00 gatesma: sorry, my son is a bit wild on the keyboard.
2024-07-25 23:07 xlchen: oh it is not some private key encoded with brainf*ck?
2024-07-26 13:00 tomusdrw: > <@sourabhniyogi:matrix.org> @room: JAM implementors, thank you for showing interest!  We have a quorum of JAM implementors -- I posted this accordingly: 
> https://polkadot.polkassembly.io/referenda/1024  
> 
> I am coordinating with yaxun@OneBlock on securing a venue (and food arrangements) [see OpenGov Ref 897], hope we can report some good news soon.

Hey! Is there still a chance to join? 3 typeberry developers would be interested to come along as well.
  ↳ 2024-07-26 18:17 sourabhniyogi: Glad to have you and everyone in the "serious implementer" category.  There is a  budget of at least $75K which can support ~ 30 people @ $2.5K/person \[$7.5K/team\], which might be exhausted but we're getting venue quotes with others.  I'll build a headcount model for teams on #1024 by July 30 so we know if we're over budget, but I think if we have 40 people we "fix" it in Dec/Jan.  We do need serious people and probably we'll learn the rough boundary between serious and non-serious together at November's Devcon.  Passing all available test vectors or being clear about whatever the bottlenecks are for each team is my idea of "serious".  Hopefully the spirit of getting each other unstuck and having fun while honoring "clean room" rules can be satisfied.   [edited]
2024-07-26 14:08 danicuki: Maybe this is a dumb question, but I decided to ask anyway...
I noticed that most implementers decided to keep their evolution and code private for now (https://github.com/w3f-webops/graypaper-website/blob/main/src/data/clients.json). Why?
  ↳ 2024-07-26 14:19 subotic: I guess as a precaution 🤷‍♂️ This is how I have interpreted the "no collusion" part of the rules, i.e., no one can have similar code to ours.
  ↳ 2024-07-26 14:20 rmagon: > <@subotic:matrix.org> I guess as a precaution 🤷‍♂️ This is how I have interpreted the "no collusion" part of the rules, i.e., no one can have similar code to ours.

Hmm, yes
  ↳ 2024-07-26 14:20 rmagon: I had the same question but did not ask :D
  ↳ 2024-07-26 14:21 subotic: but if everyone would be willing to open their codebase and this is ok with Gav and W3F, then we will certainly think about it. [edited]
  ↳ 2024-07-26 14:22 subotic: Just my personal opinion.
  ↳ 2024-07-26 14:24 danicuki: Initially I thought about leaving our code completely open, but as I saw everyone closing it, I asked myself...
  ↳ 2024-07-26 14:26 rmagon: > <@danicuki:matrix.org> Initially I thought about leaving our code completely open, but as I saw everyone closing it, I asked myself...

We started our repo as opensource but then went private because of the same reason. 
  ↳ 2024-07-26 14:26 danicuki: I far as I understand we are not competing against each
  ↳ 2024-07-26 14:26 danicuki: This is a good Game Theory use case ✌️
  ↳ 2024-07-26 14:27 rmagon: > <@danicuki:matrix.org> This is a good Game Theory use case ✌️

Haha, yes
  ↳ 2024-07-26 14:29 subotic: Well, we are competing with time. As I understood it, after there are 3 good implementations, the race will be over. So not helping other teams can be to ones advantage. On the other hand, the more implementations, the better for the ecosystem. [edited]
  ↳ 2024-07-26 15:26 danicuki: > <@subotic:matrix.org> Well, we are competing with time. As I understood it, after there are 3 good implementations, the race will be over. So not helping other teams can be to ones advantage. On the other hand, the more implementations, the better for the ecosystem.

I don't have the understanding that after 3 good implementations the race is over. Where did you see this?
  ↳ 2024-07-26 15:26 danicuki: It doesn't make any sense. If there is 10M DOTs in prize, 500k per team, there can be 20 teams to get the prize
  ↳ 2024-07-26 15:28 subotic: let me see if I can find it. It was somewhere in this chat. Maybe I misunderstood it (would actually be glad) [edited]
  ↳ 2024-07-26 15:29 oliver.tale-yazdi: For us it was a consideration to not have a 3rd party copy our code and apply with it for the prize.
  ↳ 2024-07-26 15:38 cisco: We shouldn't be influencing our implementations in any way, so we don't risk having the same bug in two implementations. I don't see why we would want to make the repos open source? Collaborating is a must, but only on the interpretations of the paper, not on code
  ↳ 2024-07-26 15:43 rmagon: > <@danicuki:matrix.org> It doesn't make any sense. If there is 10M DOTs in prize, 500k per team, there can be 20 teams to get the prize

Hmm yes, I don't think I read the 3 teams rule anywhere?
  ↳ 2024-07-26 15:55 subotic: It wasn't a rule. It was more an indirect conclusion. Maybe I got this whole thing wrong. I cannot find anything in the chat. He spoke about when 1.0 of the GP is published, which will happen once a few teams have managed to get an implementation. But don't quote me on that.
  ↳ 2024-07-26 16:05 sourabhniyogi: > <@cisco:parity.io> We shouldn't be influencing our implementations in any way, so we don't risk having the same bug in two implementations. I don't see why we would want to make the repos open source? Collaborating is a must, but only on the interpretations of the paper, not on code

See FAQ "Clean room?" here
https://hackmd.io/@polkadot/jamprize

"A: Cooperation between teams is essential but anything which goes beyond trivial misunderstandings of the graypaper should be documented, either as issues in the GP repo or as side notes of the implementation to be submitted at the time of milestone review. To stay safe, teams should stay away from the implementation specifics of other implementations and definitely not be sharing code.
It's ok to ruminate on high level approaches to solve problems or optimize, it's not so ok to be looking at some other implementation's specific solution.
What the Fellowship will be looking out for is for undeclared collusion between teams. Code which appears to be a little too similar for it to have been independently written. A big red flag would be the same bug popping up in two implementations.
But this is not to detract from the fun of getting two cleanroom impls talking to each other. Of course this is a big part of it and you mustn't feel like it's not allowed.
Just be sure to document anything which you discover when working alongside another team so everyone can benefit."
  ↳ 2024-07-26 16:23 danicuki: Now I get the full picture. Sharing code is not a problem itself, but looking at other's code is. Then, no one shares code so no one is able to copy code. 
2024-07-26 14:19 rmagon: I had the same question, tbh but did not ask :D
I'm guessing it's due to the clean room principles ? [edited]
2024-07-26 17:18 gav: I have previously proposed that the Polkadot JAM chain should not be launched until there are at least 3 implementations which perform adequately for mainnet (ie pass Milestone 5). This doesn’t affect the prize in any way. 
2024-07-26 21:50 sourabhniyogi: For Rule 19 - "Prizes are paid no earlier than the ratification by the Polkadot Fellowship of version 1.0 of the JAM protocol. Payment of the prize by the Web3.0 Foundation is conditional upon the successful completion of all KYC/AML processes." -- what are the preconditions that need be satisfied for you (or the Fellowship)  to decide to ratify version 1.0 of the JAM protocol?

Could version 1.0 of the JAM protocol be ratified with 0 teams passing Milestone 1 -- where ratification is _just_ about the GP?
Would a single implementation team passing Milestone 1 or 2 or 3 be sufficient to trigger 1.0 ratification? If so, which milestone?
Would a N implementation teams passing Milestone 1 or 2 or 3 be sufficient to trigger 1.0 ratification? If so, for what N and what milestone?

2024-07-27 14:09 gav: > <@sourabhniyogi:matrix.org> For Rule 19 - "Prizes are paid no earlier than the ratification by the Polkadot Fellowship of version 1.0 of the JAM protocol. Payment of the prize by the Web3.0 Foundation is conditional upon the successful completion of all KYC/AML processes." -- what are the preconditions that need be satisfied for you (or the Fellowship)  to decide to ratify version 1.0 of the JAM protocol?
> 
> Could version 1.0 of the JAM protocol be ratified with 0 teams passing Milestone 1 -- where ratification is _just_ about the GP?
> Would a single implementation team passing Milestone 1 or 2 or 3 be sufficient to trigger 1.0 ratification? If so, which milestone?
> Would a N implementation teams passing Milestone 1 or 2 or 3 be sufficient to trigger 1.0 ratification? If so, for what N and what milestone?
> 

The preconditions are not stated and it is the Fellowship’s decision to ratify the protocol specification when it believes it ready.
2024-07-27 14:09 gav: Realistically, it will need to be stable, useful, capable of hosting a service compatible with the relay chain and secure. The latter point will imply an external audit. 
2024-07-27 14:11 gav: However that’s just a rough guide. The Fellowship’s decision is final (notwithstanding Root-level governance, of course). 
2024-07-27 14:58 sourabhniyogi: Is the Fellowship ratification of the protocol specification just about ratifying written specifications of
(a) GP alone
(b) GP + JAMSNP
(c) GP + JAMSNP + documentation of how the service compatible with the relay chain will work
or
(d) something else ?
Is the external audit about GP + \_\_\_ written specifications (one of (a)-(d)) or about an implementation?

A serious concern is that serious implementers may (very likely) pass Milestone 1 + 2 + ..  in early 2025 handily, but, because of unknown ratification timing they aren't winning prizes for their Milestone 1 + 2 + .. until an external audit that would only be completed in late 2025 _or later_.  If this is a valid concern, then we may have teams only working on this as a hobby to part-time (\< 20%), and slowing down bringing JAM into the world.  Obviously, JAM teams would like prizes paid out when Milestone 1 is completed, when Milestone 2 is completed, ... -- and not be faced with some unstated preconditions of Rule 19.  Is there any route to get teams working on JAM implementations full-time, fully incentivized to bring JAM into the world? [edited]
2024-07-27 15:12 gav: The JAM Prize a prize, not a service agreement.  [edited]
2024-07-27 15:12 gav: Approaching this as a service agreement is going to result in unrealistic expectations. 
  ↳ 2024-07-28 16:07 sourabhniyogi: gav - off grid, slow to respond: 
Can you let me know what you think of this JAM Accelerator Bounty idea:
https://docs.google.com/document/d/1nKGi9UzWca0gIugW8UYfIrY\_uVLKVVC8FydLIHwjpWY/edit
 [edited]
  ↳ 2024-07-28 16:23 gav: > <@sourabhniyogi:matrix.org> gav - off grid, slow to respond: 
> Can you let me know what you think of this JAM Accelerator Bounty idea:
> https://docs.google.com/document/d/1nKGi9UzWca0gIugW8UYfIrY\_uVLKVVC8FydLIHwjpWY/edit
> 

I think such a bounty would be too generous. W3F have had bad experiences with client-development SLAs in the past. One good element of the prize is to help weed out the mercenaries from the missionaries; we would not especially want to attract those who would refuse to take a risk on Polkadot and its development timeline: indeed we would active want to have people who have skin-in-the-game in this regard. 
  ↳ 2024-07-28 19:05 sourabhniyogi: Both this child bounty approach and the JAM prize are driven by the same basic bounty criteria, except with unfinalized networking added (bar raised) and accepting an unratified evolving GP spec (bar lowered).     There is no "service agreement" implied after the JAM prize nor after any child bounty to continue to support the implementation, but you can certainly expect to see the entities receiving the child bounties to continue into the JAM prize because its literally 3x higher.  You could add a rule to ensure that  any payments from OpenGov could be subtracted.  Seems fairer to me to add now rather than at the end.   But what makes the "SLA" label appropriate?

I gather the underlying "SLA" expectation is that if you receive 500K DOT after having spent 2 years building something for a prize that doesn't have any SLA after it, the team will endeavor to spend many more years after as if there was an SLA.  Is that it? [edited]
  ↳ 2024-07-29 02:32 sourabhniyogi: If mercenaries are valued at $0, this is about the cost to get a JAM protocol missionary.

I conjecture that the 500K DOT bounty gets AT MINIMUM 3 missionaries + 3 mercenaries completing M3 by Q2 2025, where 4 of them get compensated.  If you believe that 100% of teams with a Fellow are missionary teams, then there are 3 missionary teams already.

I actually conjecture that it is far more likely that there are 5 missionaries and 2 mercenaries that get compensated with this bounty, all of whom continue on to earn some JAM Prize.  The cost to get a JAM protocol missionary: 100K DOT (500K/5 missionaries).

With the JAM Prize alone, I conjecture you get 10 missionaries and 10 mercenaries.  The cost to get each missionary, if all 10MM DOT are actually exhausted, is 1MM DOT/missionary.

With both in place, you get 5 more missionaries.  The cost is 10.5MM DOT/10 = 1.05MM DOT/missionary.  If you deduct any OpenGov received amounts from Prize winnings, its less than that.  So the additional cost is just the number of mercenaries funded by the bounty.  Do we have a mercenary detector mechanism to minimize this cost?

If you think you get 20 missionaries and 0 mercenaries, you'll be at 500K DOT/missionary with the JAM prize alone.  For a cost conscious missionary buyer, where does that leave the generosity?

I see so little difference between paying 1MM DOT/missionary vs 1.05MM DOT/missionary that the "generosity" is pretty clearly on the JAM Prize side.  5% is noise of the week.   I'm happy as a lark to see so many teams implementing this month, now I just want to see acceleration because the ideas are all done.

This price of accelerating JAM execution, the 4th generation blockchain architecture, is probably the absolute best use of OpenGov resources I know of.

You can suggest curator requirements (e.g there must be at least 3 teams with a fellow on them) to increase the probability that we get the cost per missionary even lower than 100K DOT/missionary, but this accelerant is only intended to get JAM execution in a better state in early to mid-2025 than without it.  That's the basic analysis. [edited]
2024-07-27 15:14 gav: Fellowship ratification of the JAM protocol would be on the JAM protocol definition which is the Gray Paper.
2024-07-27 15:17 gav: The GP will include JAMNP. 
2024-07-27 15:17 gav: This is not a priority at present since it is not required for M1. Furthermore it is the only part of the protocol which is heavily reliant on practical concerns which cannot easily be modelled. It will likely be the very last protocol element to be finalized.  [edited]
2024-07-27 15:18 gav: The JAM protocol is independent of any implementation. 
2024-07-27 15:19 gav: Most of these answers are plainly obvious. Please note that further questions with obvious answers may elicit a more blunt response.  [edited]
2024-07-27 15:56 sourabhniyogi: Thank you for clarifying, everything is now more obvious =)
2024-07-27 16:39 tebdev: > <@philip.poloczek:parity.io> Thanks Olivier, this is a great addition!
> 
> I'm the maintainer of the graypaper.com website. In the initial draft of the website we had an `Implementation` section like this in mind. We removed it for the launch as it was just empty.
> 
> Would it be fine for you and everyone, if I add it to the graypaper website based on the teams already collected on https://jamcha.in/clients?

Client diversity got my attention. I used this at NASA, etc. impressed it being considered for JAM. Bravo
2024-07-28 16:24 gav: Furthermore, canonical M1 test vectors will not be available before 1.0 is ratified. 
2024-07-28 16:25 gav: Fellowship is the basis of technical expertise in Polkadot and should generally be relied upon for judgements of a protocol/technical nature. 
2024-07-28 16:27 gav: You quoted me from this room and followed it with: “In particular, SCALE-encoding details are likely to change and as such, teams should design to have networking protocol versioning within it for efficient reasoning”. 
2024-07-28 16:28 gav: I did not say this nor did I say anything to this meaning. 
2024-07-28 16:28 gav: It is not my expectation that the underlying method for serialization/encoding will change and I would urge to refrain from writing such misleading phrases.  [edited]
2024-07-28 16:29 sourabhniyogi: Removed, is there anything else misleading?
2024-07-28 16:29 gav: Perhaps *you* should read it. I am not your fact-checker. 
2024-07-28 16:49 sourabhniyogi: On networking, https://hackmd.io/@polkadot/jamsnp 
is all we have right now, its very new and fresh since you only posted it at the start of this month =).  I cannot guess the difference betweeen JAMSNP, JAMNP-S, or JAMNP -- - is there a difference?  Its definitely not obvious with a lot of TBDs.  If you say the networking will be the one of the last things to be finalized, we understand.    

On *canonical M1*  test vectors, is this a different set than what you referred to on June 3: "Block execution vectors should be ~6 weeks out.  Availability system test vectors probably about the same timeline."  The existence of these test vectors, even in draft PR form, are highly valuable accelerants for M1/M2 well well in advance of 1.0 ratification.

But given how well described the GP is, implementers can fill in many details of block import vectors + JAM network details, some/most of which are easy to infer from the GP alone.  The more complete the test vectors are, and closer to the "prize" requirements, the better, but I understand pestering won't help. We imagine honest test vectors can come from the implementers themselves as well, however not canonical.   

Some of the leading teams have fellowship talent within their ranks, and we understand its a side goal to develop fellowship talent through increased JAM protocol expertise.  Earning your rank could be done through this kind of contribution. [edited]
2024-07-28 17:09 emielvanderhoek: If you ask me more/alternate funding in addition to the prize leads to poor incentives and attracts the wrong people. Also cringe: “serious implementers”. [edited]
  ↳ 2024-07-28 18:33 sourabhniyogi: I removed the word "serious".  I also find it problematic but the substance of the issue is what the difference is between "mercenaries" and "missionaries".  The JAM protocol needs to limit the number of long-term mercenaries,  not limit the number of people who cringe at words.  This is not playschool =).   Some short-term mercenaries can become long-term missionaries. [edited]
2024-07-28 17:38 sourabhniyogi: The notion of "serious implementers" comes from "W3F will probably not arrange any official Jam presence at Devcon unless it's clear most serious implementors plan to be there anyway."   Perhaps that will make some people cringe, but the notion of what constitutes "serious" is  difficult to discern from observing https://jamcha.in/ right now.  I gather it is "you will stick around after completing M5 and claiming the prize, and become a valued fellowship member" like a missionary instead of "We will leave after claiming X milestone bounty" like a mercenary.  Can anyone spot the mercenaries in  https://jamcha.in/ now without  ever having interacted with them? 

The mercenaries within the JAM implementer set are those that are just like "what do we have to do to pass Milestone X and get Milestone X prize money (or bounty)".  The missionaries  want to build the whole thing, are curious as to how and why it works, and will want to improve it/attack it/...    Interviewers can often detect the difference.  Unfortunately, its hard for bounty curators, JAM Prize judges or any human to read peoples minds objectively the way you can objectively check whether some implementation does or does not pass a test vector.   Every incentive structure will have some type 1 and type 2 "errors", if you can call them "errors".  After all, some "missionaries" will have kids to feed, mortgages to pay off, parents to take care of -- and some "mercenaries" can become "missionaries" after falling in love with the protocol and proving to themselves that they are good at implementing and maintaining it.  Its easy to be black-and-white about it and pretend that this kind of real life doesn't exist.     [edited]
2024-07-28 18:31 emielvanderhoek: Well, call me a purist.
“Serious implementers” is a silly notion period. There’s only “implementers”. It is: conformance, performance & security and in that particular order. Some teams will finish first and some teams will finish later.
Any additional incentive structure distorts the objectives of Jam Implementers Prize and unlevels the playing field.
I’d suggest a new moderation rule for this channel: to disallow any talk about alternate/additional funding for JAM implementation teams (besides the Prize) in this channel.
If we don’t I fear this channel may become a toxic as some of the other channels.
You can do what you want in the regular governance channels of course.
My 2cts. [edited]
2024-07-28 21:43 emielvanderhoek: “More money will make JAM arrive sooner.”: This to me seems like a big MISconception. 
2024-07-29 04:05 xlchen: I am confused about trap vs halt vs panic in PVM. In GP, the trap instruction will exit with the black square, so does the jump to `2^32-2^16` address. To my understanding that is `exit 0`. But in the pvm testvector, trap is panic and the test of the trap instruction will result trap exit status but the `inst_ret_halt` test results `halt`. There is some inconsistency.
https://github.com/w3f/jamtestvectors/blob/a2b18702aac7d15b9f51cd1ffcf0be95f987b2f7/pvm/schema.asn#L53-L55 
2024-07-29 06:49 xlchen: Screenshot 2024-07-29 at 6.49.40 PM.png
2024-07-29 06:50 xlchen: this means `jump_ind` could be used to exit the program, but how about the one using `branch`? e.g. `jump`
2024-07-29 06:51 xlchen: Screenshot 2024-07-29 at 6.50.56 PM.png
2024-07-29 06:51 xlchen: does it become panic?
2024-07-29 13:24 mkalohood: > <@emielvanderhoek:matrix.org> Well, call me a purist.
> “Serious implementers” is a silly notion period. There’s only “implementers”. It is: conformance, performance & security and in that particular order. Some teams will finish first and some teams will finish later.
> Any additional incentive structure distorts the objectives of Jam Implementers Prize and unlevels the playing field.
> I’d suggest a new moderation rule for this channel: to disallow any talk about alternate/additional funding for JAM implementation teams (besides the Prize) in this channel.
> If we don’t I fear this channel may become a toxic as some of the other channels.
> You can do what you want in the regular governance channels of course.
> My 2cts.

It is strange now to consider what is called serious implementers before enough participants. Any good ecosystem is profit-driven, and any project it wants to participate in will consider the input-output ratio, rather than competing in an uncertain competition.
2024-07-29 13:52 tebdev: > <@mkalohood:matrix.org> It is strange now to consider what is called serious implementers before enough participants. Any good ecosystem is profit-driven, and any project it wants to participate in will consider the input-output ratio, rather than competing in an uncertain competition.

 Agreed, "serious" subjective. if anyone contributes to moving the needle; it is a positive contribution and should not be discounted. Incentives is a NASH to accelerate work, but if you "serious" about blockchain being a movement then "one" would encourage participation and teamwork for democratization as the ultimate payoff. Strength in Numbers.
2024-07-29 17:17 tebdev: > <@xlchen:matrix.org> I created some diagrams, will love a review https://hackmd.io/0gSmXyElT2iKawymS5jJKw?view

Very nice. I started late, but this is an equalizer... Bravo
2024-07-30 10:29 gav: As of [PR #52](https://github.com/gavofyork/graypaper/pull/52), `trap` will panic. [edited]
2024-07-30 10:33 gav: > <@gav:polkadot.io> Looks pretty accurate.

Actually, there's one slight (probable) anomaly...
2024-07-30 10:33 gav: > Parachain collator submit work to packager

Probably the collator would be the packager.
2024-07-30 10:34 gav: Theoretically they might not be, but if you make them different you add a further degree of latency into the pipeline which could delay finality.
2024-07-30 10:46 xlchen: but for more advanced use cases such as synchronous xcmp call, do we not need something like MEV bundler to search for the best way to allocate the work?
2024-07-30 10:47 xlchen: to build multiple parachain blocks in a single work package
2024-07-30 10:48 gav: Yeah, but then each collator would need to be aware that they’re being co-bundled. 
2024-07-30 10:49 gav: So we’d need some sort of multi-parachain collator node. 
2024-07-30 10:49 gav: Probably a pluggable thing or a standard synchronous-composable parachain collation API. 
2024-07-30 10:53 xlchen: I see. Will adjust the diagram when I get the chance. 
2024-07-30 10:57 xlchen: we will need to figure out a new collator selection algorithm to maximize number of processed xcmp messages. another thing to think about in future 
2024-07-30 11:03 bkchr: > <@xlchen:matrix.org> but for more advanced use cases such as synchronous xcmp call, do we not need something like MEV bundler to search for the best way to allocate the work?

But then these parachains will also need to share one core. Probably if you have some profitable MEV that you want to execute, it may be useful. But then the question arises on who pays for the core and do the parachain agree to be bundled. Clearly will require some substantial changes to the parachains to support this I think
2024-07-30 11:06 xlchen: yeah I will imagine something similar flashbots that allow MEV searcher to build bundles from tx pool (across all parachains) and share profits with collator
2024-07-30 11:07 bkchr: The general logic of finding out what to bundle together will also be required for coreplay
2024-07-30 11:07 xlchen: but instead of a single chain MEV, it will be a crosschain and presumably there will be fees for XCMP and that’s another source of income 
2024-07-30 11:07 bkchr: But there the idea was that there exists one leader that lays out the plan for all the tasks for the work package producers 
2024-07-30 11:12 xlchen: the leader can always delegate the work out just like mining pools. it is unlikely that we can just figure out a optimal algorithm so it is something the implementors can compete 
2024-07-30 11:15 bkchr: Yes
2024-07-30 16:11 sourabhniyogi: JAM implementers if you haven't gotten tickets to Devcon yet (and want to go to this: https://polkadot.polkassembly.io/referenda/1024), they went on sale a few minutes back:
 https://tickets.devcon.org/
They tend to get sold out quickly.   There will be another wave but it might be the last one so I ask that you act quickly.  
2024-07-30 16:28 sourabhniyogi: We are getting quotes from venues still, but would like a headcount of who is committed to attend -- if you can fill in your team size and # of people who are committed to attend here:
 https://docs.google.com/spreadsheets/d/1_Ar0CWH8cDq_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0
That would help us decide whether we get a 30 vs 50 vs 70 person venue.  The good news is that the venue costs are lower than expected so we may have bigger travel budgets; the bad news is that we are on waiting lists for the best places and I can't tell you what the venue is quite yet.
2024-07-30 16:37 sourabhniyogi: As some people have had some difficulty adding a comment on Polkassembly [due to identity not being set] feel free to add your name to the sheet.  I will create a new room with the key team contacts so we don't get off JAM topics.  Thank you!
2024-07-30 20:42 shawntabrizi: I want to present an idea having only really high level understanding of JAM, so I apologize in advance if I am just talking air.

My comments basically encapsulates the issue opened on Polkadot here: https://github.com/paritytech/polkadot-sdk/issues/811

As I understand with how services are being designed in JAM, their only ability to read and write data is to the DA layer.

This is of course the preferred and most scalable method for services to place data. Services that want to store long term data are asked to have their own data shard.

However, when thinking about the kinds of services which can be built on JAM, and affording those services the most flexibility, I can imagine that services will want to be able to write to a long term storage without having to maintain their own collators or data shards. This is basically what existing smart contract platforms afford to contracts.

My high level suggestion is that JAM should also include an API where services can write data to the main JAM database, probably under the general opaque key/value store of preimages.

Then, executing the state transition function of services should be able to read from a combination of the DA and the stored preimages in the JAM database.

Writing here could be super expensive, such that we encourage good behavior to NOT use it frivolously, but to not have it at all seems like a missed scenario.

I think if JAM is going to be the most general web3 computer, it does make sense to have such an API, and can help provide a feature which can onboard more services to use JAM. [edited]
  ↳ 2024-07-31 06:54 sourabhniyogi: There is long-term storage for services in the State (kept in a binary Patricia Merkle Trie).  Section 12.1 of GP describes the basic service data storage you are looking for, Appendix D.1's Equation (291)'s last 4 lines describe the service storage state, which I think will have codehash => code in the dictionary along with other preimages. [edited]
  ↳ 2024-07-31 06:55 sourabhniyogi: The host function `write` (showing up in PVM compiled byte code) enables JAM "accumulate" invocations to write to this service storage. [edited]
  ↳ 2024-07-31 06:55 sourabhniyogi: Someone correct me if I got it wrong =)
2024-07-31 05:37 ltfschoen: > <@shawntabrizi:matrix.org> I want to present an idea having only really high level understanding of JAM, so I apologize in advance if I am just talking air.
> 
> My comments basically encapsulates the issue opened on Polkadot here: https://github.com/paritytech/polkadot-sdk/issues/811
> 
> As I understand with how services are being designed in JAM, their only ability to read and write data is to the DA layer.
> 
> This is of course the preferred and most scalable method for services to place data. Services that want to store long term data are asked to have their own data shard.
> 
> However, when thinking about the kinds of services which can be built on JAM, and affording those services the most flexibility, I can imagine that services will want to be able to write to a long term storage without having to maintain their own collators or data shards. This is basically what existing smart contract platforms afford to contracts.
> 
> My high level suggestion is that JAM should also include an API where services can write data to the main JAM database, probably under the general opaque key/value store of preimages.
> 
> Then, executing the state transition function of services should be able to read from a combination of the DA and the stored preimages in the JAM database.
> 
> Writing here could be super expensive, such that we encourage good behavior to NOT use it frivolously, but to not have it at all seems like a missed scenario.
> 
> I think if JAM is going to be the most general web3 computer, it does make sense to have such an API, and can help provide a feature which can onboard more services to use JAM.

> As I understand with how services are being designed in JAM, their only ability to read and write data is to the DA layer.

in contrast to Polkadot where "parachains's code never read from the DA layer"
source: https://blog.kianenigma.nl/posts/tech/demystifying-jam/
2024-07-31 08:37 gav: > <@shawntabrizi:matrix.org> I want to present an idea having only really high level understanding of JAM, so I apologize in advance if I am just talking air.
> 
> My comments basically encapsulates the issue opened on Polkadot here: https://github.com/paritytech/polkadot-sdk/issues/811
> 
> As I understand with how services are being designed in JAM, their only ability to read and write data is to the DA layer.
> 
> This is of course the preferred and most scalable method for services to place data. Services that want to store long term data are asked to have their own data shard.
> 
> However, when thinking about the kinds of services which can be built on JAM, and affording those services the most flexibility, I can imagine that services will want to be able to write to a long term storage without having to maintain their own collators or data shards. This is basically what existing smart contract platforms afford to contracts.
> 
> My high level suggestion is that JAM should also include an API where services can write data to the main JAM database, probably under the general opaque key/value store of preimages.
> 
> Then, executing the state transition function of services should be able to read from a combination of the DA and the stored preimages in the JAM database.
> 
> Writing here could be super expensive, such that we encourage good behavior to NOT use it frivolously, but to not have it at all seems like a missed scenario.
> 
> I think if JAM is going to be the most general web3 computer, it does make sense to have such an API, and can help provide a feature which can onboard more services to use JAM.

The DA system is not the only storage available. There is also the service state.
2024-07-31 10:08 tebdev: 
2024-07-31 13:00 tebdev: Please excuse, trying to set a tempo for my team. is the goal to have M1 - Dec, M2 - ???, etc.? If documented somewhere, please help me with a URL.
2024-07-31 14:10 gav: See the chat around here. [edited]
2024-07-31 14:10 gav: > <@tebdev:matrix.org> Please excuse, trying to set a tempo for my team. is the goal to have M1 - Dec, M2 - ???, etc.? If documented somewhere, please help me with a URL.

See ^^^
2024-07-31 15:32 sourabhniyogi: For those of you who are trying to write their first refine / accumulate code (or connect PVM + Patricia Merkle Tries + DA to your first attempt at host functions), this assembly compiler is going to be insanely useful:

```
# cat tools/spectool/spec/src/inst_branch_greater_or_equal_signed_ok.txt 
pub @main:
    a0 = 10
    a1 = -10
    jump @target if a0 >=s a1
    trap
@target:
    a0 = 0xdeadbeef

# cargo run -p polkatool -- assemble tools/spectool/spec/src/inst_branch_greater_or_equal_signed_ok.txt -o output.polkavm
# cargo run -p polkatool disassemble --show-raw-bytes output.polkavm
// RO data = 0/0 bytes
// RW data = 0/0 bytes
// Stack size = 0 bytes

// Instructions = 5
// Code size = 16 bytes

      :                          @0 [export #0: 'main']
     0: 04 07 0a                 a0 = 0xa
     3: 04 08 f6                 a1 = 0xfffffff6
     6: 2b 87 04                 jump 10 if a0 >=s a1
      :                          @1
     9: 00                       trap
      :                          @2 [export #1: 'target']
    10: 04 07 ef be ad de        a0 = 0xdeadbeef
```

This is from beloved @koute https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2257688558 -- having this assembler spares everyone from hand-assembling PVM byte code like its 1964, but at least for now we have to figure out the closest thing to read/write/solicit/lookup/historical\_lookup/import/export and do a bit of hand assembling.  But it won't be _too bad_. [edited]
2024-07-31 18:01 tebdev: > <@gav:polkadot.io> See ^^^

Perfecto. Expert is greater payoff than money. Money is easy. LQ --> LA (answer) ;)
2024-07-31 22:19 danicuki: I was thinking about organizing a JAM meetup in Lisbon. Would you come? Register here: https://lu.ma/fqg0ktn0
2024-08-01 13:22 ltfschoen: 
2024-08-01 13:38 ltfschoen: > <@danicuki:matrix.org> I was thinking about organizing a JAM meetup in Lisbon. Would you come? Register here: https://lu.ma/fqg0ktn0

i think you need to have rules for attendees like "Everyone will be required to follow the official W3F rules and unofficial "Rules" (from Gav)" as shown in https://polkadot.polkassembly.io/referenda/1024
2024-08-01 13:44 gav: There's really nothing problematic about meeting; my suggestions are there to help ensure that nobody is accidentally disenfranchised. Ultimately, if you can prove clear expertise over the code you're writing, and explain all design and interpretation decisions, then there really shouldn't be a problem. Just be sure to document and declare any non-trivial "coordinated learning"! [edited]
2024-08-01 16:43 s_saxemberg: Hello Jam implementers, we just wanted to invite you to let us know (the community and tokenholders) more about the identities of the Jam implementers that would be the beneficiaries of referendum 1024 https://polkadot.subsquare.io/referenda/1024 (trip to Thailand Devcon7) allegedly this will benefit +15 teams and many more people we would like to meet. We are reaching to you guys through this channel because this is the linked chat that was provided on the referendum. 
Thank you and sorry for the unrelated interruption. 
  ↳ 2024-08-01 17:23 celadari: I just posted a comment for jam4s
  ↳ 2024-08-01 19:56 vinsystems: Me too
  ↳ 2024-08-01 21:55 sourabhniyogi: Thanks for checking up, we appreciate it.  I have tabulated a headcount:

https://docs.google.com/spreadsheets/d/1\_Ar0CWH8cDq\_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0

Most of the teams are asking questions.  If you find any sock puppet candidates let me know!   Note there is some People Chain/Identity issue and some kind of Polkassembly issue (or polkadot.js extension update) that prevented new people commenting without an identity, so failing to comment alone is not a robust sock puppet detector =)

I don't want _everyone_ to be required to write a report (we will do our best as proponent) nor be present for 72 hours (12 hours x 6 days), but I will ask everyone what teams they learned from and who they taught what.  If there are any Michiko Watanabes, they would not appear on anyone's list.  We have 100 days before the event to know each other on matrix rooms, and at least for our part on reimbursement, I'll probably be able to remember 40 some people.   [edited]
  ↳ 2024-08-04 00:41 ltfschoen: s_saxemberg: i can't post due on that referendum thread due to reasons outlined here https://forum.polkadot.network/t/people-chain-launch-and-identity-migration-plan/5930/32?u=ltfschoen

i've added my identity and estimated budget here https://github.com/users/ltfschoen/projects/3/views/1?pane=issue&itemId=73400075

2024-08-01 18:33 celadari: Hi davxy ,

I checked the chat and read your discussion with Sourabh regarding signature verification. I also checked the two repositories `ark-ec-vrfs` and `bandersnatch-vrfs-spec`

I wanted to confirm my understanding: Is `pub type RingCommitment<S> = ring_proof::FixedColumnsCommitted<BaseField<S>, PcsCommitment<S>>; `the ring root commitment ($\gamma_z$) mentioned in the Gray Paper?

If yes, when we need a verifier for the ring commitment, we need `PcsParams`. What should I use? From the code, it seems we take these params from the ring context, and there appears to be some randomness when instantiating ring context. Is this normal? Should I just initialize the ring context with `RingContext::from_seed(RING_DOMAIN_SIZE, [0; 32])` in the code and not worry about the rest ?

Thanks in advance !
2024-08-02 05:56 xlchen: Any suggestions on in what order to implement the protocols? Considerations: stability of the spec, availability and stability of test vectors, coupling with other protocols (e.g. can't do B unless A is implemented and size/complexity. e.g. First thing should be the codec, and then Safrole (which depends on the codec) is a good starting point as it is relatively simple, presumably no plan to update it in GP, and with test vectors merged (i.e. stable). and then?
  ↳ 2024-08-02 06:18 celadari: I don't think you need codec to work on safrole. You just need to parse the json files to your data structures for testing. The way you parse the json shouldn't really matter for codec no ? 🤔
  ↳ 2024-08-02 06:20 xlchen: I guess I didn’t give the best example but the safrole test vector does have a encoded one which will need codec to be implemented to use
  ↳ 2024-08-02 06:45 celadari: What do you mean by encoded one ? I think you can evenly divide into two tests: pure safrole protocol implementation with json and later codec
  ↳ 2024-08-02 07:15 xlchen: my point will be true if there isn’t any json test case provided but only scale one
  ↳ 2024-08-02 10:59 oliver.tale-yazdi: I went by the state dependency graph. Sure there is a risk to do things wrong without test vectors, but most corrections to the GP so far were quite minor (modulo the judgement/dispute/verdict alterations).  
SCALE is still a good idea IMHO to pass all the Safrole tests.
  ↳ 2024-08-02 14:26 sourabhniyogi: I think every team will be different.

For a team of 3+ all the major "starting" components can be done in parallel:

1. Safrole (FFI)
2. PVM
3. State DB : Tries, DA abstraction
4. Erasure coding (FFI)
5. Scale
where trying to pass the test vectors is basically educational.

Then doing this serially:
6. JAMNP for some small V with a matching RS different than 4
7. Producing blocks with 1, 3, 5, 6 coming together validating tickets,  sending tickets, authoring blocks and validating blocks, write to state trie; set up your DB
8. Wiring up (2) with tiniest refine and accumulate you can write with enough host functions to put (4) together with importing and exporting.
9. work packages with core assignments (V=6, C=2)

We are putting the bones of (6)-(9) together now, then I imagine:
10. treatment of assurances, audits, and judgements/disputes (not sure how to order these yet)
11. statistics
12. authorization, transfer, gas+storage bookkeeping
13. filling in validation TODOs for conformance
14. All remaining host functions needed for serious JAM services, including privileged

===
15. Beefy
16. GRANDPA
17. General polish: Expiring items, edge cases of PVM

Along the way we'll get more test vectors and then polish and optimize polish and optimize.

We can stand up a "tiny" that doesn't do any work, then one that does work with basic JAM services, then one that does work that is guaranteed/ assured/audited, then one that has evil actors doing increasing amounts of evil, then one that has increasing numbers of cores together, ending up in the "full" toaster =).

My (increasingly less wild guess) is that I see 2 man years of work for 95-99th+ percentile engineers so having a team of 4 is best to cut it down to like 6 months (your guess), but I'd guess 2 99th percentile engineers could do it all in less than 6 months.  But the sheer diversity of different types of things seem to require a bunch of different kinds of people, so I'd worry about the team of 1.

I would hate teams to not get started on this exciting journey just because 100% of all test vectors aren't available.  They have been immensely valuable to understand all the basic components though, even if in draft form. [edited]
  ↳ 2024-08-02 23:04 xlchen: I guess I worried too much with getting it right at this stage (writing test takes more than than code because I don't exactly know what is the right behaviour).
  ↳ 2024-08-02 23:07 xlchen: Just throwing some component that most likely need to be done at some stage: tracing and diagnostic tool integration, DB management (e.g. pruning), RPC (at least some basic ones to get data out of the a running node without the needs to parse logs)
2024-08-02 05:57 xlchen: I see open PR on the testvectors so that means they are available but because not yet merged I have no idea on how stable they are.
2024-08-02 05:59 xlchen: I am a bit hesitated on working on the protocols without test vectors because I could do it completely wrong and won't be able know until related test vectors are released
2024-08-02 07:55 asmie: Hi! qq about in-memory db - can we use anything external (eg.: RocksDB, ParityDB) or it should be something implemented from scratch?
2024-08-02 15:07 gav: > <@xlchen:matrix.org> I am a bit hesitated on working on the protocols without test vectors because I could do it completely wrong and won't be able know until related test vectors are released

The protocol definition is 0.3.2. There are going to be changes. Nothing is final. 
  ↳ 2024-08-02 23:02 xlchen: I mainly want to know in relatively terms which part is more stable. But I guess that could be an unknown as well
2024-08-03 15:13 ltfschoen: does anyone know where i can find out more information about the **zkSNARK Service** that Gav mentioned at 51mins in this old discussion "Gavin Wood on JAM: The next disruptor in Web3" https://x.com/paritytech/status/1788847203622043974 [edited]
2024-08-05 15:19 tebdev: > <@asmie:matrix.org> Hi! qq about in-memory db - can we use anything external (eg.: RocksDB, ParityDB) or it should be something implemented from scratch?

This a good question. I also need advice.
2024-08-06 09:35 dudley_kilt: Dudley from the KILT Protocol team. We are currently putting a team of Parachain members to build a JAM Client in Rust. We are looking to comprise multiple ecosystem partners of a team around 4-6 people either part time or full time that would implement the graypaper. We would be beginning in the following weeks. We were wondering the state of play considering the stiff competition in the B category.

Our goal is to build knowledge from the existing ecosystem teams and share that expertise of the JAM Clients to build a stronger ecosystem when the JAM comes around consider it “Spreading the butter over the toast then the JAM .”

We are looking for team members in the ecosystem Rust from Parachain teams to include. KILT would be leading the team.
2024-08-06 10:37 darentuzi: > <@asmie:matrix.org> Hi! qq about in-memory db - can we use anything external (eg.: RocksDB, ParityDB) or it should be something implemented from scratch?

Can anyone help clarify this, my guess is that an existing DB should be fine?
2024-08-06 10:47 subotic: > <@darentuzi:matrix.org> Can anyone help clarify this, my guess is that an existing DB should be fine?

This is one of previous Gav's responses: "Third-party libraries (FFI) for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE) and networking (e.g. QUIC) are acceptable. Everything else should be properly implemented."

So from that I understand that DB falls under "everything else".
2024-08-06 17:31 gav: > <@subotic:matrix.org> This is one of previous Gav's responses: "Third-party libraries (FFI) for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE) and networking (e.g. QUIC) are acceptable. Everything else should be properly implemented."
> 
> So from that I understand that DB falls under "everything else".

Sorry missed this. It’s fine to use a third-party DB. 
2024-08-06 17:32 gav: Same goes for anything similarly generic. 
2024-08-06 20:43 erkt: Point of Clarification: The latest version of the GP removes any mention of the old SCALE codec, however, in some convos/threads in the chat, SCALE is still being mentioned. I know the variable integer encoding scheme in GP is already different from the compact integer encoding in SCALE. So is it safe to say that SCALE will not be used in JAM? 
2024-08-06 20:46 erkt: 
2024-08-06 20:55 erkt: Also, on the note of Integer encoding, I'm having a bit of confusion with the 29-bit serialization rules (Eqn 274). Did the writer mean to say the 3rd condition is: "otherwise if x <2^29" similarly to Eqn 275? Alternatively should `l` be in `N_2` instead of `N_3`?
  ↳ 2024-08-06 21:07 prematurata: N_3 should mean 0,1,2 if I remind properly
  ↳ 2024-08-06 21:07 erkt: Doh, you're totally right. Thanks a lot 
  ↳ 2024-08-06 21:08 erkt: Doing a quick search of the GP, i don't see the 29-bit serialization being used anywhere. Anyone know what is the intended use case of it?
  ↳ 2024-08-06 21:08 erkt: Why would I use that instead of the general varint encoding?
  ↳ 2024-08-06 21:14 prematurata: Is It e4*?
  ↳ 2024-08-06 21:14 erkt: Yep
  ↳ 2024-08-06 21:15 erkt: image.png
  ↳ 2024-08-06 21:15 prematurata: Gav already said it's not currently used and most likely to be removed 
  ↳ 2024-08-06 21:15 prematurata: I would not spend much time on it If I were you :)
  ↳ 2024-08-06 21:15 erkt: Ah i must have missed that. Do you know where he said that?
  ↳ 2024-08-06 21:15 erkt: Thanks a lot again for responding, you're awesome. 
  ↳ 2024-08-06 21:16 prematurata: I asked about it some days ago
  ↳ 2024-08-06 21:16 prematurata: Don't remember the context sorry
  ↳ 2024-08-06 21:16 erkt: no problem 
  ↳ 2024-08-06 21:16 erkt: 🫡
2024-08-07 09:38 gav: > <@erkt:matrix.org> Point of Clarification: The latest version of the GP removes any mention of the old SCALE codec, however, in some convos/threads in the chat, SCALE is still being mentioned. I know the variable integer encoding scheme in GP is already different from the compact integer encoding in SCALE. So is it safe to say that SCALE will not be used in JAM? 

Yes. 
2024-08-08 19:21 celadari: Is the size in bytes of gamma_z always the same ? If not, is there a limit on the number of bytes of gamma\_z Or a way to know it in advance before computing it ?
(I ask this because we use a ffi to execute the rust code ark-bandersnatch and to get the result back from our language we provide a pointer with free memory and the length of this memory) [edited]
2024-08-08 19:31 celadari: So far I've only seen gamma_z with size of 144 bytes in the test vectors but I wanted to confirm the size in bytes of gamma_z instead of assuming [edited]
2024-08-08 19:32 prematurata: it's 144
2024-08-08 19:34 prematurata: you can confirm it also by checking appendix `I` which states `Y_r` is a subset of `Y_144` and if u check (49) then `gamma_z` is defined to be in `Y_r`
  ↳ 2024-08-08 19:37 celadari: I should have remembered that...
Thanks a lot
  ↳ 2024-08-08 19:37 prematurata: np
  ↳ 2024-08-08 19:38 prematurata: what ffi language allows u to give a pointer in memory? im curious
  ↳ 2024-08-08 19:41 celadari: > <@prematurata:matrix.org> what ffi language allows u to give a pointer in memory? im curious

Java
It's not a pointer with * per say (it doesn't exist in java) but it's an object called Memory that when it arrives to rust is a raw pointer
2024-08-09 11:41 vinsystems: 
In the test enact-epoch-change-with-no-tickets-4.json of Safrole, the value of the parameters in post_state indicates that there has been an epoch change (e' > e). However, if I calculate the value of e and e', they are the same... 
e = tau / E; e = 10 / 600 = 0
e' = tau' / E; e' = 15 / 600 = 0

Therefore, e' = e. What I missing here? 
https://github.com/w3f/jamtestvectors/blob/master/safrole/tiny/enact-epoch-change-with-no-tickets-4.json
  ↳ 2024-08-09 11:44 celadari: You're talking about tiny or full ? Because if you're talking about tiny then E=12 [edited]
  ↳ 2024-08-09 11:46 vinsystems: About tiny. Thank you!
2024-08-09 11:44 xlchen: https://github.com/w3f/jamtestvectors/blob/master/safrole/tiny.asn#L4
2024-08-09 16:25 celadari: Hello, I have a doubt regarding **ordering of extrinsic** in file `tiny/publish-tickets-with-mark-2.json`.

We have the following extrinsic:

```json
{
        "attempt": 1,
        "signature": "0x8e.......cf7"
      },
      {
        "attempt": 0,
        "signature": "0x38.....92"
      },
      {
        "attempt": 0,
        "signature": "0xa7....38"
      },
      {
        "attempt": 1,
        "signature": "0x52....f0"
      },
      {
        "attempt": 1,
        "signature": "0x16......53"
      }
```

Verifying signatures and thus getting VRF output I get in the same order:
0x3a....ad
0x5d....98
0x8b....d9
0xae....b4
0xb1.....75

but then they are not in any order (ascending or descending) if taken as LITTLE-ENDIAN.
(They are in ascending order if taken as BIG-ENDIAN though...)

**Is there a problem with the order of extrinsic in this file or there is something I am missing ?** [edited]
  ↳ 2024-08-09 21:10 xlchen: I think you are confused how le/be works between hex string vs binary number
  ↳ 2024-08-09 21:11 xlchen: for data [1,2,3,4], written in hex using le will be 0x01020304
  ↳ 2024-08-09 21:11 xlchen: lsb is on left, unlike numbers
  ↳ 2024-08-09 21:23 celadari: The example you provided is accurate, but I'm having trouble understanding how it relates to ordering.

The representation of a hex string is independent of endianness (big-endian or little-endian). However, if you're trying to define an ordering between arrays of bytes, endianness will have an impact. 

When comparing two arrays of bytes, you need to decide whether the arrays are in big-endian (BE) or little-endian (LE) format. This will determine how you compare the bytes one by one until a strict comparison is established.
  ↳ 2024-08-09 21:37 xlchen: yes and they are le
  ↳ 2024-08-09 21:39 celadari: Oh wait, thank you, Bryan.

You've just made me realize that my code already assumes endianness; otherwise, I wouldn't have been able to print the hex format correctly. The hex representation was derived from an array of bytes from the start. If the hex values are among the postState gamma_a, then they are correct
2024-08-12 11:00 dakkk: 
2024-08-12 11:28 dakkk: Regarding the definition of Y in appendix G, the two functions "decode" and "hashed_output" are referenced; where are defined?  I can't find a valid "name match" in the linked papers
  ↳ 2024-08-12 11:34 celadari: In the code (https://github.com/davxy/bandersnatch-vrfs-spec/blob/main/example/src/main.rs), you have line 163 `let vrf_output_hash: [u8; 32] = output.hash()[..32].try_into().unwrap();` where they "apply Y"
  ↳ 2024-08-12 11:46 celadari: My bad, you were asking about linked/referenced papers. Paper "Jeff 2023" defines the function "rVRF.Verify(comring, in, ad, sigma)" (in part 4 of the paper) that returns the output if it verifies and false otherwise. The decode function I don't know how to "name match" it
I hope it answers your question 🤷‍♂️ [edited]
  ↳ 2024-08-12 13:31 dakkk: yep, thank you (y) 
2024-08-14 17:48 davxy: ⚠️ First proposal for Disputes STF test vectors (Section 10) : https://github.com/w3f/jamtestvectors/pull/9
Be aware, it may not be final, and some adjustments might be made. However, you can start using it.
2024-08-15 07:23 bkchr: > <@sourabhniyogi:matrix.org> JAM implementers if you haven't gotten tickets to Devcon yet (and want to go to this: https://polkadot.polkassembly.io/referenda/1024), they went on sale a few minutes back:
>  https://tickets.devcon.org/
> They tend to get sold out quickly.   There will be another wave but it might be the last one so I ask that you act quickly.  

With the recent proposal of having a sub0 next to devcon, this event should be scrapped and included in sub0. The sub0 proposal is any way about having a hackathon style event thst wants to attract different kind of peoples. First, this will reduce costs for the ecosystem and secondly it will also have a much bigger impact if the ecosystem can participate. 
2024-08-15 07:25 bkchr: This was also directly proposed by rtti-5220 as comment to the proposal: https://polkadot.polkassembly.io/referenda/1024#GJjjWhHPJSlZt2NObHFO
2024-08-15 07:25 gav: > <@bkchr:parity.io> With the recent proposal of having a sub0 next to devcon, this event should be scrapped and included in sub0. The sub0 proposal is any way about having a hackathon style event thst wants to attract different kind of peoples. First, this will reduce costs for the ecosystem and secondly it will also have a much bigger impact if the ecosystem can participate. 

When you say “next to”, do you mean in time or space?:)
2024-08-15 07:26 bkchr: Time and space. 
2024-08-15 07:27 gav: Ahh right - actually during devcon and in Bangkok.  [edited]
2024-08-15 07:30 bkchr: https://forum.polkadot.network/t/sub0-reset-devcon-bangkok-back-to-the-roots/9626
2024-08-15 07:31 bkchr: 9-11 November. Devcon starts at the 12th
2024-08-15 07:31 rtti-5220: > <@gav:polkadot.io> Ahh right - actually during devcon and in Bangkok.

which is the case for this proposal, but i think something in parallel to sub0, same venue, 1 day completely focused on JAM would make more sense for JAM impl devs who can attend both events easily (sub0 and Jam0), and it would reduce costs (instead of organising 2 separate events in different parts of the city, we get two events in one) - we are also experimenting with this first JAM event so something in a more controlled enviroment like Sub0 and getting support from the Sub0 organisers might make more sense. 
2024-08-15 07:33 gav: Perhaps we could run a parallel event in Europe at the same time. 
  ↳ 2024-08-15 07:39 rtti-5220: i dont think running an event in asia and one in europe in parallel is the best idea for devs who might want to see both, which in general happens - since JAM is on the first stage of development and is the first event focused on this impl. Furthemore, it makes it more costly. 
2024-08-15 07:40 emielvanderhoek: Although it may not be official I believe lots of JAM teams are making preparations for attending JAM0 as a side event for Devcon in Bangkok. 
2024-08-15 07:42 emielvanderhoek: 15 teams already last I read. 
2024-08-15 07:43 gav: Out of 23, but if the other 8 happen to be within easy travelling distance of Lisbon then it could be nice to host something small at the Parity office there. 
2024-08-15 07:43 gav: Cost would be minimal compared to the 100k being asked for Jam0 Bangkok. 
2024-08-15 07:44 emielvanderhoek: Sure it would be nice to have a shared agenda/objective at least. 
2024-08-15 07:44 gav: And personally I probably can’t make Bangkok in November.  [edited]
  ↳ 2024-08-15 07:48 rtti-5220: OK, then given your role on JAM development it might not make sense to do it at all then. You could join virtually, but I think key people working on the protocol should be there - I think all of these events are running on the idea you would present on them, so its a pity. 
  ↳ 2024-08-15 08:05 gav: > <@rtti-5220:matrix.org> OK, then given your role on JAM development it might not make sense to do it at all then. You could join virtually, but I think key people working on the protocol should be there - I think all of these events are running on the idea you would present on them, so its a pity. 

I think it’s probably fine; it’d be nice to meet everyone but assuming I can’t make it we can always organise JAM1 in early 2025. The idea of engendering cross-pollination between Eth and Jam communities is a good one, and if it’s mostly about M1 interop then physical presence is a bit less important. 
2024-08-15 07:53 emielvanderhoek: The assumption I believe is that half November we’d get as far as running a M1 ‘tiny’ importer network between clients. Timing at least makes this reasonable perhaps given it is three month ahead of us. 
2024-08-15 08:00 bkchr: Also JAM could be helpful to "lure in" more people to sub0. Getting actually people from ETH interested on JAM and through this learning some stuff about the current stack could be quite helpful for the entire ecosystem
2024-08-15 12:09 sourabhniyogi: Guys, thank you for entertaining the JAM0 event.  It was about travel budgets for like 38 people, which are not covered under the sub0 proposal, which has dates which are too early for most people to sustain a 9-10 day trip.  I hope JAM implementers didn't buy Devcon 7 tickets and nonrefundable airfare. [edited]
2024-08-15 12:15 bkchr: The sub0 proposal is not up yet and they would be happy to extend the proposal by including the proposed travel budgets
2024-08-15 12:15 sourabhniyogi: Let us consider 1024 JAM0 scrapped.  If you bought tickets/airfare/hotel in expectation that it would be covered by 1024, please get them refunded.  
2024-08-15 12:17 bkchr: I don't get why you want to scrape it? 
2024-08-15 12:20 sourabhniyogi: https://polkadot.polkassembly.io/referenda/1024 won't pass at this stage?
2024-08-15 12:21 bkchr: Yeah, but just let it integrate into sub0. Why not? 
2024-08-15 12:24 sourabhniyogi: Some of us literally can't make 9th/10th ( In particular, me ).   Here is the list of teams for Roman to work with:

 https://docs.google.com/spreadsheets/d/1_Ar0CWH8cDq_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0
2024-08-15 12:27 bkchr: You can still join on the 11th as you had planned before
2024-08-15 12:27 bkchr: I mean this is not really about one single individual, but instead of getting some benefit for the entire ecosystem 
2024-08-15 12:32 sourabhniyogi: Is Roman / WebZero in this room?  Or, Basti.await  can you lead the JAM portion of the sub0 event and get the travel budget added and approved for people?  [Or delegate to someone who wants to lead it]
2024-08-15 12:37 sourabhniyogi: Hi rektormoon thanks for joining =)
2024-08-15 12:37 rektormoon: Hey everyone, glad to be here
2024-08-15 12:39 sourabhniyogi: We would like to fuse the JAM0 event concept into sub0 which I understand is on the 9th-11th -- Basti.await believes it is reasonable to get some JAM implementer travel budget added in.  
2024-08-15 12:40 sourabhniyogi: https://docs.google.com/spreadsheets/d/1_Ar0CWH8cDq_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0

has the list of interested people from 1024.  

2024-08-15 12:40 rektormoon: I think it makes sense to add the program, which ofc would change the nature of your original plan, as we are more interested in showcasing the concepts and progress to ppl not involved with building JAM (yet)
2024-08-15 12:41 rektormoon: Budget wise we don’t really comp travel for speakers and such, but that could also be dealt with by a treasury tip for example. We just don’t really have capacity to be a “travel agency” for idk 30-40 ppl 
2024-08-15 12:42 bkchr: The point is more about including the travel budget in the sub0 proposal
2024-08-15 12:43 rektormoon: > <@bkchr:parity.io> The point is more about including the travel budget in the sub0 proposal

Ofc, but we would be responsible for that budget
2024-08-15 12:44 bkchr: Okay, I think we can find a way for getting and handling the budget 
2024-08-15 12:45 rektormoon: As long as we find good ways to transparently report…
2024-08-15 12:46 rektormoon: At web3 summit we are paying partial travel comp for hackers for the first time, so it’s a new thing for us 
2024-08-15 12:46 bkchr: I had misunderstood you, I had thought you had said earlier today that you would be okay to include this in the sub0 proposal. I will figure something out 
2024-08-15 12:47 rektormoon: Program wise absolutely!
2024-08-15 12:47 rektormoon: When it comes to payments and budgets, I just want to understand how you see it working and who would be responsible for what :-)
2024-08-15 12:49 sourabhniyogi: Did you lock down an exact venue + dates yet?  For pre 11th, you own everything.  For 12-17th dates, I can be an assistant to Basti.await .
2024-08-15 12:51 bkchr: I think the general idea would be to move everything earlier
2024-08-15 12:51 gav: > <@gav:polkadot.io> And personally I probably can’t make Bangkok in November.

Can't promise anything yet but I might be able to make 9th-11th.
2024-08-15 12:52 sourabhniyogi: To state the obvious, a sub0 without you is barely a sub0 =)
2024-08-15 12:54 rektormoon: That would be sub-par
2024-08-15 12:55 sourabhniyogi: Basti.await: I have a Valia room for the 11th - 16th.  
https://www.valiahotelbangkok.com/meetings-venues/
This can be a room for JAM Implementers to work after sub0 (assuming 9th-11th)  Can you approve this as being addable to the budget?  This would be \< $20K [edited]
2024-08-15 13:04 bkchr: I mean I'm not doing the budget, but did you already booked this? 
2024-08-15 13:05 sourabhniyogi: I did [50%]  
2024-08-15 13:06 bkchr: So you mean you already paid 50% upfront? 
2024-08-15 13:08 emielvanderhoek: I would be great to have some center of gravity mid November. Obviously there is some risk for the organizing party if funding is required. It would be good to get some consensus on date (and later content) for an event planning wise. 
2024-08-15 13:08 sourabhniyogi: image.png
2024-08-15 13:09 sourabhniyogi: Approximately, yes.  There is a OneBlock Polkadot hackathon where I'm not sure where they ended up.
2024-08-15 13:10 sourabhniyogi: They originally wanted 13th+14th so since it opened up I asked for it.  
2024-08-15 13:11 emielvanderhoek: My JAM team (3x) has devcon tickets already. We have not yet booked flight and accommodation. Nice if we can get some reimbursement but not strictly necessary. 
2024-08-15 13:11 rektormoon: So from the WebZero side I would like to involve the teams building on JAM to be on the sub0 program on the 11th. 
2024-08-15 13:11 rektormoon: > <@sourabhniyogi:matrix.org> They originally wanted 13th+14th so since it opened up I asked for it.  

Overlaps with devcon, not wise
2024-08-15 13:13 emielvanderhoek: We’ll travel to where center of gravity is for JAM0 if any. 
2024-08-15 13:13 gav: > <@sourabhniyogi:matrix.org> To state the obvious, a sub0 without you is barely a sub0 =)

Well it certainly wasn’t my preference to run it twice in Bangkok in the same year. 
2024-08-15 13:14 rektormoon: We felt the opportunity is too good to pass up 😅
2024-08-15 13:23 sourabhniyogi: Ok rektormoon 11th being the JAM day of sub0 makes sense, thanks for jumping in here -- I'll check if I can swap out the Valia room on the 11th for the 13th / 14th.  We really want more time to work together in person than just 1 day.
2024-08-15 13:24 rektormoon: We plan to have a hacker space in sub0, so you could start work together there on the 9th and 10th
2024-08-15 13:24 rektormoon: Also open at night
2024-08-15 14:01 bkchr: > <@sourabhniyogi:matrix.org> Ok rektormoon 11th being the JAM day of sub0 makes sense, thanks for jumping in here -- I'll check if I can swap out the Valia room on the 11th for the 13th / 14th.  We really want more time to work together in person than just 1 day.

It would also be nice to be more cost efficient. Aka only one event. Can you cancel it? Or at least partly? People will also go to devcon, not sure that much will then appear there to code after a long day of conference 
  ↳ 2024-08-18 19:26 sourabhniyogi: Basti.await: rtti-5220   We hope JAM Implementers travel budgets can be covered to Lisbon and other JAM0/1/2/.. events and this sub0 and the upcoming sub0's with JAM content.

It seems natural to combine JAM events with both sub0 + PBA.  But it is just a passing thought, especially since this channel is not appropriate to talk about treasury expenditures and cost efficiencies. [edited]
2024-08-15 14:11 sourabhniyogi: Alright updated https://polkadot.polkassembly.io/referenda/1024 -- its cost-efficient in that the cost is $0.  I don't want to let anyone down.
2024-08-17 06:47 xlchen: While it is great if we can get a multi client testnet running on JAM0/Sub0 RESET, it is a relatively involved work and I am sure the first try wouldn't work. And I can already foresee some struggles that we are going to have due to number of components required for the whole thing to work especially many of the components are still in draft stage (e.g. networking). In simple words, this is too much for an initial MVP and there will be a good chance we won't be able to deliver it as there are too much uncertainties. It is a good target for us to try, but I won't bet for it.

When a task is too big, what we do is to break it down. So here is my suggestion:

Figure out a simple way for implementations to communicate. It needs to be simple, so pipes (i.e. stdout/stdin). Every program can print and shouldn't take more than 10 line of code to allow it to read. In that way we can have many standalone binaries confirming a same interface and we can assemble all those binaries together for lot more interesting tests. For example, team A have implemented all the components and team B only implemented Safrole, team C only implemented PVM. We can replace the Safrole@TeamA to Safrole@TeamB and PVM@TeamA to PVM@TeamC and still be able to setup a multi client testnet covers some work from team B and C. This also forces everyone to write modular code, which is a good thing as well.
and this will be the first step https://github.com/w3f/jamtestvectors/issues/7
2024-08-17 11:32 sourabhniyogi: Awesome Bryan Chen | Laminar & Acala , thank you for suggesting it.  The "pipes" model standing in place of QUIC and the binary from teams being the core deliverable would be immensely valuable -- is repurposing a fraction of ZombieNet \[which works using chain binaries\] useful for this?

Its immediately clear this pipes+binaries approach is clearly a LOT easier for teams working together with as a proxy for JAMNP, automating the ip/port "setup", but probably can continue into JAMNP with "binaries trading" with a few flags switching modes.

Having a test runner for the existing test vector set makes sense, but the PVM test vector case is quite a different character than all the others in that its almost totally removed from networking -- to use your concrete example, if "team C" only implemented PVM, they would only be able to run through the test runner on just the PVM, and not be able to do anything with "team A" and "team B".  In contrast, team A+B will talk Safrole and can continue onto the other 4 extrinsics, which are .. not very modular.    Team C hasn't gotten very far, not to pass too much judgement here, but has a LOT of catching up to do.

We do have a tiny (V=6, C=2) QUIC passing Ticket + Blocks  (with JSON serialization/deserialization instead of SCALE encoding/decoding) and are proceeding along with our own little RS code (with W\_C x W\_S \<\< 4104, like 24) to get the other 4 extrinsics with DA over the next 4-6 weeks, going from "Team B" to "Team A".   We believe deviating from GP Appendix H to support a tiny RS code is essential for multi-team MVP success and hope we can "pick some parameters" together matched to the "tiny" Safrole test vectors.

We believe a battery of "trivial" jam work packages / services (refine+accumulate, then adding in the auth+transfer) that utilize the host functions are critical for education and enabling team As to keep going.   (In the absence of this, we are currently hand assembling our own little sum of squares battery, replacing a byte here and there for host function calls).  We imagine the first A teams that publish 4-5 epochs (48-60 blocks) covering this battery can argue between themselves about state roots, but it would be even better if we had a  authoritative "M0" 48-60 block dump that covered all the extrinsics, modeled DA, to make arguments tend to zero.  Then we all would just try to get M0 to work on our own first as a prereq to binary trading.

We would be happy to supply whatever binary works by early Oct and hope there are a bunch of "A teams" and "B teams" where we can do pre-work in October.   If there are any A candidates who get to pipes model before Oct, we'll be inspired to match you, pls share! [edited]
2024-08-17 12:42 gav: > <@sourabhniyogi:matrix.org> Awesome Bryan Chen | Laminar & Acala , thank you for suggesting it.  The "pipes" model standing in place of QUIC and the binary from teams being the core deliverable would be immensely valuable -- is repurposing a fraction of ZombieNet \[which works using chain binaries\] useful for this?
> 
> Its immediately clear this pipes+binaries approach is clearly a LOT easier for teams working together with as a proxy for JAMNP, automating the ip/port "setup", but probably can continue into JAMNP with "binaries trading" with a few flags switching modes.
> 
> Having a test runner for the existing test vector set makes sense, but the PVM test vector case is quite a different character than all the others in that its almost totally removed from networking -- to use your concrete example, if "team C" only implemented PVM, they would only be able to run through the test runner on just the PVM, and not be able to do anything with "team A" and "team B".  In contrast, team A+B will talk Safrole and can continue onto the other 4 extrinsics, which are .. not very modular.    Team C hasn't gotten very far, not to pass too much judgement here, but has a LOT of catching up to do.
> 
> We do have a tiny (V=6, C=2) QUIC passing Ticket + Blocks  (with JSON serialization/deserialization instead of SCALE encoding/decoding) and are proceeding along with our own little RS code (with W\_C x W\_S \<\< 4104, like 24) to get the other 4 extrinsics with DA over the next 4-6 weeks, going from "Team B" to "Team A".   We believe deviating from GP Appendix H to support a tiny RS code is essential for multi-team MVP success and hope we can "pick some parameters" together matched to the "tiny" Safrole test vectors.
> 
> We believe a battery of "trivial" jam work packages / services (refine+accumulate, then adding in the auth+transfer) that utilize the host functions are critical for education and enabling team As to keep going.   (In the absence of this, we are currently hand assembling our own little sum of squares battery, replacing a byte here and there for host function calls).  We imagine the first A teams that publish 4-5 epochs (48-60 blocks) covering this battery can argue between themselves about state roots, but it would be even better if we had a  authoritative "M0" 48-60 block dump that covered all the extrinsics, modeled DA, to make arguments tend to zero.  Then we all would just try to get M0 to work on our own first as a prereq to binary trading.
> 
> We would be happy to supply whatever binary works by early Oct and hope there are a bunch of "A teams" and "B teams" where we can do pre-work in October.   If there are any A candidates who get to pipes model before Oct, we'll be inspired to match you, pls share!

Indeed, such a dump is in line with my expectations of what we’ll provide for M1 tests.
2024-08-18 16:28 shwchg: davxy: Hi, I have a question about your dispute test vector
You mentioned in your README that when an execution error occurs, the post-state must match the pre-state. But some of your vectors are still being updated.
https://github.com/davxy/jam-test-vectors/blob/disputes/disputes/tiny/progress_with_culprits-3.json
```
"pre_state": {
        "psi": {
            "psi_g": [],
            "psi_b": [],
            "psi_w": [],
            "psi_o": []
        },
        "rho": [
            null,
            null
        ]
"post_state": {
        "psi": {
            "psi_g": [],
            "psi_b": [
                "0x11da6d1f761ddf9bdb4c9d6e5303ebd41f61858d0a5647a1a7bfe089bf921be9"
            ],
            "psi_w": [],
            "psi_o": []
        },
        "rho": [
            null,
            null
        ]
```
So are there specific errors that you handle in a way that allows the process to continue running?

2024-08-18 16:32 davxy: Nice catch. I'll fix it. For what concerns test vectors, on error post matches pre
2024-08-18 16:40 shwchg: ok thanks!
2024-08-18 17:01 davxy: Fixed. Thank you for reporting :-) 
2024-08-18 19:34 gav: This is not the place to argue over treasury expenditure. Go to Polkassembly or wherever to do that and vote with your stake. 
2024-08-18 19:37 gav: [@sourabhniyogi:matrix.org](https://matrix.to/#/@sourabhniyogi:matrix.org) Please remove the offending text and be more careful in the future. 
2024-08-20 20:14 danicuki: I am organizing an informal JAM enthusiasts meetup at Lisbon, for those who are nearby: https://lu.ma/fqg0ktn0 
2024-08-20 20:41 danicuki: For those who are building JAM, I suggest adding your org / repo to the Electric Capital Crypto Report repo: https://github.com/electric-capital/crypto-ecosystems

Here is a PR reference to follow:
https://github.com/electric-capital/crypto-ecosystems/pull/1443
2024-08-20 20:57 vinsystems: > <@danicuki:matrix.org> I am organizing an informal JAM enthusiasts meetup at Lisbon, for those who are nearby: https://lu.ma/fqg0ktn0

We are from Spain but we won't be able to attend at that date
2024-08-21 05:59 xlchen: I am refactoring our codec (i.e. ditch the existing ScaleCodec library) and just realize that was the Safrole test vector using Scale codec instead of Jam codec? davxy 
2024-08-21 06:00 xlchen: the length prefix in the provided tests are encoded using compact encoding, not the Jam natural number serialization method
2024-08-21 06:19 luka99: Regarding availability using erasure-coding, it says in 14.2.2 that the justification data needed to verify the segments/chunks is too large to be stored by every validator and that it too goes through the same availability framework. Doesn't that create the same problem as to why the justification data is needed in the first place? Someone can give a corrupted chunk of the justification data and we can't restore it? 
2024-08-21 06:27 davxy: Current vectors are provided in two flavors. SCALE and JSON. [edited]
2024-08-21 06:28 davxy: Indeed at the beginning only json was provided. But IIRC someone asked for a scale version as well [edited]
2024-08-21 06:30 davxy: I guess SCALE vectors will be probably replaced at some point 
2024-08-21 06:45 xlchen: it was me asking for it with assumption that scale is used for jam, but that’s actually not the case so will need a version for Jam codec
2024-08-21 06:46 xlchen: I think the only difference is just the encoding format for compact number 
2024-08-21 09:11 tomusdrw: Hi all! Our team was recently working on a PVM implementation and we've also built a tool that we hope will help other implementors. https://pvm.fluffylabs.dev/ <-- here you can find our PVM Disassembler.

It can load a JSON test case file and visualise what instructions are used in the code. By plugging a PVM implementation you can also turn it into a debugger. If any of the teams is interested we want to make it possible to upload a WASM blob of your PVM implementation and run it instead of ours (see open issue on github regarding the interface). We plan to support running two PVMs in parallel and checking their state (registers / memory / gas) at every step and display the exact instruction when they start to differ.

Tool's code is open source on github, so feel free to fork or report any issues or feature requests there. We are looking forward for your feedback.
2024-08-21 09:11 tomusdrw: Huge kudos for Wojciech Kwiatek Krystian Fras who are behind the code of this one :) 👏👏👏
2024-08-21 15:10 rmagon: Hi - for those who are implementing in Go, are there any native libraries for cryptographic primitives like the ones in Rust? For, say, Bandersnatch, RingVRF etc. ? I can see that it is allowed to use such libs but couldn't find anything that we could rely on, specially in Go. Or are you implementing them from scratch Or using FFI for M1 atleast?
  ↳ 2024-09-10 21:14 rick: Hi Rachit -- I did find a bandersnatch implementation in go with a partial audit: 

https://github.com/Consensys/gnark-crypto/tree/master/ecc/bls12-381/bandersnatch

No guarantees for side channels but this should be plenty good enough to get started. 
2024-08-21 15:23 rick: I don’t think there are specific implementations but Filipo Valsorda has published a few of the necessary lower level primitives.

I’ll post here if I find more specific ones. Other people to check out are probably David Stainton from katzenpost, Yawning, and I will probably post mine as a separate oss lib if I get to it. [edited]
2024-08-21 15:24 subotic: > <@rmagon:matrix.org> Hi - for those who are implementing in Go, are there any native libraries for cryptographic primitives like the ones in Rust? For, say, Bandersnatch, RingVRF etc. ? I can see that it is allowed to use such libs but couldn't find anything that we could rely on, specially in Go. Or are you implementing them from scratch Or using FFI for M1 atleast?

FFI is explicitly allowed in these cases (for all milestones).
2024-08-22 09:40 luke_f: image.png
2024-08-22 09:40 luke_f: @davxy:matrix.org
looking at bandersnatch-vrf code example here
https://github.com/davxy/bandersnatch-vrfs-spec/blob/ae82b19e99cdc1301820d9cbd978e0a73b9de2a8/example/src/main.rs#L52

i see that Prover has `prover_idx` field

I'm assuming this corresponds to the index into the validator set of said signer/ prover

could you confirm please?@davxy:matrix.org  [edited]
2024-08-22 09:45 davxy: Confirmed
2024-08-22 09:45 luke_f: Thank you :)
2024-08-23 12:33 rmagon: > <@subotic:matrix.org> FFI is explicitly allowed in these cases (for all milestones).

Makes sense! thank you!
2024-08-23 12:33 rmagon: > <@rick:carback.us> I don’t think there are specific implementations but Filipo Valsorda has published a few of the necessary lower level primitives.
> 
> I’ll post here if I find more specific ones. Other people to check out are probably David Stainton from katzenpost, Yawning, and I will probably post mine as a separate oss lib if I get to it.

That would be great if you can find anything. I will do the same :)
2024-08-23 18:43 sourabhniyogi: sub0 with a bit of JAM is up for vote at https://polkadot.polkassembly.io/referenda/1113 -- This is followed by 5 days of "JAM0" for Implementers (venue sponsored by us, let me know if you are JAM implementers and want in =).  If you intend to trek to sub0 in Bangkok and Devcon but haven't gotten tickets, here is where you can get the final wave on September 3:
 https://devcon.org/en/tickets/ 
If you want discounted hotel rooms use "JAM0" at https://valiahotelbangkok.com [edited]
2024-08-23 19:41 emielvanderhoek: There was discussion on a Bangkok & Lisbon JAM0 gathering. With the Sub0 addition is it now all happening in Bangkok? [edited]
2024-08-24 09:29 bmaas: > <@sourabhniyogi:matrix.org> sub0 with a bit of JAM is up for vote at https://polkadot.polkassembly.io/referenda/1113 -- This is followed by 5 days of "JAM0" for Implementers (venue sponsored by us, let me know if you are JAM implementers and want in =).  If you intend to trek to sub0 in Bangkok and Devcon but haven't gotten tickets, here is where you can get the final wave on September 3:
>  https://devcon.org/en/tickets/ 
> If you want discounted hotel rooms use "JAM0" at https://valiahotelbangkok.com

That sounds like a brilliant idea. I will definitely be up for it.
2024-08-24 17:20 prematurata: Hello all i'm trying to implement the verification for the ticket extrinsic (74),

I am using the data coming from https://github.com/w3f/jamtestvectors/blob/master/safrole/tiny/publish-tickets-no-mark-2.json

so basically this inputs: 
- so signature from `input.extrinsic[0].signature` = `0xb342bf8f...85a8`
- and ringroot commitment `pre_state.gamma_z` = `0x96a4b4...74cf`
- posterior eta_2 from `post_state.eta[2]` = `0xbb30..14aa`

according to paper i just need to concatenate `$jam_ticket_seal` with `posterior eta 2` and the attempt (`1` in the json)

this (if i understand properly) should be the input data. 

I am not able to get the code to verify the signature. I basically checked this piece of code for it
https://github.com/davxy/bandersnatch-vrfs-spec/blob/ae82b19e99cdc1301820d9cbd978e0a73b9de2a8/example/src/main.rs#L134

and modified to have the ring context to be of size 6 and pass an empty aux_data... but `Public::verify().is_err()` is always `true` 

I am a bit lost to be honest any help would be appreciated. 
  ↳ 2024-09-23 05:43 turuslan: 
Thanks, prematurata, davxy

Couldn't find "\$..." definition in notation section of graypaper.

So latex "\$jam\_ticket\_seal" is "jam_ticket_seal" without "$".

([davxy answer outside thread](https://matrix.to/#/!wBOJlzaOULZOALhaRh:polkadot.io/$r3qxlOvQdQAKRJs8mFPLf0Q6ag8oK2XzGutiilGKJvw?via=polkadot.io&via=matrix.org&via=parity.io))

2024-08-24 17:42 gav: > <@prematurata:matrix.org> Hello all i'm trying to implement the verification for the ticket extrinsic (74),
> 
> I am using the data coming from https://github.com/w3f/jamtestvectors/blob/master/safrole/tiny/publish-tickets-no-mark-2.json
> 
> so basically this inputs: 
> - so signature from `input.extrinsic[0].signature` = `0xb342bf8f...85a8`
> - and ringroot commitment `pre_state.gamma_z` = `0x96a4b4...74cf`
> - posterior eta_2 from `post_state.eta[2]` = `0xbb30..14aa`
> 
> according to paper i just need to concatenate `$jam_ticket_seal` with `posterior eta 2` and the attempt (`1` in the json)
> 
> this (if i understand properly) should be the input data. 
> 
> I am not able to get the code to verify the signature. I basically checked this piece of code for it
> https://github.com/davxy/bandersnatch-vrfs-spec/blob/ae82b19e99cdc1301820d9cbd978e0a73b9de2a8/example/src/main.rs#L134
> 
> and modified to have the ring context to be of size 6 and pass an empty aux_data... but `Public::verify().is_err()` is always `true` 
> 
> I am a bit lost to be honest any help would be appreciated.

One for davxy to look at.
2024-08-24 17:49 motifnetwork: > <@emielvanderhoek:matrix.org> There was discussion on a Bangkok & Lisbon JAM0 gathering. With the Sub0 addition is it now all happening in Bangkok?

Hear the same at the AAG 
2024-08-24 17:49 motifnetwork: yep, here
https://polkadot.polkassembly.io/referenda/1113
2024-08-25 19:58 davxy: prematurata: https://gist.github.com/davxy/54892e1ebd548040615a9fdc627de632
I hope it helps
2024-08-26 10:46 davxy: Another batch of test vectors: https://github.com/w3f/jamtestvectors/pull/11
This one focuses on the "Recent History" STF (section 7). 
Overall, it's fairly straightforward, but the update to MMR peaks adds some interesting elements.
Any feedback or notes are appreciated. Thanks!
2024-08-27 07:09 ksc85pwpj5: 
2024-08-27 07:09 ksc85pwpj5: 
2024-08-27 07:09 ksc85pwpj5: 
2024-08-27 07:12 ksc85pwpj5: 
2024-08-27 07:12 ksc85pwpj5: 
2024-08-27 07:12 ksc85pwpj5: 
2024-08-27 09:06 niubob: Hi, I just saw Gav's notes, where can I see the current progress of each team? Or are there any language sets that no one is participating in?
  ↳ 2024-08-27 09:08 cisco: You can see the teams in https://graypaper.com/clients/ albeit without the progress of each team.

All language sets have been picked, unless you want to challenge yourself with language set Z 😂
  ↳ 2024-08-27 09:16 niubob: > <@cisco:parity.io> You can see the teams in https://graypaper.com/clients/ albeit without the progress of each team.
> 
> All language sets have been picked, unless you want to challenge yourself with language set Z 😂

Thanks! set Z lol:
2024-08-28 18:36 sourabhniyogi: 
2024-08-29 03:33 xlchen: Can someone start merging PRs at https://github.com/w3f/jamtestvectors? Otherwise we have to use our own forks to be able to run all the tests on different branches and they are start getting merge conflicts now
2024-08-29 14:02 ntnntn: Is there any rules regarding using FFI for stuff that is implemented in-house? E.g. we run for a TS implementation, can we offload any of the lower-level stuff that require performance to Rust components we would also write from scratch and expose them via FFI?
  ↳ 2024-08-29 14:36 dakkk: FFI Is allowed only for "Third-party libraries for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE), and networking (e.g. QUIC) are acceptable". You can use rust and FFI if you implement yourself one of these things.
  ↳ 2024-08-29 14:37 dakkk: Otherwise "Code must be idiomatic for languages which define idiom."
  ↳ 2024-08-29 14:57 ntnntn: Thanks a lot!
  ↳ 2024-08-29 14:58 ntnntn: I'm wondering if performance could be taken into account. Not sure it will be possible to reach M4 with some languages.
  ↳ 2024-09-09 06:36 gav: It probably won't. The point on idiomaticness does not imply that an implementation must use all the same language. Only that for code written in some language must be idiomatic for that language.
  ↳ 2024-09-09 06:38 gav: For less performant languages, it's perfectly reasonable for a team to write e.g. a database or VM in some lower-level higher-performance language and utilize it through FFI.
  ↳ 2024-09-09 06:42 gav: In the (I'd hope) unlikely event that a team writes 50% of their impl in a language from one set and 50% in a language from another, it will be totally at the discretion of the Fellowship/Foundation to determine how the prize should be allotted from the prize pots. One _possible_ strategy would be to split the prize fund according to the ratio of lines of code written in each language. [edited]
  ↳ 2024-09-09 06:51 jan: I'd expect that for some languages it will be essentially impossible to write even a half speed implementation without resorting to a systems language for the low level performance critical parts, so I would expect in those cases people will not be penalized when it comes to prize. In my opinion people should only be penalized if they use another language unnecessarily.
  ↳ 2024-09-09 06:57 gav: Well, "unnecessarily" is rather vague, but point taken. I updated my notes accordingly.
  ↳ 2024-09-09 07:08 jan: But of course most likely one might not want to implement something in another language right off the bat. Initially it's usually simpler/more convenient to just keep everything in a single language, you don't need to be fast for the first two milestones anyway, and also because probably the easiest way to prove that you _had_ to use another language for speed is to compare it with an implementation in your original language and show the difference.

Once we get to the point where people will reach the latter milestones and will want to optimize the performance of their implemenations then (if there's interest) I could probably host a workshop/presentation/whatever on how to write a fast VM, to help people write more performant PVM implementations (this could be especially useful if your team doesn't have any VM or low-level performance experts) [edited]
2024-08-29 14:02 ntnntn: Or does FFI only apply for the existing libraries that are allowed to be used?
2024-08-29 18:42 davxy: I'm working on a version of the vectors using the codec prescribed by GP. It's almost ready. So maybe it's worth waiting? I'll submit the vectors for the codec first [edited]
2024-08-30 16:37 davxy: https://github.com/w3f/jamtestvectors/pull/12
Your feedback is appreciated 
2024-08-30 17:01 philip.poloczek: 
2024-08-30 17:01 sourabhniyogi: This is awesome and gives us a lot to chew on, thank you!  All the components of Eq (289), C(1)-C(13) and at least 1 test case for service state (the last 4) would be awesome, culminating in  state root that we can strive for.

Generally having a codectest  for all the JAMNP objects would be useful as well, most of which are inside your test vectors already, but not all.  Having  network-centric test vectors would be awesome alongside this "block" centric view.

We are wondering if `Vote` would be broadcasted by validators instead of `Dispute` objects in JAMNP. [edited]
  ↳ 2024-08-30 20:05 dave: Re the last bit, yes I believe validators will only broadcast their votes (judgements) and announcements. The block author will construct the disputes extrinsic based on what they have seen.
  ↳ 2024-08-31 07:54 shwchg: David Emett: As far as I know, the extrinsic ED is processed before the audit is conducted. 

So, is this extrinsic formed during the audit phase and then passed on to the author of the next block?
  ↳ 2024-08-31 15:35 dave: The extrinsic ED is a result of the auditing process. If a block author has sufficient information to put something in ED then they will, otherwise they won't. Note that in normal operation ED is always empty. It will only be non-empty if some validator misbehaves.
  ↳ 2024-08-31 15:53 dave: FWIW auditing is an off-chain activity that may stretch over multiple time slots. While it is triggered by work reports becoming available, which is reported on-chain, the chain doesn't really wait for auditing to finish as such. If, as a result of the auditing process, a block author discovers that some other validator has misbehaved, then they will include this in ED. They may also build on an older block, if accumulation of some bad work reports needs to be reverted
  ↳ 2024-08-31 16:21 shwchg: https://youtu.be/Ed--83UTLPk?t=115
The lecture mentioned that disputes will slash the bad work reports before accumulation.
  ↳ 2024-08-31 16:26 dave: Yes, in the case that a bad work report was made available, it is removed before accumulation. However note that in this case the chain is being rewound; this will happen in wall time well after the work report was accumulated
  ↳ 2024-08-31 16:26 dave: The fork on which the work report was accumulated will never be finalized though, and will be discarded by validators once they see the that the work report was bad
  ↳ 2024-08-31 16:28 dave: The first block author which has enough information to determine that the work report is faulty will wind back the chain to just before accumulation, place the information in the ED extrinsic, and the bad work report will get erased
  ↳ 2024-08-31 17:26 shwchg: I get it.Thank you very much!
  ↳ 2024-08-31 18:10 dave: Nice! Glad I could help 😃
  ↳ 2024-09-03 14:23 shwchg: David Emett: Hi again, I'd like to ask you some further questions.
In ELVES, an initial small group of auditors is selected to audit the block. If all members of this group vote in favor, the block is approved. However, if someone is absent or votes against, the process either enters the dispute phase or additional auditors are selected to vote until a sufficient number of approvals are obtained.

In Jam, a work report group is selected for auditing, and each validator performs this task. 
Here, does each validator select ten others to issue announcements, or is it a single validator selecting ten?
After the announcement is made, do others who receive it also perform the corresponding audit work?

I might have many questions. If it's convenient, could you please give me a more detailed explanation? I believe there are some differences between ELVES and the audit process described in the Gray Paper, and it seems like there are many aspects in the GP that aren't clearly explained.
  ↳ 2024-09-03 14:26 dave: In each tranche, each validator makes its own decision of whether to audit the work report or not. This decision is made based on the outcome of a VRF. An announcement is made by each validator that decides it should perform an audit
  ↳ 2024-09-03 14:27 dave: As validators choose randomly whether to perform an audit or not, the number in each tranche isn't really fixed, it's an expected number
  ↳ 2024-09-03 14:28 dave: The announcements are used by other validators to determine if auditing was successful and if not how many auditors to aim for in the next tranche (the more missing auditors there are in a tranche, the more auditors there should be in the following one)
  ↳ 2024-09-03 14:30 dave: FWIW I'm not really familiar with the details of the elves paper, not sure exactly how what's in the GP differs from what is described there
  ↳ 2024-09-03 14:30 dave: The fundamental idea is the same though
  ↳ 2024-09-03 14:54 shwchg: 

I think what you said makes sense to me. So, if a validator wants to participate in the audit, they will use this function to select the initial work reports to audit and will issue announcements for these 10 work reports in tranche 0. At the same time, other validators will also be doing this.

https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMWIiLCJBdWRpdGluZyBhbmQgSnVkZ2luZyIsIlNlbGVjdGlvbiBvZiBSZXBvcnRzIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHhkYiBoYiB5ZTc2IGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeGFmIGhiIHllN2YgZmYxNiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d

In tranche 1, they will use this function to check if there are any missing or false judgments and then decide whether or not to join the audit for that work report.

https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMWMiLCJBdWRpdGluZyBhbmQgSnVkZ2luZyIsIlNlbGVjdGlvbiBvZiBSZXBvcnRzIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHgxNDYgaDIgeWVjOCBmZjFjIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4NDQgaGIgeWVjOCBmZjE2IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iXV0=


  ↳ 2024-09-03 15:24 dave: The first tranche works a bit differently to the others. _Every_ validator will select 10 cores at random to audit, these are chosen according to the first set of equations you linked. Note that this means each report will get on average 30 validators auditing it (at most one report per core per block, 3 validators per core), but there may be more or less depending on how the randomness works out
  ↳ 2024-09-03 15:27 dave: In tranches 1 and later yes the second set of equations you linked are used. The |An−1(w)∖ J⊺(w)| term is the number of missing judgements (the number of announcements without matching judgements)
  ↳ 2024-09-03 15:28 dave: These equations effectively evaluate each work report separately
  ↳ 2024-09-03 15:29 dave: Note that in the case that a negative judgement is seen, a validator should always audit the work report. So the equations only apply in the case of missing judgements
  ↳ 2024-09-03 15:33 shwchg: Nice! Thank you for answering 
2024-08-30 20:03 dave: 
2024-08-30 23:31 sourabhniyogi: https://github.com/davxy/jam-test-vectors/blob/codec-vectors/codec/data/work_package.json#L36-L45
2024-08-30 23:31 sourabhniyogi: image.png
2024-08-30 23:32 sourabhniyogi: Issue: We were expecting arbitrary length blobs in the "extrinsics" attribute of a Work Package, not (hash, length) combinations.   Section 14.3 says "In general this data will be passed to the guarantor alongside the work-package."  I guess the "alongside" doesn't mean "inside" here but then we're left wondering how these work packages could get _audited_ if only the guarantors get the extrinsics "alongside" the work package rather than inside the work package. [edited]
2024-08-31 06:56 davxy: 
2024-08-31 06:57 davxy: That doesn't seem to be what the gray paper suggests, see eq 285 (GP 0.3.6)
  ↳ 2024-08-31 08:10 sourabhniyogi: I believe the easter egg design that Gav is aiming for with JAM is:
(1) work packages with `refine` that have arbitrary length extrinsic blobs, but
(a) assurable by the MANY (2/3) \[183\] but
(b) auditable by the FEW
(2) SLIM blocks with just (hash, length) pairs sharable with ALL, validated by ALL, thus (285)

Clearly, JAM departs from the classic FAT block paradigm where all transactions/extrinsics are stored in every block (and validated by ALL), all state transitions verifiable from genesis, in favor of SLIM blocks ala (2) with as much "work" **and data** pushed out to cores ala (1).  (285) shows the FAT extrinsics are gone, but   the question is how audits can be done with the TINY onion of (183)+(184). [edited]
  ↳ 2024-08-31 08:18 sourabhniyogi: The contention on the work packages + work items on whether FAT extrinsics are kept "alongside" vs "inside" work packages is also to keep work packages SLIM like the blocks, by keeping FAT extrinsics out of work items _as well_, while also meeting assurance/auditability concerns and keeping the availability proof onion TINY.

Just a guess (since we have not reconstructed the onion yet) but its seems clear of the whole extrinsic by the FEW when audited is necessary.  The key bits doesn't have to be in the block or the work package, and maybe not in the work items either so long as it makes it into the onion.

I think the bottom line is we need to get clarity on where "extrinsic data" represented by the symbol ${\bf x}$ are 
(a) (hash, len) pairs  
vs 
(b) arbitrary length blobs 
From [my guess of] the design considerations I believe the Work Items will use (a) but we need to know where (b) is exactly.   The "alongside" imply the first guarantor erasure encode (b) and then everyone else deals with (a).  Can you confirm this? [edited]
  ↳ 2024-08-31 09:37 sourabhniyogi: It appears all of FAT extrinsics of (b) slips into $\bar{x}$ of eq 251
  ↳ 2024-08-31 09:45 sourabhniyogi: image.png
  ↳ 2024-08-31 09:45 sourabhniyogi: Is this in fact the only place?
  ↳ 2024-08-31 10:20 dave: The extrinsic data is placed into the availability system alongside the work package, so it is available to all validators. This is necessary as all validators may need to audit the work report. One possible confusion here is that "extrinsic" is used to describe both extrinsic block data (guarantees, assurances, disputes, etc) _and_ extrinsic work item blobs
  ↳ 2024-08-31 10:29 dave: The full extrinsic block data is shared amongst all validators, though only via block publication. I see now that my reply earlier saying that disputes are not broadcast is not entirely true; I meant they are not broadcast prior to block construction. They do effectively get broadcast when the block containing them gets broadcast
  ↳ 2024-08-31 10:33 dave: FWIW I'm not sure what the purpose of the extrinsic work item data is as AFAIK it is passed everywhere the work package is
  ↳ 2024-08-31 14:56 sourabhniyogi: > <@dave:parity.io> The full extrinsic block data is shared amongst all validators, though only via block publication. I see now that my reply earlier saying that disputes are not broadcast is not entirely true; I meant they are not broadcast prior to block construction. They do effectively get broadcast when the block containing them gets broadcast

Which part of GP (or JAMNP) describes this "The full extrinsic block data is shared amongst all validators"?

I believe 
(a) ${\bf x}$ are the hashes of 
(b) $\bar{x}$ 
where (b) is erasure-encoded into "Audit DA system" for a few hours, and just for auditing to reduce bandwidth/storage.  

Work items/work packages only have (a).  The availability proof (eq 183) only concerns (a) but auditors can reconstruct (b) for just a few hours.  
  ↳ 2024-08-31 15:03 dave: "To reduce bandwidth/storage" is not really accurate. The extrinsic data for a work report is made available until the report is considered audited, at which point it is no longer needed
  ↳ 2024-08-31 15:04 dave: The reason for erasure coding is so that the data can be retrieved by auditors even if the original guarantors refuse to present it upon request
  ↳ 2024-08-31 15:04 dave: In normal operation, auditors will not reconstruct via the erasure coded chunks but simply ask the guarantors for the data
  ↳ 2024-08-31 15:05 dave: Possibly in the initial version the just-ask-the-guarantors thing will not exist, as it's just an optimisation
  ↳ 2024-08-31 15:10 dave: Re which part of the GP describes this, I guess 14.4 is what you want to read
  ↳ 2024-08-31 15:15 dave: In particular the stuff talking about "availability specifiers". The bundle erasure coded for the Audit DA is Encode(p, x, i, j), where p is the package, x is the referenced extrinsic data, i is the imported data, and j the justifications for this imported data
  ↳ 2024-08-31 15:18 dave: > <@dave:parity.io> The reason for erasure coding is so that the data can be retrieved by auditors even if the original guarantors refuse to present it upon request

Sorry I guess this is not really accurate. The reason for distributing amongst all validators is this. Erasure coding rather than eg sending the full data to each validator _is_ to save bandwidth/storage
  ↳ 2024-08-31 15:31 dave: > <@sourabhniyogi:matrix.org> Which part of GP (or JAMNP) describes this "The full extrinsic block data is shared amongst all validators"?
> 
> I believe 
> (a) ${\bf x}$ are the hashes of 
> (b) $\bar{x}$ 
> where (b) is erasure-encoded into "Audit DA system" for a few hours, and just for auditing to reduce bandwidth/storage.  
> 
> Work items/work packages only have (a).  The availability proof (eq 183) only concerns (a) but auditors can reconstruct (b) for just a few hours.

FWIW the message you replied to was talking about the block extrinsic data E, though it seems this is not actually what you're interested in. Not sure if the GP says anywhere explicitly that this is shared, but it's not really possible to validate blocks etc unless it is
  ↳ 2024-08-31 16:55 sourabhniyogi: Validation of the "off-chain" refine extrinsic data is done through the auditing (which re-executes the same refine after reconstruction), which is a requirement for finalization of blocks.  Validation of blocks (which is done by all validators) does not require this auditing of the `refine` execution to be done by every validator, but just a few.    The `accumulate` execution must be done by all validators to validate a block.  We need to peel all the layers of the availability specifier to maximally appreciate the beauty/novelty of this =) [edited]
2024-08-31 16:57 sourabhniyogi:  davxy  After review we don't have an issue =)  We need a fully worked out case (in your style =)) of the Availability Specifier inputs ${\bf b}$ and ${\bf s}$, intermediate Encode(p, x, i, j), where p is the package, x is the [hash, len], i is the imported data, and j the justifications for this imported data -- culminating in a JAMP instruction for sharing (justified) DA chunks, which gav says will likely just be `Vec<Hash>` (blob subtree) ++ `Blob` ++ `Vec<Hash>` (segments subtree) ++ `Vec<SegmentChunk>` ++ `Vec<Hash>` (super-tree) and maps onto these Encoded inputs.  It is super helpful to have you choose verbose JSON attribute names both consistent with everything else and disambiguating.   Even better would be a diagram though =)
2024-09-02 10:22 rhee: kianenigma: Hey Kian, this is the first Korean_translated version of your [JAM summary blog](https://blog.kianenigma.nl/posts/tech/demystifying-jam/). I've invited a professional local technical writer + one of the research firms to deliver your contents in a correct tone & manner. Hope you like it and link to your blog article: https://research.despread.io/ko/report-jam/
  ↳ 2024-09-02 15:30 kianenigma: that's awesome, thanks for sharing! 

1. if any comments or feedback, please open a PR in the corresponding repository 
2. would it be useful if I share the original SVG files as well, so you can edit the images to your liking? 
  ↳ 2024-09-02 15:31 kianenigma: for the drawings and such. 
  ↳ 2024-09-02 15:31 kianenigma: actually they are technically already public, you just have to know where to look for them 
  ↳ 2024-09-02 15:45 kianenigma: Screenshot 2024-09-02 at 16.45.13.png
2024-09-04 07:54 vinsystems: Where do you guys define the PVM's ram memory: in the stack or in the heap? The max ram size of a 32bit proccessor is 4GB, so defining it in the stack may be better in terms of performance, but will also consume a lot of system resources.  [edited]
2024-09-04 08:12 vinsystems: Where do you guys have define the PVM's ram memory: in the stack or in the heap? The max ram size of a 32bit proccessor is 4GB, so defining it in the stack may be better in terms of performance but will also consume a lot of system resources. 
2024-09-04 08:16 dakkk: > <@vinsystems:matrix.org> Where do you guys have define the PVM's ram memory: in the stack or in the heap? The max ram size of a 32bit proccessor is 4GB, so defining it in the stack may be better in terms of performance but will also consume a lot of system resources.

I'm currently using the heap
2024-09-04 08:16 jan: 1. Competently implemented there is no performance difference.
2. No one sane ever puts something as big as 4GB on the stack, nevermind that by default it's not even possible since every OS has a strict stack limit that is at most a few megabytes (it can be increased, but the idea of putting a 4GB value on the stack is so insane that I don't even know if you can increase it that much, as no on ever does this). [edited]
2024-09-09 07:09 gav: > <@sourabhniyogi:matrix.org> Issue: We were expecting arbitrary length blobs in the "extrinsics" attribute of a Work Package, not (hash, length) combinations.   Section 14.3 says "In general this data will be passed to the guarantor alongside the work-package."  I guess the "alongside" doesn't mean "inside" here but then we're left wondering how these work packages could get _audited_ if only the guarantors get the extrinsics "alongside" the work package rather than inside the work package.

A Work Package contains only (hash, length) pairs to define extrinsic data. Guarantors may disregard a Work Package if they have been failed to be furnished with the correct preimages (it's up to the submitter to give them the real extrinsic data in addition to the WP).
2024-09-09 07:10 gav: As for auditors, extrinsic data is contained in the Work Package Bundle, which is made available.
2024-09-09 12:25 davxy: Could I kindly request concise feedback from the various teams regarding this PR: https://github.com/w3f/jamtestvectors/pull/12? If you encounter any issues, please report them directly in the PR.
2024-09-09 12:26 davxy: Please give a thumbs up if you process it correctly, and a thumbs down if you encounter any issues.
2024-09-09 13:05 emielvanderhoek: 
2024-09-09 13:09 emielvanderhoek: Added a comment in the Safrole PR for one more Safrole testvector. 
2024-09-11 08:50 luke_f: 
2024-09-11 08:55 luke_f: Screenshot from 2024-09-11 15-50-26.png
2024-09-11 08:55 luke_f: davxy: question for you sir:
I have a problem with decoding "blank" public key into an AffinePoint when creating epoch root  / ringCommitment

in the attached image, we see that we create a new epoch root with possibly some "blank" public bandersnatch keys

when i try to decode these into an AffinePoint using `point_decode`  https://github.com/davxy/ark-ec-vrfs/blob/main/src/codec.rs
the decoding fails
could you suggest please how to handle these [edited]
2024-09-11 09:15 gav: > <@luke_f:matrix.org> davxy: question for you sir:
> I have a problem with decoding "blank" public key into an AffinePoint when creating epoch root  / ringCommitment
> 
> in the attached image, we see that we create a new epoch root with possibly some "blank" public bandersnatch keys
> 
> when i try to decode these into an AffinePoint using `point_decode`  https://github.com/davxy/ark-ec-vrfs/blob/main/src/codec.rs
> the decoding fails
> could you suggest please how to handle these

Don't decode them.
2024-09-11 09:15 gav: https://www.goodreads.com/quotes/7570350-the-patient-says-doctor-it-hurts-when-i-do-this
2024-09-11 09:19 luke_f: right, but then the size of the ring would change.
by your answer i gather that's ok


edit:
what i mean is, if I'm not decoding them back to a point, then i understand i just filter these keys out when creating a new epoch root, but the GP does not  mention any filtering action here, 
so I'm not sure how to procceed
 [edited]
2024-09-11 09:26 gav: From the GP perspective, there is no filtering action.
2024-09-11 09:26 gav: However, said filtering should be defined within the Bandersnatch appendix. I introduced a note [Bandersnatch: Ignore bad keys](https://github.com/gavofyork/graypaper/pull/77/commits/f1c867f163b326d21a7654f0cb7898754f1750f4)
2024-09-11 09:27 gav: In general bad keys should just be noops (in the case of adding to a ring) or fail (in the case of signature verification). The GP doesn't care about specific representations of the key. From its perspective keys are just opaque 32-byte blobs. It's only within the Bandersnatch def that we attempt to make sense of the blob, and thus it is there where the meaning of "bad" keys is defined. [edited]
2024-09-11 09:28 gav: (This is not limited to the nullifier key either: we don't prevent validators from uploading bad keys.) [edited]
2024-09-11 09:30 luke_f: understood. Thank you gav 
2024-09-11 10:25 davxy: luke_f: Your question reminded me of an interesting missing case in the test vectors, which I had noted earlier here: https://github.com/w3f/jamtestvectors/pull/8#issuecomment-2275460028.
Thank you for the reminder! I will proceed with adding it. :-)
2024-09-11 10:26 luke_f: > <@davxy:matrix.org> luke_f: Your question reminded me of an interesting missing case in the test vectors, which I had noted earlier here: https://github.com/w3f/jamtestvectors/pull/8#issuecomment-2275460028.
> Thank you for the reminder! I will proceed with adding it. :-)

my pleasure :)
2024-09-12 03:01 gav: > <@gav:polkadot.io> However, said filtering should be defined within the Bandersnatch appendix. I introduced a note [Bandersnatch: Ignore bad keys](https://github.com/gavofyork/graypaper/pull/77/commits/f1c867f163b326d21a7654f0cb7898754f1750f4)

Note: After davxy's comment, the GP appendix was updated to state that when building the ring, do *not* skip but instead use the Bandersnatch padding point for any keys with no point of their own.
2024-09-12 13:17 prematurata: question about the host call definition. Appendix A.6. it looks like that the invocation shouldreturn `x'` when a page fault happen when callling `f` but `x'` is not defined anywhere so i guess it's just a typo and instead of `x'` we want `x`... is this assumption correct?


Also I have a couple of questions about gammax (green underline). 

- my understanding is that since it should be a type any of the Accumulate functions can be expected there. is it correct?
- also not sure its intended but there are 2 gamma x definitions. one in accumulate and one in general functions 

2024-09-12 13:17 prematurata: image.png
2024-09-12 15:07 jimboj21:  Hey davxy I saw in the codec PR that you are keeping tabs on teams that are able to process the codec test vectors, so wanted to say we (Gossamer team) are able to fully process them 👍️ Thanks for the work getting us the vectors!
2024-09-12 15:18 prematurata: I also think the `B.2` is-authorized invocation `ΨI` has something strange.

- `ΨM` is being called with 1st param `p_c`
- `p` is of type workpackage ( `P` )
- `_c` is codehash
- `ΨM` first param is a member of `Y`or generic blob but that is being used for `Y()` fn in `239`
- `239` implies that if all the statements cannot be satisfied, then basically `Y()` output is "empty/nil"
- this means that since the `ΨI` always passess a code hash then `ΨM` is always returning `panic` due to `246` [edited]
2024-09-12 15:46 gav: here it is p_c where the c is bold and not italic, thereby referring to the code preimage not the hash. 
2024-09-12 15:50 gav: > <@prematurata:matrix.org> question about the host call definition. Appendix A.6. it looks like that the invocation shouldreturn `x'` when a page fault happen when callling `f` but `x'` is not defined anywhere so i guess it's just a typo and instead of `x'` we want `x`... is this assumption correct?
> 
> 
> Also I have a couple of questions about gammax (green underline). 
> 
> - my understanding is that since it should be a type any of the Accumulate functions can be expected there. is it correct?
> - also not sure its intended but there are 2 gamma x definitions. one in accumulate and one in general functions 
> 

Yes that should be x not x’. Will be fixed in next release. 
2024-09-12 15:52 gav: [@prematurata:matrix.org](https://matrix.to/#/@prematurata:matrix.org)this stuff is OT in here. In future please use the gray paper channel.  [edited]
2024-09-13 04:13 gav: > <@prematurata:matrix.org> question about the host call definition. Appendix A.6. it looks like that the invocation shouldreturn `x'` when a page fault happen when callling `f` but `x'` is not defined anywhere so i guess it's just a typo and instead of `x'` we want `x`... is this assumption correct?
> 
> 
> Also I have a couple of questions about gammax (green underline). 
> 
> - my understanding is that since it should be a type any of the Accumulate functions can be expected there. is it correct?
> - also not sure its intended but there are 2 gamma x definitions. one in accumulate and one in general functions

prematurata: please explain what you mean by "gamma x".
2024-09-13 07:54 prematurata: > <@gav:polkadot.io> prematurata: please explain what you mean by "gamma x".

 sorry I meant omega
2024-09-13 08:12 gav: > <@prematurata:matrix.org> sorry I meant omega

Fixed in https://github.com/gavofyork/graypaper/pull/77/commits/b1f172bdf98a52b12cebd9d5064b22230730b5d9
2024-09-13 08:13 prematurata: > <@gav:polkadot.io> Fixed in https://github.com/gavofyork/graypaper/pull/77/commits/b1f172bdf98a52b12cebd9d5064b22230730b5d9

movin discussion in graypaper chan
2024-09-13 10:41 bmaas: > <@davxy:matrix.org> Please give a thumbs up if you process it correctly, and a thumbs down if you encounter any issues.

https://github.com/w3f/jamtestvectors/pull/12#issuecomment-2348625189 I have a question here davxy 
2024-09-13 11:59 davxy: I reviewed your comments. The reasons are design decisions, so you should eventually raise your concerns in the graypaper. In any case, IMHO, it is better to maintain a uniform design for u16/u32 encoding in the protocol rather than saving 1 byte here and there by introducing pitfalls related to variable-length encoding.
2024-09-13 12:10 davxy: Side note for slot number. Even though the test vectors are using small slot numbers, in production the slot count begins with the "JAM common era" (1 Jan 2024 = 1704110400). As of today, you would already have a slot = (1726229014 - 1704110400) / 6 = 3686435 = 0x384023 (3 bytes). [edited]
2024-09-13 12:15 bmaas: image.png
2024-09-13 12:24 bmaas: Thanks for the prompt reply davxy . I'm not suggesting saving everything in just one byte. When I study the formula—272—I expect that the length of the encoding should be derivable from the l-value. Thus in the example `header-0.json` case, `l` would be 0, and thus following the formula it would produce 0 extra octets. For this reason I was not expecting the extra 3 bytes. 

2024-09-13 12:29 bmaas: > <@davxy:matrix.org> Side note for slot number. Even though the test vectors are using small slot numbers, in production the slot count begins with the "JAM common era" (1 Jan 2024 = 1704110400). As of today, you would already have a slot = (1726229014 - 1704110400) / 6 = 3686435 = 0x384023 (3 bytes).

I believe I found the misunderstanding, 272 , there is a note: at present utilized only in encoding the length prefix of variable-length sequences.
2024-09-13 12:41 davxy: Screenshot from 2024-09-13 14-41-11.png
2024-09-13 12:42 davxy: Also H_t is explicitly encoded as E_4 , so you need to refer to the formula for fixed length integers (just above the one you're looking at)
2024-09-16 07:53 xlchen: gav: there are many open PR here https://github.com/w3f/jamtestvectors/pulls can we have the ready one merged? i.e. #2 and #12
2024-09-18 01:12 gav: Merged
2024-09-18 08:13 stephenta: Hi Gavin and fellowship,

Our team has an interest in working on JAM implementation. Can I ask a question is there any criteria of a success deliverable milestone?
  ↳ 2024-09-18 08:15 jan: Have you read https://jam.web3.foundation ?
  ↳ 2024-09-18 08:15 xlchen: https://hackmd.io/@polkadot/jamprize
  ↳ 2024-09-18 08:27 stephenta: > <@xlchen:matrix.org> https://hackmd.io/@polkadot/jamprize

Thank you Bryan! It's much helpful🙏
2024-09-19 08:41 luke_f: davxy: apologies in advance for the kinda silly question:
is there ANY CHANCE that the order of gamma_s in tiny/enact-epoch-change-with-no-tickets-4.json is wrong?

asking because I'm getting different order 😅
  ↳ 2024-09-19 10:23 celadari: Has there been a merge ? Last time we checked we had the same order. Did you check that your language is working on untyped bytes ? Otherwise you might get surprises [edited]
  ↳ 2024-09-27 10:48 luke_f: celadarithanks, we figured it out. it was(of course) a bug on our end
2024-09-20 03:11 xlchen: Some question about Safrole ticket submission. https://hackmd.io/@polkadot/jamsnp
To confirm my understanding first:

- On each epoch, every next epoch validator (`γk`) can submit to up two tickets
- Block authors are incentivized to include up to 16 tickets in extrinsic
- Potential block authors should maintain an tickets pool and include top tickets when authoring new blocks
- Tickets are not gossiped. So every next epoch validators should submit their two tickets to every current epoch validators.
- Next epoch validators shouldn't need to resubmit their tickets or it could be counted as spam?
- So current validators should persist the pending tickets pool across restarts
- In order to make it possible for the first block of an epoch to include full 16 tickets, next next epoch validators (`ι`) should start generating and submit tickets before they become `γk`. The ring commitment will depends on `ψo` but it is unlikely for it to change at and of an epoch as we are not expecting punishments in more than 99.9% of the time.
- So validators should be expected to receive tickets for both current and next ring commitment

And my questions:
As JAMSNP currently defined, ticket submission seems like is only for 1 ticket only? But validator are almost always want to send two tickets. So better to make it to expect two tickets
What exactly does the success / bad mean? Ack the data is received or expecting the receiver to validate the data? i.e. verify it is a valid ticket and not a duplicated etc. I will image it will be just ack but need to confirm.
What is the expected optimal behaviour of ticket submission? Every next next epoch validators (`ι`)  submit tickets at and of an epoch and resubmits at start of an epoch in case the expected ring commitment changed?
So validators are expected to receive tickets for two different epoch. In that case, should the ticket submission protocol to include an epoch index to keep things simpler? Otherwise the receiver may need to verify the tickets twice to figure out if it is valid or not. [edited]
2024-09-20 07:53 gav: > <@xlchen:matrix.org> Some question about Safrole ticket submission. https://hackmd.io/@polkadot/jamsnp
> To confirm my understanding first:
> 
> - On each epoch, every next epoch validator (`γk`) can submit to up two tickets
> - Block authors are incentivized to include up to 16 tickets in extrinsic
> - Potential block authors should maintain an tickets pool and include top tickets when authoring new blocks
> - Tickets are not gossiped. So every next epoch validators should submit their two tickets to every current epoch validators.
> - Next epoch validators shouldn't need to resubmit their tickets or it could be counted as spam?
> - So current validators should persist the pending tickets pool across restarts
> - In order to make it possible for the first block of an epoch to include full 16 tickets, next next epoch validators (`ι`) should start generating and submit tickets before they become `γk`. The ring commitment will depends on `ψo` but it is unlikely for it to change at and of an epoch as we are not expecting punishments in more than 99.9% of the time.
> - So validators should be expected to receive tickets for both current and next ring commitment
> 
> And my questions:
> As JAMSNP currently defined, ticket submission seems like is only for 1 ticket only? But validator are almost always want to send two tickets. So better to make it to expect two tickets
> What exactly does the success / bad mean? Ack the data is received or expecting the receiver to validate the data? i.e. verify it is a valid ticket and not a duplicated etc. I will image it will be just ack but need to confirm.
> What is the expected optimal behaviour of ticket submission? Every next next epoch validators (`ι`)  submit tickets at and of an epoch and resubmits at start of an epoch in case the expected ring commitment changed?
> So validators are expected to receive tickets for two different epoch. In that case, should the ticket submission protocol to include an epoch index to keep things simpler? Otherwise the receiver may need to verify the tickets twice to figure out if it is valid or not.

davxy: ^^
2024-09-20 08:26 dave: I've got some pending changes to JAMSNP. For Safrole ticket submission I currently have this...

### CE 128/129: Safrole ticket submission

Sharing of a Safrole ticket for inclusion in a block.

Safrole tickets are distributed in the epoch prior to the one in which they are to be used. They
are distributed in two steps. Each ticket is first sent from the generating validator to a
deterministically-selected "proxy" validator. This proxy validator then sends the ticket to _all_
current validators.

The first step should be performed shortly after the connectivity changes for a new epoch are
applied. The index of the proxy validator for a ticket is determined by interpreting the last 4
bytes of the ticket's VRF output as a big-endian unsigned integer, modulo the number of validators
minus 1. The proxy validator is selected from the next epoch's validator list, excluding the
generating validator.

Proxy validators should verify the signature of any ticket they receive, and verify that they are
the correct proxy for the ticket. If these checks succeed, they should forward the ticket to all
current validators. Forwarding should be delayed until a fixed point in the epoch (eg 3 minutes
in), to avoid exposing the timing of the initial message. Forwarding should be spaced out over the
first half of the Safrole lottery period. Forwarding may be stopped if the ticket is included in a
block.

Protocol 128 is used for the first step (generating validator to proxy validator), protocol 129 is
used for the second step (proxy validator to all current validators).

```
Attempt = { 0, 1 }
Ticket = Attempt ++ Signature

Validator -> Validator

--> Ticket
--> FIN
<-- FIN
```

2024-09-20 08:32 xlchen: when does the connectivity change applies? it must happen before the new epoch starts right?
2024-09-20 08:32 dave: > As JAMSNP currently defined, ticket submission seems like is only for 1 ticket only? But
> validator are almost always want to send two tickets. So better to make it to expect two tickets

Might be changed in the full protocol but for simplicity we decided to stick with a single ticket for JAMSNP.

> What exactly does the success / bad mean? Ack the data is received or expecting the receiver to validate the data? i.e. verify it is a valid ticket and not a duplicated etc. I will image it will be just ack but need to confirm.

I've taken out success/bad. Failure should be indicated by resetting/stopping the stream. I think
for Safrole you can finish (= succeed) as soon as you have received the data, ie just ack.

> What is the expected optimal behaviour of ticket submission? Every next next epoch validators (ι)
> submit tickets at and of an epoch and resubmits at start of an epoch in case the expected ring
> commitment changed?

I think this is described now.

> So validators are expected to receive tickets for two different epoch. In that case, should the
> ticket submission protocol to include an epoch index to keep things simpler? Otherwise the
> receiver may need to verify the tickets twice to figure out if it is valid or not.

Validators should only expect tickets for the next epoch.

2024-09-20 08:33 dave: > <@xlchen:matrix.org> when does the connectivity change applies? it must happen before the new epoch starts right?

No. I currently have this defined as follows...

### Epoch transitions

At the beginning of a new epoch, validators should wait to apply connectivity changes until both:

- The first block in the epoch has been finalized.
- At least 2 minutes have elapsed since the beginning of the epoch.

This rule is intended to synchronize connectivity changes across validators, making epoch
transitions smoother.

2024-09-20 08:34 dave: FWIW this is still all subject to change...
2024-09-20 08:39 xlchen: i see. I will assume all tickets are for current epoch
2024-09-20 08:41 dave: To be included in current epoch blocks, yeah. I don't think you should get tickets for other epochs unless a node is really confused 😅
2024-09-20 09:12 davxy: > <@luke_f:matrix.org> davxy: apologies in advance for the kinda silly question:
> is there ANY CHANCE that the order of gamma_s in tiny/enact-epoch-change-with-no-tickets-4.json is wrong?
> 
> asking because I'm getting different order 😅

[@luke_f:matrix.org](https://matrix.to/#/@luke_f:matrix.org) I'll take a look. I'll be afk until tomorrow 😅


2024-09-20 12:56 danicuki: I am organizing a JAM meetup in Lisbon on Oct 21th right after ETH Lisbon. The meetup will be at Parity's office and everyone is invited to join. 

https://lu.ma/fqg0ktn0

We are looking for sponsors for foods and drinks. DM me if you are interested 

  ↳ 2024-09-20 12:58 rtti-5220: danicuki: for sponsoring, have you checked the events bounty? All the info you might need: 

https://x.com/dotevents_/status/1806020324678349038
  ↳ 2024-09-23 19:27 bmaas: Not sure I am going yet, if so I will let you know danicuki 

2024-09-21 02:54 gav: > <@danicuki:matrix.org> I am organizing a JAM meetup in Lisbon on Oct 21th right after ETH Lisbon. The meetup will be at Parity's office and everyone is invited to join. 
> 
> https://lu.ma/fqg0ktn0
> 
> We are looking for sponsors for foods and drinks. DM me if you are interested 
> 

I’ll probably stop by. 
2024-09-23 22:11 celadari: Regarding ticket submission for Safrole, would it make sense to adopt an onion routing approach? Not for initial release but for latter. Each ticket could be sent through 3 different routes, with 3 proxies per route. The message would be encrypted for each proxy along the way, and only the final proxy decrypts the ticket without knowing the original sender.

We can deterministically choose the routes using VRF output for different inputs and require a ring root signature for validation.
  ↳ 2024-09-23 22:11 celadari: Regarding the last part to be a bit more specific:
  ↳ 2024-09-23 22:11 celadari: idea_routing_anonymous.png
2024-09-23 22:49 gav: This is indeed the plan. Perhaps davxy wants to comment further.
2024-09-24 09:59 davxy: The idea has been considered and maybe, in some variant, will become part of the final protocol for ticket submission. Initially, however, the protocol described by David Emett  (JAMSNP CE 128/129) will be adopted, where the ticket is submitted via a proxy whose identity is pseudo-randomly determined by the ticket ID. This means that anyone can infer the proxy responsible for a given ticket T (i.e., the proxy is f(T) and he knows who is the ticket creator).

In the upcoming weeks, various possibilities will certainly be discussed. However, it is important to understand whether the existence of this "public" actor (aka proxy) who knows the identity of the ticket author is required, for instance, to efficiently submit information directly to the next block author directly via the proxy. Honestly this point is not 100% clear to me yet.

If the presence of a public proxy to the ticket author is indeed required, the relevance of onion routing becomes a bit less relevant. Although it may still useful for some other aspects, such make traffic analysis more complicated. Proxy can still exist even with onion routing, e.g. by disclosing ticket's author identity only to the exit node and reusing the idea of CE 128 for deterministic proxy in function of T.

I would be happy to hear more ideas in this area, indeed!
  ↳ 2024-09-24 10:18 celadari: I'm not sure to see why the public actor is required but I'm curious to learn more about it.
Let us know when discussions about it start 🙌
2024-09-24 15:14 danicuki: > <@danicuki:matrix.org> I am organizing a JAM meetup in Lisbon on Oct 21th right after ETH Lisbon. The meetup will be at Parity's office and everyone is invited to join. 
> 
> https://lu.ma/fqg0ktn0
> 
> We are looking for sponsors for foods and drinks. DM me if you are interested

I am preparing the agenda for the JAM meetup Oct 21st. If anyone has a proposal for lightning talk / panel, workshop or whatever, DM me.
2024-09-24 17:42 davxy: I have updated the outstanding test vectors PRs (safrole, history, disputes) to include vectors encoded using the new compact integer codec as prescribed by the GP.

- The vectors using the new codec have the extension *.bin. The old *.scale files are temporarily maintained in case anyone is still working with the old codec. These will be removed in the near future.
- Safrole vectors have also been updated in content. The ring-proof backend introduced some internal changes which invalidate the old signatures (and tickets). If you are using `ark-ec-vrfs`, please update to the latest revision, as ticket verification will fail otherwise.
- `ark-ec-vrfs` now provides a function to retrieve the padding point to be used to replace invalid keys when computing the ring commitment (https://github.com/davxy/ark-ec-vrfs/blob/e491b41b48d9132f59ff2a4d4f1c6c3e853deab7/src/ring.rs#L212) [edited]
2024-09-24 18:26 darentuzi: Hi, two questions about preimage lookups for service accounts:
1. Is all the raw data, meaning preimage data itself stored in the preimage dictionary, or can it reference external storage?
2. Is the preimage data being deleted when unrequested, and if not, when requested again, is it available within the service or needs to be supplied from an external source?
2024-09-24 20:16 danicuki: 
2024-09-24 20:16 danicuki: 
2024-09-24 20:17 danicuki: 
2024-09-25 03:11 xlchen: I am trying to figure out what is the best way to know if I am the block author of the next block and it seems a bit tricky for the first block on an epoch. `γs'` determines the block authors and it is only updated at the first block on an epoch. That means for validators to check if they are the block author, they need to figure out `γs'` first and then check for it.
2024-09-25 03:29 xlchen: What I really want is at begin of an epoch, check `γs`, and then I know exactly when I need to spawn the block producing task in this epoch. However this won't work for the edge case.
  ↳ 2024-09-25 06:08 celadari: At the begin of a new block the ticket submission period should be over for I think 100 time slots so you should have an updated gamma_s by then I would say. Unless your node has been malfunctioning and two epochs have passed.
Can someone correct me on this one ?
  ↳ 2024-09-25 06:08 xlchen: yes but that's the happy path
  ↳ 2024-09-25 06:18 celadari: Can you elaborate on the unhappy case ? Fallback mode or divergence with grandpa to solve
  ↳ 2024-09-25 06:21 xlchen: fallback mode, punishments, and maybe forks
  ↳ 2024-09-25 06:53 celadari: - Fallback mode you should know as well gamma_s because there is a 100 timeslots delay between end of ticket submission and next epoch

- forks are handled with using grandpa. Safrole should make the forks only for one epoch when they happen. Grandpa with most normal tickets should be used

- punishment: I don't know yet
  ↳ 2024-09-25 06:58 xlchen: in very extreme case, the end phase could be completely skipped
  ↳ 2024-09-25 07:49 celadari: I think if that happens then you should update gamma_s according to what you had before the skipped end phase: can be normal or fallback mode
  ↳ 2024-09-25 07:58 xlchen: what I don't want to do is figure out every single edge case and handle them with different code
  ↳ 2024-09-25 08:02 celadari: I don't think you need to do this.
I think you need to update gamma_s accordingly after end ticket submission as soon as possible: best is before new epoch but if as you said the whole end phase is skipped then you do it before "taking in" the new block you receive

Does it make sense ?
  ↳ 2024-09-25 08:14 xlchen: I don't 100% get it but I ended up wait until last timeslot of an epoch and simulate safrole STF for next block
2024-09-25 06:09 gav: 1. Data available for lookup is always stored in the service account state. 
2. Whether and when it is deleted from service account state is determined according to the relevant logic described in the host function `forget`. Once deleted from state it must be resupplied to the chain if a fresh request arrives.  [edited]
  ↳ 2024-09-25 06:12 darentuzi: Are there risks of bloat, or are there limitations to how much data can be put there?
  ↳ 2024-09-25 06:16 darentuzi: Thinking about an underlying storage layer for larger amounts of data and the source for resupplying  [edited]
  ↳ 2024-09-25 06:57 gav: As you can see if you read the GP, the amount of data a service is able to store for lookup in state is constrained by its account balance. See specifically (94): https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMTEiLCJTZXJ2aWNlIEFjY291bnRzIiwiQWNjb3VudCBGb290cHJpbnQgYW5kIFRocmVzaG9sZCBCYWxhbmNlIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHgxMiBoNiB5NzlhIGZmNyBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeGYxIGhkIHk3YzcgZmYxOCBmczUgZmMwIHNjMCBsczAgd3MwXCI+Il1d
  ↳ 2024-09-25 06:59 gav: Lookup can be helpful for data which is regularly needed by Refine as fairly large amounts of data can be stored and retrieving it is almost free. Parachain code is the obvious use-case here.
  ↳ 2024-09-25 07:01 gav: However, it is expensive (for the reason you mention: on-chain bloat must be controlled). For use-cases where data can change often or is not used very regularly in Refine, keeping it in the DA system may be better.
  ↳ 2024-09-25 07:21 darentuzi: thank you
2024-09-25 07:39 bamzedev: 
2024-09-26 17:03 danicuki: We have a question about the JAM prize payment. Rule 20:

```
Prizes are paid to the earliest Polkadot /
 Kusama account IDs stated in the
 repository's README. In the case of a tie,
 payment is split equally. Local (Swiss) law
 requires that Web3.0 Foundation take
 KYC/AML information on the recipient
 together with proof of account control.
```

What if the prize will be divided between individuals? Even if these individuals create a multisign wallet, the wallet itself does not belong to any specific entity (individual or company). Who should KYC? All multisign signers? Do individuals need to create an entity that "owns" the multisign wallet? [edited]
2024-09-26 17:09 tomusdrw: > <@danicuki:matrix.org> We have a question about the JAM prize payment. Rule 20:
> 
> ```
> Prizes are paid to the earliest Polkadot /
>  Kusama account IDs stated in the
>  repository's README. In the case of a tie,
>  payment is split equally. Local (Swiss) law
>  requires that Web3.0 Foundation take
>  KYC/AML information on the recipient
>  together with proof of account control.
> ```
> 
> What if the prize will be divided between individuals? Even if these individuals create a multisign wallet, the wallet itself does not belong to any specific entity (individual or company). Who should KYC? All multisign signers? Do individuals need to create an entity that "owns" the multisign wallet?

Curious as well. Note that the tokens are also vested so it needs to be not a one-off distribution between multisig members, but rather a 24-months+ active collective
2024-09-26 22:55 gav: > <@danicuki:matrix.org> We have a question about the JAM prize payment. Rule 20:
> 
> ```
> Prizes are paid to the earliest Polkadot /
>  Kusama account IDs stated in the
>  repository's README. In the case of a tie,
>  payment is split equally. Local (Swiss) law
>  requires that Web3.0 Foundation take
>  KYC/AML information on the recipient
>  together with proof of account control.
> ```
> 
> What if the prize will be divided between individuals? Even if these individuals create a multisign wallet, the wallet itself does not belong to any specific entity (individual or company). Who should KYC? All multisign signers? Do individuals need to create an entity that "owns" the multisign wallet?

More of a question for W3F financial. In principle it is a prize, nothing more. W3F will do what it can to make things smooth but don’t *expect* anything more  than one payment to an account or entity nominated by that person or persons who prove(s) ownership/control/knowledge of codebase. 
2024-09-26 22:55 gav: IANAL but I’d expect KYC would be on those persons which the W3F could reasonably know or suspect are in receipt of funds. 
2024-09-28 19:09 danicuki: In Formula 139: on part (kv)E, shouldn't this "E" be lowercase as defined in formula 54? 
2024-09-28 19:10 danicuki: 
2024-09-29 09:19 gav: In fact the other way around. E was meant to be upper case. Feel free to make an issue in the repo.  [edited]
2024-09-29 11:28 danicuki: > <@gav:polkadot.io> In fact the other way around. E was meant to be upper case. Feel free to make an issue in the repo.

Do you mean e should be uppercased here: https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiZCIsIkJsb2NrIFByb2R1Y3Rpb24gYW5kIENoYWluIEdyb3d0aCIsIktleSBSb3RhdGlvbiIsWyI8ZGl2IGNsYXNzPVwidCBtMCB4ZmUgaGMgeTRlOCBmZjE1IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4NzEgaGQgeTRlOSBmZjE3IGZzNSBmYzAgc2MwIGxzMCB3czBcIj4iXV0= ?
2024-09-29 11:38 gav: Yes
2024-10-07 03:10 xlchen: A question about timing. Say current time t = 60, timeslot = 10, for block author of timeslot 11, when should it start producing block? what time is the deadline? say we provide 2s for block production (what is the max time allowed for block production?), then the block author should start producing block at t = 66 and sending blocks at t = 68? other validators should receive block by t = 70 and have it confirmed before t = 72?

How about guaranteeing? For guarantors of cores at timeslot 11, what time should it start producing work report and what's the deadline of sending it out? Does it need to make sure the work report is available at t = 66 so the block author can accumulate it in block #11? So it should start the work at t = 60?
2024-10-07 06:57 gav: A block of time slot t = 10 becomes valid once the clock reads 60. On this basis, an optimal block author for t=10 will have sent the block to arrive at all other validator nodes by then. Validators should then have distributed all relevant extrinsic information for this block to arrive in time for the author to include it in a block and then send the necessary block information back to them (we’re working on merklising the extrinsic commitment so that not the whole block needs to be distributed if the receiver has the various extrinsic components). We’re still working on having specific timing guidelines as this will be affected by practical matters ; indeed ideal timing probably won’t be properly fixed until we have the toaster running.  [edited]
2024-10-07 06:57 gav: [@dave:parity.io](https://matrix.to/#/@dave:parity.io) might be able to shed a bit more light. 
2024-10-07 07:09 xlchen: I see. I will put some placeholder values for now. 
2024-10-07 07:52 dave: FWIW, at the moment, our node starts authoring at the start of its timeslot. Guaranteeing is fairly flexible as a block author can include reports from both the current and previous core rotations. I expect guarantor timing will be mostly down to builders as, unless guarantors are already busy with previous packages, there seems little point in waiting to refine a package. As Gav says though I don't think we will have a good idea of when things should be scheduled until we have a test network running, so I would just make sure any values are easy to change.
2024-10-07 08:13 voliva: Hi everyone!

I wanted to share that after reading about decentralized JAM, Whitespace caught my curiosity. So, during my spare time, I decided to give it a try and implemented Keccak-256 in Whitespace. The code is available here under GPLv3: https://github.com/voliva/wsa/blob/main/examples/keccak.ws. It's an initial version, and it may have a few bugs, but for the few words I've tried, it hashes them correctly.

To facilitate this, I've also built a Whitespace assembler/interpreter/debugger, which helped me work on it. It’s released under the MIT license here: https://github.com/voliva/wsa. Additionally, I've developed a memory layout convention and a "standard library" to make it a bit more practical.

I thought I'd share this in case someone finds it interesting. I don't think I'll be building JAM (probably not even the first milestone) in Whitespace, as I really don't have time for it, but I find it fun to solve small objectives in esoteric languages like these.
  ↳ 2024-10-07 08:14 voliva: image-2.png
2024-10-07 10:16 gav: > <@voliva:matrix.org> Hi everyone!
> 
> I wanted to share that after reading about decentralized JAM, Whitespace caught my curiosity. So, during my spare time, I decided to give it a try and implemented Keccak-256 in Whitespace. The code is available here under GPLv3: https://github.com/voliva/wsa/blob/main/examples/keccak.ws. It's an initial version, and it may have a few bugs, but for the few words I've tried, it hashes them correctly.
> 
> To facilitate this, I've also built a Whitespace assembler/interpreter/debugger, which helped me work on it. It’s released under the MIT license here: https://github.com/voliva/wsa. Additionally, I've developed a memory layout convention and a "standard library" to make it a bit more practical.
> 
> I thought I'd share this in case someone finds it interesting. I don't think I'll be building JAM (probably not even the first milestone) in Whitespace, as I really don't have time for it, but I find it fun to solve small objectives in esoteric languages like these.

awesome :) what's the next thing to implement?
  ↳ 2024-10-07 11:01 voliva: I have to read the JAM graypaper again to find achievable goals, maybe ed25519 it would be one of the hard ones, but there could be other easier parts.
Another challenge I'm interested to solve is how to do other IO like network requests, as stdin/stdout is a bit limited 😬
  ↳ 2024-10-07 11:25 gav: fwiw, for M1 you only need block import logic so network wouldn't actually be a requirement 
2024-10-07 19:54 danicuki: Does anybody have the vectorized version of the JAM logo combined with the Polkadot - I found only this one: https://github.com/w3f-webops/graypaper-website/blob/main/src/images/faviconjam.svg ? gav  [edited]
2024-10-07 20:05 gav: There’s no vectorized logo - it’s a slightly processed photo of my handwriting on paper. 
2024-10-07 20:05 gav: I can dig out the png though. 
2024-10-07 20:09 tebdev: I plan to use Keccak-256 and other algo from a Crypto Library. Is that allowed?
  ↳ 2024-10-07 21:58 xlchen: yes https://hackmd.io/@polkadot/jamprize
  ↳ 2024-10-07 23:13 tebdev: > <@xlchen:matrix.org> yes https://hackmd.io/@polkadot/jamprize

Thank you for reminding me of the rules reference. Sorry
2024-10-08 00:01 xlchen: Anyone have started implement some RPC? What will be the best way for us to collaborate it so we all implements a same set of RPC methods?
2024-10-08 00:04 xlchen: There are few key decisions I would like to confirm with everyone before I invest too much time on our RPC implementation :

- Which RPC protocol?
  - JSONRPC
  - gRPC
  - Restful
  - something else?
- How high level should the RPC be?
  - e.g. like Substrate, the RPC provide metadata and raw data and it is up to the SDK to decode the data
    - we don't need metadata here as the types are all spec'ed in GP
  - or make it more complicated but dev friendly by returning typed data directly (e.g. JSON)
2024-10-08 00:09 xlchen: And once we have some RPC implemented, I plan to build some simple TUI/webapp (TDB). Something like substrate telemetry
2024-10-08 01:28 tebdev: Sounds good. I am flexible. You have my proxy since you taking the lead.
2024-10-08 05:01 xlchen: I think we will go for JSONRPC + HTTP. i.e. something similar to Substrate for the reasons:

- Target users are only JAM devs and network operators. Note: dapp devs, service providers (e.g. CEX), wallets are NOT target users. They should not deal with JAM chain directly. Therefore most of the downsides of the existing Substrate JSONRPC doesn't apply (e.g. requires heavy SDK to decode data returned from JSONRPC). Block explorer / Indexer may have some interests on fetching JAM chain data but it is still only for devs only. No user should worry about JAM chain data.
- Most if not all JAM devs will already be familiar with JSONRPC.
- JSONRPC with WebSocket supports pushing, which is a very useful feature. RESTful is out of option then. We could do RESTful + WebSocket but then it will be extra work for benefits not super relevant. This RPC does not need to be easy to use.
- JSONRPC is not efficient. But under the context of JAM chain, that's something we can deal with. We may want to have some HTTP methods for methods that needs to return large binary payload to avoid the overhead of hex encode / decode the binary data.

2024-10-08 08:35 tomusdrw: I wonder if it's really worth to have every client build it's own RPC (especially based on JSON+HTTP). Have you considered writing a standalone application that would connect to the node via mmap/IPC or some lower-than-http-and-ws-level API and just speak JAM-codec data, possibly just a subset of JAMSNP?
I think that would save a lot of time to implement JSON serialisation and could be re-used between client implementaitons.
2024-10-08 08:36 tomusdrw: Initially it would expose JSONRPC over HTTP/WS just for devs, but in future it could evolve into a user-facing RPC
2024-10-08 09:56 xlchen: Substrate RPC are exposing raw data directly and we can do similar thing here so we don’t need to define the JSON shape
2024-10-08 09:57 xlchen: JAM chain are not for users to access so no need to worry about user friendliness. for example, exchanges only integrate with parachains/jam services but never need to deal with JAM chain
2024-10-08 09:59 xlchen: there must be a way to get data out of the node for diagnostic purpose so all the implementations have to implement some sort of it
2024-10-08 10:00 xlchen: we might as well make the interface to be the same so we can reuse tools. that’s one of the reason I think JSONRPC is better compared to to gRPC due to simplicity 
2024-10-08 10:06 oliver.tale-yazdi: > <@xlchen:matrix.org> There are few key decisions I would like to confirm with everyone before I invest too much time on our RPC implementation :
> 
> - Which RPC protocol?
>   - JSONRPC
>   - gRPC
>   - Restful
>   - something else?
> - How high level should the RPC be?
>   - e.g. like Substrate, the RPC provide metadata and raw data and it is up to the SDK to decode the data
>     - we don't need metadata here as the types are all spec'ed in GP
>   - or make it more complicated but dev friendly by returning typed data directly (e.g. JSON)

JSONRPC + Websocket sounds good to me, i would integrate this into our node if it existed. About metadata: for most of them we probably dont need it, only if we want to have extensions or something later that should be forward-compatible with future clients. I think for the beginning maybe not needed?
2024-10-08 10:08 tomusdrw: > <@xlchen:matrix.org> Substrate RPC are exposing raw data directly and we can do similar thing here so we don’t need to define the JSON shape

I get your point. What I'm arguing about is:
1. Why wrap binary data into JSON if we can just return binary data directly.
2. Why introduce another layer of API methods if we have JAMSNP already that should cover the case of getting and even announcing required raw data from the node.
3. Why integrate HTTP/WS server into the node if this can be a middleware that's shared between all implementations.

So my idea would be to:
1. define a low-level IPC/mmap socket that can speak JAMSNP (or some subset of it) (every implementation)
2. have a "RPC app" connect to that socket and expose JSONRPC or whatever more human/browser friendly protocol to display the data (shared between implementations)
2024-10-08 10:16 emielsebastiaan: JSON introduces an extra layer of opinionation that you don’t want for testing purposes I suppose. All implementation teams should be capable of working with the codec data.
2024-10-08 10:18 xlchen: I see. JAMSNP is basically jamcodec over QUIC. Then we can probably find some existing proxy convert QUIC to websocket or the node can just doing jamcodec over websocket directly to serve requests to browser [edited]
2024-10-08 10:21 xlchen: the only downside is that to build a dashboard, we need to implement jamcodec in JS to parse the data. but hopefully one of the nodejs implementation team can provide the codec part for use
2024-10-08 10:25 tomusdrw: > <@xlchen:matrix.org> I see. JAMSNP is basically jamcodec over QUIC. Then we can probably find some existing proxy convert QUIC to websocket or the node can just doing jamcodec over websocket directly to serve requests to browser

Either this or have the nodes create this IPC/memory-mapped file endpoint that can be used. You don't need QUIC for that, pure in-out, new-line delimited, etc.
2024-10-08 10:26 xlchen: that will require two binary to run side by side, which may cause some trouble on some deployment setup
2024-10-08 10:27 tomusdrw: > <@xlchen:matrix.org> the only downside is that to build a dashboard, we need to implement jamcodec in JS to parse the data. but hopefully one of the nodejs implementation team can provide the codec part for use

Ah, that's true. That could either be done in the shared middleware or if there is something that could be used out of the box to just translate the transport then yes, that would be in the app.
We do have the codec ready and we happen to write in TypeScript - I'm happy to publish it separately to npm.js It wasn't my intention to plug our solutions stuff here, so sorry about that.
2024-10-08 13:12 tebdev: > <@xlchen:matrix.org> There are few key decisions I would like to confirm with everyone before I invest too much time on our RPC implementation :
> 
> - Which RPC protocol?
>   - JSONRPC
>   - gRPC
>   - Restful
>   - something else?
> - How high level should the RPC be?
>   - e.g. like Substrate, the RPC provide metadata and raw data and it is up to the SDK to decode the data
>     - we don't need metadata here as the types are all spec'ed in GP
>   - or make it more complicated but dev friendly by returning typed data directly (e.g. JSON)

Please excuse, I am a little confused. How will this help collaboration and avoid feedback becoming collusion? What is the incentive?
2024-10-08 13:20 oliver.tale-yazdi: > <@tebdev:matrix.org> Please excuse, I am a little confused. How will this help collaboration and avoid feedback becoming collusion? What is the incentive?

From what i understood this targets non-GP functionality, like logs monitoring and telemetry etc
2024-10-08 13:33 tebdev: Please excuse, could logs/monitoring/telemetry indicate health and status. If problem detected and team T(i) makes suggestion to T(i+1) could that be collusion? The incentive of "prize reduction to boost network security" may need clarification so we can collaborate without a lawyer ;) If I am reading rules wrong, please correct me.
2024-10-08 13:40 oliver.tale-yazdi: yea it could be good to have some examples of things that teams are allowed to work on together (if any). [edited]
2024-10-08 13:42 tebdev: I am eager to collaborate - Strength in Numbers. The prize is not my primary motivation, but it is an incentive ;)
2024-10-08 16:03 lucas: Any Gossamer team members interested in chatting? I am interested in networking with the Gossamer team. 
  ↳ 2024-10-16 15:15 p1sar: Hey hey, yeah, we can have a chat maybe you can drop a message to @jimboj21:matrix.org
2024-10-08 17:03 gav: Anything not specified nor referenced in the GP is probably fine. If you don’t need to do it for a milestone then it’s fine to chat about.  [edited]
2024-10-08 17:06 gav: Examples: database structure and formats, CLI arguments, RPCs, xUIs. 
2024-10-08 20:56 tebdev: > <@gav:polkadot.io> Examples: database structure and formats, CLI arguments, RPCs, xUIs.

Sounds reasonable. Focus on interface agreements and treat GP as black box. There is value in that.
2024-10-11 12:58 sebastian: > <@danicuki:matrix.org> We have a question about the JAM prize payment. Rule 20:
> 
> ```
> Prizes are paid to the earliest Polkadot /
>  Kusama account IDs stated in the
>  repository's README. In the case of a tie,
>  payment is split equally. Local (Swiss) law
>  requires that Web3.0 Foundation take
>  KYC/AML information on the recipient
>  together with proof of account control.
> ```
> 
> What if the prize will be divided between individuals? Even if these individuals create a multisign wallet, the wallet itself does not belong to any specific entity (individual or company). Who should KYC? All multisign signers? Do individuals need to create an entity that "owns" the multisign wallet?

Hi danicuki. For payments, see rule 8.5 of the [T&Cs](https://github.com/w3f/jam-milestone-delivery/blob/main/docs/T%26Cs.md). As for KYC, all beneficiaries have to KYC if no legal entity exists.
2024-10-11 14:23 dave: I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

2024-10-11 14:26 dave: I do not intend to change this any more, except to correct errors, and to add stream protocols for Grandpa (which is not currently specified). Any changes for e.g. efficiency will be made in the full network protocol, which won't be defined any time soon
  ↳ 2024-10-12 01:27 sourabhniyogi: David Emett: Thank you for putting JAMSNP together with high precision, we can execute on this.  

One issue we're looking is that in CE 137 / 138  
https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-137-shard-distribution

you have  Assurers *pulling* from Guarantors by "Shard Index" rather than Guarantors *pushing* to Assurers.   GP uses "distribute" + "send" vocabulary here:
* Section 11: "At this point, the work-package is erasure coded into a multitude of segments and each segment *distributed* to the associated validator who then attests to its availability through an assurance placed on-chain"

* Section 14: "Validators are incentivized to **distribute** each newly erasure-coded data chunk to the relevant validator, .... Given our work-package p, we should therefore **send** the corresponding work-package bundle chunk and exported segments chunks to each validator whose keys are together with similarly corresponding chunks for imported, extrinsic and exported segments data, such that each validator can justify completeness according to the work-report’s erasure-root.

Is this done as a simplification in your JAMSNP?  Or is there a technical reason for switching from GP's "push" to your "pull" in CE 137?

In August @gav suggested this sharing (justified) DA chunks:  
```
Vec<Hash> ++ Blob ++ Vec<Hash> ++ Vec<SegmentChunk> ++ Vec<Hash>

The Vec<Hash> will just be complementary Merkle-node-hashes from leaf to root.  The first will contain hashes for the blob-subtree, the second for the segments subtree and the third for the super-tree.
```
which appeared to us to be "push" oriented and consistent with the GP's active "distribute/send" in Section 11/14?
  ↳ 2024-10-12 08:36 dave: > <@sourabhniyogi:matrix.org> David Emett: Thank you for putting JAMSNP together with high precision, we can execute on this.  
> 
> One issue we're looking is that in CE 137 / 138  
> https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-137-shard-distribution
> 
> you have  Assurers *pulling* from Guarantors by "Shard Index" rather than Guarantors *pushing* to Assurers.   GP uses "distribute" + "send" vocabulary here:
> * Section 11: "At this point, the work-package is erasure coded into a multitude of segments and each segment *distributed* to the associated validator who then attests to its availability through an assurance placed on-chain"
> 
> * Section 14: "Validators are incentivized to **distribute** each newly erasure-coded data chunk to the relevant validator, .... Given our work-package p, we should therefore **send** the corresponding work-package bundle chunk and exported segments chunks to each validator whose keys are together with similarly corresponding chunks for imported, extrinsic and exported segments data, such that each validator can justify completeness according to the work-report’s erasure-root.
> 
> Is this done as a simplification in your JAMSNP?  Or is there a technical reason for switching from GP's "push" to your "pull" in CE 137?
> 
> In August @gav suggested this sharing (justified) DA chunks:  
> ```
> Vec<Hash> ++ Blob ++ Vec<Hash> ++ Vec<SegmentChunk> ++ Vec<Hash>
> 
> The Vec<Hash> will just be complementary Merkle-node-hashes from leaf to root.  The first will contain hashes for the blob-subtree, the second for the segments subtree and the third for the super-tree.
> ```
> which appeared to us to be "push" oriented and consistent with the GP's active "distribute/send" in Section 11/14?

I did this for simplicity. Pretty sure the final protocol will be a push protocol. That said I think Gav is keen to change it even for JAM-SNP.
  ↳ 2024-10-12 18:58 sourabhniyogi: Got it.  We did a push method but the pull is a great simplification for PoC work, that's great.  We can reimplement in pull, no problem.

If you could map these terms into GP symbols that probably will help

Bundle Shard, 
[Segment Shard], 
Justification = [Hash OR (Hash ++ Hash)]

We are pretty sure we know the first 2 having implemented it and drawn our own diagrams... but are not sure whats going on with the OR 😅 and having confirmations that map onto our various diagrams will help us and everyone else attack this head on 😀

  ↳ 2024-10-12 21:08 dave: [Segment Shard] is simply a sequence of 12-byte segment shards, with no length prefix (in cases where a length prefix is required this is made explicit with "len++")
  ↳ 2024-10-12 21:16 dave: [Hash OR (Hash ++ Hash)] is effectively just a sequence of 32-byte hashes, also with no length prefix. The OR (Hash ++ Hash) bit is because for the final item of the proof/justification you will in most cases need two hashes: a work-bundle shard hash and a segment shard merkle root
  ↳ 2024-10-12 21:17 dave: The erasure root is defined here in the GP https://graypaper.fluffylabs.dev/#/c71229b/1b76001bba00
  ↳ 2024-10-12 21:19 dave: And the proofs should be built as per the function T in the General Merklization appendix. Note that the return of this function is [H OR Y_n] where n is the byte length of the leaves of the tree
  ↳ 2024-10-12 21:20 dave: In the case of the erasure root merkle tree, Y_n = Y_64 = Hash ++ Hash
  ↳ 2024-10-12 21:23 dave: A Bundle Shard is simply a raw byte sequence, corresponding to one of the items returned by C_⌈|b|/W_E⌉(P_W_E(b)) in the bit of the GP linked above
  ↳ 2024-10-12 21:23 dave: That is, one of the shards resulting from erasure coding a work-package bundle
  ↳ 2024-10-12 21:32 dave: > <@dave:parity.io> [Segment Shard] is simply a sequence of 12-byte segment shards, with no length prefix (in cases where a length prefix is required this is made explicit with "len++")

These segment shards are constructed by the C_6^#(s ⌢ P(s)) expression in the bit of the GP linked above
  ↳ 2024-10-14 17:22 sourabhniyogi: We'll give it a shot and follow up, thank you for explaining!

Some quick+easy questions:

1. You don't use JAM Codec  except the "As in GP" cases (UP 0 - Header, CE 128 - Block, CE 133 - Work Package, CE 134-Work Package Bundle, CE 135+136 - Work Report) -- so teams who pass the codec test (which cover all of these except "Work Package Bundle") have little-to no "extra" codec work to do since everything else is just byte-level work.  Can you confirm this?
2. What is the type of `len` in the `len++` prefixes?   Is it u32/... or is it following JAM codec (being the only other exception to (1))?
3. Why is CE 136 needed if the block contains the work report within a guarantee, contained within a block?  See https://github.com/w3f/jamtestvectors/blob/master/codec/data/guarantees\_extrinsic.json#L3
4. What should happen where some object (Block, Work Report, Bundle Shard, Audit Shard, Segment Shard, Preimage) is "not found"?
5. Since most teams haven't gotten to auditing+GRANDPA implementations yet, is the expected behavior of handshake to dump of headers from genesis (the only finalized states) to the tip?
6. Many of us grew up with easily shared "curl" for JSON-RPC calls -- what do you recommend as an equivalent tool for QUIC testing?  Specifically, for CE 133, is there some way to have an easy to use builder package submission that eliminates any need to have JSON-RPC `jam_submitWorkPackage` methods?
7. Is feedback like "It might be nice to have Work Report at the end for CE 135" useful?
8. You didn't have "Ticket" as one of the "As in GP" cases because you felt the need to split out "Epoch" in there.  Would you agree that the JAM-codec encoded Ticket should have "Epoch" so "CE 131/132" could have "Ticket" transmission be "As in GP"?
 [edited]
  ↳ 2024-10-14 17:31 dave: > You don't use JAM Codec except the "As in GP" cases (UP 0 - Header, CE 128 - Block, CE 133 - Work Package ), CE 134-Work Package Bundle, CE 135+136 - Work Report) -- so teams who pass the codec test have no "extra" codec work to do since everything else is just byte-level work. Can you confirm this?

Not sure that's true. Sequences and integers are encoded as per the JAM codec ("Encoding is as per the serialization codec defined in the gray paper"). The things where I've said "As in GP" are simply entire structures that are already well-defined in the GP.
  ↳ 2024-10-14 17:32 dave: > What is the type of len in the len++ prefixes? Is it u32/... or is it following JAM codec (being the only other exception to (1))?

As in the JAM codec; `len++` is the same as the up/down arrow symbol in the GP. Maybe there is a unicode character for that symbol that I can use instead.
  ↳ 2024-10-14 17:36 dave: > Why is CE 136 needed if the block contains the work report within a guarantee, contained within a block?

That's currently how blocks are defined in the GP, but Gav had tentatively agreed to change blocks to only contain work-report hashes, to improve distribution efficiency (work-reports should be distributed to all validators via CE 135, so also distributing them as part of blocks is quite wasteful). Either this change will get made in the GP or the SNP will need updating.
  ↳ 2024-10-14 17:41 dave: > What should happen where some object (Block, Work Report, Bundle Shard, Audit Shard, Segment Shard, Preimage) is "not found"?

Simply stop/reset the stream: "Unless otherwise specified, resetting/stopping of a CE stream by the stream initiator should be considered cancellation of the request, and resetting/stopping of a stream by the stream acceptor should be considered rejection of the request or failure to process the request". QUIC allows an error-code to be passed when stopping/resetting a stream; currently, I've not defined error codes, but it may prove useful to define some in the future.
  ↳ 2024-10-14 17:45 dave: > Since most teams haven't gotten to auditing+GRANDPA implementations yet, is the expected behavior of handshake to dump of headers from genesis (the only finalized states) to the tip?

We've implemented a dummy finalizer which simply finalizes blocks which have at least 5 descendants. I don't think we'll specify this anywhere but something like this should do until Grandpa is in place. Note that the handshake should only include _leaves_, so even in the case where no finality has occurred it would only include the tips of all known forks
  ↳ 2024-10-14 17:48 dave: > Many of us grew up with easily shared "curl" for JSON-RPC calls -- what do you recommend as an equivalent tool for QUIC testing? Specifically, for CE 133, is there some way to have an easy to use builder package submission that eliminates any need to have JSON-RPC jam_submitWorkPackage methods?

We've added an RPC like that to our node. Don't think a tool like this exists at the moment unfortunately, but if someone wants to make one... ;)
  ↳ 2024-10-14 17:50 dave: > Is feedback like "It might be nice to have Work Report at the end for CE 135" useful?

Sure, you should be able to open issues on the repo for things like this.
  ↳ 2024-10-14 17:55 dave: > You didn't have "Ticket" as one of the "As in GP" cases because you felt the need to split out "Epoch" in there. Would you agree that the JAM-codec encoded Ticket should have "Epoch" so "CE 131/132" could have "Ticket" transmission be "As in GP"?

I think I didn't say "as in GP" in this case because the definition of a ticket is so simple. The epoch index isn't really required, as it's implied by the time at which the ticket is sent/received, but I figured it was sensible to include it anyway as a sanity check. I'll reword things a bit to clarify that the rest of the ticket _is_ as in the GP.
  ↳ 2024-10-14 18:44 dave: I've clarified things a bit in the SNP doc, note that assurances currently aren't exactly as in the GP as the validator index is implicit
  ↳ 2024-10-24 04:30 sourabhniyogi: > <@dave:parity.io> We've implemented a dummy finalizer which simply finalizes blocks which have at least 5 descendants. I don't think we'll specify this anywhere but something like this should do until Grandpa is in place. Note that the handshake should only include _leaves_, so even in the case where no finality has occurred it would only include the tips of all known forks

Alright we did the same "dummy finalizer" and since we're closing in on Recent Blocks/C3=Beta we can attack Section 18 "Beefy Distribution".  Is there going to be some on chain aggregation of BLS Signatures every epoch or something like that?  If so, don't we need a CE for individual sigs to be gossiped around.   If not, where do these go?

https://graypaper.fluffylabs.dev/#/439ca37/1e88001e8f00

  ↳ 2024-10-24 07:34 dave: Something will be needed but as with Grandpa, not specified yet
  ↳ 2024-10-24 09:44 gav: > <@dave:parity.io> Something will be needed but as with Grandpa, not specified yet

The beefy signatures aren’t likely to be aggregated on-chain. 
  ↳ 2025-04-24 10:16 knight1205: Any updates to this? Till now we only have pull protocol. I guess each assurer have to request chunks when it receives report? 

Shouldn't the guarantor itself ensure that each validator receives chunk when it is erasure coded as per GP?
  ↳ 2025-04-25 13:12 knight1205: David Emett: Do you have any updates on this?
  ↳ 2025-04-25 13:15 dave: Almost certainly there will be a push protocol in the final network protocol. Not intending to change SNP though.
  ↳ 2025-04-25 13:16 knight1205: Alright. Thanks for the confirmation.
  ↳ 2025-04-25 15:51 knight1205: David Emett: Could you please elaborate on how is shard index mapped to a particular validator at time of distribution? Like which particular validator will recive which particular shard?
  ↳ 2025-04-25 15:54 dave: Hmm good question, not sure if this is documented anywhere!
  ↳ 2025-04-25 16:07 dave: So shard index = ((core index * systematic threshold) + val index) % num vals, will add this to the SNP doc
  ↳ 2025-04-25 16:08 dave: core index meaning the core the package was refined on
  ↳ 2025-04-25 16:09 dave: systematic threshold meaning the minimum number of shards required to reconstruct, this is 342 with the "full" params, 2 with the "tiny" params
  ↳ 2025-04-25 16:34 dave: I've added a section to the SNP doc covering this, see https://github.com/zdave-parity/jam-np/blob/main/simple.md
  ↳ 2025-04-25 16:34 dave: ("Shard assignment" section)
  ↳ 2025-04-25 17:36 jaymansfield: Oh good to know! I previously assumed shard index = validator index.
  ↳ 2025-04-25 17:37 knight1205: Thanks a ton!!
  ↳ 2025-04-25 17:53 knight1205: >shard index = validator index

in that case few initial nodes will receive too many requests to handle, and they will form most traffic for an epoch for responding to them.
2024-10-11 14:26 dave: AFAIK Gav does not intend to include this initial "simple" network protocol in the Gray Paper; only the full network protocol will be included, once it has been defined
2024-10-11 14:27 dave: So as far as the simple protocol is concerned, the linked repo can be considered definitive
2024-10-11 15:25 oliver.tale-yazdi: > <@dave:parity.io> I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

Included it here: https://docs.jamcha.in/advanced/networking/SNP  
I will try to keep aggregating all non-graypaper docs in there for easy discovery in the future 
  ↳ 2024-10-11 15:26 dave: Ah, thanks!
2024-10-11 22:55 danicuki: Shouldn't this test vector have an error code? 
infinite: 1, halt: 2, bad: 3, big: 4

https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_result_1.json

(panic: null) should be (panic: <number>) 

or am I missing something?
2024-10-11 23:01 rick: Generally speaking they are "syntactically correct only" according to the README, I took that to mean per the binary format it decodes.. 

In this case, WorkExecResult in the ASN defines panic as null and not having a byte sequence: 

https://github.com/w3f/jamtestvectors/blob/master/codec/schema.asn#L93

The only one that has a specified by sequence is the "ok" result. So `"panic": null` looks correct to me as none of the errors have byte sequences.  [edited]
2024-10-11 23:10 danicuki: understood. A suggestion for changing this would be

WorkExecResult ::= CHOICE {
ok \[0\] ByteSequence,
error \[1\] INTEGER
}

and return the error number:
out\_of\_gas: 1, panic: 2, bad-code: 3, code-oversize: 4

because the way it seems ambiguous. E.g. when bad-code is not defined, it is null, as well as the panic being explicitly defined as null [edited]
2024-10-11 23:20 rick: > <@danicuki:matrix.org> understood. A suggestion for changing this would be
> 
> WorkExecResult ::= CHOICE {
> ok \[0\] ByteSequence,
> error \[1\] INTEGER
> }
> 
> and return the error number:
> out\_of\_gas: 1, panic: 2, bad-code: 3, code-oversize: 4
> 
> because the way it seems ambiguous. E.g. when bad-code is not defined, it is null, as well as the panic being explicitly defined as null

When it's an error, the binary encodes 0x01, 0x02, 0x03, or 0x04. When it's not, it encodes 0x00 [len encoding] [bytesequence]. This is proposing  0x01 [4 byte integer], so an additional 4 bytes when there is an error. That doesn't seem unreasonable to me, but worth mentioning. 
2024-10-12 08:41 danicuki: > <@rick:carback.us> When it's an error, the binary encodes 0x01, 0x02, 0x03, or 0x04. When it's not, it encodes 0x00 [len encoding] [bytesequence]. This is proposing  0x01 [4 byte integer], so an additional 4 bytes when there is an error. That doesn't seem unreasonable to me, but worth mentioning.

Understood. The binary indeed is better to keep small as you mentioned. I was just wondering if there is another way of the json be more intuitive. 
2024-10-12 11:10 danicuki: rick do you know whether the `work_item` and `work_package` test vectors already updated to the latest GP version (0.4.1)?
2024-10-12 14:05 rick: > <@danicuki:matrix.org> rick do you know whether the `work_item` and `work_package` test vectors already updated to the latest GP version (0.4.1)?

No, sadly I am just a lowly implementer like yourself 😅
2024-10-15 14:45 luke_f: Hello.
is chapter 19, Grandpa and the Best chain part of the requirements for milestone 1?
2024-10-16 09:03 gav: No. 
2024-10-16 09:05 gav: > <@danicuki:matrix.org> rick do you know whether the `work_item` and `work_package` test vectors already updated to the latest GP version (0.4.1)?

I expect they’re still 0.3 since we have not yet finished the changes for 0.4 internally yet. 
2024-10-16 09:07 gav: Fwiw, I’ll be bringing a few limited-edition 0.4.2 “Lisbon” gray paper prints to the Monday night Lisbon Jam meetup. 
2024-10-16 13:24 danicuki: For those JAM implementors who will be at the meetup next Monday, would be nice to have you for 10min on stage sharing your experience with the audience. Please reach out to me ASAP so I can organize the agenda.  
2024-10-16 13:28 danicuki: From what I saw in the event subscription, we will have people from these teams:
PyJAMaz, JAM Zig, GrayMatter, Gossamer and Jamixir. Please reach out
  ↳ 2024-10-16 15:13 p1sar: No one from Gossamer probably will join
  ↳ 2024-10-17 16:36 lucas: Kyrylo Pisariev: noticed a message from you in notifications, can't see it in the client. Feel free to message me if you'd like to chat further.  There may be some issue with my client with receiving messages properly. Are you also on Discord or another channel?  
2024-10-17 16:32 dave: > <@dave:parity.io> I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

FYI I've made a fix to the epoch transition section and tweaked relevant bits of the Safrole ticket protocol section. Diff here: https://github.com/zdave-parity/jam-np/commit/6d2cba57f45fb1af52baab6618c9a32f71dc185b
2024-10-17 19:56 stanleyli: Hi David Emett (also davxy), sorry I still have questions about work package and work package bundle:

(1) For the import_segments sitting inside of work_item. what's the definition of tree_root & index in import_segments? Is the tree_root here referring to certain work report's exported_segment_root and exported_segment_idx, which will include justification going up erasure_root(u), or is this are the exported_segment_root with justification going up to expoerted_segment_root(e)?

https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_package.json#L22-L62
{
  "tree_root": "0x461236a7eb29dcffc1dd282ce1de0e0ed691fc80e91e02276fe8f778f088a1b8",
  "index": 0
}

(2) When looking at published codec data, I can see both work package have workItem containing importedSegment always starting from index 0 ... up to 3 with no gap. Is it a coincidence, or index here actually mean the index within a workItem?

(3) In CE134, you mentioned "All import segments have been retrieved..." and "a full work-package bundle is sent, along with any necessary work-package hash to segment root mappings". [Work Package Hash ++ Segment Root] how does this allow other guarantor to validate anything? Also what does the original Guarantor have to do to get the exportedSegment, by doing CE 139?

(4) Is there a work_package_bundle data available so we can make sure we got the format correct conforming to 14.1.1 in GP 0.4.2 and your jam_np?
  ↳ 2024-10-17 20:55 dave: > Is the tree_root here referring to certain work report's exported_segment_root and exported_segment_idx

Yes.
  ↳ 2024-10-17 20:58 dave: > which will include justification going up erasure\_root(u), or is this are the exported\_segment\_root with justification going up to expoerted\_segment\_root(e)

Not sure I understand what you're asking here. Individual segment shards can be proven up to the erasure root. Reconstructed segments can be proven up to the segment root. These proofs of segments up to the segment root are packed into proof pages and erasure coded alongside the segments. When you fetch the shards for a segment and reconstruct it, you will also need to fetch the shards for the relevant proof segment and reconstruct it in order to be able to (a) confirm that the segment was reconstructed correctly and (b) prove this to auditors [edited]
  ↳ 2024-10-17 21:04 dave: > (2) When looking at published codec data, I can see both work package have workItem containing importedSegment always starting from index 0 ... up to 3 with no gap. Is it a coincidence, or index here actually mean the index within a workItem?

This sounds like a coincidence to me, but I am not really familiar with the released test vectors.
  ↳ 2024-10-17 21:07 dave: > how does this allow other guarantor to validate anything?

The other guarantor can check the work-package in the same way the original guarantor checked it when receiving it from the builder. It doesn't need to fetch the import segments though, as the work-package bundle should contain these plus proofs of them; the logic for verifying the import segments can be the same as for auditors.

If you mean how should the WPH->SR mapping be checked, then the answer can simply be by constructing a mapping in the same way the original guarantor did and seeing if it matches. The point of sending this mapping is just to avoid wasting time in the case where the guarantors don't agree on a mapping. [edited]
  ↳ 2024-10-17 21:14 dave: > Also what does the original Guarantor have to do to get the exportedSegment, by doing CE 139?

Yes, exactly.
  ↳ 2024-10-17 21:14 dave: > Is there a work_package_bundle data available so we can make sure we got the format correct conforming to 14.1.1 in GP 0.4.2 and your jam_np?

I don't know, sorry. I'll leave this one for davxy
  ↳ 2024-10-17 22:11 stanleyli: I believe you are describing the "H⊞" variant of import_data_segment_i - which guarantors can fetch data using (exporting_work_package, exporting_segment_idx).  That makes sense.

But for the regular (H,i) case, which I think it's the hash is the segmentroot of a single segment itself? In this case, how can guarantor recover the segment as using this segmentRoot alone if builder only provide the guarantor single segmentRoot?

I think the more difficult case is recovering  exported segments using its own segement root and I don't know how guarantor can get such mapping
  ↳ 2024-10-17 22:11 stanleyli: https://graypaper.fluffylabs.dev/#/293bf5a/19a00019a500
  ↳ 2024-10-17 22:14 dave: For the H⊞ variant the first thing guarantors should do is map the work-package hash to a segment root, making it the same as the segment root case
  ↳ 2024-10-17 22:15 dave: A segment root is not the hash of a single segment, it is the root of the merkle tree of the segments exported by some work package. The work-report for the package contains this segment root.
  ↳ 2024-10-17 22:17 dave: To fetch a particular import segment, you need to map the segment root to an erasure root and a set of assurers, request appropriate segment shards from these assurers, and reconstruct
  ↳ 2024-10-17 22:18 stanleyli: oh so you are referring to this root: https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_report.json#L6?
  ↳ 2024-10-17 22:18 dave: In order to map segment root to erasure root + assurers, you will need to keep a record of all the work-reports you have seen in the past ~28 days in a database. A work-report associates work-package hash + segment root + erasure root + timeslot
  ↳ 2024-10-17 22:19 dave: (Obviously you don't need to keep the entire work reports, just these bits of information from them)
  ↳ 2024-10-17 22:20 dave: > <@stanleyli:matrix.org> oh so you are referring to this root: https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_report.json#L6?

Yes, exports_root = segment root
  ↳ 2024-10-17 22:27 dave: I should probably have used the term "segments-root" in the SNP doc, will fix this
  ↳ 2024-10-17 22:32 stanleyli: Originally I was thinking about the case when a builder submit a WP for processing, it can store the result as segments [G] ... it seems natural from PVM exception's perspective to have exportSegment maps to something that's H(exportSegment) and then continue using the segment by requesting the segment using H(exportSegment) in the next refine WP. But looks like you are saying Builder must gather the WP to recover the "segment_root, idx" in order to use in next import?
https://graypaper.fluffylabs.dev/#/293bf5a/309102309102
  ↳ 2024-10-17 22:35 dave: I think one reason it's not specified this way is that you would need to remember ~2000x as many hashes -- each work-package can export ~2000 segments
  ↳ 2024-10-17 22:36 dave: So instead of remembering the hash of each exported segment, we just remember the merkle root of all the up-to 2000 segments, and require importing work-packages to specify this root plus the index of the segment they want
  ↳ 2024-10-17 22:39 stanleyli: thanks for your explanation. it makes sense now
  ↳ 2024-10-17 22:40 dave: Re the PVM import function, I'm not really familiar with how that works
  ↳ 2024-10-17 22:44 dave: Looks like you just specify the index of the import segment in the manifest that you want though
  ↳ 2024-10-17 22:44 dave: So no hashes involved
  ↳ 2024-10-17 23:00 stanleyli: Originally I thought having "constant/stable" identifier -- where correctness of the segment can be verified by doing H(recovered\_data) in pvm (similar to how work\_pacake\_hash can be used  identify workpackage\_byte or codeHash -> codeBlob  would be straight forward). But I understand your concerns of having to memorize 2k hash. 

In our implementation, we decided to provide segmentRoot for each segment\_shard to enable direct segment fetch. This endup being quite wasteful since the shard is only 12 bytes. We will remove it and follow your design. 

Our remaining question is the size of pageproof: https://graypaper.fluffylabs.dev/#/293bf5a/1a4f001a5100

 Is the ↕s here the actual segment or the segmentHash? If it's segment, then each element within the pageproof (encode as 6Hash + G) will make this pageproof super large (up to 64G).

Can you predict the size of pageproof? I think you might be saying that pageProof will not include the segment itself?  which is different than what I see in eq 196
 [edited]
  ↳ 2024-10-17 23:06 dave: The function P which produces the proof pages takes the sequence of exported segments (the actual segments, not their hashes), and produces a sequence of proof segments
  ↳ 2024-10-17 23:06 dave: The number of proof segments is ceil(number of exported segments / 64)
  ↳ 2024-10-17 23:08 dave: Though I agree that something looks wrong here
  ↳ 2024-10-17 23:09 dave: I think some hash calls are missing in P
  ↳ 2024-10-17 23:10 dave: Or perhaps P should take the segment hashes instead, though this is not what its type implies, and is not how it is used in eg 202
  ↳ 2024-10-17 23:10 dave: Would ask Gav about this in the GP channel
  ↳ 2024-10-17 23:14 dave: I think probably the ↕s_{i⋅⋅⋅+64} bit just needs tweaking to ↕H^#(s_{i⋅⋅⋅+64})
  ↳ 2024-10-18 02:45 stanleyli: Sorry, I have one more question.

For CE 140, since "j⌢\[b\]" are the same for all segments, should it just be

--> \[Erasure-Root ++ Shard Index ++ len++\[Segment Index\]\]
--> FIN
\<-- \[Segment Shard\]
\[Protocol 140 only\] j⌢\[b\] \<--- CE\_137
\[Protocol 140 only\] for each segment shard {
\[Protocol 140 only\]  T(s,i,H) 
\[Protocol 140 only\] }
\<-- FIN [edited]
  ↳ 2024-10-18 07:47 dave: Not necessarily the same for all segment shards as you can request segment shards from multiple erasure roots in the same stream. For all the shards returned for one erasure root this could be done. I didn't do this primarily to keep things simple. Protocol 140 should only be used in exceptional circumstances so efficiency is not super important
  ↳ 2025-04-21 10:58 knight1205: Any testcases for this function or merklization functions?
2024-10-18 07:08 xlchen: I am confused about JAMNP ALPN
> The protocol name, version, and chain are identified using QUIC/TLS "ALPN" (Application Layer Protocol Negotiation). The protocol identifier should be either jamnp-s/V/H or jamnp-s/V/H/builder. Here V is the protocol version, 0, and H is the first 8 nibbles of the hash of the chain's genesis block header.

firstly, I guess the V and H are ASCII encoded? so it will be `jamnp-s/0/12345678` encoded using ASCII?
2024-10-18 07:09 xlchen: And shouldn't it be using genesis state hash rather genesis block header hash? surely it can't be the first block in the network
2024-10-18 07:13 xlchen: so just searched genesis header in GP so I guess it will be something predefined along with genesis state. i.e. something should be included the chainspec file
2024-10-18 07:51 dave: > <@xlchen:matrix.org> I am confused about JAMNP ALPN
> > The protocol name, version, and chain are identified using QUIC/TLS "ALPN" (Application Layer Protocol Negotiation). The protocol identifier should be either jamnp-s/V/H or jamnp-s/V/H/builder. Here V is the protocol version, 0, and H is the first 8 nibbles of the hash of the chain's genesis block header.
> 
> firstly, I guess the V and H are ASCII encoded? so it will be `jamnp-s/0/12345678` encoded using ASCII?

Yes
2024-10-18 07:55 dave: > <@xlchen:matrix.org> so just searched genesis header in GP so I guess it will be something predefined along with genesis state. i.e. something should be included the chainspec file

Yes
2024-10-18 11:33 sourabhniyogi: David Emett: We need a way for users interact with “always accumulate” services, at least the assign privileged service right now but maybe all of them in the same way.  Should we use CE130 to prototype this on our own or maybe you have a design in mind?  
2024-10-18 11:35 dave: > <@sourabhniyogi:matrix.org> David Emett: We need a way for users interact with “always accumulate” services, at least the assign privileged service right now but maybe all of them in the same way.  Should we use CE130 to prototype this on our own or maybe you have a design in mind?

I don't understand what you mean by this
2024-10-18 11:35 gav: sourabhniyogi: please read [the Code of Conduct effective across all public Polkadot channels](https://hackmd.io/@puaoX3mpTI-9hXSB8NeGEw/B1WUlNqvV) [edited]
2024-10-18 11:36 gav: > This is a room for informal and inclusive conversation. It is not an opportunity to call out for a **specific individual** to answer arbitrary questions. Questions that are made directly to a room member not already in direct conversation with the asker will not be tolerated. [edited]
2024-10-18 11:37 gav: If you have a question, ask it. Do not address a particular person unless as part of a pre-existing and on-topic conversation.
2024-10-18 11:47 sourabhniyogi: > <@gav:polkadot.io> If you have a question, ask it. Do not address a particular person unless as part of a pre-existing and on-topic conversation.

Sorry I was asking as a follow up to a preexisting conversation from a week ago.  How are users supposed to interact with the assign service or privileged/ always accumulate services? 
2024-10-18 11:51 gav: In the same way as any other service. [edited]
2024-10-18 11:51 gav: By sending Work Packages.
2024-10-18 11:52 gav: There will need to be a "bootstrap" service, specified in the genesis config and already in state, which accepts simple Work Packages with instructions in them, such as for assigning coretime, creating new services, requesting preimages and changing the validator keysets. [edited]
2024-10-18 11:53 gav: We already have an early revision of this internally (just used for tests at present) and will tidy up and publish in due course. [edited]
2024-10-18 11:54 gav: It doesn't make much sense to have this service sitting around until we have a testnet going.
2024-10-18 12:27 sourabhniyogi: We have single-team testnet  and can definitely have multi-team testnets after getting this genesis state containing the bootstrap service.  Definitely ready.

We have our "tiny" V=6/C=2 testnet with CE133/134/135 (work package submission/sharing => work report distribution) with 1 core being assured now via CE141 and hitting accumulate entry points, updated with the new JAMSNP details.   We currently have "hard coded" a `fib` test service into state trie (via the service's preimage) -- we can totally improve this to have a genesis state with this "bootstrap" assign service (with a `new` host call) instead of our current "hard coded" situation.

Ok -- so my questions concerning privileged / always accumulate services (which are not GP but JAMSNP related, but its blurry here):

1. if a user sends their Work Package into the bootstrap assign service via CE133 containing their service code blob, presumably to any validator on any core (since the assign service does not belong to a core ... or does it?), what happens next?
2. In JAMSNP,  CE134 has the first guarantor sharing with 2 others, resulting in a work report distribution -- should it share with all V-1 instead if its known to be among the 3 privileged  or always-accumulate  services in `\chi_g`?
3. Does a work report need to be distributed at all then via CE 135 for the privileged / always accumulate service?
4. Can CE 141 be skipped then?  

We will take the answers to this and accommodate in our revisiting "Accumulate" (to cover ordered accumulation since we finally have real assurances in our testnet), covering both the normal work packages and the above "always-accumulate".  We can publish our genesis state and believe many other teams can use the same genesis state + publish exact same answers to get single-team testnets and then proceed to multi-team testnets now. [edited]
2024-10-18 12:39 dave: AFAIK there is nothing special about work packages containing items for always-accumulate services. They are guaranteed and audited in the same way as any other work package
2024-10-18 13:07 gav: There is indeed nothing special about privileged services. Also note that *privileged services* do not always accumulate. There is now (GP-0.4) a separate item which contains a mapping of always-accumulate services and the free gas they get.  [edited]
2024-10-18 13:09 gav: 1. There will likely be a single bootstrap service which is given all three privileges.
  ↳ 2024-10-19 15:35 sourabhniyogi: How should we envision JAM service builders publishing something equivalent to Contract ABIs for Services?

We're writing our "Create New Service" service (for this bootstrap service) with code/code length coming through payload ${\\bf y}$, in a very byte-y way and find ourselves wishing for ABIs for calls "createService(uint32 code\_length, \[\]byte code)" and something like event logs like "ServiceCreated(uint32 service\_id)".

Some other bootstrap design could have used extrinsics ${\\bf x}$ to do the same basic function, another might use imported segments to  exported segments, or have multiple methods (to cover changing the validator keysets) to cover all 3 functions.   Is there some convention services should use to publish their invocation for the 4 entry points?

What is the role of JAM Codec for the key input and outputs { y, x, i, e, o, ...  } in such a convention?

Any recommendation on how a service should emit Events / Logs, for JAM Service indexers/explorers? [edited]
2024-10-18 13:11 gav: There’s nothing special about the service (other than being privileged). The WP will be processed as long as there is a core whose assignment is acceptable. Probably we’ll start with a null-authorizer assigned to all cores which allows any core to accept any WP.  [edited]
2024-10-18 13:12 gav: 2. It shouldn’t do anything different. 
2024-10-18 13:12 gav: 3. Same. 
2024-10-18 13:12 gav: 4. Same. 
2024-10-18 13:14 davxy: > <@stanleyli:matrix.org> Hi David Emett (also davxy), sorry I still have questions about work package and work package bundle:
> 
> (1) For the import_segments sitting inside of work_item. what's the definition of tree_root & index in import_segments? Is the tree_root here referring to certain work report's exported_segment_root and exported_segment_idx, which will include justification going up erasure_root(u), or is this are the exported_segment_root with justification going up to expoerted_segment_root(e)?
> 
> https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_package.json#L22-L62
> {
>   "tree_root": "0x461236a7eb29dcffc1dd282ce1de0e0ed691fc80e91e02276fe8f778f088a1b8",
>   "index": 0
> }
> 
> (2) When looking at published codec data, I can see both work package have workItem containing importedSegment always starting from index 0 ... up to 3 with no gap. Is it a coincidence, or index here actually mean the index within a workItem?
> 
> (3) In CE134, you mentioned "All import segments have been retrieved..." and "a full work-package bundle is sent, along with any necessary work-package hash to segment root mappings". [Work Package Hash ++ Segment Root] how does this allow other guarantor to validate anything? Also what does the original Guarantor have to do to get the exportedSegment, by doing CE 139?
> 
> (4) Is there a work_package_bundle data available so we can make sure we got the format correct conforming to 14.1.1 in GP 0.4.2 and your jam_np?

The content of the **codec** test vectors is not supposed to be significant. These vectors are only used to test your codec encode/decode functions
https://github.com/w3f/jamtestvectors/tree/master/codec#semantic-correctness

2024-10-18 13:14 gav: The above should all be clear from reading the GP carefully. 
2024-10-18 13:14 sourabhniyogi: Alright, thank you for clarifying, this is simpler.  Is the bootstrap service assigned to just one core?  
2024-10-18 13:14 gav: Cores are not assigned to services  [edited]
2024-10-18 13:14 gav: Nowhere in the GP is this implied. 
2024-10-18 13:15 gav: Cores are assigned to authorizers. Authorizers authorize (sets of) work packages. Work packages contain work items. Work items are associated with a service.  [edited]
2024-10-18 13:15 sourabhniyogi: Ok understood, thank you.
2024-10-18 13:49 carlos379: 
2024-10-18 15:31 dvladco: Hello, I have a question regarding the milestone 1. What does "PVM instancing" imply? having a general PVM that will be later used for the four types of invocations (is-authorized, refine, accumulate, on-transfer) or does this mean implementing each of the four invocation types. In short does "PVM instancing" mean implementing only `Ψ` and `ΨH` and perhaps `ΨM` or  does that also involve `ΨI`, `ΨA`, `ΨR`, `ΨT`? [edited]
2024-10-18 15:58 gav: The former.
2024-10-18 15:59 gav: But it must be possible to implement each of the other things with it. 
2024-10-18 16:00 gav: (M1 necessarily includes the last two PVM invocation functions too since they’re used on-chain)
2024-10-18 16:01 dvladco: last two meaning accumulate and on-transfer?
2024-10-18 16:01 gav: Yes
2024-10-18 16:01 dvladco: thanks
2024-10-18 16:04 dvladco: I was trying to implement the is-authorized first but it required work packages, cores and what not, so I was not sure if we needed all that for the M1, thanks for clarifying it 🙂
2024-10-18 20:16 xlchen: about JAMNP, can we have explicit length prefix for CE stream request/response and length prefix for UP messages?
2024-10-18 20:18 xlchen: because otherwise it will be much more work to be able to reject bad data
2024-10-18 20:19 xlchen: many streams have implicit fixed size data so they maybe don’t need such prefix, but in that case will be good to explicit note the expected message size in the spec
2024-10-18 21:59 dave: Possibly I misunderstand, but all messages are length prefixed on the wire: "A message is transmitted in two parts. First, the size (in bytes) of the message content is transmitted, encoded as a little-endian 32-bit unsigned integer. Second, the message content itself is transmitted."
2024-10-19 04:53 xlchen: my bad. not sure why I missed that part 🤦‍♂️
2024-10-19 15:16 gav: 
2024-10-19 15:56 gav: Services are not smart contracts. 
JAM is not intended to be used directly as an application chain since it’s primarily a roll-up host. If you’re desperate to get information out of JAM you can write to a service’s storage and inspect that. 
  ↳ 2024-10-21 17:38 sourabhniyogi: Regarding JAM’s primary role being a roll-up host, is the intention for it to be exclusively used for Polkadot parachains/rollups built with the Polkadot SDK/Substrate, or extend to support non-Polkadot "foreign" rollups?

You suggest the foreign possibility in GP: “Smart-contract state may be held in a coherent format on the Jam chain, as long as any updates are made through the 15kb/core/sec work results, which would only need to contain the hashes of the altered contracts’ state roots.”     Would it be worthwhile to build shims between smart contract platforms like OP Stack, ArbOS, etc., to leverage JAM DA+Work packages, or would this be a futile effort given the native capabilities of Polkadot SDK/Substrate-built chains, extending to revive+PVM?

A Rollup host that can have "semi-coherent" messaging between different kinds of rollup platforms would be very awesome.  Is there some spam-resistant DMP-like process out of accumulate/transfer or HRMP-like messaging service that could support both native and foreign rollups ... if foreign rollups belong in JAM?

These questions are not directly related to JAM implementation life but helpful to understand the big picture! [edited]
  ↳ 2024-10-22 10:29 gav: Jam is intended to be generally usable and not at all constrained to validating substrate/cumulus chains. The point was that it’s not designed to supplant a smart contract platform in terms of end-user experience, at least not directly.  [edited]
  ↳ 2024-10-22 16:58 sourabhniyogi: This foreign possibility suggestion is super titillating, do you see a way for it to apply to Ethereum L2 optimistic rollups?   

Not sure about this, but from your suggestion, I assume you mean being able to prove the next state root of an optimistic rollup (e.g. OP Stack, ArbOS)  with a JAM work package containing JUST the hashes of the altered contracts’ state roots, correct?    But what about { Account balances/Nonces, Contract storage, Contract code, remaining unaltered state }, which also affect the state root?  You must have some key simplification/insight to make it fit within JAM, maybe coupled with a particular enabling technology.   

The lazy/stay-optimistic approach would be to have another rollup (Asset Hub or whatever else with revive) represent ETH L1 and get the messaging service in place.  Making optimistic rollups into "cynical/pessimistic" rollups for foreign rollup platforms would be groundbreaking but needs these simplifications/insights.   Can you share your insights on how Polkadot ecosystem can break ground with foreign rollups in this way? [edited]
2024-10-19 18:59 sourabhniyogi: Understood about JAM services not intended to be used directly as application chain.

But what about the bootstrap service itself: how should a new service creator learn that the newly created service has a particular new service index (from check/bump entropy driven processes, via 4.2 (281)'s check ala hostfunction `new` after `accumulate` completes).  

Do you mean that a new creator of a service should look in the bootstrap service's storage?  This is fine for PoC -- but do you mean for production multifunction bootstrap service as well? [edited]
2024-10-21 11:07 gav: > <@sourabhniyogi:matrix.org> Understood about JAM services not intended to be used directly as application chain.
> 
> But what about the bootstrap service itself: how should a new service creator learn that the newly created service has a particular new service index (from check/bump entropy driven processes, via 4.2 (281)'s check ala hostfunction `new` after `accumulate` completes).  
> 
> Do you mean that a new creator of a service should look in the bootstrap service's storage?  This is fine for PoC -- but do you mean for production multifunction bootstrap service as well?

Production would be different. Most likely it will be the parachains service which is given all three privileges. The Staking/CoreTime chains would be able to set validators, assign cores, request blobs and create services. 
2024-10-21 11:08 gav: > how should a new service creator learn that the newly created service has a particular new service index

The most obvious way (and what I'm doing in my little test) is to write to a known storage key the new index.
2024-10-21 11:23 gav: FWIW logs/receipts are basically an unsolved problem in blockchain. It's not at all clear how to build a secure decentralised scalable service capable of indexing arbitrarily large numbers of state-change events. Ethereum's bloom filter became saturated shortly into its lifetime. Deterministic hash-maps are trivially spammable. Non-deterministic hash-maps are difficult to validate. Maybe there's something clever which can be done with ZK these days, but overall it's a hard one to solve and not one I especially want to bundle into the core of JAM.
2024-10-22 09:18 prematurata: Not sure if this is the right place and if it is allowed to ask. But I was thinking it could be helpful and cool to have some "voting" support for jam teams right now in the polkadot chain as a perk for jam implementors. 

Especially now that the number of validators in the dot chain was (and is being) raised.
2024-10-22 10:31 gav: > <@prematurata:matrix.org> Not sure if this is the right place and if it is allowed to ask. But I was thinking it could be helpful and cool to have some "voting" support for jam teams right now in the polkadot chain as a perk for jam implementors. 
> 
> Especially now that the number of validators in the dot chain was (and is being) raised.

To some extent this is already provided for via the Fellowship membership rules. But I suppose there could be an additional collective for the maintainers of all milestone-achieving teams. 
2024-10-22 12:14 jaymansfield: Hey all. Should we be updating anyone at w3f about our progress as we go or only after completing milestones? 
2024-10-22 12:58 gav: Feel free to give updates - we’re interested to know.
2024-10-22 15:24 dakkk: > <@jaymansfield:matrix.org> Hey all. Should we be updating anyone at w3f about our progress as we go or only after completing milestones?

It would be interesting to know at what stage are all the teams working on a jam implementation
2024-10-22 15:24 dakkk: (at least those using the language I'm using 😄) 
2024-10-22 17:22 gav: JAM should be easily performant enough to be able to verify most Ethereum L2 transitions in a single WP. Along with a secure ethereum bridge, it should be viable to provide cheap, fast and secure Ethereum L2s from JAM. It may even be possible to grandfather in pre-existing L2s. 
  ↳ 2024-10-27 08:34 sourabhniyogi: Can you explain the grandfathering idea a bit?  Touching on it here 

https://github.com/polkadot-fellows/RFCs/pull/127#discussion_r1817937026

Basically having pre-existing L2s prove finality with *both* ETH + JAM as anchors is a winning solution.  But I'm  not sure how we get Ethereum finality into `accumulate` to feed back into `refine`'s  `historical_lookup`.



  ↳ 2024-10-28 09:23 gav: > <@sourabhniyogi:matrix.org> Can you explain the grandfathering idea a bit?  Touching on it here 
> 
> https://github.com/polkadot-fellows/RFCs/pull/127#discussion_r1817937026
> 
> Basically having pre-existing L2s prove finality with *both* ETH + JAM as anchors is a winning solution.  But I'm  not sure how we get Ethereum finality into `accumulate` to feed back into `refine`'s  `historical_lookup`.
> 
> 
> 

One not entirely dismissible possibility is to run an Ethereum full-node as a JAM service. 
2024-10-22 17:24 gav: It’s still in the early stages of ideation but I don’t see any obvious flaws with the approach. It is perhaps something which could be discussed at JAM0. 
2024-10-22 22:54 danicuki: ima_8984eb0.jpeg
2024-10-22 22:54 danicuki: ima_779bc41.jpeg
2024-10-22 22:54 danicuki: ima_ab4d75d.jpeg
2024-10-22 22:54 danicuki: ima_53184c7.jpeg
2024-10-22 22:54 danicuki: ima_ddab933.jpeg
2024-10-22 22:54 danicuki: ima_e241c29.jpeg
2024-10-22 22:54 danicuki: ima_43b6c06.jpeg
2024-10-22 22:54 danicuki: ima_b13309a.jpeg
2024-10-22 22:54 danicuki: ima_1f92268.jpeg
2024-10-22 22:54 danicuki: ima_03602d0.jpeg
2024-10-22 22:54 danicuki: video_af05d68.mp4
2024-10-22 22:54 danicuki: Pictures from the JAM Meetup yesterday in Lisbon. 
2024-10-23 04:24 lucas: I am intersted in chatting with Gossemer team members. 

I am also interested in networking with other JAM engineers. 

I saw that a solo JAM implementation may also be desired, & beneficial. 

I am also wondering if  there are any set vcs practices that aren't mentioned anywhere on the relevant web resources? Is there any universal agreement among teams with VCS or other engineering practices? What happens if I am engineering solo, parts of my implementation are copied by another team & put in their implementation? How would anyone know if it was originally my implementation vs theirs or vice versa?  

Wondering as well if anyone is working on JAM related projects that aren't specifically implementations? 

I am also wondering if I build for example a dApp or something similar on top of a new JAM client implementation if that is more desired than for example an improved JAM client implementation by itself even if the client may perform better by focusing only on that & not building on top of it?   

For example, I think it'd be cool to build a decentralised gaming server, that could also be a good experiment to test decentralised network performance & benchmark it against non decentralised server clusters. 

Some questions that can be explored for example, are all server clusters a form of decentralisation if some resources are distributed or only if they are distributed in a certain way? 

What defines a decentralised http or protocol request? 

I haven't discovered any universal answers for the above, or agreement related to them. 

Is there a stack exchange or similar forum, where it is better to ask these questions? 
2024-10-23 04:28 xlchen: I didn't read all the fine print of the prize rule but I assume copyright infringement is an immediate disqualify. KYC/KYB is required so it should be possible to take legal action if necessary
2024-10-23 04:29 xlchen: we definitely need all sorts of tools and applications built on top of JAM but I will say it is a bit too early to actually working on it until we have a public JAM testnet 
2024-10-23 04:37 xlchen: JAM is the foundation. it is very low level. users are not suppose to use JAM directly. we need all sorts of services to make JAM useful. however, to build such service, we also need some framework for it. I presume Parity is working on some internal experimental framework and it will take time and many trial and error for such framework to be mature enough for use
2024-10-23 06:07 bill: > <@lucas:digitale-gesellschaft.ch> I am intersted in chatting with Gossemer team members. 
> 
> I am also interested in networking with other JAM engineers. 
> 
> I saw that a solo JAM implementation may also be desired, & beneficial. 
> 
> I am also wondering if  there are any set vcs practices that aren't mentioned anywhere on the relevant web resources? Is there any universal agreement among teams with VCS or other engineering practices? What happens if I am engineering solo, parts of my implementation are copied by another team & put in their implementation? How would anyone know if it was originally my implementation vs theirs or vice versa?  
> 
> Wondering as well if anyone is working on JAM related projects that aren't specifically implementations? 
> 
> I am also wondering if I build for example a dApp or something similar on top of a new JAM client implementation if that is more desired than for example an improved JAM client implementation by itself even if the client may perform better by focusing only on that & not building on top of it?   
> 
> For example, I think it'd be cool to build a decentralised gaming server, that could also be a good experiment to test decentralised network performance & benchmark it against non decentralised server clusters. 
> 
> Some questions that can be explored for example, are all server clusters a form of decentralisation if some resources are distributed or only if they are distributed in a certain way? 
> 
> What defines a decentralised http or protocol request? 
> 
> I haven't discovered any universal answers for the above, or agreement related to them. 
> 
> Is there a stack exchange or similar forum, where it is better to ask these questions?

1. Yes, there is a 10 million DOT pot available for implementations of JAM. Many different teams are already working on it https://jam.web3.foundation/
2. As Bryan said, teams that copy/paste from others are disqualified. You can timestamp your code in a variety of ways, e.g., making a system.remark of the latest commit hash at regular intervals. I recommend reading through the rules here: https://jam.web3.foundation/rules

2024-10-23 11:00 emielsebastiaan: Could anyone please update me on JAM-related Bangkok events in November?

The bits and pieces I have:
- Last day at sub0 (11 Nov) will focus on JAM
- JAM0 scheduled on 12-16 Nov. But treasury proposal got rejected. Is this still happening? If yes is there a rough idea of objectives?

Where can I find the latest info and keep updated? 🙏🏻
2024-10-23 13:22 gav: I had understood it was to be on the 9th and 10th November. 
  ↳ 2024-10-23 14:15 sourabhniyogi: Between sub0 and JAM0 everything you want to happen between the 9th and the 16th can be arranged.  sub0 (9th-11th)is best for recorded talks as usual but JAM0 (11th evening - 16th) for seminars, office hours with teams in whatever form you'd like (within room space constraints).  

Anything you want to do will create Schelling points for all of us schedule-wise.  What would you like to see?
  ↳ 2024-10-24 04:47 gav: I'll be there 9th and 10th, and I'm fairly flexible over how the time is used.
  ↳ 2024-10-26 14:35 sourabhniyogi: Thank you for making yourself super accessible for all of us here.   

I myself would be  most keen to get your concrete ideas on how to properly design/develop a JAM Service for ETH L2 optimistic rollups.  Here is my first attempt at a write up:

 https://github.com/polkadot-fellows/RFCs/pull/127

We can find you at the end of the 10th, but if we should study something beforehand to gain some competence in how to approach this better, we will do that.  If we're on the right track, we can take a stab at reducing it to practice, or course correct based on your advice right now.  
2024-10-23 13:49 sourabhniyogi: sub0 is 9th through the 11th -- You should register for a free ticket https://sub0.gg/ and look for JAM related content on the schedule, which is under prep there.    127 Na Ranong Rd. , Khlong Toei, Bangkok is the address.  rektormoon can speak to other details not on the site but... Hackerspace is open to all implementers 24h!

JAM0 is a mostly open ended hackathon type arrangement with 2-3x/day "sessions" where we cover whatever topics anyone wants for 30-90 mins (e.g at 10:30am and 2pm and 5pm) as a group and any team can network with any other team \[always following official/unofficial rules\].   We have a big room that can hold everyone for up to 80 people on the 11th,12th,15th,16th so we can do whatever we want.  On the 13th and 14th we have a smaller room that can hold up to 30.  For 11th-16th both rooms are available 9am-9pm.  I'm collecting a headcount here so we can buy everyone a lunch or dinner if there is quorum of people:

https://docs.google.com/spreadsheets/d/1\_Ar0CWH8cDq\_mAoVkqZ20fXjfNQQ9ziv1jsVJBAfd1c/edit?gid=0#gid=0

You can add your topics \[I put 2\] but no prep is required.  If you are a JAM implementer (and have ever asked a JAM-related GP question to qualify you), I'll put you in a JAM0 room so you can find everyone else.  We are happy to sponsor the venue + food but have no travel budget.  If you have any questions/wishes, you can DM me @sourabhniyogi and we'll do our best to be a good host.  Address is 95,370 Sukhumvit Soi 24, Khwaeng Klongton, Khet Klongtoey

Devcon 7 is Nov 12th-15th and a 25 min walk from both places.  Tickets are sold out but there is a waitlist.  I'm not seeing a schedule but everyone is welcome to go back and forth between the JAM0 rooms at Valia and Devcon 7 all through 4 days from 9am-9pm. [edited]
2024-10-23 14:29 dave: > <@dave:parity.io> I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

FYI I've pushed a fix to CE 142. Previously, only the hash of the preimage was sent, which isn't really enough to check whether the preimage has been requested on chain or not. Now the ID of the requesting service and the length of the preimage are also sent.
  ↳ 2024-10-23 19:28 mkchung: Can you clarify who is "non-validator" node in your CE 142, and whether CE 142 is primarily designed for covering the "solicit=13" case?

Is the "non-validator" a node outside of V=1023? I initially thought this "non-validator" could be the wp "builder" submitting a wp that ultimately triggers the "new=9" or "solicit=13" at the accumulation stage. If that were the case, it would make sense that the builder wouldn't know which service account is being created, thus only allowing the `preimageHash` to be announced. It would also make sense that builder would want to get its preimage into on-chain state, thus it will resume preimage announcement responsibility.

However, if CE 142 is also intended to cover the "new=9" case, then the "non-validator" cannot be just the builder -- as the `service_id` must go through the check-and-bump logic [here](https://graypaper.fluffylabs.dev/#/439ca37/2b5c012b5c01). (I interpret builder as core user who only cares about using it, but not actually running it)

If non-validator != builder, how does non-validator know the `service_id` and `preimageData` in general, especially when a new service is being created? If non-validator implies that the announcement responsibility is from someone outside of [active validator set](https://graypaper.fluffylabs.dev/#/439ca37/183400183700), then what's the incentive or penalty to make sure requested preimages are being answered promptly?
  ↳ 2024-10-23 21:58 dave: "Non-validator node" was just to clarify that you should allow these announcements from essentially any node. You probably don't need to prevent validator nodes from using this protocol, but a normal validator node would have no reason to use it, as these announcements are not intended to be gossiped.
  ↳ 2024-10-23 22:17 dave: CE 142 is intended for both the solicit case and the new case. In the new case, the party providing the preimage will need to learn what the new service ID is by following the chain somehow. How exactly this is done is not prescribed as there is no need for everyone to do it in the same way.
  ↳ 2024-10-23 22:17 dave: > then what's the incentive or penalty to make sure requested preimages are being answered promptly?

This is a concern of the service requesting the preimages, not a concern of JAM. [edited]
  ↳ 2024-10-23 22:24 dave: That is to say, if you write a service which requests some preimage, you should have a plan for who is responsible for providing the actual preimage. Maybe your service allows people to pay to create smart contracts, in which case the creator of a contract will have an incentive to upload the contract code.
  ↳ 2024-10-26 11:34 tebdev: Q1: Is this required for M1 Q2: Will Public CA be required for OCSP Stapling for MITM? Comment: That could pin us to "Stoppable"
2024-10-23 18:20 sourabhniyogi: Excellent, thank you for this fix -- I think its workable to complete the picture and implement a bootstrap service like this now:
https://github.com/jam-duna/jamtestnet/blob/main/services/jam-duna/bootstrap/README.md

Let me know what you think I got wrong?  Or if you have a bootstrap assembly that does it better/right, maybe that is ready for sharing?  I understand there are problems that are useful as exercises for the reader, and this is a great one, but perhaps achieving consensus on this is worth it. [edited]
  ↳ 2024-10-23 19:11 sourabhniyogi: ?  We believe the `Service ID` was necessary in your fix, but don't see why `Preimage Length` was needed as well.  What is the reason for its inclusion in CE142?
  ↳ 2024-10-23 22:31 dave: The dictionary **l** in each service has keys of type (Hash, Preimage Length). You will want to look into this dictionary to determine if a preimage has been requested or not. Without the preimage length it's not easy to do this (not strictly speaking impossible of course) [edited]
  ↳ 2024-10-23 22:41 dave: Re the proposed bootstrap service, sounds like that would work to me. That is certainly how CE 142/143 are intended to work.
2024-10-24 00:34 charliewinston14: I have a question about "publish-tickets-no-mark-4" which is "Fail: Submit tickets in bad order.". Where in the grey paper can i find information about how to properly order tickets? I see "in order of their implied identifier." on page 15 but unsure what that means exactly. 
2024-10-24 00:35 xlchen: they need to be ordered by output in ascending order. it is specified somewhere
2024-10-24 01:31 charliewinston14: > <@xlchen:matrix.org> they need to be ordered by output in ascending order. it is specified somewhere

Thanks!
2024-10-25 01:43 xlchen: For JAMNP CE128 block request, does the response have to give exact amount of block requested?
2024-10-25 01:44 xlchen: the response appears to not having a length prefix
2024-10-25 01:44 xlchen: but the wording is that the number is request is maximum so response can give something less than that
2024-10-25 09:55 dave: Yeah the intent is that some number of blocks up to the given maximum is returned
2024-10-25 09:56 xlchen: in that case shouldn’t it have a length prefix?
2024-10-25 09:57 xlchen: so I can decode it as Array<Block> directly with jam codec
2024-10-25 10:13 dave: I was assuming you would decode one block at a time in a streaming fashion, stopping once you had read the entire message. Perhaps an additional length prefix would be useful, that's not particularly clear to me though
2024-10-25 10:20 xlchen: it is lot more complicated to implement an online decoder and for what benefit? save 1 to 2 bytes?
2024-10-25 10:25 xlchen: > len++ preceding a sequence indicates that the sequence should be explicitly prefixed by its length. If a sequence is not preceded by len++, the length is either fixed or implied by context.

and in this case, neither the length is fixed or implied by context
2024-10-25 10:33 dave: It is implied by the message length? If you want to read the entire message and decode it into an array I don't see what the difficulty is with this?
2024-10-25 10:34 xlchen: it is doable but the wording is confusing. there is no way to derive the block count purely from total message length 
2024-10-25 10:36 dave: > <@xlchen:matrix.org> it is doable but the wording is confusing. there is no way to derive the block count purely from total message length 

I agree, does that matter?
2024-10-25 10:36 xlchen: it is ok to keep as it is, but you could say something like when the array does not have length prefix, people should repeatedly decode the type until all the data are read [edited]
2024-10-25 10:37 xlchen: I am suggesting to improve the wording to make it less ambiguous otherwise you may get similar questions in future 
2024-10-25 10:58 dave: I'll try to clarify this
2024-10-25 13:33 dave: I've added a few sentences covering this particular case, hopefully clearer now
2024-10-27 19:42 danicuki: Screenshot 2024-10-27 at 19.42.22.png
  ↳ 2024-10-28 08:45 jan: I don't have a better name for this column, but the "RISC-V VM" doesn't really mean much. Just because a VM is RISC-V based doesn't mean squat. For example, see this table here in my benchmarks:

https://github.com/paritytech/polkavm/blob/master/BENCHMARKS.md#oneshot-execution-for-pinky

The "CKB VM" is also a RISC-V VM (and it's arguably even more RISC-V than PolkaVM/PVM, because it uses completely vanilla RISC-V) and yet it's, well, not that great if you look at the benchmarks. :P
  ↳ 2024-10-28 16:15 danicuki: Agreed. Maybe the advantage then is PVM itself? 
  ↳ 2024-10-28 16:55 tebdev: This was great work. Thank you for pulling it together. I can use this with some stakeholders on fence about Polkadot.
2024-10-27 19:42 danicuki: People pay attention when there is a table comparing different products. We all know JAM is the amalgamation of different breakthrough technologies. I tried to put this in a map, so we can use it when we explain JAM to others. It came from a conversation with ChatGPT, helping me to identify other chains that partially implement what we are doing in full on JAM. 

Here is the conversation link:
https://chatgpt.com/share/671e96b7-1e8c-800f-989a-04acc01f1bee

and this is the generated table (food for thought and debate)
Feedback is very welcome [edited]
2024-10-27 19:44 danicuki: Blockchain_Technology_Comparison_with_Finalized_Corrections.csv
2024-10-28 09:25 gav: The less ostentatious way would be to implement an Ethereum light client within a JAM service (or just use eg Snowfork, which essentially does that but in a parachain)
  ↳ 2024-10-28 15:45 sourabhniyogi: I don't see a way to follow your suggestion here
https://graypaper.fluffylabs.dev/#/293bf5a/206500206500
to make non-Polkadot ORUs validated in JAM. 

We would like to implement a Eth light client to do what Snowfork does and apply it usefully but don't see how it helps the non-Polkadot ORUs get validity.  It can only help non-Polkadot ZKRUs achieve finality more quickly, but its non-Polkadot ORUs that need their challenge window to disappear. [edited]
  ↳ 2024-10-28 15:56 sourabhniyogi: With non-Polkadot ORUs you don't win much of anything with verification of storage proofs against state root at B and storage proofs against the child of B.  For an ORU, the best we can really do is ensure blocks are available in DA, which is fine, but not the giant win -- you still need fraud proofs and a challenge window.  Or, I missed some critical insight of what you mean here
https://graypaper.fluffylabs.dev/#/293bf5a/206500206500
Did you mean for this to apply to ETH L2 ORU?

For useful JAM Services for non-Polkadot rollups its these:
(1) Basic DA for non-Polkadot RUs (ORU or ZKRU) 
(2) ETH Light Client Service
(3) Grandfatherable ZKRU, using (2)
but not
(4) Grandfatherable ORU, except for (1) [edited]
2024-10-28 09:48 tebdev: > <@gav:polkadot.io> The less ostentatious way would be to implement an Ethereum light client within a JAM service (or just use eg Snowfork, which essentially does that but in a parachain)

Very interesting, Help: would it be safe to say this is probabilistic trust versus absolute as a performance tradeoff?
2024-10-28 10:04 gav: Light clients generally are, yes. 
2024-10-28 10:10 gav: The good ones will only rely on sensible assumptions about the behaviour of validators. Most are not so good. A full node would manually verify the state transition and therefore give a solid guarantee of correctness. But regarding finality, it’s not so much about correctness and more about the validators committing to one of (potentially) several options. Such a commitment is generally correct per se and therefore about as secure on light (finality-tracking) as full (block-executing) nodes. 
2024-10-28 10:37 tebdev: > <@gav:polkadot.io> The good ones will only rely on sensible assumptions about the behaviour of validators. Most are not so good. A full node would manually verify the state transition and therefore give a solid guarantee of correctness. But regarding finality, it’s not so much about correctness and more about the validators committing to one of (potentially) several options. Such a commitment is generally correct per se and therefore about as secure on light (finality-tracking) as full (block-executing) nodes.

Yes non-sensible versus "sensible" in today's world may be more when versus if. ;) Games relying on rational actors is a concern. Bravo on using/funding multi programming languages. That is Nobel prize level stuff towards unstoppable ;) For direct multi-objective incentive mechanisms to counter non-rational actors, could the JAM framework consider incorporating game-theoretic approaches that weigh reputational and non-financial factors? In my humble view and experience NASH is not absolute with state actors when stoppable is a goal..
2024-10-28 11:33 tebdev: image.png
2024-10-28 11:37 tebdev: I could be way off, but I could not find this in Jam paper. Normal payoff with deviation added for irrational ... Mixed strategy. Resilience ... [edited]
2024-10-28 13:00 tebdev: Off-Equilibrium Paths thinking out loud... , Maybe Cantelli's inequality can help bound Dj irrational cost which may need treatment in ELVES. ELVES may deal with this, but not clear. Maybe update Game theory payoff model first as foundation to PoS, then show how ELVES would deal with system sensitivity to irrational actions. Maybe mixed incentives plus redistribution of stake. Slashing seems one dimensional, maybe slash and redistribute. [edited]
2024-10-28 17:21 charliewinston14: Hello. Question about erasure coding in JAM. I’ve broken the blob into pieces, and then those pieces into the octet pairs. The pairs were then converted to 16 bits. I’m now trying to figure out the field element formula. It looks to be the summation of each bit multiplied by “vj” and this is where I’m not sure what value to use. If j = 7, then vj = α14 +α4 +α. What is α here? 
2024-10-28 17:21 charliewinston14: Screen Shot 2024-10-28 at 1.20.33 PM.png
2024-10-28 22:30 danicuki: Presentations from teams at the JAM Meetup in Lisbon:

https://www.youtube.com/watch?v=7N2x6ulVA-E
https://www.youtube.com/watch?v=j-Qf25zuQ8w

Unfortunately, the camera didn't catch the two last presentations from PolkaJAM and Jamixir, so we will have to wait for sub0 / jam0 meeting in Bangkok for those. 
2024-10-29 04:39 xlchen: https://github.com/open-web3-stack/jam-dashboard we created a simple telemetry dashboard displaying chain head for Boka nodes. I can spend a bit time to document the RPC if anyone else is interested
2024-10-29 04:39 xlchen: Screenshot 2024-10-29 at 5.39.36 PM.png
2024-10-29 07:00 dakkk: > <@xlchen:matrix.org> https://github.com/open-web3-stack/jam-dashboard we created a simple telemetry dashboard displaying chain head for Boka nodes. I can spend a bit time to document the RPC if anyone else is interested

I'm interested in the RPC, and would be awesome to have the genesis state you used
2024-10-29 08:21 xlchen: we currently only have a helper to create genesis state in code directly. i can export it in some json format 
2024-10-29 17:50 dave: > <@dave:parity.io> I've uploaded a more fleshed out definition of the "simple" network protocol for JAM here: https://github.com/zdave-parity/jam-np/blob/main/simple.md

FYI I've made a minor modification to the availability protocols to discriminate elements of the justification sequences. This should hopefully allow simpler implementations. I've also removed some statements which I now realise were not accurate! See https://github.com/zdave-parity/jam-np/commit/7637e963cfd22fc452a957904b2f8d5ff181e67b and https://github.com/zdave-parity/jam-np/commit/032a7f14264c0e441c8e50d9c3c8504d5ac0c62c
2024-10-29 18:01 sourabhniyogi: image.png
2024-10-29 18:02 sourabhniyogi: Is the above suggestion to interpret EVM byte code using PolkaVM sane?  I didn't think it was sane until this week with the suggestion that JAM run an Ethereum full node and the above, which is truly ostentatious!  This is from 
https://vitalik.eth.limo/general/2024/10/26/futures5.html [edited]
2024-10-30 09:57 gav: > <@sourabhniyogi:matrix.org> Is the above suggestion to interpret EVM byte code using PolkaVM sane?  I didn't think it was sane until this week with the suggestion that JAM run an Ethereum full node and the above, which is truly ostentatious!  This is from 
> https://vitalik.eth.limo/general/2024/10/26/futures5.html

Optimistic to the max, as usual. 
2024-10-30 09:59 gav: Definitely reads like it’s written by a mathematician and not an engineer. 
2024-10-30 09:59 gav: But if you mean the bottom bit, yes it’s an idea. I don’t see it being readily implementable from what is written here. It is however something that Parity is working on within the smart contracts team.   [edited]
  ↳ 2024-11-05 06:46 sourabhniyogi: Here is my JAM Service design to follow through on the ostentatious suggestions
https://github.com/polkadot-fellows/RFCs/pull/130
I followed Rob H's feedback on "pursue all forks" instead of Jeff's for now (as well as the intuition of all the other Polkadot heavyweights, see #127) -- basically geth's Consensus API [recently added by karalabe in Sept] gets the state witnesses and it can feed into revm -- all good with JAM refine.  I am not sure how much work it will be to put revm through polkatool, but I am now optimistic we can do this.  

In addition to general feedback, do you have a better choice of Rust EVM interpreter than revm such that we can more easily achieve the goal of interpret EVM in PolkaVM?    [edited]
  ↳ 2024-11-05 07:33 gav: Not really. There may be some possibility of recompiling EVM bytecode into PVM, but Alex T and Jan would have a better idea of the feasibility of that than me.
2024-10-30 09:59 gav: I don’t see much in there except half-baked ideas and a general lamenting of the realities of building and maintaining real systems (rather than mathematical constructs).  [edited]
2024-10-30 11:19 dakkk: Should usage of LLM and similiar be allowed in JAM implementations? I think that since they are trained by the same data, they may introduce the same bug across multiple implementations
2024-10-30 11:56 gav: What do you mean “in JAM implementations”?
2024-10-30 11:56 dakkk: graypaper implementations*
2024-10-30 11:57 gav: By implementers to write code? Or by the code itself to govern its behaviour?
2024-10-30 11:57 dakkk: by implementers to write code using those tools 
2024-10-30 11:58 gav: No. LLMs shouldn’t generally be used to write code to be submitted. This would count as collusion.  [edited]
2024-10-30 12:01 dakkk: ok 👍️  it was already my opinion, but I asked since it is not specified in JAM prize rules.
2024-10-31 23:30 ycc3741: Hi I can't find my country in JAM Prize Interest Form 
2024-10-31 23:30 ycc3741: I'd already sent the mail to jam@web3.foundation and might need so help.
2024-11-01 04:17 keegan: Thanks ycc3741 just responded
2024-11-02 07:24 sourabhniyogi: sub0 schedule is up! 💓 😍 🥰

 https://agenda.sub0.gg/sub0-reset-2024/schedule/#2024-11-11 

Nov 11th is packed with JAM talks (or closely related topics) on the Main Stage, but also plenty of time and space to meet each other over lunch/coffee.

Registration is at: https://sub0.gg/
  ↳ 2024-11-02 08:07 prematurata: Sounds great. Unfortunately I cannot attend in person. Will talks be available on demand after the event?
  ↳ 2024-11-02 08:23 tomusdrw: No one from my team can attend too and we are fomoing hard, also curious if there is going to be a live stream or recordings available.
  ↳ 2024-11-05 19:01 vinsystems: Yes, Im interested as well if there is a live stream or recordings
2024-11-02 07:59 gav: Do we have somewhere to congregate on the 9th/10th?
  ↳ 2024-11-02 08:27 rektormoon: Yes you are welcome at sub0, we have the hacker space floor which is 24h and also some breakout rooms for more private sessions. 
2024-11-02 08:15 dakkk: > <@sourabhniyogi:matrix.org> sub0 schedule is up! 💓 😍 🥰
> 
>  https://agenda.sub0.gg/sub0-reset-2024/schedule/#2024-11-11 
> 
> Nov 11th is packed with JAM talks (or closely related topics) on the Main Stage, but also plenty of time and space to meet each other over lunch/coffee.
> 
> Registration is at: https://sub0.gg/

will it be available a live stream?
  ↳ 2024-11-02 08:36 rektormoon: Main stage will be live streamed :-)
2024-11-04 03:14 jam_man: Are we still accepting teams that work in python? I’m a PhD candidate in computation neuroscience and have a team interested in working on a python implementation. 
2024-11-04 03:17 jam_man: > <@jam_man:matrix.org> Are we still accepting teams that work in python? I’m a PhD candidate in computation neuroscience and have a team interested in working on a python implementation. 

I submitted an official application already. I am just wondering while we wait to hear back. 
2024-11-04 03:41 jam_man: Second question. How many milestones / how many rewards are left to be paid out. I don’t see an easy place to see that. Thanks !
2024-11-04 03:42 xlchen: GP is not yet finalized so it is not yet currently for anyone to deliver any milestones 
2024-11-04 03:43 jam_man: Thank you. Sorry but could you clarify what a GP is ?
2024-11-04 03:43 xlchen: graypaper
2024-11-04 03:43 jam_man: Gotcha thank you.👍
2024-11-04 03:44 xlchen: here are the participating teams: https://graypaper.com/clients/
2024-11-04 03:44 jam_man: Does that mean teams have not begun working yet? Or just that submission are halted until a finalized GP is out.
2024-11-04 03:46 xlchen: not everything are defined but many components are stable and people are working on those
2024-11-04 03:47 xlchen: https://github.com/gavofyork/graypaper this have bit more details
2024-11-04 03:47 jam_man: Are new teams still being accepted. Or is that list of clients you sent solidified
2024-11-04 03:47 xlchen: there is no acceptances, anyone are welcome to start a new implementation at any time
2024-11-04 03:48 xlchen: the list I shared is just a list of teams sharing they are participating. it is most likely not the complete list
2024-11-04 03:49 xlchen: the only thing matters is deliveries. e.g. no prize will be reserved for any teams
2024-11-04 03:51 jam_man: okay awesome thank you. 
2024-11-04 06:49 dakkk: > <@jam_man:matrix.org> Are we still accepting teams that work in python? I’m a PhD candidate in computation neuroscience and have a team interested in working on a python implementation. 

There are other two teams working using python here, you are in good company ;)
2024-11-04 06:51 jam_man: Exciting! What are the rules on how many python implementations can get rewards for each milestone, I don’t see any rules on that. 
2024-11-04 06:51 jam_man: Could all 3 python teams get rewards for all 5 mile stones?
2024-11-04 06:51 xlchen: https://jam.web3.foundation/rules
2024-11-04 06:52 jam_man: Ahh great thanks 
2024-11-04 06:52 jam_man: Was looking for something that extensive 👍
2024-11-04 06:55 jam_man: Oh actually I have seen / read that before. I didn’t see any clarification on how many times a specific language could produce an implementations. I know one team can only do one implementation for each milestone. But hypothetically could all the rewards go to teams that happen to be working on python. 
2024-11-04 06:57 xlchen: it is first-come, first-served so yes if for some reason all the python teams are faster than other teams in the same language set
2024-11-04 06:58 jam_man: Thank you good to know 
2024-11-04 07:01 jam_man: I assume the answer to this first question is no. But Is it considered colluding to join a team that has already been working.
 Secondly would it be considered colluding or against the rules to have communication with a teams even if it simply the prospect of joining their team. [edited]
2024-11-04 07:05 jam_man: Colluding I assume no to either. But would either of these need to be officially disclosed.
2024-11-04 07:06 xlchen: not sure if there is written rule about those situation but IMO, teams can definitely be able to grow. I guess the only thing that's not allowed is to having people transferring between two teams
2024-11-04 07:08 jam_man: Okay yeah, i assumed once two teams had already begun working the transfer of members between groups would be prohibited. But growing with new independent members was fine. 
2024-11-04 16:20 emielsebastiaan: > <@jam_man:matrix.org> I submitted an official application already. I am just wondering while we wait to hear back. 

I sent you a DM on X.
2024-11-05 02:13 xlchen: https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-129-state-request
I don't really understand about the boundary node part. can we have some examples? also examples for each message request/response will be super helpful
2024-11-05 15:02 dave: > <@xlchen:matrix.org> https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-129-state-request
> I don't really understand about the boundary node part. can we have some examples? also examples for each message request/response will be super helpful

As an example, say the trie looks like this:

           a
       b       c
     d   e   f   g
    h i j k l m n o

And we get a query where the start key matches leaf i and the end key matches leaf k.

We would return the key/value pairs from i,j,k. We would also return a,b,d,i,e,k as boundary nodes. These boundary nodes cover the paths from the root (a) to the start and end keys (leaves i and k). Note that there is quite a bit of redundant information returned here; more than necessary to prove presence of i,j,k in the trie. This might be changed in the full protocol; it's defined this way to hopefully make the boundary proof easy to build and verify.

If we get a query where the start key is _not_ in the trie, it is a bit more complicated as the boundary nodes need to cover the path where this key _would_ be found, if it was in the trie (in order to prove absence). If we imagine, for example, the same query but with the start key changed so it is greater than i's key but would still be found at the location of i in the trie. In that case, we would only return the key/value pairs from j and k, but the returned boundary nodes would be the same (a,b,d,i,e,k).

  ↳ 2024-11-05 20:31 xlchen: the boundary nodes is not length prefixed, so how am I suppose to know how many nodes are there?
  ↳ 2024-11-05 20:32 xlchen: also can you confirm each node is 64 bytes data?
  ↳ 2024-11-05 20:36 xlchen: I guess I will skip CE129 until we have some concrete test cases. it should only be used by light clients right? and maybe warp sync mode. otherwise I don't see why a fullnode need to make state request
  ↳ 2024-11-05 21:35 dave: > <@xlchen:matrix.org> the boundary nodes is not length prefixed, so how am I suppose to know how many nodes are there?

The boundary nodes are sent in their own message, you can determine the number of nodes from the message length
  ↳ 2024-11-05 21:36 dave: > <@xlchen:matrix.org> I guess I will skip CE129 until we have some concrete test cases. it should only be used by light clients right? and maybe warp sync mode. otherwise I don't see why a fullnode need to make state request

It will be used for warp sync, though finality proofs will also be needed for that which are not specified yet 😅
  ↳ 2024-11-05 21:37 dave: Should be possible to get by without it for now
  ↳ 2024-11-05 21:39 xlchen: we should have the proof format defined in GP if it is not already there. but JAMNP will be part if GP right? so that will happen eventually. will move this to bottom of my todo list for now
  ↳ 2024-11-06 00:22 dave: > <@xlchen:matrix.org> we should have the proof format defined in GP if it is not already there. but JAMNP will be part if GP right? so that will happen eventually. will move this to bottom of my todo list for now

The final network protocol will be in the GP yeah. Don't think the simple version will ever be as it's just a stepping stone
  ↳ 2024-11-06 00:25 dave: > <@jam_man:matrix.org> I’m just starting to look into this. So could someone help clarify some general questions about this “competition”. Is the goal to build a fully functional prototype of the JAM protocol in  your selected language (Python), closely aligned with the Gray Paper? Each milestone—covering state transitions, block importing, block production, PVM implementation, performance optimization, and security auditing—seems to reflect key sections of the Gray Paper, so I’m wondering if the intent is for us to create an end-to-end model of JAM’s core functionality in Python.

You should probably move this message to the main channel 😅
  ↳ 2024-11-06 00:25 jam_man: Ya that’s probably a good call 😅
2024-11-05 15:03 dave: Example requests/responses for the various protocols will probably be covered by test vectors at some point, at least where this makes sense. These don't exist yet though.
2024-11-05 16:27 jaymansfield: Hello all. We have been silently coding away but are happy to finally share our first public update here. We are working on a Java implementation of JAM, temporary name is JavaJAM. 

Currently we have the following sets of test vectors passing: codec, safrole, disputes, recent history, trie and as of today PVM tests are also all passing now. 

Next priority is networking so we can start or join a testnet. Let's keep building! [edited]
2024-11-06 00:17 jam_man: 
2024-11-06 02:45 bmaas: JamZig has landed at the Valia Hotel, Bangkok. Milestone #1: find koffie! ☕ [edited]
2024-11-06 12:28 sourabhniyogi: Does anyone have a Rust QUIC implementation demonstration showing the JAMSNP UP 0 handshake between Rust <> Rust?  

We can snowball a Go equivalent to match and show Rust <> Go (or whomever can contribute their own language), and I imagine everyone else can basically use this as a reference so JAMSNP connectivity issues are basically on par with FFIing into w3f's bandersnatch/ring-vrf+bls libraries (consistent with Rule 1).
  ↳ 2024-11-06 12:35 celadari: We are also interested in seeing that, because the quic part is still a blurry for us
  ↳ 2024-11-06 12:42 dave: I'd rather clarify the specification than provide an implementation, as this stuff will eventually need to go into the GP. Is there anything in particular that is unclear or in general it just needs fleshing out?
  ↳ 2024-11-06 13:53 sourabhniyogi: Ok.  We can post a Go <> Go implementation (since we'd probably do Rust <> Rust badly in some way) and folks can check if it matches the spec.  
  ↳ 2024-11-08 01:51 sourabhniyogi: https://github.com/jam-duna/jamtestnet/tree/main/jamnp/go
  ↳ 2024-11-08 01:51 sourabhniyogi: has a tiny skeleton -- if there is a Rust one we could connect them together and see if they made the same correct choices.
  ↳ 2024-11-11 18:52 tebdev: I suggest we have a discussion related to QUIC, one of the options I am researching wraps Rust for C++ but I think we should align on TLS library or not which seems to be a big dependency e,g, wolfSSL, LibreSSL, Boring OpenSSL, etc.
  ↳ 2024-11-11 18:53 tebdev: The team has more Polkadot experience than I do so looking for guidance, opinion. [edited]
  ↳ 2024-11-11 19:45 clearloop: > <@sourabhniyogi:matrix.org> has a tiny skeleton -- if there is a Rust one we could connect them together and see if they made the same correct choices.

Interesting, I'll start my rust implementation after devcon, imo a shared command line interface could be helpful for doing e2e tests with different clients
  ↳ 2024-11-11 20:21 dave: > <@sourabhniyogi:matrix.org> has a tiny skeleton -- if there is a Rust one we could connect them together and see if they made the same correct choices.

Thanks, will try to connect this with our implementation this week
  ↳ 2024-11-11 20:25 dave: > <@tebdev:matrix.org> I suggest we have a discussion related to QUIC, one of the options I am researching wraps Rust for C++ but I think we should align on TLS library or not which seems to be a big dependency e,g, wolfSSL, LibreSSL, Boring OpenSSL, etc.

IMO it would be preferable for implementations to use different TLS libraries to reduce the impact of vulnerabilities, possibly I'm misunderstanding
  ↳ 2024-11-11 20:26 dave: Also to avoid accidentally depending on the details of a particular implementation
  ↳ 2024-11-14 14:16 dave: > <@sourabhniyogi:matrix.org> https://github.com/jam-duna/jamtestnet/tree/main/jamnp/go

Not clear how I am supposed to run this? Looking through the implementation though I can see a few things that are not correct:

- Message size should be little-endian on the wire, as stated in the SNP doc.
- The block announcement protocol is supposed to be _persistent_ (hence the persistent in UP). In this repo it seems like it is opened for a single announcement and then closed again.
- The block announcement stream should be opened only by the peer which initiated the connection.
- The certificate's alternative name should be checked against its public key, see the SNP doc for details. The point of this is just to make things look more like the Web 2.0 case, which is what most QUIC libraries are designed to handle.
- Your handling of the connection<->public key association seems pretty sketchy, particularly considering that it is possible AFAIK to have multiple QUIC connections with the same IP:port endpoint.
  ↳ 2024-11-14 18:00 sourabhniyogi: Stellar feedback— will fix the first 4 next week and research how to do the last one, thank you! 
  ↳ 2024-11-14 18:03 dave: Fixing the last one _might_ be tricky. It's actually one of the main reasons polkajam uses Quinn instead of `s2n-quic`: with `s2n-quic` there seemed to be no easy way to access the certificate/public key used by the peer during the handshake.
  ↳ 2024-11-14 18:05 dave: Looks like the peer certificate can be accessed in quic-go via `ConnectionState().TLS.PeerCertificates`
2024-11-06 12:29 sourabhniyogi: We have some guesses as to how Ed25519 public keys are mapped into validator indexes but aren't super sure that our guesses are right.  So, having this mapped out in a Rust <> Rust working demo would make everything crystal clear.  
2024-11-06 12:39 dave: > <@sourabhniyogi:matrix.org> We have some guesses as to how Ed25519 public keys are mapped into validator indexes but aren't super sure that our guesses are right.  So, having this mapped out in a Rust <> Rust working demo would make everything crystal clear.  

The index of a validator is simply its position in the validator key list in the state. Is this what you weren't sure about or something else?
2024-11-06 12:50 sourabhniyogi: > <@dave:parity.io> The index of a validator is simply its position in the validator key list in the state. Is this what you weren't sure about or something else?

By this I mean if some node X connects to another node Y, node Y has to figure out which validator index X in the state it is.  Both X and Y have some ed25519 pub key, which are used in the TLS handshake with self-signed certs as per https://github.com/zdave-parity/jam-np/blob/main/simple.md#encryption-and-handshake -- so both X and Y use their [genesis] state -- something like https://github.com/jam-duna/jamtestnet/blob/main/traces/safrole/genesis.json#L81-L118 which use develop -- to basically map the pub key from the cert into a validator index in that state.  

That's the first part, which gets all the basic niceties of TLS mapping into validator indexes out of the way

Then the second part is everything here down to the exact "Unique Persistent" part
https://github.com/zdave-parity/jam-np/blob/main/simple.md#up-0-block-announcement

where we can just have some dummy data to support the `Handshake` and `Announcement`, maybe like every 6 seconds.
2024-11-06 12:52 sourabhniyogi: We can post our Go <> Go but I don't want to spread the wrong answer if someone has a Rust <> Rust correct answer?
2024-11-06 12:54 charliewinston14: Are third party libraries allowed for the QUIC protocol? The rules only mention crypto related ones but not all languages have it built in yet and would be a massive undertaking to write from scratch.
2024-11-06 12:55 dakkk: image.png
2024-11-06 13:03 sourabhniyogi: > <@charliewinston14:matrix.org> Are third party libraries allowed for the QUIC protocol? The rules only mention crypto related ones but not all languages have it built in yet and would be a massive undertaking to write from scratch.

Definitely as per Rule 1 "Third-party libraries for cryptographic primitives (erasure-coding, Bandersnatch, Ed25519), codecs (e.g. SCALE), and networking (e.g. QUIC) are acceptable." 
2024-11-06 13:04 sourabhniyogi: Has anyone succeeded with FFIing into one, just curious?
2024-11-06 13:06 dave: FWIW we're using Quinn at the moment in PolkaJam (Rust)
2024-11-06 13:10 sourabhniyogi: Ok for Quinn is there some snippet of rust that if we add to
 https://github.com/quinn-rs/quinn/blob/main/quinn/examples/server.rs#L168
gets at the Ed25519 pub key correctly?

And covers the generation of the self-signed certs. [edited]
2024-11-06 13:17 dave: Once you have a `Connection` in Quinn you can call `handshake_data` to get at the peer's certificate (https://docs.rs/quinn/0.11.5/quinn/struct.Connection.html#method.handshake_data)
2024-11-06 13:28 dave: > <@dave:parity.io> Once you have a `Connection` in Quinn you can call `handshake_data` to get at the peer's certificate (https://docs.rs/quinn/0.11.5/quinn/struct.Connection.html#method.handshake_data)

Ah sorry the function is `peer_identity`, not `handshake_data`
2024-11-06 13:32 dave: You should also set custom certificate verifiers for `rustls` to check the requirements given in the SNP doc. The requirement that the "alternative name" be derived from the public key was intended to fit with APIs that allow you to specify an expected name when connecting. eg In Quinn, `Endpoint::connect` takes an IP address and an expected name (https://docs.rs/quinn/0.11.5/quinn/struct.Endpoint.html#method.connect)
2024-11-06 13:38 sourabhniyogi: Got it -- It is sufficient to check the pub key, and ignore checking that the ip address in the metadata matches, right?   A latent background question is: why do we need/want ip address data on-chain? [edited]
2024-11-06 13:39 dave: There is no need to verify IP address/port no
2024-11-06 13:39 dave: These are included on-chain so that all validators know how to connect to each other
2024-11-06 13:40 dave: In Polkadot there is a DHT for this, which has some advantages (eg IP/port can be changed at any time), but overall we decided it was not worth the extra complexity
2024-11-06 13:52 sourabhniyogi: Ok, how are validators expected to change their ip/port  -- isn't this a slow process?  is allowing dns into the mix a reasonable move for the ip part?   It sure seems too easy to firewall out the entire network.  Probably a rabbit hole discussion to be saved for another day!
2024-11-06 14:16 dave: A new validator set can be specified every epoch, with new addresses for all the validators in the set. New validator sets are queued, but epochs are only an hour each, so a transition to a new IP address should take at most a few hours. There is at least one wrinkle in this: exported segments are expected to be available for 28 days. The validators holding them may not be elected as validators again, and so may not get a chance to "announce" new addresses. In all honesty I'm not totally clear on what the incentives are for these validators to remain online and continue serving requests for the old exported data.
2024-11-06 14:17 dave: Not sure what you mean by "It sure seems too easy to firewall out the entire network"
2024-11-06 14:18 dave: Re allowing DNS, don't have a strong opinion on this, though it would be less simple :)
2024-11-06 17:30 xlchen: there is little needs to change ip address with ipv6
2024-11-06 17:31 xlchen: we are using msquic btw and it offers callback to perform custom cert validation 
2024-11-07 02:05 jaymansfield: I have a question relating to JAMNP. For the ephemeral encryption key for the DH key exchange, is this also Ed25519? Or does it use TLS 1.3 default sig algorithms? [edited]
2024-11-07 02:19 xlchen: our implementation just use the default
2024-11-07 08:55 dave: You can just use the default settings for this, IIRC there is some negotiation to pick an algorithm both sides support
2024-11-07 13:14 emielsebastiaan: > <@gav:polkadot.io> Do we have somewhere to congregate on the 9th/10th?

Did anyone share any new details for the 9th or 10th on any gathering of implementer teams? Lmk 🙏🏻
2024-11-07 14:21 oliver.tale-yazdi: > <@emielsebastiaan:matrix.org> Did anyone share any new details for the 9th or 10th on any gathering of implementer teams? Lmk 🙏🏻

i think this is the most up-to-date link https://polkadot.subsquare.io/referenda/1024
2024-11-08 01:54 sourabhniyogi: For the 9th/10th  whoever gets there tomorrow first can find a spot/room and announce that spot for JAM builders here?

For the 11th-16th I updated https://polkadot.subsquare.io/referenda/1024 with food arrangement details.  

Happy travels all [edited]
2024-11-08 10:54 ycc3741: Hi. I consider that I need some help. I'd sent the mail to your team and asking for whether or when our team can be on the JAM Prize client page. Look forward to your response, I appreciate your efforts. Thanks a lot.
2024-11-08 11:19 gav: > <@ycc3741:matrix.org> Hi. I consider that I need some help. I'd sent the mail to your team and asking for whether or when our team can be on the JAM Prize client page. Look forward to your response, I appreciate your efforts. Thanks a lot.

There is a link for getting in touch with the W3F prize team on the [W3F JAM Prize page](https://jam.web3.foundation/)
2024-11-08 11:20 gav: That link doesn't seem to mention 9-10. Is there any info on where and who will attend on the 9-10? [edited]
2024-11-08 17:00 olanod: Random thought, perhaps off-topic...I was very briefly checking [hyperlight](https://github.com/hyperlight-dev/hyperlight) and their "micro vms" concept, it looks interesting and familiar to what we see with WASM runtimes or PolkaVM. Assuming 99% of chain infrastructure runs on x86_64 linux, would it be reasonable to support chain infrastructure running sandboxed binaries of the same architecture as the host machines?("polkavm micro vms" should still be possible).
2024-11-08 17:19 gav: Firstly, PVM is already pretty close in ISA to x86_64, by design, so x86 code should not be too hard to express as PVM. The harder part is making the I/O work - CPUs enjoy a much greater memory/disk random access bandwidth than blockchains due to the need to ferry data and prove correctness to all nodes involved in verifying. Secondly, the really hard part for a trustless ISA is gas accounting. A lot more becomes possible with effective secure deterministic metering and hyperlight doesn’t make any efforts to support this afaict.  [edited]
2024-11-08 17:25 olanod: yeah I don't think metering is in their radar and might not be trivial to implement.
2024-11-09 04:46 ycc3741: > <@gav:polkadot.io> There is a link for getting in touch with the W3F prize team on the [W3F JAM Prize page](https://jam.web3.foundation/)

Thanks a lot. I'd sent the.
2024-11-09 04:46 ycc3741: I'd send the pr. 
2024-11-09 04:47 gav: Maybe it’s worth setting up a group for those who will be in Valia Hotel over the next days?
2024-11-09 04:47 gav: [@emielsebastiaan:matrix.org](https://matrix.to/#/@emielsebastiaan:matrix.org) [@sourabhniyogi:matrix.org](https://matrix.to/#/@sourabhniyogi:matrix.org)?
2024-11-09 04:50 boymaas: > <@gav:polkadot.io> Maybe it’s worth setting up a group for those who will be in Valia Hotel over the next days?

Great idea! Feel free to add me too.
2024-11-09 04:51 sourabhniyogi: > <@gav:polkadot.io> Maybe it’s worth setting up a group for those who will be in Valia Hotel over the next days?

Can you be at valia after sub0 on 11th (you have the last talk) or on 12th ? 
2024-11-09 04:57 gav: As I have previously said, I’ll be in Thailand 9th and 10th only. 
  ↳ 2024-11-09 05:33 0xjunha: In the Sub0 agenda, I see you are giving a speech on 11th at the main stage, will it be virtual?

https://agenda.sub0.gg/sub0-reset-2024/talk/XKWVPR/
2024-11-09 04:57 oliver.tale-yazdi: > <@gav:polkadot.io> Maybe it’s worth setting up a group for those who will be in Valia Hotel over the next days?

kianenigma: and me are also in the area
2024-11-09 04:57 oliver.tale-yazdi: Currently sub0
2024-11-09 05:07 emielsebastiaan: I am around (sub0) and available. Same for danicuki 
2024-11-09 05:17 gav: JAM0 chat: https://app.element.io/#/room/#jam0:polkadot.io
2024-11-09 06:01 gav: No -in person but I’ll be leaving shortly afterwards. 9th and 10th are my only full days
2024-11-09 09:59 emielsebastiaan: We’ll have a JAM meetup for JAM Implementers in private meeting room (Meeting Room II) with beamer at Valia Hotel from 19:00h - 22:00h tonight (Valia Hotel Bangkok, Sukhumvit 24).
We’ll have plenty of pizza and drinks.   We can accommodate ~25 people. Agenda:
	1.	Team Introductions. We’d appreciate a 5-10 minute presentation about your team, reasons for implementing JAM, and some lessons learned.
	2.	Graypaper Questions and Answers
	3.	Planning, timelines, versions, milestones.
	4.	Suggestions for additional topics are welcome.
Please confirm your attendance.

One more important fact: Gavin will be joining.


2024-11-09 10:01 emielsebastiaan: Join chat to confirm attendance: https://app.element.io/#/room/#jam0:polkadot.io
2024-11-09 11:00 emielsebastiaan: I know it is a last minute call. But if you or your team is implementing JAM please join our little meetup. It is a great opportunity to get to know each other and converge on some common topics. 

We hope to see you in one hour. 
2024-11-09 11:20 emielsebastiaan: Meeting Room 2 can be found on the 18th floor and should be accessible by elevator. [edited]
2024-11-09 15:46 emielsebastiaan: ima_b848e0f.jpeg
2024-11-09 15:46 emielsebastiaan: ima_0087e61.jpeg
2024-11-09 15:46 emielsebastiaan: ima_d2fd7ea.jpeg
2024-11-09 15:46 emielsebastiaan: ima_d2c6157.jpeg
2024-11-09 15:46 emielsebastiaan: ima_4388d2e.jpeg
2024-11-09 15:46 emielsebastiaan: ima_ec8e5b7.jpeg
2024-11-09 15:47 emielsebastiaan: ima_24c082c.jpeg
2024-11-09 15:47 emielsebastiaan: ima_1bc1af5.jpeg
2024-11-09 15:47 emielsebastiaan: ima_c0934de.jpeg
2024-11-09 15:47 emielsebastiaan: ima_7755b40.jpeg
2024-11-09 15:47 emielsebastiaan: ima_5020b59.jpeg
2024-11-09 15:47 emielsebastiaan: ima_d1dbc71.jpeg
2024-11-09 15:47 emielsebastiaan: ima_9aeb50b.jpeg
2024-11-09 15:47 emielsebastiaan: ima_28c47bb.jpeg
2024-11-09 15:47 emielsebastiaan: ima_4601e36.jpeg
2024-11-09 15:48 emielsebastiaan: Lesson for next time: group picture. 

Thank you everyone for participating!!! 🙏🏻🙏🏻🙏🏻
2024-11-09 15:49 emielsebastiaan: Does anyone have a picture of me on stage?
2024-11-09 15:53 emielsebastiaan: Apologies Kamil, I did not take a picture of you on stage. 
2024-11-09 15:55 emielsebastiaan: We hope to share recordings of presentations in due time. 
2024-11-10 14:28 clearloop: If it is still possible to join the public implementation )) I sent the form from the get in touch button and waited reply for months, just know it already started xd [edited]
2024-11-10 14:44 xlchen: there is no need to get anyone’s approval before you can start it 
2024-11-11 03:47 oliver.tale-yazdi: Hey i added a tutorial for certificate generation, just in case if someone needs a straight forward way to crosscheck: https://docs.jamcha.in/advanced/networking/Certificates  
Also please LMK if this seems wrong to you, will try to use this for networking soon with other teams
2024-11-11 05:47 danicuki: Video with the JAM Roadmap to 1.0

https://www.youtube.com/watch?v=Jq8XBs1wPhg
2024-11-11 08:44 danicuki: I didn't know, but looks like someone already thought about running Doom on a blockchain and build it for Cardano. https://x.com/inputoutputhk/status/1824496224764039678?s=46&t=uDWflhDt4F1i47bMUn3yKA

Does anyone can explain the differences on JAM compared to the Cardano solution?
2024-11-11 08:47 xlchen: a 5s look it is still transaction based, which is fundamentally different compare to JAM, which is transactionless. ie no need anyone to trigger the execution 
2024-11-11 09:12 oliver.tale-yazdi: > <@danicuki:matrix.org> I didn't know, but looks like someone already thought about running Doom on a blockchain and build it for Cardano. https://x.com/inputoutputhk/status/1824496224764039678?s=46&t=uDWflhDt4F1i47bMUn3yKA
> 
> Does anyone can explain the differences on JAM compared to the Cardano solution?

Jan had a demo about this last year already: https://github.com/koute/polkadoom, so not sure who got the idea from whom
2024-11-11 09:16 emielsebastiaan: ima_ed13495.jpeg
2024-11-11 09:16 emielsebastiaan: https://canitrundoom.org/
2024-11-11 09:18 bkchr: > <@xlchen:matrix.org> a 5s look it is still transaction based, which is fundamentally different compare to JAM, which is transactionless. ie no need anyone to trigger the execution

Yeah and they are just committing the frames to the chain, while with JAM Doom itself could on a core and you just send the inputs as transactions
2024-11-11 09:18 bkchr: Would actually be some funny game. Like these twitch games. Everybody controls the movement
2024-11-11 10:02 ycc3741: Hi I had sent the pr which is #56 and accepted by the bot. 
I wonder when the website will be update.
Thanks a lot. Also, today's event on youtube is awesome and I really appreciate your effort.
2024-11-11 18:26 danicuki: I have a conceptual question about JAM: does JAM offer any guarantee of privacy for users? Wouldn't be possible that the validators node owner have access to the hardware memory and could see everything that is being executed in their own node, unencrypted?  
2024-11-11 18:47 tebdev: Good question and observation danicuki ! I have had clients that chose Corda and Hyperledger for this reason and others rolled their own blockchain e.g. JP Chase. Also does the Validator have a transport confidentiality requirement that justifies use of TLS? That then leads us to key lifecycle questions. [edited]
2024-11-11 20:36 dave: TLS is primarily for peer authentication and ensuring data integrity. The privacy aspect is not particularly important though it does matter in some cases (e.g. Safrole tickets would not be anonymous if everyone could see where they came from)
2024-11-11 20:42 dave: Re privacy within JAM, everything is public so anyone can see what is being computed. It would presumably be possible to have private computation in a service using ZK stuff though
2024-11-11 20:49 tebdev: > <@dave:parity.io> TLS is primarily for peer authentication and ensuring data integrity. The privacy aspect is not particularly important though it does matter in some cases (e.g. Safrole tickets would not be anonymous if everyone could see where they came from)

Thank you for clarifying. If I read this right the secuirty requirements are 1) authentication 2) data integrity (transport versus payload(Tx, Extrensic) ? ). Can you help me understand risk of Safrole ticket confidentiality requirement?
2024-11-11 20:58 dave: One of the goals of Safrole is to keep the identity of the selected block authors secret up until the point they actually author their blocks, to prevent them being DoSed for example. Tickets themselves are anonymous due to the RingVRF magic, but it is also important that the way tickets are distributed does not reveal their author. This is achieved by first sending each generated ticket to a randomly selected "proxy" validator who then distributes the ticket more widely. Anyone who sees this ticket get sent to the proxy validator can infer who created it so the sending should be private. Of course the proxy validator could itself be compromised, this is hopefully rare!
2024-11-11 21:00 dave: > <@tebdev:matrix.org> Thank you for clarifying. If I read this right the secuirty requirements are 1) authentication 2) data integrity (transport versus payload(Tx, Extrensic) ? ). Can you help me understand risk of Safrole ticket confidentiality requirement?

Re security requirements, for the transport between validators we definitely need authentication and integrity, otherwise the security arguments for the protocols built on top will fall apart
2024-11-11 21:11 tebdev: Please accept my apology in advance if I am too direct, The prize is not my primary incentive. I am trying to convince my stakeholders that Polkadot and JAM is the future. I ask questions to defend my Polkadot lemma. Very interesting ... "things fall apart" ... So Validator requires Trust to enable Trustless transactions. Does this indicate that Polkadot will become a CA since a key pair at server level a dependency for mTLS? [edited]
2024-11-11 21:15 dave: I meant only that if a validator thinks it's talking to another validator but is actually talking to someone else then that is bad
2024-11-11 21:15 dave: Don't think this is anything special to JAM
2024-11-11 21:16 tebdev: Agreed, but it seems to be a foundational element If not there may be confusion in the craft or my observation.

2024-11-11 21:18 tebdev: Please excuse me being a Polkadot neophite, but for one server to trust another keys, there must be trusted third party in a brokered trust model ... Right ?
2024-11-11 21:46 dave: If you identify servers by name then yes, but we just identify them by their public key
2024-11-11 21:46 tebdev: a public key is an identity as in authentication ... Right
2024-11-11 21:48 tebdev: In laymen terms public key (ID), private key (password) ... figuratively speaking
2024-11-11 21:49 tebdev: Ok the Server (1) is first party Server (2) is second party and Polkadot is trusted third party issueing keys to registered agents ... Private CA like Apple
2024-11-11 21:50 tebdev: In my humble view Polkadot is a private CA with all the rights, privileges and risk there unto appertaining ... ;)
2024-11-11 21:52 tebdev: Passport or a coin (staking) is just a hurdle any CA can legislate but in the end it is the same. trusted third party issuing trust with keys.
2024-11-11 21:58 tebdev: This is my humble Polkadot lemma . I am open to "reductio ad absurdum" ;), encourage it, welcome it because security a team quality sport. [edited]
2024-11-11 22:10 dave: > <@tebdev:matrix.org> Ok the Server (1) is first party Server (2) is second party and Polkadot is trusted third party issueing keys to registered agents ... Private CA like Apple

No, validators generate their own keys. There is no trusted third party or central authority
2024-11-11 22:12 tebdev: OK, then validator creates own keys, server (1) and server (2) , which is reasonable, but what is mechanisms for them to trust each other ... JAM/Polkadot
2024-11-11 22:12 dave: Unless you consider the blessed chain that can set the validators to be a central authority, which I can see
2024-11-11 22:12 tebdev: Yes, I used term issue, but registration is another option for a CA
2024-11-11 22:13 tebdev: You still roll up to brokered trust model in the end, just semantics on who and what you call it.
2024-11-11 22:14 tebdev: Crypto chicken and egg... ;)
2024-11-11 22:15 tebdev: Google app store uses the CA registration versus Apple which is issuer ...
2024-11-11 22:15 tebdev: Both valid, but tradeoffs, 
2024-11-11 22:19 tebdev: Polkadot as a Certificate Authority:
Since Polkadot is issuing or registering keys for the servers, it qualifies as a certificate authority (CA) if these keys are used to establish mutual trust. The registration or issuance process is still central to Polkadot being considered a CA.
In set notation, the formal definition becomes:

2024-11-11 22:19 tebdev: 
2024-11-11 22:22 tebdev: image.png
2024-11-11 22:23 tebdev: If JAM/Polkadot will leave trust to the validators then OK, that is the law... If not then the judge is JAM/Polkadot
2024-11-11 22:33 tebdev: Net/Net, I need some help with this as foundational element to QUIC Key Life Cycle. 
2024-11-11 23:12 dave: > <@tebdev:matrix.org> sent an image.

Don't understand this sorry 😅
2024-11-11 23:26 dave: > <@tebdev:matrix.org> Net/Net, I need some help with this as foundational element to QUIC Key Life Cycle. 

Not sure what the question is exactly, sorry. You can argue that the blessed service is a central authority because it decides the next validator set. But assuming you trust the previously elected validator set, this service just behaves according to its code, which in practice will elect validators based on the staking decisions of Dot holders; there is no central authority.
2024-11-11 23:27 xlchen: I don’t really understand the question but there is some kind of chain of trust for validator keys. The root is genesis validators. And then via beefy/grandpa anyone can validate if a block is sealed by a current validator by proofs and exposed identity will be validator keys, which include ipv6 address in metadata
2024-11-11 23:27 tebdev: Sorry , early and multiplexing. Here is a better explanation. 
2024-11-11 23:28 xlchen: the only centralized part is the genesis, which is possible to find someways to generate it in decentralized way
2024-11-11 23:30 tebdev: PolkadotasCA.pdf
2024-11-11 23:33 tebdev: > <@dave:parity.io> Not sure what the question is exactly, sorry. You can argue that the blessed service is a central authority because it decides the next validator set. But assuming you trust the previously elected validator set, this service just behaves according to its code, which in practice will elect validators based on the staking decisions of Dot holders; there is no central authority.

Good point, but staking is a gate that Polkadot can up/down vote . If Validator approved how does the QUIC get a key it will trust. This goes back to your "fall down" comment to avoid a bad actor/imposter
2024-11-11 23:35 tebdev: Even if we have Governance and voting, the governance body = Polkadot
2024-11-11 23:35 tebdev: Or better said Polkadot stakers
2024-11-11 23:55 dave: To answer "If Validator approved how does the QUIC get a key it will trust": the blessed service provides the keys when specifying a new validator set
2024-11-11 23:59 tebdev: Ok , fair enough ... NO arguments from me, trying to walk it down to get my head around it, Blessed Service = (Some Polkadot Community) = (Distributed Authority) --> Issue keys (X.509, EC, Dual Key Pair) = Certificate. So would an entity issuing certificates with some rules or authority be a CA?. 
2024-11-12 00:19 dave: Not sure what you mean by (X.509, EC, Dual Key Pair) = Certificate. Each validator has 2 public keys at the moment: an Ed25519 public key and a "Bandersnatch" public key. These are the keys that are provided when the blessed service specifies a new validator set. The nodes generate their own certificates containing their Ed25519 key. This is done only to keep the TLS protocol happy. The certificates are self-signed but these signatures are not expected to be checked. FWIW I wouldn't say the authority "issues" keys but rather selects keys that have been previously generated by nodes.
2024-11-12 00:23 tebdev: 
2024-11-12 00:28 tebdev: Ok, corrected...  I was being figurative in speech to say a dual key pair of a mutually agreed type. I may have got ahead of myself with "Certificate." If I am validator and I can be slashed, I would want a trust chain for this key signed and sealed by whomever sent it to me e.g. a "Certificate" ... This could be a Tx Extrinsic signature or a self contained root chain like X.509. QUIC and TLS best practice is X.509 to handle numerous risk scenarios. 
2024-11-12 00:31 tebdev: This can also be genesis related as Bryan Chen | Laminar & Acala mentioned to establish a trust chain.
2024-11-12 00:32 tebdev: The validator would check public key to whatever trust chain before assuming trust of another validator?
2024-11-12 00:33 xlchen: what do you mean by check publicly key? they are read from onchain state which are checked
2024-11-12 00:34 tebdev: This delegates risk of bad key to governing body or genesis to mitigate validator risk
2024-11-12 00:34 xlchen: the risk of a few bad keys are minimal. that’s what PoS about (which is not part of GP)
2024-11-12 00:36 tebdev: Well, in all my security training we can 1) accept risk, 2) defer risk 3) mitigate risk ... Just need know which one is being asserted.
2024-11-12 00:36 tebdev: I am easy ;)
2024-11-12 00:37 tebdev: The flip side, I must be transparent to stakeholders when I explain. Then they chose to accept risk [edited]
2024-11-12 00:38 xlchen: GP implicitly covers the part of the maximum damage can be done by few bad keys
2024-11-12 00:38 xlchen: ie not possible to have bad reports to be finalized 
2024-11-12 00:40 tebdev: Fair enough, can you provide document. I am easy, but those that care will ask where did key come from and how can we trust it? If we just defer / accept risk , then that must be reveiwed for indemnification. 
2024-11-12 00:40 xlchen: the risks are mitigated 
2024-11-12 00:41 tebdev: OK, I am novice, help me understand
2024-11-12 00:41 xlchen: it is not possible for example to finalize a bad parachain block currently in polkadot 1.0. same for JAM
2024-11-12 00:42 tebdev: Hmm, I think we comparing apples to oranges... ;)
2024-11-12 00:44 xlchen: they are same. there are auditing process defined by GP to ensure bad reports will be identified and reported and having bad validators to be removed
2024-11-12 00:48 tebdev: I am only focused on QUIC server (1) <--> Server (2) TLS handshake now. Respectfully, I think what you referring to comes lager ... 
2024-11-12 00:49 xlchen: then the max damage is dos, which is nothing 
2024-11-12 00:50 xlchen: I am talking about max damage of a bad key
2024-11-12 00:50 xlchen: there is little damage can be done on network level
2024-11-12 00:52 xlchen: of course the node must implement the usual networking best practice. ie rate limiting, peer reputation, message sanitation etc
2024-11-12 00:54 xlchen: it will be bad for example if everyone is using openssl with another heartbleed bug. and that’s why we should use different libraries [edited]
2024-11-12 00:59 tebdev: Key management with X.509 is an industry best practice when using TLS even if QUIC(TLS) ., We can decide not to do that, but needs to be a decision at some level or maybe backlogged as issue to keep moving forward.
  ↳ 2024-11-12 01:07 xlchen: if you can identify vulnerabilities of the current approach, just show it and I am sure the next version of the networking spec will be adjusted to fix it
2024-11-12 01:03 tebdev: > <@xlchen:matrix.org> it will be bad for example if everyone is using openssl with another heartbleed bug. and that’s why we should use different libraries

I agree, but think we should discuss use of different sources. I developed "Aerospace" and Crititical infrastructure code... commented deciding to do clean room and funding it was Nobel Prize level for unstoppable. We should seek unstoppable for the network too.
2024-11-12 01:05 sourabhniyogi: For those of you not in Bangkok, this is from this weekend's JAM0 meetup with Gav

 https://www.youtube.com/watch?v=Jq8XBs1wPhg
 https://x.com/colorfulnotion/status/1856135098929951219

Its more detailed than the sub0 talk of yesterday, so JAM implementers won't want to miss it!
2024-11-12 01:15 tebdev: To be clear, I have no dog in fight, I am following Sr. Polkadot guys.  I just want to know where dogs may fight to avoid it ;)
2024-11-12 01:17 tebdev: Maybe we agree QUIC keys are either issued or registered and tied to some authority to establish a trust chain and put in backlog as issue. ... I am flexible.
2024-11-12 01:19 xlchen: we are not going to make adjustments just because some people may have false understanding of security. we can provide more education content to explain why our approach is secure but if people insist on useless addition, well, I don’t know, I am not going to make my life harder because of that
2024-11-12 01:20 xlchen: there IS a chain of trust already 
2024-11-12 01:20 xlchen: it is not like people can become validators as they want
2024-11-12 01:21 dave: SNP uses certificates only because this is the path of least resistance: basically all QUIC libraries are designed for the Web 2.0 use case of a client connecting to a server via a name like google.com. In that case you need a certificate chain and trusted root to establish a link between google.com and a public key. In the case of JAM, we start with a public key so the certificate stuff is all somewhat pointless. It's just hoop jumping so that the protocol can be implemented without having to hack around with QUIC libraries too much. In a perfect world we would just use some noise protocol (http://www.noiseprotocol.org/) and there would be no certificates involved.
2024-11-12 01:21 tebdev: Fair enough. I did ask to help me understand as neophyte. I am too old to argue and to fat to fight. Also I am flexible and easy. I just ask for explanation so I can explain to others that rely on me. 
2024-11-12 01:22 tebdev: NO one asked you to change. I do not know where you got that. 
2024-11-12 01:22 tebdev: I hope this is safe place for open dialogue. 
2024-11-12 01:23 tebdev: Security = Quality, Quality = teamwork, Teamwork = open mind
2024-11-12 01:24 xlchen: > <@tebdev:matrix.org> Maybe we agree QUIC keys are either issued or registered and tied to some authority to establish a trust chain and put in backlog as issue. ... I am flexible.

this read like a change request? anyway, nothing personal. I don’t mind this kind of discussion. always happy to discuss things and I understand I maybe wrong as well
2024-11-12 01:24 tebdev: At the end it says "I am flexible" ;)
2024-11-12 01:26 tebdev: If you do not want something in backlog, I am OK. I just document and move on. I am truly easy...
2024-11-12 01:29 tebdev: I was asking for help to understand since I was not in the room when the design was developed. David was a good sport and made me think... this should be fun :)
2024-11-12 01:31 tebdev: No worries I am headed to Ethereum conference. I got people asking me about that one too. Maybe we catchup later with a beer. I have very open mind.
2024-11-12 03:49 danicuki: My initial question about security was exactly similar to Boy s condition: I am very happy to be building JAM. And can't keep this happyness within myself: I share what I am doing with others. People outside have many questions. I know how to answer most of them, but some are trickiest. 

That's why I ask here. We know some people are more specialists than me.  I am like Boy, kind of new to Polkadot. One idea would be to maybe include a FAQ section in the graypaper website or any other place might be convenient. 
2024-11-12 04:05 danicuki: If computation done in JAM is "public" - because hardware owner can read the memory - does this mean that some applications are not suitable for JAM, because of its design? Or am I missing something? [edited]
2024-11-12 06:54 emielsebastiaan: This is the point of having a public world computer. You can build private systems on a public infrastructure you cannot build a public system on a private infrastructure. 
2024-11-12 07:09 tebdev: World Computer  ... Indeed. Eth BT discussed that in keynote ... L1 = The Trust, L2 = The GPU ... Hmmm this sounds like Polkadot but with more validators 
2024-11-12 07:10 tebdev: hmmm [edited]
2024-11-12 13:21 olanod: Any word or place to discuss on the capabilities of the vm(during refine at least), i.e. what syscalls/host-functions would be available to guest programs? is it going to be very limited, fixed and jam specific or is it something that could evolve over time? I like the approach of WASI, after its MVP that provided basic std support(e.g IO with file descriptors), it's evolving into a flexible "component model" where interfaces are defined with the [WIT IDL](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) and based on the platform different bundles("worlds") are defined, interfaces can also include higher level capabilities like http clients or ML primitives(e.g. wasi-nn). Could we do something similar or better yet just use the same stuff? I imagine the Polkadot fellowship could be in charge of discussing via RFCs what goes in this "jam world" and jam implementers would be expected to support the agreed on capabilities.
2024-11-12 17:06 gav: JAM is a trustless supercomputer. this implies that it's a global singleton. whatever it does must be universally agreed. this is why we go to great pains to write a single formal specification that exactly describes correct behaviour in any possible circumstance. [edited]
2024-11-12 17:08 gav: if you can find a way to express an http client (or indeed any real-world I/O) in such a way, feel free to make a PR to the graypaper. [edited]
2024-11-12 17:09 gav: but i think you'll find it's a fool's mission.
2024-11-12 17:10 gav: (this is because the correct behaviour of an HTTP request is totally dependent on factors which cannot be universally agreed including network status, timing, server response, physical interface characteristics, ...) [edited]
2024-11-12 17:11 gav: without doing a comprehensive analysis i'd expect that the same is true for pretty much all useful sys calls.
2024-11-12 17:12 gav: there may be some which expose computation machinery which can be universally agreed upon to be available (e.g. a particular amount of "GPU gas"). this could _potentially_ be an in-core resource down the line. [edited]
2024-11-12 20:23 charliewinston14: Question about JAMNP. For the preferred initiator equation the last part has just (a < b) where a and b are ed25519 keys. What is meant by that comparison?
2024-11-12 21:08 alxmirap: hi, in my understanding, this equation is the XOR of 3 booleans, or equivalently 1-bit values. a and b are 32-byte arrays, but in essence they can be thought of as  very large numbers of the same size, so they can be sorted numerically. Then, a < b is literally their numerical comparison. 

Given that they are of the same domain, if they are both represented in, say, hex strings of the same size (as in, don't ignore leading 0s) then an alphabetical comparison should be equivalent to the numerical one.
2024-11-12 21:23 tebdev: > <@alxmirap:parity.io> hi, in my understanding, this equation is the XOR of 3 booleans, or equivalently 1-bit values. a and b are 32-byte arrays, but in essence they can be thought of as  very large numbers of the same size, so they can be sorted numerically. Then, a < b is literally their numerical comparison. 
> 
> Given that they are of the same domain, if they are both represented in, say, hex strings of the same size (as in, don't ignore leading 0s) then an alphabetical comparison should be equivalent to the numerical one.

agree with your statement, in C++ not a problem going from hex to int , If very large use Boost library ;)
2024-11-12 22:39 gav: > <@charliewinston14:matrix.org> Question about JAMNP. For the preferred initiator equation the last part has just (a < b) where a and b are ed25519 keys. What is meant by that comparison?

a and b are 32 byte quantities. They can be compared using a standard dictionary comparator. 
2024-11-12 22:55 tebdev: > <@gav:polkadot.io> a and b are 32 byte quantities. They can be compared using a standard dictionary comparator.

Agreed... good point. Using a "dictionary" more efficient std::lexicographical_compare, but depending on language including C++ can just be...  return hexStr1 < hexStr2, but do not want to speak for other languages.
2024-11-12 23:04 tebdev: > <@xlchen:matrix.org> this read like a change request? anyway, nothing personal. I don’t mind this kind of discussion. always happy to discuss things and I understand I maybe wrong as well

Please excuse, philosophically I agree this is better served as PR to JAM YP to avoid being disruptive. I am new to this project.
2024-11-13 05:59 haikoschol: At the JAM0 meeting yesterday we discussed what kind of dev tools we might want.

ltfschoen  just described how he is using TDD to implement Safrole, adding comments to the tests that reference the relevant part of the graypaper.

If those comments were in a specific format, a tool could identify changes to the graypaper that impact the behaviour those tests cover. Maybe the tool could use links to the fluffylabs reader (diffing HTML might be brittle though). Or it could use the LaTeX source.

Does that sound reasonable/useful to anyone?
2024-11-13 08:50 leonidas_m: Hello, given that passing the state-transition conformance tests is required for Milestone 1, do we need to fully implement the validator-core assignment logic as detailed in Section 11.3, or can we temporarily mock this for now (M1)?
2024-11-13 08:54 dakkk: > <@leonidas_m:matrix.org> Hello, given that passing the state-transition conformance tests is required for Milestone 1, do we need to fully implement the validator-core assignment logic as detailed in Section 11.3, or can we temporarily mock this for now (M1)?

g and g* are required for guarantees extrinsic validation, so you need to implement 11.3 in order to check the validity of a block
2024-11-13 17:12 tomusdrw: > <@haikoschol:matrix.org> At the JAM0 meeting yesterday we discussed what kind of dev tools we might want.
> 
> ltfschoen  just described how he is using TDD to implement Safrole, adding comments to the tests that reference the relevant part of the graypaper.
> 
> If those comments were in a specific format, a tool could identify changes to the graypaper that impact the behaviour those tests cover. Maybe the tool could use links to the fluffylabs reader (diffing HTML might be brittle though). Or it could use the LaTeX source.
> 
> Does that sound reasonable/useful to anyone?

We are using the links to the reader heavily in our code (duh!) and I think this kind of tool would make perfect sense.
I've passed that to the team and I think we can figure something out.

There is no need to parse HTML, because the reader link contains synctex blocks which point exactly to the latex source line that contains the selection. So it's just a matter of checking if that particular latex source line has been changed between versions.
  ↳ 2024-11-14 01:21 sourabhniyogi: Wish you were here, you have a growing fan base -- I think one topic we want to know your thoughts on is what the import format for State should be 
 https://trie.fluffylabs.dev/ 
Option 1: https://github.com/jam-duna/jamtestnet/blob/main/traces/safrole/jam_duna/traces/373496_0.json
Option 2: 
https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-129-state-request

We would adjust Option 1 format to whatever you support today/tomorrow -- there are some details of lossiness in the service storage we are fretting over but there is no debate that with a little bit of work on your part to import some key-vals we can all benefit from a shared "state root" hasher and be like "what leaves do we differ on" so much faster!

  ↳ 2024-11-14 09:06 tomusdrw: I think we can easily support both 31-bytes and 32-bytes input to the trie tool. We drop the last byte anyway right after the import. Let me prepare a PR for this.
  ↳ 2024-11-15 00:28 sourabhniyogi: Eager to try it out and get your feedback on this, which I hope we can make as compatible as possible

https://hackmd.io/nk0Tr0iIQHmLm7WIXe_OoQ?both
2024-11-14 07:00 sourabhniyogi: Should CE 129 have 31-byte keys in the response or 32-byte keys in the response?

We believe it would be beneficial to have responses be *not* 31 bytes but instead 32 bytes, in order for a full range scan of CE129 (from 0x00...00 to 0xFF..FF) to have full 32-byte keys (and of course values) hashable into a comparable state root.   

Generating state roots with the 31 bytes, given the lossy service storage, is not possible -- but having 32 byte keys requires a tad more bookkeeping to match up with some UI like this https://trie.fluffylabs.dev/ 
  ↳ 2024-11-14 13:04 dave: The response has 31-byte keys. This is explicitly stated in the SNP doc: `Key = [u8; 31] (First 31 bytes of key only)`
  ↳ 2024-11-14 13:06 dave: The last byte of the key is ignored in the trie so I'm not sure including it makes sense
  ↳ 2024-11-14 13:08 dave: You can do a full range scan and recompute the state root from the returned key/value pairs. Of course the idea is that you know the state root in advance and use it to verify the responses you receive
  ↳ 2024-11-15 22:29 sourabhniyogi: Are we to compute state roots from 31 byte keys?  This detail escaped our attention … checking what we missed. 
  ↳ 2024-11-26 04:18 sourabhniyogi: David Emett: Filed an issue / recommendation here [edited]
  ↳ 2024-11-26 04:24 sourabhniyogi: https://github.com/zdave-parity/jam-np/issues/1 [edited]
2024-11-14 07:57 dakkk: There will be a video of the today JAM implementers meetup at Bangkok? 
2024-11-14 09:28 tomusdrw: > <@sourabhniyogi:matrix.org> Should CE 129 have 31-byte keys in the response or 32-byte keys in the response?
> 
> We believe it would be beneficial to have responses be *not* 31 bytes but instead 32 bytes, in order for a full range scan of CE129 (from 0x00...00 to 0xFF..FF) to have full 32-byte keys (and of course values) hashable into a comparable state root.   
> 
> Generating state roots with the 31 bytes, given the lossy service storage, is not possible -- but having 32 byte keys requires a tad more bookkeeping to match up with some UI like this https://trie.fluffylabs.dev/

IMHO it's better to just use `31-byte` for everything. I don't see a reason for this extra byte being useful at all.

Also I'd love to see the node hash truncated to 255bits everywhere to allow trie manipulation without recomputing the hash. If you merkelize everything from scratch, there is obviously no issue, but if you allow adding/removing nodes it's sometimes required to recompute the last bit in case the node moves from left to right branch.
2024-11-14 10:16 sourabhniyogi: > <@dakkk:matrix.org> There will be a video of the today JAM implementers meetup at Bangkok? 

We will have a second session on Friday at 11am and will share notes, but no recording :( 
2024-11-14 10:17 dakkk: got it (y) I'm a bit confused about those meetups, aren't a potential occasion of violating collusion rule? [edited]
2024-11-14 11:16 emielsebastiaan: Videos for the Saturday meetup have been published. We mostly got to know each other a bit better and got an opportunity to ask questions with Gavin present.
 I was also present at the Tuesday meetup. I can assure you we did not discuss anything that violates (collusion) prize rules. That said, I am no longer in Bangkok now.
 Discussion on Tuesday was mostly related to:  1. Awareness of tooling that is already present and useful for everyone (e.g. fluffylabs)

2. Creating a list of things that would be useful besides the implementations (such as telemetry, explorer, cli flags, docker, RPC, other uis, etc)

3. Some coordination/scoping of M1, M2 priorities in order to have some form of cross-client testnet as initiated by Colorful Notion with useful phases to get implementer teams on board.

4. Discussion on having a (private) monthly call for implementers to further discuss on these topics. 
It would be great if we can get notes out here on the chat. 1. To be transparent, 2. To follow up with actionable items. [edited]
2024-11-14 11:20 emielsebastiaan: Video’s Saturday: https://youtube.com/playlist?list=PLjGN96vX3BTKjLfBd5LimBuDuch-QfKPy&si=JyiUssgVrnaIdXqo

Scroll down to the end of the playlist. 
2024-11-14 11:37 emielsebastiaan: Notes by Oliver Tale-Yazdi - async and sourabhniyogi here: https://matrix.to/#/!KKOmuUpvYKPcniwOzw%3Amatrix.org/%24DL2Vsua2TFzSAZDzOYO4pH0A6Ud7cABS6C49vBZhx28
2024-11-14 17:32 prematurata: hey davxy , starting from the [padded ring commitment](https://github.com/davxy/jam-test-vectors/commit/2d71c3f76ac89aaf57abd892cc691841fa225c87) commit i am having issues in generating posterior_gamma_z. I've seen you changed all gamma_zs so I find it hard to pinpoint what changed at that point in time. Can you help out? 
2024-11-14 17:36 prematurata: > <@prematurata:matrix.org> hey davxy , starting from the [padded ring commitment](https://github.com/davxy/jam-test-vectors/commit/2d71c3f76ac89aaf57abd892cc691841fa225c87) commit i am having issues in generating posterior_gamma_z. I've seen you changed all gamma_zs so I find it hard to pinpoint what changed at that point in time. Can you help out?

ah i see ark-ec-vrfs also changed 2 months ago. Updating the underlying dependency fixed my issues. sorry for ping
2024-11-14 18:42 tomusdrw: 
2024-11-14 18:42 tomusdrw: > <@tomusdrw:matrix.org> We are using the links to the reader heavily in our code (duh!) and I think this kind of tool would make perfect sense.
> I've passed that to the team and I think we can figure something out.
> 
> There is no need to parse HTML, because the reader link contains synctex blocks which point exactly to the latex source line that contains the selection. So it's just a matter of checking if that particular latex source line has been changed between versions.

You ask, we provide: https://www.npmjs.com/package/@fluffylabs/links-check
2024-11-15 13:00 danicuki: Here is the video with JAM 1.0 detailed road map presented by Gav last week:

https://youtu.be/Jq8XBs1wPhg?si=8KvEZdAyeqeqaYP7
2024-11-15 19:20 sourabhniyogi: We would like to get systematic-ish access to the toaster to test V=1023 in mid-December after spinning up medium sized kubernetes cluster in Google Cloud of around V=384.  What do we do exactly? 
2024-11-15 20:09 gav: Wait until it’s built, for a start
2024-11-15 20:09 gav: mid-December is likely to be around the right timing though
2024-11-15 21:48 sourabhniyogi: Are there some smaller toaster configurations / parameters that could be appropriately be considered the Kusama JAM chain (and Paseo JAM chain) or are they going to be the same V? [edited]
2024-11-15 21:56 gav: I’d default to the same size unless there’s good reason to change it.  [edited]
2024-11-15 21:57 gav: As for the spec I’d have thought around 50% of the performance would be about right. 
2024-11-15 22:22 sourabhniyogi: I was thinking slightly more than V=341 for Paseo and slightly less than V=682 for Kusama (which could fit into the V=1023 toaster hardware) so as to grow like 1-2-3 but if that means teams spend time on appendix H variations it might not be worth it.  
2024-11-15 22:40 sourabhniyogi: In the big picture, is refine suitable for zk proof generation ? Are there any GPU resources per chance in this toaster we could use for some zk proof generation side use case? 
2024-11-16 08:44 gav: > <@sourabhniyogi:matrix.org> In the big picture, is refine suitable for zk proof generation ? Are there any GPU resources per chance in this toaster we could use for some zk proof generation side use case? 

No and it’d be dumb anyway. 
2024-11-16 08:45 gav: Refine is already trustless. 
2024-11-16 08:45 gav: ZK proof generation is verifiable. That’s the whole point of it. 
  ↳ 2024-11-16 22:22 sourabhniyogi: Thanks for confirming that JAM should only be used to verify ZK proofs, and that the JAM Toaster has no role to play in being a ZK prover network itself.  How should JAM State integrate the results of ZK prover networks then, esp those powering rollups, in fulfilling its role as a rollup host?

Some underlying context, related to accumulate/integration:
https://github.com/gavofyork/graypaper/issues/134#issuecomment-2480827857


2024-11-16 15:18 ycc3741: Sorry, I would like to clarify whether we should mock the imported block to test the import functionality, or if there is any data already provided by Parity?
2024-11-16 16:04 davxy: Some vectors related to WP reporting STF (Section 11 - Part 2) are now available.
As always, your feedback is most welcome.

https://github.com/w3f/jamtestvectors/pull/20
2024-11-16 16:05 davxy: https://github.com/davxy/jam-test-vectors/blob/work-reports/reports/README.md
  ↳ 2024-11-18 06:19 shwchg: is the entropy need to go into the state?
2024-11-16 22:27 gav: Rollups take time to get from sequencing through to fraud-detection-period. JAM gives certainty faster. This allows message/value transfers to happen almost instantaneously. JAM may or may not be competitive with ZK rollups. Difficult to tell since they’re currently vapourware. 
  ↳ 2024-11-16 22:31 sourabhniyogi: Besides production-grade implementation, what would you need to see in "turn your ORU into ZKRU" prover networks like this OP Succinct
 https://github.com/succinctlabs/rsp
to not consider them vapourware?  
2024-11-16 22:33 gav: Just that. 
2024-11-16 22:34 gav: An actual, economically viable, production implementation which works with fully Turing complete computation on the level of a JAM core and doesn’t take several minutes to get from sequencing to finality.  [edited]
  ↳ 2024-11-22 01:44 sourabhniyogi: Ok, I did some research on Succinct today and got some data on latency and ballpark costs =).  How much do you think a days worth of ZK proofs of finality (not proofs of validity, which was what I was doing in RFC #130) in the sense of
https://x.com/pepyakin/status/1857647576293716164
should cost per day to be "economically viable" for
(a) Ethereum
(b) Base
I got 32 blocks (a checkpoint's worth) of ZK proofs for (a) and at least for OP Stack and Arbitrum its easy to have similar estimates for that fraction of the rollup ecosystem. [edited]
  ↳ 2024-11-22 12:35 gav: Ok so that’s $10m/year for ~25tps. All told, JAM should be able to handle around 1m tps. Equivalent cost for zk proofs alone (ignoring sequencing, finality and DA costs) would be maybe $400b/year. 

And (via ELVES), JAM gets secure validation of transactions in 12-18seconds, as opposed to zk, which takes 1 hour.  [edited]
  ↳ 2024-11-22 13:01 sourabhniyogi: image.png
  ↳ 2024-11-22 13:03 sourabhniyogi: https://explorer.succinct.xyz/proof/01jd8c8x6rermrft701efck1k3
  ↳ 2024-11-22 13:04 sourabhniyogi: ZK proving a single ETH block in the public prover network takes 2-3 mins, like $0.16-0.32.  This is "noise" in the grand scheme of everything in present day.  The way they approach OP Stack (Base, Optimism, ..) is running private prover networks so latency is reduced.  You scale the private prover network based on how many "cycles" the prover needs.  To prove ETH needs ~ 25 Million cycles/sec, requiring a certain number  + kind of GPU to achieve (e.g. 50-100 GPUs of Nvidia L4s) [edited]
  ↳ 2024-11-22 13:05 sourabhniyogi: The cost of a 32block checkpoint is $5-10.  You have to pay more to get latency down.
  ↳ 2024-11-22 23:11 sourabhniyogi: For https://graypaper.fluffylabs.dev/#/911af30/3f8e003f8e00 $W_P$ = 12MB (the maximum size of a work package)  how did you choose this 12MB number?

I'm seeing that these "compressed" proofs are over 6MB 
https://gist.github.com/sourabhniyogi/c054965807711ff7ad62ff251edded9e
so it appears "Groth16" proofs are the primary proof (since PLONK takes 1.5mins)
https://docs.succinct.xyz/generating-proofs/proof-types.html#compressed
  ↳ 2024-11-23 07:57 gav: > <@sourabhniyogi:matrix.org> For https://graypaper.fluffylabs.dev/#/911af30/3f8e003f8e00 $W_P$ = 12MB (the maximum size of a work package)  how did you choose this 12MB number?
> 
> I'm seeing that these "compressed" proofs are over 6MB 
> https://gist.github.com/sourabhniyogi/c054965807711ff7ad62ff251edded9e
> so it appears "Groth16" proofs are the primary proof (since PLONK takes 1.5mins)
> https://docs.succinct.xyz/generating-proofs/proof-types.html#compressed

12mb came from expected bandwidth implications on nodes. 
2024-11-16 22:46 sourabhniyogi: For "JAM may or may not be competitive with ZK rollups" why not take an approach of "If you can't beat them, JOIN them" (pun intended 😅 , Join-Accumulate ZRKUs) by aiming to have the worlds ZKRU proofs  indexed in JAM DA along with all ORU proofs of validity for rollups that cant afford ZK prover networks.  It seems to be the winning approach?
2024-11-16 22:48 gav: Feel free to make whatever service you feel you can sell.  [edited]
  ↳ 2024-11-18 00:56 sourabhniyogi: Do you believe the "JAM ecosystem" should cut across multiple Web3 ecosystems and aim for a not only a Polkadot JAM Chain but a { Ethereum, Bitcoin, Cardano, ... } JAM Chain with beefy finality proofs cutting across all of these JAM Chains?     Or should there be just ONE trustless JAM supercomputer?

I believe on this question of what we can sell with X JAM Chain is about 
(a) the technical problem (with elegance of "coprocessors") re beefy finality 
and
(b) the social problem of tribalism + branding (of "Polkadot Cloud" being the only place for JAM protocol vs X JAM Chain for X ecosystem for X = {Polkadot, Ethereum, Bitcoin, Cardano, X/DOGE ...}).  
If the JAM protocol wants us to do its bidding (instead of us wanting the JAM protocol to do our bidding) then how should JAM ecosystem participants vs DOT stakeholders reason about problems (a) vs (b).   Can you provide guidance on both problems? [edited]
  ↳ 2024-11-18 10:38 gav: Well, in the context of the JAM Prize, which is in DOT and KSM, JAM is a protocol for use explicitly for the Polkadot and Kusama ecosystems.
  ↳ 2024-11-18 10:38 gav: However, at the end of the day, JAM is a protocol and as such largely agnostic to where it is used.
  ↳ 2024-11-18 10:40 gav: I don't see why Cardano would drop all their tech and move to a JAM protocol.
  ↳ 2024-11-18 10:40 gav: Nor any other ecosystem.
  ↳ 2024-11-18 10:41 gav: Polkadot does it because a) it's explicitly made to be compatible with what already exists and b) it already has a good amount of expertise on JAM within the ecosystem.
  ↳ 2024-11-18 10:42 gav: I do think that JAM can potentially do a lot to close the gap between bridged-Ethereum and L2-Ethereum, which to a large extent is merely a psychological and branding gap. [edited]
  ↳ 2024-11-18 10:44 gav: It's not a question of just "spinning up more JAM chains"
  ↳ 2024-11-18 10:44 gav: There needs to be a validator base for each one, and thus for a trustless chain, there needs to be a staked token of high value for each one.
  ↳ 2024-11-18 10:46 gav: You could launch "Sourabhinicoin" of course and launch an SourabhiniJAM on the back of it, but making the coin worth anything (and thus the network secure) would come down to token marketing, and if you're good at that then you probably don't need to bother becoming world experts in the Graypaper. [edited]
  ↳ 2024-11-18 10:49 gav: In short I wouldn't be too keen to start thinking about launching your own instance of a JAM network.
  ↳ 2024-11-18 10:51 gav: I'm not really sure what you're trying to say here, but overall I would advise that making services which are *useful to people* is (as always) the thing you should be focusing your efforts on (beyond creating JAM, of course).
  ↳ 2024-11-18 10:52 gav: Launching a new instance of JAM does nothing for this; in fact it fragments the JAM-service-ecosystem and actually hampers all our efforts.
  ↳ 2024-11-18 10:53 gav: If you think that the Ethereum service you suggested would be helpful to people (presumably those in the Ethereum ecosystem), then you should definitely launch it, and resell JAM Coretime adding (and extracting) value to it.
2024-11-17 18:29 rustybot: > <@prematurata:matrix.org> hey davxy , starting from the [padded ring commitment](https://github.com/davxy/jam-test-vectors/commit/2d71c3f76ac89aaf57abd892cc691841fa225c87) commit i am having issues in generating posterior_gamma_z. I've seen you changed all gamma_zs so I find it hard to pinpoint what changed at that point in time. Can you help out? 

@[prematurata | TSJam] 

https://github.com/davxy/jam-test-vectors/blob/safrole-ring-signatures-update/safrole/README.md#%EF%B8%8F-warning--%EF%B8%8F
2024-11-19 06:42 sourabhniyogi: Pictures from JAM0 are up on Polkadot forum:
 
https://forum.polkadot.network/t/jam0-jam-implementers-meetup-sub0-devcon-7-bangkok-nov-11-nov-16-2024/10866

If you enjoyed the event and want to do a similar event again in late Winter / early Spring 2025, please post something there, thank you all for making this a special week for everyone! [edited]
2024-11-19 06:53 sourabhniyogi: Please retweet https://x.com/colorfulnotion/status/1858765451071000716 =)
2024-11-19 16:04 danicuki: Useful PVM invocation dependency created by Luke | Jamixir  
2024-11-19 16:04 danicuki: 
2024-11-19 16:04 danicuki: image.png
2024-11-19 17:06 ycc3741: Pardon. Regarding Appendix D. In State Merklization, do we need to manually implement the serialization and encoding functions B and L ourselves, or are there available libraries for this?
  ↳ 2024-11-19 18:21 luke_fishman: don't know what language you work in, it probably has a util to represent a decimal as a binary.
i don't see why you would need a library for that.


  ↳ 2024-11-19 18:22 luke_fishman: anyways I think you're expected to implement it on your own
  ↳ 2024-11-20 14:12 ycc3741: What I mean is, when I read a block, I will need to generate a new block, which would require a new H_r, right? In that case, wouldn't serialization and Merkle trees be necessary? Or did I misunderstand something?
  ↳ 2024-11-20 14:40 ycc3741: Oh i see  what you mean
  ↳ 2024-11-20 14:40 ycc3741: thanks a lot
2024-11-19 21:55 jaymansfield: > <@sourabhniyogi:matrix.org> Pictures from JAM0 are up on Polkadot forum:
>  
> https://forum.polkadot.network/t/jam0-jam-implementers-meetup-sub0-devcon-7-bangkok-nov-11-nov-16-2024/10866
> 
> If you enjoyed the event and want to do a similar event again in late Winter / early Spring 2025, please post something there, thank you all for making this a special week for everyone!

Wish we could have been apart of this!
2024-11-20 19:04 danicuki: Hi davxy, would you please explain what is this "entropy" in input? Shouldn't entropy be part of the pre_state? 

https://github.com/davxy/jam-test-vectors/blob/7dc0f5cee1552bd535a4cd76836b9d2a279fb878/reports/tiny/anchor_not_recent-1.json#L55
2024-11-20 19:16 greywolve: Isn't this because the entropy pool doesn't change, so it's just an input? [edited]
2024-11-20 20:17 danicuki: Actually I don't see why we can't simple use only pre-state and block as inputs. In the end, STF is just this: inputs are blocks and state. Would be much simpler than having another "input" which, in the end, must be transformed into some block and state to run the STF. 
2024-11-20 23:48 xlchen: can we please having the PRs in the jamtestvectors merged? it is not fun to try to run tests against with all those branches. it is not like we can't update the tests after they are merged
2024-11-21 06:58 rustybot: > <@danicuki:matrix.org> Actually I don't see why we can't simple use only pre-state and block as inputs. In the end, STF is just this: inputs are blocks and state. Would be much simpler than having another "input" which, in the end, must be transformed into some block and state to run the STF. 

Right. I'll move it to the state
2024-11-21 07:29 sourabhniyogi: A test vector in the codec with a full JSON + JAM-codec for state (C1-C15 _and_ some service account 42) with a precise state root (to get the 31 vs 32 byte key detail resolved) would be terrific -- I imagine it should follow this: https://graypaper.fluffylabs.dev/#/911af30/358101358101
2024-11-21 09:45 gav: > <@xlchen:matrix.org> can we please having the PRs in the jamtestvectors merged? it is not fun to try to run tests against with all those branches. it is not like we can't update the tests after they are merged

We're working on doing this now
2024-11-21 12:03 gav: JPEG image-46E2-99A7-AC-0.jpeg
2024-11-21 12:04 gav: JAM Toaster/Polkadot Palace internet uplink speed test. [edited]
2024-11-21 12:04 gav: Some other JAM Toaster pics...
2024-11-21 12:04 gav: JPEG image-4D01-A7E4-92-0.jpeg
2024-11-21 12:04 darkartistry: > <@gav:polkadot.io> sent an image.

How far apart were the machines 
2024-11-21 12:04 gav: JPEG image-498F-958B-74-0.jpeg
2024-11-21 12:05 gav: JPEG image-4EC7-BFE3-64-0.jpeg
2024-11-21 12:05 gav: > <@darkartistry:matrix.org> How far apart were the machines

This is internet uplink.
2024-11-21 12:05 gav: > <@gav:polkadot.io> sent an image.

Power distribution racks.
2024-11-21 12:05 gav: > <@gav:polkadot.io> sent an image.

Insulated panels for JAM Toaster enclosures.
2024-11-21 12:05 gav: > <@gav:polkadot.io> sent an image.

Installing the panels.
2024-11-21 12:06 darkartistry: What is the costs of maintaining this toaster ? 
2024-11-21 12:06 darkartistry: 100k per month ? Based on the uplink speed … 
2024-11-21 12:08 gav: Wouldn't know.
2024-11-21 12:08 gav: I don't think it's anything nearly as expensive as that though
2024-11-21 12:10 vinsystems: Amazing! 🤩 
2024-11-21 12:12 gav: Data_Center_video.mp4
2024-11-21 12:12 darkartistry: The monthly cost of a 1 Gbps (Gigabit per second) connection in data centers varies based on several factors, including geographic location, service provider, and specific service requirements. Here’s an overview:

Geographic Variations:
	•	North America and Europe: In these regions, transit costs are relatively low. For instance, a 1 Gbps connection might be priced around $10 per Mbps per month, totaling approximately $10,000 monthly. However, actual prices are often lower due to competition and peering agreements. ￼
	•	Asia: Transit pricing is significantly higher, approximately seven times that of North America and Europe. This means a 1 Gbps connection could cost around $70,000 per month. Peering arrangements can reduce this cost, but the effective price remains higher than in Western regions. ￼

Service Provider Examples:
	•	Dedicated Internet Access (DIA): For a 1 Gbps DIA circuit, prices can vary. A general guide suggests that any 500 Mbps+ DIA circuit priced under $1,000 per month is considered a solid deal, though this is typically outside data centers. ￼
	•	Colocation Services: Colocation providers often offer bandwidth as part of their packages. For example, some providers include 1 Gbps connections in their colocation plans, with overall monthly costs ranging from $79 for a single server to $599 for a full rack. These prices encompass space, power, and bandwidth. ￼

Additional Considerations:
	•	Peering vs. Transit: Engaging in peering agreements can significantly reduce bandwidth costs compared to purchasing transit from Tier 1 providers. The extent of peering varies by region and provider.
	•	Data Center Location: Data centers in regions with higher operational costs, such as Asia, may charge more for bandwidth. Conversely, facilities in areas with lower costs may offer more competitive pricing.
	•	Service Level Agreements (SLAs): Premium SLAs with guaranteed uptime and performance may increase costs.

In summary, while a 1 Gbps connection in data centers can range from under $1,000 to over $70,000 per month, the actual cost depends on various factors, including location, provider, and specific service requirements. It’s advisable to consult directly with data center providers to obtain accurate and tailored pricing.
2024-11-21 12:12 gav: And here's a simple 3d model of the final setup
2024-11-21 12:12 darkartistry: > <@darkartistry:matrix.org> The monthly cost of a 1 Gbps (Gigabit per second) connection in data centers varies based on several factors, including geographic location, service provider, and specific service requirements. Here’s an overview:
> 
> Geographic Variations:
> 	•	North America and Europe: In these regions, transit costs are relatively low. For instance, a 1 Gbps connection might be priced around $10 per Mbps per month, totaling approximately $10,000 monthly. However, actual prices are often lower due to competition and peering agreements. ￼
> 	•	Asia: Transit pricing is significantly higher, approximately seven times that of North America and Europe. This means a 1 Gbps connection could cost around $70,000 per month. Peering arrangements can reduce this cost, but the effective price remains higher than in Western regions. ￼
> 
> Service Provider Examples:
> 	•	Dedicated Internet Access (DIA): For a 1 Gbps DIA circuit, prices can vary. A general guide suggests that any 500 Mbps+ DIA circuit priced under $1,000 per month is considered a solid deal, though this is typically outside data centers. ￼
> 	•	Colocation Services: Colocation providers often offer bandwidth as part of their packages. For example, some providers include 1 Gbps connections in their colocation plans, with overall monthly costs ranging from $79 for a single server to $599 for a full rack. These prices encompass space, power, and bandwidth. ￼
> 
> Additional Considerations:
> 	•	Peering vs. Transit: Engaging in peering agreements can significantly reduce bandwidth costs compared to purchasing transit from Tier 1 providers. The extent of peering varies by region and provider.
> 	•	Data Center Location: Data centers in regions with higher operational costs, such as Asia, may charge more for bandwidth. Conversely, facilities in areas with lower costs may offer more competitive pricing.
> 	•	Service Level Agreements (SLAs): Premium SLAs with guaranteed uptime and performance may increase costs.
> 
> In summary, while a 1 Gbps connection in data centers can range from under $1,000 to over $70,000 per month, the actual cost depends on various factors, including location, provider, and specific service requirements. It’s advisable to consult directly with data center providers to obtain accurate and tailored pricing.

These were why I estimated 100k 
2024-11-21 12:13 gav: I'm not certain but I think it was more around 5k/mon
2024-11-21 12:14 gav: maybe quite a bit less
2024-11-21 12:14 darkartistry: Cooooool !!! 
2024-11-21 12:14 gav: but i know they had to lay a new fibre line so it took a while to get installed
2024-11-21 12:14 darkartistry: Nice I’ll follow closely on the progress ! 🙇🏻‍♂️🙇🏻‍♂️🙇🏻‍♂️
2024-11-21 12:16 vinsystems: Is in Portugal?
2024-11-21 12:18 gav: Yes - at the Polkadot Palace in Cascais
2024-11-21 12:19 gav: the existing pool is used as a giant heat sink for the toaster
2024-11-21 12:19 gav: So the toaster is located in an underground concrete "bunker" next to the pool's filtration system
2024-11-21 12:22 subotic: cool 😀 good luck with the construction 🍀🍀🍀 I hope all goes smoothly.
2024-11-21 12:27 gav: me too:) aiming to have phase 1 complete EOY
2024-11-21 12:30 gav: that's 86 machines, each with 96 cores, simulating full JAM with 8 cores/node. it'll then be extended by 85 more machines (phase 2) so each node has 16 cores and we'll be quite close to the final node spec. [edited]
2024-11-21 12:34 gav: close enough, i expect, for effective modelling and experimentation. [edited]
2024-11-21 12:34 xlchen: is it possible to expose some heat sink somehow for it to be used as a real toaster
2024-11-21 12:35 gav: i'll ask :)
2024-11-21 14:44 danicuki: > <@gav:polkadot.io> Yes - at the Polkadot Palace in Cascais

What is the Polkadot Palace? Is it a space open to community? Can we make JAM0 there in March/2025?
2024-11-21 14:50 gav: Yes, JAM0 gatherings can probably take place there in due course. But it's currently under heavy redevelopment and is unlikely be usable before 2026.
2024-11-21 14:54 danicuki: Maybe we can make JAM0/March in a nearby hotel, close to Cascais, and have a tour to the datacenter. Would this be possible? I am already planning next JAM0, this is so exciting!
2024-11-21 15:44 subotic: > <@danicuki:matrix.org> Maybe we can make JAM0/March in a nearby hotel, close to Cascais, and have a tour to the datacenter. Would this be possible? I am already planning next JAM0, this is so exciting!

I would love that 👍
  ↳ 2024-11-21 17:06 celadari: Me too 👌✨
2024-11-21 17:00 gav: Definitely
2024-11-21 17:03 boymaas: Amazing! 😎 It’s an honour to be part of this process so unique to our times. 🚀✨ 
2024-11-21 17:08 dakkk: I made this tool in order to track graypaper equations inside jampy between different graypaper releases. If someone needs it, it is public: https://github.com/dakk/jambiato [edited]
2024-11-21 17:08 dakkk: image.png
2024-11-21 17:52 danicuki: > <@gav:polkadot.io> Definitely

Please share the dates you will be in town in March/25 so we setup things to have you with us during JAM0.
2024-11-22 04:43 rithy: I came late in the group. Which country is JAM0 planning to host?
2024-11-22 05:54 danicuki: > <@rithy:matrix.org> I came late in the group. Which country is JAM0 planning to host?

Next JAM0 will be in Portugal / March 2025
2024-11-22 06:17 rithy: Thank you for the information 
2024-11-22 12:37 gav: 
2024-11-22 13:05 danicuki: > <@rustybot:matrix.org> Right. I'll move it to the state

I propose something similar for "output" in test vectors. Why do we have this "output"? Why don't simple put every side effect of STF into post_state branch?

For exemple, here:

```
consume_authorization_once-1.json

            "reported": [
                {
                    "work_package_hash": "0x63c03371b9dad9f1c60473ec0326c970984e9c90c0b5ed90eba6ada471ba4d86",
                    "segment_tree_root": "0x5c9dca800c145685f052ce1ba343e2b66b4c333ee4c4ca3b29cb347b1009cb83"
                }
            ],
            "reporters": [
                "0x22351e22105a19aabb42589162ad7f1ea0df1c25cebf0e4a9fcd261301274862",
                "0x5c7f34a4bd4f2d04076a8c6f9060a0c8d2c6bdd082ceb3eda7df381cb260faff",
                "0x837ce344bc9defceb0d7de7e9e9925096768b7adb4dad932e532eb6551e0ea02"
            ]
```

would it be better to put these "output" into ρ  on post_state?
  ↳ 2024-11-22 20:32 celadari: - `reporters` should be output because they represent bold R in the graypaper

- now, `reported` => I wonder what part of the GP it represents ? If anyone knows ???
2024-11-22 13:08 danicuki: Generally speaking, test vectors should have only:
"input" => contain all extrinsic and header information
"pre_state" => all info related to previous state
"post_state"  => expected post_state will all relevant components change
"output" => only "error / error name" or "ok"
2024-11-22 15:23 ycc3741: Hi, I wonder wether we should sort the hash value by "Lexicographical Order".
2024-11-22 20:58 celadari: Hey guys, a few questions on the work report test vectors:

- in the state part of the .json (`"pre_state"` or `"post_state"`) we have fields `bytes` and `items` => what do they represent in the GP ? If I go to the chapter 9,service accounts, I see `s`, `p`, `l`, `c`, `b`, `g`, `m` but I don't see what fields they could represent. I guess I would have to parse/decode `bytes` and `items` to get `p`, `l`, `s` but I don't see how. I feel there is something I'm not seeing. Also there are 6 fields in the .json but the GP has 7 elements.
- I put here a question I put in a comment (just to centralize my questions): in the `"output"` field we have the field `"reported"` => what variable in the GP does it represent ? [edited]
2024-11-22 21:11 jaymansfield: > <@celadari:matrix.org> Hey guys, a few questions on the work report test vectors:
> 
> - in the state part of the .json (`"pre_state"` or `"post_state"`) we have fields `bytes` and `items` => what do they represent in the GP ? If I go to the chapter 9,service accounts, I see `s`, `p`, `l`, `c`, `b`, `g`, `m` but I don't see what fields they could represent. I guess I would have to parse/decode `bytes` and `items` to get `p`, `l`, `s` but I don't see how. I feel there is something I'm not seeing. Also there are 6 fields in the .json but the GP has 7 elements.
> - I put here a question I put in a comment (just to centralize my questions): in the `"output"` field we have the field `"reported"` => what variable in the GP does it represent ?

There is a definition of items/bytes at the start of section 9.3
  ↳ 2024-11-22 21:24 celadari: I see, thank yoou for the answer.

Follow-up question: aren't they computed using equations at section 9.3 ? What I mean is => shouldn't we store them/consider them as state variables ?
2024-11-22 21:37 rick: Will the Safrole test vectors be updated to match the codec? Looks like it's just EpochMarks adding tickets-entropy, so nbd but it did trip up my tests. 
2024-11-23 17:31 danicuki: I have a doubt about work report test vectors, on services list. What are "bytes" and "items" fields are? Should'nt `s`: Storage dictionary (D⟨H → Y⟩)  `p`: Preimage lookup dictionary (D⟨H → Y⟩) and  `l`: Preimage lookup dictionary be provided as well?

2024-11-23 17:39 danicuki: Also on the same tests, I don't see slot or next_validators provided. Is it correct? Because when slot is not provided in previous state, there is a key rotation and since next_validators are also not provided, we come to a situation with empty validators set
2024-11-23 17:43 jaymansfield: > <@danicuki:matrix.org> I have a doubt about work report test vectors, on services list. What are "bytes" and "items" fields are? Should'nt `s`: Storage dictionary (D⟨H → Y⟩)  `p`: Preimage lookup dictionary (D⟨H → Y⟩) and  `l`: Preimage lookup dictionary be provided as well?
> 

There is a definition of items/bytes at the start of section 9.3
2024-11-23 17:44 jaymansfield: Slot # is provided in the input for the report vectors (it’s right above entropy) [edited]
2024-11-23 17:45 danicuki: > <@jaymansfield:matrix.org> Slot # is provided in the input for the report vectors (it’s right above entropy)

I assume slot in the input is the header slot. What about pre_state slot? 
2024-11-23 17:47 jaymansfield: > <@danicuki:matrix.org> I assume slot in the input is the header slot. What about pre_state slot? 

I think for pre state slot we just used the input slot subtracted by one
2024-11-23 17:48 danicuki: Why isn't this explicit in the test vectors? How could I guess this? [edited]
2024-11-23 17:56 jaymansfield: > <@danicuki:matrix.org> Why isn't this explicit in the test vectors? How could I guess this?

It might not really matter what value you use. The tests only really cover validating guarantees and updating state afterwards. I don’t think we did anything special for epoch updates in relation to it. 
2024-11-23 20:22 oliver.tale-yazdi: At JAM0 we talked briefly about how to construct the Dev account secret keys, I followed the approach of the test vectors now and updated the accounts here https://docs.jamcha.in/basics/dev-accounts  [edited]
2024-11-24 14:48 gav: signal-2024-11-22-170556_002.jpeg
2024-11-24 14:48 gav: signal-2024-11-22-171645_002.jpeg
2024-11-24 14:48 gav: signal-2024-11-22-174613_002.jpeg
2024-11-24 14:48 gav: signal-2024-11-22-174723_002.jpeg
2024-11-24 14:48 gav: A few more pics from the building of the Toaster
2024-11-24 14:49 gav: The first batch of racks has arrived. One of the enclosures is finished. And there's the copper power cable (it's very thick) and conduit. That's for the ~100kW power draw. Thankfully the Palace has a ~300kW power line so we're good for now. [edited]
2024-11-24 14:55 boymaas: Racks in, power set, lots of movement!—this setup is getting ready to run some rock-solid, efficient Zig code. ⚡🚀😎
2024-11-24 15:36 emielsebastiaan: 1.21 Gigawatts Great Scott ⚡️ 
2024-11-24 17:45 prematurata: > <@boymaas:matrix.org> Racks in, power set, lots of movement!—this setup is getting ready to run some rock-solid, efficient Zig code. ⚡🚀😎

Or some interpreted code like typescript :) 
2024-11-24 23:57 xlchen: I have published a docker image for Boka so that it can be used to test networking compatibility https://hackmd.io/HsBZpvxQSXOBMSu0Z3ciFA?view cc Oliver Tale-Yazdi - (back on 25th) 
2024-11-25 03:11 sourabhniyogi: Can someone suggest a better name for this ambiguous JSON attribute `tree_root`

https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/codec/data/work\_item.json#L8

like `segment_root_or_work_package_hash`  before we fall in love with `tree_root` ...

Origin of the concept is https://graypaper.fluffylabs.dev/#/911af30/19e30019e300 [edited]
2024-11-25 09:58 dakkk: davxy: regarding codec tests, is it correct to assume that data is valid? for instance, in the block test (https://github.com/w3f/jamtestvectors/blob/master/codec/data/block.json), should extrinsic_hash correspond to the computed hash of the given extrinsic?
2024-11-25 10:20 tomusdrw: AFAIR it was mentioned earlier that the codec test data is not valid semantically. It should be decoded successfully, but it doesn't necessarily make any sense in JAM context. [edited]
2024-11-25 10:21 dakkk: > <@tomusdrw:matrix.org> AFAIR it was mentioned earlier that the codec test data is not valid semantically. It should be decoded successfully, but it doesn't necessarily make any sense in JAM context.

ok my bad (y) thank you for re-clarifying it
2024-11-25 10:28 rustybot: @[dakkk | JamPy] https://github.com/w3f/jamtestvectors/tree/master/codec#semantic-correctness
2024-11-25 10:29 dakkk: > <@rustybot:matrix.org> @[dakkk | JamPy] https://github.com/w3f/jamtestvectors/tree/master/codec#semantic-correctness

yep, understood
2024-11-25 11:48 tomusdrw: I believe the `W_X` in `export` host call definition: https://graypaper.fluffylabs.dev/#/911af30/33ae0033b100 should rather be `W_M` (i.e. the maximal number of imported/exported items). The former doesn't seem to be defined anywhere. [edited]
2024-11-25 11:57 gav: > <@tomusdrw:matrix.org> I believe the `W_X` in `export` host call definition: https://graypaper.fluffylabs.dev/#/911af30/33ae0033b100 should rather be `W_M` (i.e. the maximal number of imported/exported items). The former doesn't seem to be defined anywhere.

https://github.com/gavofyork/graypaper/pull/150/commits/968dc94aec3e9cada4b177b44ef7320a16ecc434
2024-11-25 11:57 gav: Will be in 0.5.1
2024-11-25 19:12 piotrzwolinski: 
2024-11-25 19:14 piotrzwolinski: Hello JAM Community!

Over the past few weeks, the FluffyLabs team has been finalizing the first official release of the PVM Debugger (https://pvm.fluffylabs.dev). Alongside this, we’re preparing a proposal for retroactive funding from the Polkadot Treasury to support the development of this tool. We also plan to continue expanding its features in the near future.

We’ve started a discussion about the planned Treasury proposal on Polkassembly: https://polkadot.polkassembly.io/post/2578 and would greatly appreciate your feedback. Please don’t hesitate to ask any questions or share your thoughts!
  ↳ 2024-11-25 19:20 oliver.tale-yazdi: Could this be something for the Fellowship Treasury?  
It did not see many proposals yet, so I don't know, but it could be worth exploring.
  ↳ 2024-11-25 19:45 dave: This is neat, not sure in practice how useful it will be for debugging large programs. I have some experience testing/debugging a processor implementation, which is a sort of similar problem to creating a PVM implementation. The most useful tool there was one which compared execution traces from the real processor and a reference implementation. Whether such a tool would be feasible or worthwhile for PVM I'm not sure.
  ↳ 2024-11-26 09:30 tomusdrw: > <@oliver.tale-yazdi:parity.io> Could this be something for the Fellowship Treasury?  
> It did not see many proposals yet, so I don't know, but it could be worth exploring.

What would be a good place to figure out if it's actually a good idea? General treasury seems to be a more of a beaten track, but we are open for discussion.
  ↳ 2024-11-26 09:32 tomusdrw: > <@dave:parity.io> This is neat, not sure in practice how useful it will be for debugging large programs. I have some experience testing/debugging a processor implementation, which is a sort of similar problem to creating a PVM implementation. The most useful tool there was one which compared execution traces from the real processor and a reference implementation. Whether such a tool would be feasible or worthwhile for PVM I'm not sure.

Yes, debugging large programs is yet to be figured out. The low hanging fruits that come to my mind (and we have them on our roadmap) are:
1. Supporting/folding basic blocks
2. Supporting debug symbols

We already support running two PVMs in parallel and stopping on the first difference. So comparing to reference implementation should be easy, figuring out why the code is not working correctly for given set of inputs (actually debugging the program in question) might need some extra work.
  ↳ 2024-11-26 18:21 sourabhniyogi: As soon as polkatool + CoreChains (presumably a very very large service) has "eureka!" from PolkaJAM (in solving the same problem as the Polkadot Relay Chain does for a couple dozen blocks), every JAM implementer will be able to use this to support matching the same results, which probably will touch almost everything in Appendix A + B.  

However, its critical to have the scope include all the host functions to take a "PVM debugger" seriously, which means you kind of have to extend out to the "host" with a reasonably complex "X Context" \[accumulate\] and "(m,e)" \[refine\], extending to  imported segments, gas details, and probably a bunch of other host state.  Having a well defined interface (RPC + codec) between a JAM implementation _with host state_ and the PVM Debugger is a must, and hopefully only take a day to wire up.  I imagine you'd need to have a codec test vectors for this { XContext, m, e, i, ... } state to make this tractable + useful for the challenging cases?

If you have all that in scope, it would be wonderful. [edited]
  ↳ 2024-11-27 17:04 tomusdrw: > <@sourabhniyogi:matrix.org> As soon as polkatool + CoreChains (presumably a very very large service) has "eureka!" from PolkaJAM (in solving the same problem as the Polkadot Relay Chain does for a couple dozen blocks), every JAM implementer will be able to use this to support matching the same results, which probably will touch almost everything in Appendix A + B.  
> 
> However, its critical to have the scope include all the host functions to take a "PVM debugger" seriously, which means you kind of have to extend out to the "host" with a reasonably complex "X Context" \[accumulate\] and "(m,e)" \[refine\], extending to  imported segments, gas details, and probably a bunch of other host state.  Having a well defined interface (RPC + codec) between a JAM implementation _with host state_ and the PVM Debugger is a must, and hopefully only take a day to wire up.  I imagine you'd need to have a codec test vectors for this { XContext, m, e, i, ... } state to make this tractable + useful for the challenging cases?
> 
> If you have all that in scope, it would be wonderful.

Indeed. So far we were trying to keep the tool as JAM-agnostic as possible, so it may help not only JAM-PVM but also for instance revive (Solidity to PVM compiler).

Next on our roadmap is to support more JAM-specific features (entry points), support host calls and have "mocked" JAM host calls implementation (for instance specialised UI where you can provide the segments to be available for `export` host call, etc).
Connecting to a running JAM node to invoke host calls is something worth considering as well, I will add that to our issue tracker.
2024-11-26 18:38 gav: Initial version of Parity JAM SDK is out, along with the Bootstrap Service: [Parity JAM SDK](https://hackmd.io/@polkadot/jamsdk)
2024-11-26 18:39 gav: It's not much right now and I've only tested it locally. But (if it works) it should be enough for anyone to build the Bootstrap service PVM code blob and (vaguely) see its Work Item ABI. [edited]
2024-11-26 18:39 gav: Rust coders should also be able to code and build their own services and authorizers.
2024-11-26 18:40 gav: The docs are a WiP, and I've thus far focussed only on basic Bootstrap service description. They should be improved in the coming days.
2024-11-26 18:41 gav: NOTE: There's no Github repo open yet, since we have a monorepo together with our node impl. So the code is currently available on crates.io only.
  ↳ 2024-11-27 00:43 sourabhniyogi: Happily got through

```
jam-pvm-build ./jam-bootstrap-service
jam-pvm-build ./jam-null-authorizer
```

and put the .pvm and rust code here for us to take a look:
https://github.com/jam-duna/jamtestnet/tree/main/services/parity

0. Does Parity Rust JAM SDK completely phase out Jan's polkatool?
1. What is the recommended way to disassemble the `jam-pvm-build`- built PVM byte code ?

```
# cargo run -p polkatool disassemble --show-raw-bytes ~/go/src/github.com/jam-duna/jamtestnet/services/parity/jam-bootstrap-service.pvm
warning: /root/go/src/github.com/colorfulnotion/polkavm/Cargo.toml: unused manifest key: workspace.lints.rust.unexpected_cfgs.check-cfg
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/polkatool disassemble --show-raw-bytes ~/jam-duna/jamtestnet/services/parity/jam-bootstrap-service.pvm`
ERROR: failed to parse "/root/go/src/github.com/jam-duna/jamtestnet/services/parity/jam-bootstrap-service.pvm": failed to parse program blob: blob doesn't start with the expected magic bytes
```

2. Does the program start with the 5x4 = 20 bytes of jumps
https://github.com/jam-duna/jamtestnet/blob/main/services/jam-duna/bootstrap/bootstrap.txt#L10-L17
3. Can we build 32-bit vs 64-bit until the end of Jan/Feb/March with this?    How do we specify the 32 vs 64 target?
4. The 72K is surprisingly large, because it went for instructions in the payload with full generality 😅  --  Our first bootstrap code is ~200 bytes, hand built
https://github.com/jam-duna/jamtestnet/blob/main/services/jam-duna/bootstrap/bootstrap.txt#L8
We will try redoing it in this Parity SDK with a "barebones" mindset in a 32-bit or 64-bit way, but is the expectation that the bootstrap will actually be this big in the end?  Is there some code blob reuse _across services_ that is desired, e.g. for super common operations like hashing

5. Work Item ABI  -- earlier you said "Services are not smart contracts", but I'm glad you referred to it this way -- how would you see the end Bootstrap described in ABI form?
6. Any way to slip in some assembly code? [edited]
  ↳ 2024-11-27 10:12 gav: I'm about to push 0.1.4 which adds support for building without logging and debug symbols. This takes Bootstrap down to 35k and NullAuth to ~8k.
  ↳ 2024-11-27 10:13 gav: Can't do much more without a deeper analysis of code generation.
  ↳ 2024-11-27 10:13 gav: ABI can probably just be specified similar to net protocol.
  ↳ 2024-11-27 10:14 gav: It's on my list but haven't done it yet since it can be fairly easily derived from the Rust code.
  ↳ 2024-11-27 10:14 gav: No easy way to insert assembly afaik, though Jan Bujak would know better
  ↳ 2024-11-27 10:15 gav: 32-bit PVM isn't really supported going forward.
  ↳ 2024-11-27 10:16 gav: The program code should begin with the appropriate jumps, but of course the `.pvm` output is the standard program format as detailed in GP-A.1, which doesn't begin with the PVM code. [edited]
  ↳ 2024-11-27 10:18 gav: If you want to disassemble, you'll probably first want to write PVM program blob deconstructor to extract the PVM code. Then I guess you'll want to write a disassembler.
  ↳ 2024-11-27 10:18 gav: This doesn't "completely phase out" anything. It's an early WiP, not a major product/service launch. [edited]
  ↳ 2024-11-27 10:19 gav: Use whatever tooling you feel makes sense from what's out there. At present, this is provided on a "hope it's helpful" basis. Maybe that changes when it gets to 1.0. But until then, don't expect too much. [edited]
2024-11-27 04:28 xlchen: I plan to focus on the RPC part for Boka next and that includes the ability to generate RPC docs. Oliver Tale-Yazdi suggested to use https://github.com/ethereum/execution-apis / https://ethereum.github.io/execution-apis/api-documentation/ as the playground / documents for RPCs. Let me know what do you think 
  ↳ 2024-11-27 08:46 sourabhniyogi: Here is my wish list of RPC methods 
https://github.com/jam-duna/jamtestnet/blob/main/RPC.md
and a protospec of using opentelemetry (in Go)
https://github.com/jam-duna/jamtestnet/blob/main/telemetry/go/otel.go
We have not reduced this to practice nor have we actually connected opentelemetry to prometheus (the way we have connected to Datadog + Google Cloud logging).  
  ↳ 2024-11-27 09:01 sourabhniyogi: What is your wishlist?
  ↳ 2024-11-27 09:25 dave: If we want all nodes to provide a "standard" set of RPC calls I think we should try to keep these calls easy to implement. So for example I wouldn't require a JSON encoding for any of the JAM structs but just use the JAM codec, which all nodes need to understand anyway. Any conversion to/from JSON can be handled by libraries on the client side.
  ↳ 2024-11-27 09:37 dave: Re jam_getWorkPackageByHash this probably can't be usefully implemented as only the guarantors and auditors of a report ever have the corresponding WP data to hand and they will likely discard it once their duties are done (which should not take long)
  ↳ 2024-11-27 10:17 xlchen: yeah we should start from simple ones and add more gradually. I will also define some namespaces for standard and non-standard implementations and everyone are free to implement any methods on the non-standard namespaces 
  ↳ 2024-11-27 10:30 oliver.tale-yazdi: How would you then handle the non-standard Json versions? Appending a `Json` to the name?

It will probably help a lot for scripting to have these variants easily accessible without having to know about JAM codec [edited]
  ↳ 2024-11-27 10:31 oliver.tale-yazdi: Or would it have its own namespace?
  ↳ 2024-11-27 11:06 xlchen: we really should do the decoding in client side but otherwise we can have a convert rpc to convert between json and binary
  ↳ 2024-11-28 12:15 olanod: Any chance nodes will offer other things beyond (websocket) JSON-RPC API? I'm thinking of a simpler http multipart/form-data + server sent events for small clients where avoiding encoding data to JSON to save some CPU cicles, bandwidth and size of the program would be nice if possible. Other transports like gRPC or similar would be interesting as well.
  ↳ 2024-11-28 19:51 xlchen: gRPC is too complicated so I don’t think we can push it to have all implementation to implement. RESTful style is possible but it can’t have notifications 
  ↳ 2024-11-29 09:16 olanod: That's why I mention SSE ;) they're simple and pair well with an HTTP API(that doesn't need to be too RESTy).

This combo besides being easier for embedded(an interest of mine) has the interesting side effect over websockets that can be intercepted in service workers, to have a simple DevX and avoid users installing extensions I have this experiment of a substrate client running in a (shared)WebWorker that processes HTTP requests that were intercepted by a service worker. To websites it looks like a normal http API
  ↳ 2024-11-29 21:16 xlchen: one thing to keep in mind that general users and most devs does not need to have direct RPC access to jam chain. they only need light clients which should use the p2p protocol, not rpc 
2024-11-27 18:42 danicuki: 
2024-11-27 18:45 danicuki: Report test vectors seem to be using max gas GA = 1,000,000 - but GP sets to 100,000 - any particular reason for using a different number?

davxy  [edited]
2024-11-27 18:45 danicuki: Formula (11.29) ∀w∈w∶ ∑(rg)≤GA
2024-11-27 18:54 davxy: See discussion with [@dakkk:matrix.org](https://matrix.to/#/@dakkk:matrix.org) here https://github.com/w3f/jamtestvectors/pull/20
2024-11-27 18:55 davxy: I need to fix it 
2024-11-27 19:06 danicuki: > <@davxy:matrix.org> See discussion with [@dakkk:matrix.org](https://matrix.to/#/@dakkk:matrix.org) here https://github.com/w3f/jamtestvectors/pull/20

thanks for sharing. Solved another doubt I had  about "duplicates" / "out of order" cores
2024-11-27 19:21 danicuki: It would be REALLY REALLY helpful if vectors README had GP Formula Numbers / links for each condition being tested.

e.g.:

```
- [not_authorized](./tiny/not_authorized-1.json) 🔴
  - Target core without any authorizer.
```

I can't find out from this description what this test is all about. Sometimes the phrasing explanation is not accurate. A simple link to a formula would solve any doubt [edited]
2024-11-27 19:27 gav: JAM SDK API docs are slowly improving https://docs.rs/jam-pvm-common/0.1.5/jam_pvm_common/
2024-11-27 19:34 danicuki: davxy: what value are you using for rotation period (R) in test vectors? 
2024-11-27 22:32 danicuki: An interesting article that brings even more excitement to our JAM builders community: https://user.fm/files/v2-261b7914c204931fbf213d7d35307264/worldcomputer.pdf
2024-11-28 09:26 gav: > <@danicuki:matrix.org> An interesting article that brings even more excitement to our JAM builders community: https://user.fm/files/v2-261b7914c204931fbf213d7d35307264/worldcomputer.pdf

TBH I don't think it'll be a single "World Computer" any more.
2024-11-28 09:26 gav: At least as long as it is not totally free.
2024-11-28 09:27 gav: More likely, we'll see several weakly-compatible ("bridged") World Computer networks.
2024-11-28 09:27 gav: Kinda similar to the cloud services at present.
2024-11-28 09:28 gav: Each with their own tradeoffs in terms of reliability, scale, cohesion and peripheral services.
2024-11-28 09:28 gav: JAM as a protocol would be the architecture of the (first wave, anyway) of machines on the Polkadot "World Computer Network".
2024-11-28 09:30 gav: But the idea is for multiple JAMs to be placed in a sort of grid network, similar in approach to the Omniledger protocol. This seems like the only sensible option *at present* to scale more-or-less indefinitely. [edited]
2024-11-28 09:40 sourabhniyogi: As an old guy (so old I have seen a "Cray" and "Thinking Machines"), I really adore the shift to the words "trustless supercomputer" more than the "World Computer", where it matches 1 core = World Computer, N cores = Supercomputer. In a completely ordinary way, I think the term "SUPERcomputer" works on people well because of the superhero vs hero distinction that loosely maps onto your favorite word "Core", which ALSO works for everyday PC computer buyers.   Why not be consistent with this new "supercomputer" term for marketing reasons? [edited]
2024-11-28 09:44 sourabhniyogi: Polkadot JAM Chain is the world's first trustless SUPERCOMPUTER because ____
(a) it has more than one core!
(b) it is actually semi-coherent!
You get to decide the truthiness of (a)+(b) =)
2024-11-28 09:51 gav: I remember back in the old days (~y2k), pre-cloud, there was the concept of the "grid", basically a network of supercomputers with streamlined interconnects and access.
2024-11-28 09:53 gav: It seems unlikely to me that any fully-coherent system is going to scale indefinitely and economics being what they are, it seems unlikely that strict coherence will be paid for when it's not needed.
2024-11-28 09:54 gav: This all points to a multi network stable-state.
2024-11-28 09:55 gav: But probably with a range of interoperability/cohesion across the various (super)computers which make it up. [edited]
2024-11-28 09:55 gav: I don't really see crappy (trustful) bridges in this, except perhaps to connect low-quality low-resilience not-really-web3 networks.
2024-11-28 10:05 gav: But then probably we'll see a spectrum of connectivity; trustless light-client bridges, L1-L2 and other one-way full-node (ala Eth L2s and parachains), dual-way full-node, shared validators (ala Omnipool), weakly-coherent shared DA (ala JAM) and fully-coherent synchronous shared state (ala Eth L1).
2024-11-28 10:07 gav: We're already seeing a bit of this, but it's very much at the poles so far (incoherent or fully synch).
2024-11-28 10:11 gav: For the Polkadot Cloud Grid, we could almost certainly make a matrix of JAMs with a shared validator pool and light-client bridge interconnects (at the cost of a ~35% drop in cost of attack). This would be a basic Supercomputer Network. We can probably do better though, with a shared DA and maybe some built-in service migration or even Work Report and Transfer forwarding, so that Refine is spread around the network but Accumulation/OnTransfer still happens synch on a single "home JAM" of the service. [edited]
  ↳ 2024-11-28 12:00 sourabhniyogi: The Polkadot Cloud Grid is an insanely great vision.  Concretely, I hope GP Sec 18 can incorporate the JAM-to-JAM process alongside the MMB nitty gritty, developed early between { Polkadot, Kusama, Paseo/Westend } JAM chain (maybe even in the Toaster!) or at least charted in Sec 20+ in a JAM 2.0 roadmap.

Apologies if this is too pushy ... but I believe there needs to be an equally insanely great vision for (homogenous) "Polkadot \[Asset\] Hubs" running across that grid, with clarity on how DOT can work across the grid.  I believe the poor messaging situation in OP's superchain can be easily attacked, but it seems to be a "if you can't beat them, join them" and we need a hijacking plan here.

This is too good of a vision to be locked inside this chat room -- can you get on like Unchained to share your vision
https://polkadot.polkassembly.io/treasury/576
with the broader Web3 masses? [edited]
  ↳ 2024-11-28 12:37 gav: As I say, there's a few things to be solved with the idea of Work Report Forwarding to make Refine be scalable across the JAM Grid from a single service, but if those things can be solved (and I don't think it's unreasonable to expect they can be), then CorePlay (which is basically the logical successor to P(A)H/Plaza) could be scaled out across the JAM Grid. [edited]
  ↳ 2024-11-28 12:38 gav: What I would aim to achieve with Grid scaling is JAM-style weak-coherency. Which is to say it'll never do the wrong thing regardless of where on the JAM Grid the Work Package is executed, but it might take much longer in some places than others (with the worst case being it takes so long as to time out completely). [edited]
  ↳ 2024-11-28 12:44 gav: This would result CorePlay having existing JAM-style per-core synchronous composition for those transactors willing to pay for it, but with massively scalable (and therefore very cheap) asynchronous composition for everyone else. Since CorePlay would be continuations-based, high-quality primitives abound for minimising the pain of asynch programming. The main difference shouldn't be DevEx, but rather very particular functionality which strictly requires synchroneity ("Stop-The-World") in execution like flash-loans.
2024-11-28 10:12 gav: This would provide totally unprecedented levels of scale; an e.g. a 10x10x10 grid would give 1000x on the total compute throughput of JAM - so like ~1 quadrillion EVM-equiv gas/sec [edited]
2024-11-28 10:16 gav: There's still some stuff to be worked out, like preimage fetching/sharing across JAMs (possibly a simple cache model would do, or perhaps also an explicit fetch) and DA handoff as the partitioning changes (possibly just ephemeral connections across JAM validator partitions for segment-fetching). [edited]
2024-11-28 10:17 gav: But overall I see it as a pretty interesting next step once JAM is solid.
2024-11-28 10:19 gav: We should also keep our eyes on the progression of ZK stuff too. I think (and this is almost exclusively informed by the W3F research team) that it's too early to tell yet whether it'll become economically viable compared to ELVES, but if it does eventually come down in price enough to be a sensible option when we could potentially see a backward-compatible JAM-ZK on the cards in a few years.
2024-11-28 10:21 danicuki: davxy: are safrole test vectors already updated to GP 0.5? I see some of our tests failing after we upgraded our code to 0.5 specification
2024-11-28 10:22 emielsebastiaan: This made my day thx for sharing these insights once in a while. 
2024-11-28 10:24 davxy: > <@danicuki:matrix.org> davxy: are safrole test vectors already updated to GP 0.5? I see some of our tests failing after we upgraded our code to 0.5 specification

Which ones? And what is the actual failed condition? They should be aligned to 0.5
  ↳ 2024-11-28 10:27 danicuki: I will double check on my side and get back to you if they still fail
  ↳ 2024-11-28 14:50 rick: I raised this earlier, the EpochMarks added a field, TicketsEntropy, which isn't in the Safrole test vectors yet. 
  ↳ 2024-11-28 14:51 rick: I *think* thats all I had to change. Hope this helps danicuki | Jamixir 
  ↳ 2024-11-28 19:12 davxy: > <@rick:carback.us> I raised this earlier, the EpochMarks added a field, TicketsEntropy, which isn't in the Safrole test vectors yet. 

It is. I added it 3 days ago
  ↳ 2024-11-28 20:28 rick: thanks davxy  i'll take a look 👍️ [edited]
2024-11-28 12:07 gav: Sure if you want to set it up
2024-11-28 12:32 davxy: Was 4 for both `tiny` and `full`.
I've just fixed it to be 10 for `full`.
The values are  NOW explicitly reported in the README [edited]
2024-11-28 19:13 davxy: https://github.com/w3f/jamtestvectors/pull/8/commits/df18b318433fda0cf0dd2b4aac29abce09f0b15a
2024-11-28 20:43 davxy: Could this be the breaking change? https://github.com/w3f/jamtestvectors/pull/8/commits/aeb976ff3eed8afed4dda53286f7cb2af5b81ebd

Specifically, post-offenders have been moved to the "state". Please refer to the ASN.1 schema for further details.

I followed the recommendation to include in the "input" struct only the elements found within the block (I.e. header items and extrinsics). When a pre-execution state item is "posterior" it is explicitly specified in the ASN.1 schema.
 
Always keep an eye on the schema. [edited]
2024-11-28 20:50 davxy: ^ posterior with respect to some other subsystem STF (in this case, it is the "disputes" subsystem that advances the offenders' list). Thus, it is assumed that the subsystem has already been executed to obtain psi_o'.


2024-11-28 23:26 danicuki: About the work report vectors: why the post_state doesn't include the core report component - with all its fields? Shouldn't be better than using an "output" in the json? @davxy 
2024-11-29 06:38 xlchen: Trying to use OpenRPC tools for JAM RPC spec work. It is kind of working: https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/open-web3-stack/jam-rpc-spec/refs/heads/master/openrpc.json

The spec defs is generated by our Swift code from our RPC implementation so those methods are what we have implemented currently, not what I wanted to propose
2024-11-29 06:40 xlchen: I created a repo here but not sure if it should just be part of some other repos https://github.com/open-web3-stack/jam-rpc-spec?tab=readme-ov-file
2024-11-29 06:43 xlchen: I plan to create the actual spec proposal (in Swift code) and update the openrpc spec file next week
2024-11-29 06:46 xlchen: open-rpc have client and server generator which I didn't try, but the docs generated don't work for me https://github.com/open-rpc/generator 
2024-11-29 14:32 nathanccxv: I recently finished reading Jam's GrayPaper and am preparing to develop its implementation. Is it too late for that? Is there any time limit? gav 
2024-11-29 15:09 gav: There’s no time limit, though of course the prize pool is limited and it’s FCFS :)
2024-11-29 15:26 nathanccxv: Thank you for your clarification. According to the 'Gav's Unofficial JAM Prize Notes' document, up to five implementations per language set can receive rewards. 2500k/(100k*5 milestones) = 5. Is this understanding correct?
2024-11-29 16:30 dakkk: > <@nathanccxv:matrix.org> I recently finished reading Jam's GrayPaper and am preparing to develop its implementation. Is it too late for that? Is there any time limit? gav

if may I ask, which language are you going to use?
  ↳ 2024-11-29 16:58 nathanccxv: I'm not entirely sure yet, but I'm more proficient in Go and Python, so I might go with Go.
  ↳ 2024-11-29 16:58 dakkk: GOod choice 👍️
2024-11-29 16:32 gav: Well, this assumes each of those 5 implementations get to M5 before any others get to M1. [edited]
  ↳ 2024-11-30 12:43 clearloop: Curious about will PolkaJam take one of the slots in set B 😂


2024-11-29 21:50 tomusdrw: > <@gav:polkadot.io> Well, this assumes each of those 5 implementations get to M5 before any others get to M1.

Hmm, I guess that creates a risk of having no incentives to go up to M5 for some of the "heavily occupied" language sets depending on the timing of when it will be possible to submit implementations for acceptance, doesn't it? But AFAIR I saw in the repo, that there is not going to be milestone deliveries before GP 1.0, right? 
2024-11-29 22:27 gav: Indeed
2024-11-29 22:33 sourabhniyogi: I'm putting together a "importblocks" fuzz tester and would like to know which state elements would be changed by blocks in "M1 Import blocks" milestone from
https://graypaper.fluffylabs.dev/#/293bf5a/348e00348e00
in different testing modes to match the goals of M1 vs M2 vs M3 as well as which extrinsics.  I think we should have a super precise answer for M1 Import Blocks now?

My guess is:

- "M1 Import blocks" will have blocks that change the state of:

    - C(4), C(6), C(7), C(8), C(9), C(10), C(11), C(13), C(15)
    - all service storage (δ, a\_s, a\_p, a\_l)
    - extrinsics E\_{T,G,A,P}

... implying these will happen later:

- M2/M3: C(1), C(2), C(3), C(5), C(12), C(14), E\_D

Can someone clarify what M1 Import Blocks state changes should cover?

This has implications as to what teams should focus on finishing in what order.   I remember earlier comments that M1 doesn't even need PVM implementation, which is at odds with the above guess.

This is important for the design+implementation of a fuzz tester that only generates blocks suitable for each milestone / mode, with a parameter like "mode" that is like
M1: "fallback" (no extrinsics), "safrole" (only ticket extrinsics), "assurances" (all but dispute extrinsics and no prereqs)
M2: "orderedaccumulation" (adjusting C(14), including prereqs), "authorization" (adjusting C(1)+C(2)), "recenthistory" (C(3)), "blessed" (adjusting C(5), C(12)), "basichostfunctions" (most common host functions)
M3: "finalization" (everything in C(1)-C(15) except disputes), "disputes" (everything, including dispute extrinsics), "conformance" (every single host function) [edited]
2024-11-29 23:05 charliewinston14: Anyone else having difficulty verifying the beefy_root's in the report vectors? Just wondering if it's my issue or if its an issue with the vectors themselves?
  ↳ 2024-11-30 07:00 sourabhniyogi: Note that MMRs will be replaced with MMBs soon so it might not be worth sweating too much about this.
  ↳ 2024-11-30 07:04 dakkk: I'm having issue too 
  ↳ 2024-11-30 17:45 danicuki: I have the same issue also. Can't match beefy_root - davxy  maybe you are using a different Hash algorithm than specified? Or something else related to encode_mmr function - I tried different combinations here but none of them matched the vector 
  ↳ 2024-11-30 18:43 davxy: > <@danicuki:matrix.org> I have the same issue also. Can't match beefy_root - davxy  maybe you are using a different Hash algorithm than specified? Or something else related to encode_mmr function - I tried different combinations here but none of them matched the vector 

You are referring to the 'reports' vectors, correct? 
  ↳ 2024-12-01 14:32 danicuki: > <@davxy:matrix.org> You are referring to the 'reports' vectors, correct?

yes
  ↳ 2024-12-02 11:05 davxy: Given an MMR, i.e. a sequence of hashes where some items may be null. How do you produce the beefy root?
  ↳ 2024-12-02 11:06 davxy: I.e. what equation, from the GP, you're using?
  ↳ 2024-12-02 11:19 danicuki: E.9 - E(↕[¿x ∣ x <− b])
  ↳ 2024-12-02 11:20 danicuki: This is EM
  ↳ 2024-12-02 11:20 dakkk: in 11.32 the beefy_root of the context of the work reports should be equal to the keccak of the encoded_mmr (E.9) of the history element matching the context anchor.


  ↳ 2024-12-02 11:20 danicuki: Exactly
  ↳ 2024-12-02 11:20 danicuki: this is what we are doing
  ↳ 2024-12-02 11:21 dakkk: I know, I was answering davxy
  ↳ 2024-12-02 11:21 dakkk: maybe the issue is the sorting of b; b can contain null values, how should we sort them?
  ↳ 2024-12-02 11:21 danicuki: HK(EM(yb))
  ↳ 2024-12-02 11:22 danicuki: ```Elixir
Hash.keccak_256(Codec.Encoder.encode_mmr(y.accumulated_result_mmr))
```
  ↳ 2024-12-02 11:23 danicuki: we don't sort them. Just take them as they are
  ↳ 2024-12-02 11:23 danicuki: there is nowhere in the GP specified that they should be sorted
  ↳ 2024-12-02 11:23 danicuki: as long as I remember
  ↳ 2024-12-02 11:23 davxy: I guess we have an inconsistency in our impl. Probably we need to fix it 
  ↳ 2024-12-02 11:26 dakkk: > <@danicuki:matrix.org> there is nowhere in the GP specified that they should be sorted

you're right, I made confusion with another thing
  ↳ 2024-12-02 11:26 dakkk: anyway danicuki | Jamixir what is your result? mine is 0x233440078b657c8f7c8fa7316a13f002da38a5ed38f33e616dd0e02505d7995f
  ↳ 2024-12-02 11:34 danicuki: what vector?
  ↳ 2024-12-03 18:07 danicuki: > <@davxy:matrix.org> I guess we have an inconsistency in our impl. Probably we need to fix it 

Please let us know when you release it so we can test against it again. 
2024-11-30 06:07 ksc85pwpj5: davxy:  Excuse me, may I kindly ask if there are currently any test vectors available for shuffle, or if anyone else has any results related to shuffle?
  ↳ 2024-11-30 06:48 sourabhniyogi: https://github.com/w3f/jamtestvectors/pull/17
  ↳ 2024-11-30 06:48 sourabhniyogi: We were able to pass it along with a couple of others. [edited]
  ↳ 2024-11-30 06:51 sourabhniyogi: The ${\cal F}$ in F.3 here: 
https://graypaper.fluffylabs.dev/#/911af30/39a30239a302
probably should have a subscript to distinguish it from the ${\cal F}$ in F.1 
2024-11-30 06:41 dakkk: 
2024-11-30 06:42 dakkk: 
2024-11-30 07:04 rustybot: 
2024-11-30 07:04 davxy: > <@sourabhniyogi:matrix.org> I'm putting together a "importblocks" fuzz tester and would like to know which state elements would be changed by blocks in "M1 Import blocks" milestone from
> https://graypaper.fluffylabs.dev/#/293bf5a/348e00348e00
> in different testing modes to match the goals of M1 vs M2 vs M3 as well as which extrinsics.  I think we should have a super precise answer for M1 Import Blocks now?
> 
> My guess is:
> 
> - "M1 Import blocks" will have blocks that change the state of:
> 
>     - C(4), C(6), C(7), C(8), C(9), C(10), C(11), C(13), C(15)
>     - all service storage (δ, a\_s, a\_p, a\_l)
>     - extrinsics E\_{T,G,A,P}
> 
> ... implying these will happen later:
> 
> - M2/M3: C(1), C(2), C(3), C(5), C(12), C(14), E\_D
> 
> Can someone clarify what M1 Import Blocks state changes should cover?
> 
> This has implications as to what teams should focus on finishing in what order.   I remember earlier comments that M1 doesn't even need PVM implementation, which is at odds with the above guess.
> 
> This is important for the design+implementation of a fuzz tester that only generates blocks suitable for each milestone / mode, with a parameter like "mode" that is like
> M1: "fallback" (no extrinsics), "safrole" (only ticket extrinsics), "assurances" (all but dispute extrinsics and no prereqs)
> M2: "orderedaccumulation" (adjusting C(14), including prereqs), "authorization" (adjusting C(1)+C(2)), "recenthistory" (C(3)), "blessed" (adjusting C(5), C(12)), "basichostfunctions" (most common host functions)
> M3: "finalization" (everything in C(1)-C(15) except disputes), "disputes" (everything, including dispute extrinsics), "conformance" (every single host function)

https://github.com/w3f/jamtestvectors/issues/21
2024-11-30 07:55 davxy: It seems your tool aligns somewhat with the conformance testing tool for M1. I encourage the sharing of relevant ideas and discussions within the GitHub issue, as people (me included) may occasionally miss messages in the chat 


2024-11-30 08:07 prematurata: > <@davxy:matrix.org> https://github.com/w3f/jamtestvectors/issues/21

hey davxy thanks for this. I previously used your `polkajam-vectors` branch but i noticed that compared to the upstream repository gamma_z is computed differently (my findings were that a different version of ark repo was used.) caan you share some insights on which of the 2 provide the "correct" gamma_z computation?
2024-11-30 10:51 davxy: I checked the value of `gamma_z` and is the same in both the upstream PR and my fork.
Obviously if for upstream you mean the master branch, yes. This is different. At this point master is quite outdated.
I suggest you to work with the changes in the PR or using my fork, that I try to keep updated WRT the open PRs we have upstream.

I report the **current** values here:

### Tiny

"gamma\_z": "0xa949a60ad754d683d398a0fb674a9bbe525ca26b0b0b9c8d79f210291b40d286d9886a9747a4587d497f2700baee229ca72c54ad652e03e74f35f075d0189a40d41e5ee65703beb5d7ae8394da07aecf9056b98c61156714fd1d9982367bee2992e630ae2b14e758ab0960e372172203f4c9a41777dadd529971d7ab9d23ab29fe0e9c85ec450505dde7f5ac038274cf",

### Full

"gamma\_z": "0x96fcd017ddd980b1847422ee6d9c7619e71d1a17acfbb9c572feec917cf3c12f5a87d33f249b5ecf2639859bf3eb2795841d5317144feab07f6e7d0add7a8b3591b9c913ea56198c53a0894f040d7f1392c790755b97a6167e0ca9978421e6b596c1b168e2dcc743f9eadda76c041db42d39f27a58418f88c0ea67656a224934e12b5dfc8f0f460a95c2d467fa41907b", [edited]
2024-11-30 10:51 davxy: You can check for the ark-ec-vrfs revision currently used here: https://github.com/davxy/jam-test-vectors/tree/polkajam-vectors/safrole#%EF%B8%8F-warning--%EF%B8%8F
2024-11-30 10:58 davxy: Following suggestions from some other team members, the `tiny` configuration now uses a maximum tickets per validator of 3 (compared to 2 for the `full` configuration). This adjustment ensures that epoch slots can be filled with tickets from a supermajority of honest nodes (5 out of 6 validators). This change aligns the vectors to the proposed testing values outlined here: https://docs.jamcha.in/basics/chain-spec/Tiny.
  ↳ 2024-11-30 21:08 sourabhniyogi: image.png
  ↳ 2024-11-30 21:08 sourabhniyogi: https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=615049643#gid=615049643
  ↳ 2024-11-30 21:10 sourabhniyogi: Do you have suggestions on how to have larger configurations than "tiny"?  Above is my starting point for some chain specs, in expectation that the JAM Toaster will support teams having { small => 2x large } configs 100% on their own and then { 2, 3, 4 } teams can assemble into a { xlarge, 2xlarge, 3xlarge } config in 2025. 
  ↳ 2024-12-01 14:25 sourabhniyogi: For `R` (rotation) https://github.com/JamBrains/jam-docs/issues/5 

what is the logic of having R=4 in `tiny` instead of R=10?

Do you have recommendations for other chain specs 

https://docs.jamcha.in/basics/chain-spec/small
https://docs.jamcha.in/basics/chain-spec/medium
https://docs.jamcha.in/basics/chain-spec/large
... [edited]
2024-11-30 11:47 sourabhniyogi: > <@davxy:matrix.org> It seems your tool aligns somewhat with the conformance testing tool for M1. I encourage the sharing of relevant ideas and discussions within the GitHub issue, as people (me included) may occasionally miss messages in the chat

https://github.com/w3f/jamtestvectors/issues/21#issuecomment-2508934671
2024-11-30 12:28 tomusdrw: > <@gav:polkadot.io> JAM SDK API docs are slowly improving https://docs.rs/jam-pvm-common/0.1.5/jam_pvm_common/

I'm playing around with the SDK and have some `.pvm` files compiled. It seems to me that there is one extra byte between "read-only data" `o` and `E_4(codeLength)`. Normally there should be `w` there, but length of `w` is set to 0. Am I missing something, or might this be a bug?
  ↳ 2024-11-30 14:57 tomusdrw: Hmm, is it actually based on GP 0.5.0 or some other version? I'm trying to:

1. Read it as SPI (need to alter the `|w|` to 1 byte to make it valid (i.e. skip one byte between `o` and `|c|`)
2. Disassemble the instructions. For bootstrap service I see 3 `JUMP(5)` at the beginning which looks like pre-0.5 instruction numbers, but in `0.5.` JUMP is `40`? [edited]
  ↳ 2024-11-30 15:31 tomusdrw: FWIW: it seems that the instruction set is the current `master` branch of `polkavm`, which looks kind of like in between `GP-0.4.5` and `GP-0.5.0`, so `0.4.5 + 64-bit stuff`
  ↳ 2024-12-01 11:18 jan: Yes, sorry, this isn't yet fully updated with the GP. I'll update it sometime this week.
  ↳ 2024-12-01 11:21 jan: Our current linker emits 64-bit code but still with the old opcode numbers, and the JAM blob builder still needs its header adjusted.
2024-11-30 13:47 gav: We won’t
  ↳ 2024-12-01 20:50 sourabhniyogi: Ok!  Some advice on how to organize this would be appreciated

https://docs.jamcha.in/testing/import-blocks#modes
2024-11-30 14:59 gav: Would need to check with [@jan:parity.io](https://matrix.to/#/@jan:parity.io)
2024-11-30 15:50 gav: Yeah it’s possible @jan didn’t yet update it. 
2024-11-30 16:02 subotic: I have an open PR with the updated opcodes. Jan wants to wait with merging.
2024-11-30 16:04 subotic: > <@subotic:matrix.org> I have an open PR with the updated opcodes. Jan wants to wait with merging.

The reason is that there are smart contracts on Westend, which would otherwise break.
2024-11-30 16:14 subotic: > <@subotic:matrix.org> The reason is that there are smart contracts on Westend, which would otherwise break.

Furthermore, there are additional opcodes coming with the ZBB extension, and there might be another round of opcode reshuffling. This is what I have understood anyway. Jan is the authority, though.
2024-11-30 16:50 tomusdrw: Yeah, no worries. I was just trying to figure out if it's possible to import the service code into [PVM disassembler](https://pvm.fluffylabs.dev). I think I do understand where we are at, so it's fine and I can wait for full GP-0.5.0 migration.
2024-12-01 11:55 jan: So we've recently switched to a 64-bit PVM in the GP. I haven't got the updated the test vectors ready yet (I will have them ready soon-ish), but in case some of you are already looking to update your PVM implementations to 64-bit here are some tips to make this process easier:

- *The* major change introduced with the 64-bit PVM is that the registers are now 64-bit, and in case of the most of the instructions their behavior stays essentially exactly the same, except they operate on 64-bit values instead of on 32-bit values now.
- The instruction encoding is unchanged. Those instructions which previously took at most a 32-bit immediate value (like e.g. `and_imm`) now still can have at most a 32-bit *physical* immediate, *however* the immediate value is now sign extended to full 64-bit before being used.
- There's only a *single* instruction which takes a 64-bit immediate that is actually *physically* encoded in the code stream as 64-bit (`load_imm_64`)
- There are a couple of instructions where there exists both a 64-bit variant and a 32-bit variant. (e.g. `add_32` and `add_64`) The `_32` variants work like the old 32-bit instruction from 0.4 - they ignore the upper 32-bits of the registers and use only the lower bits, but their result is *always* sign extended to full 64-bits when written to the destination register.
- The address space is still 32-bit and memory accesses ignore the upper 32-bits of registers.

If any of you have trouble updating your PVMs or have any questions regarding PVM then, as always, feel free to ping me and I'll be happy to help.
  ↳ 2024-12-01 14:50 sourabhniyogi: Thank you so much for summarizing what we should do next!

We have been using polkatool to build a few test services in 32-bit =) and are trying out building the same with the Parity Rust SDK.  Is polkatool going to be 64-bit soon or is it 64-bit already under certain flag / conditions or 64-bit already?

We could not tell exactly
https://github.com/paritytech/polkavm/commits/master/



  ↳ 2024-12-01 16:19 jan: `polkatool` and PolkaVM supports both 32-bit and 64-bit simultaneously; no extra flags are needed. It picks the appropriate target based on which RISC-V target you used to compile your code.
  ↳ 2024-12-01 19:18 sourabhniyogi: 1. It appears mul\_upper\_s\_s\_imm + mul\_upper\_u\_u\_imm existed in 0.4.5 but disappeared in 0.5.0 -- is this intentional?
2. GP keeps a lot of 32-bit instructions alongside 64-bit instructions, creating a lot of "twins", which I tabulated in two columns here "32-bit twin" and "64-bit twin"
https://docs.google.com/spreadsheets/d/1R7syeL7GYq4KH2B3Zh03v3CAFnK1iNNF0J4c2r-vKWw/edit?gid=1743195954#gid=1743195954
Is there a way to eliminate the 32-bit ones in favor of 64-bit?  After all, the R = Reduced and we appear to have a bit of instruction bloat -- If this to support 32-bit and 64-bit simultaneously in GP/polkadot/JAM Rust SDK/..., may I suggest we cut out the 32-bit support by a certain date to make everyone's life easier, the sooner the better?
3. In A.5.10 -- why is there not store\_ind\_i8, store\_ind\_i16, store\_ind\_i32, store\_ind\_i64, load\_ind\_i64, load_i64 [edited]
  ↳ 2024-12-01 20:06 sourabhniyogi: Filed issue https://github.com/gavofyork/graypaper/issues/158 and thanks for responding =) [edited]
2024-12-01 17:19 danicuki: What is the difference between 
tickets_per_validator: 3 and  max_tickets_per_extrinsic: 3
in tiny vectors specification?
Aren't the the same thing?

https://docs.jamcha.in/basics/chain-spec/tiny
  ↳ 2024-12-01 17:45 oliver.tale-yazdi: there is some short explanation here https://docs.jamcha.in/basics/chain-spec

Ticket per validator is [N](https://graypaper.fluffylabs.dev/#/911af30/3f67003f6900), and max_tickets_pre_extrinsic is [K](https://graypaper.fluffylabs.dev/#/911af30/3f61003f6300)
  ↳ 2024-12-01 17:46 oliver.tale-yazdi: I will add some GP reader links to the explanation, basically the first one is the number of ticket entries each validator can do into the contest, and the second one is just to limit the size of the extrinsic
  ↳ 2024-12-01 17:47 oliver.tale-yazdi: there can be at most 18 tickets in tiny, with at worst 15 in the honest majority case. But the Ticket extrinsic will only carry at most 3 per block [edited]
  ↳ 2024-12-04 08:16 danicuki: with max_tickets_pre_extrinsic = 3, safrole tiny vectors fail. Should tiny be set to 16 also? or vectors should be changed?
  ↳ 2024-12-04 09:48 oliver.tale-yazdi: right, my node was missing this. Looks indeed like two tiny vectors fail [edited]
  ↳ 2024-12-04 12:44 davxy: > <@danicuki:matrix.org> with max_tickets_pre_extrinsic = 3, safrole tiny vectors fail. Should tiny be set to 16 also? or vectors should be changed?

Our tiny node has a max tickets per extrinsics = 16 (same as full). Why 3?
  ↳ 2024-12-04 15:55 davxy: > <@oliver.tale-yazdi:parity.io> right, my node was missing this. Looks indeed like two tiny vectors fail

Fixed
  ↳ 2024-12-05 07:39 danicuki: > <@davxy:matrix.org> > <@danicuki:matrix.org> with max_tickets_pre_extrinsic = 3, safrole tiny vectors fail. Should tiny be set to 16 also? or vectors should be changed?
> 
> Our tiny node has a max tickets per extrinsics = 16 (same as full). Why 3?

In the definition of tiny here is 3: https://docs.jamcha.in/basics/chain-spec/tiny
2024-12-01 18:58 sourabhniyogi: I tabulated the 0.4.5 opcode => 0.5.0 opcode updates here
https://docs.google.com/spreadsheets/d/1R7syeL7GYq4KH2B3Zh03v3CAFnK1iNNF0J4c2r-vKWw/edit?gid=1743195954#gid=1743195954

If you think the sheet is wrong, just update the sheet and point out what you changed.
2024-12-01 19:18 jaymansfield: > <@sourabhniyogi:matrix.org> I tabulated the 0.4.5 opcode => 0.5.0 opcode updates here
> https://docs.google.com/spreadsheets/d/1R7syeL7GYq4KH2B3Zh03v3CAFnK1iNNF0J4c2r-vKWw/edit?gid=1743195954#gid=1743195954
> 
> If you think the sheet is wrong, just update the sheet and point out what you changed.

Thank you for this!
2024-12-02 12:02 danicuki: davxy: How do you setup the initial value for authorizer queue (φ) for work report vectors? They are not supposed to be empty. Formula 8.2 adds φ[c][Ht] to authorizer pool, but in vectors they are not being added.
2024-12-02 12:13 danicuki: What are "offenders" state field in the work report vectors? Are they part of the psi state field? If so, please, use the same convention you used on disputes vectors. Please, be consistent with test vectors, regarding to json field names, use the same convention on all vectors, otherwise we get crazy ✌️   [edited]
2024-12-02 12:36 rustybot: The asn.1 syntax is clear about it
2024-12-02 12:37 davxy: https://github.com/davxy/jam-test-vectors/blob/work-reports/reports/reports.asn
2024-12-02 12:48 danicuki: Thanks for the clarification. the .asn helps a lot. My suggestion is more about using the same names / structure for the same field in different test vectors. e.g.: why not use the same naming convention that you were already using in safrole and disputes vectors (psi, rho, tau, kappa, etc)? 
2024-12-02 12:55 davxy: I believe that reading the ASN.1 syntax file is more than enough to eliminate any ambiguity. Regarding the state, I’m open to renaming it if it helps. However, at the time of writing, I felt that `offenders` was a clearer choice compared to `psi_o_prime`. :-) [edited]
2024-12-02 13:34 rick: Hard agree +1 to `offenders` over `psi_o_prime`, you've already got defs in the GP which make that link to the asn spec name. 
2024-12-02 14:04 danicuki: > <@davxy:matrix.org> I believe that reading the ASN.1 syntax file is more than enough to eliminate any ambiguity. Regarding the state, I’m open to renaming it if it helps. However, at the time of writing, I felt that `offenders` was a clearer choice compared to `psi_o_double_dagger`. :-) 
> 
> 

My suggestions is to use offenders, but ender psi branch:

Psi: {
 offenders: [...]
 other_psi_fields...
}

This is how it is in disputes vectors, which for me makes much more sense. Offenders under the main state branch seems odd, as state doesn't have an "offenders" component. 
2024-12-02 14:30 davxy: I understand your perspective. However, the state in question is not the "main" state. Only the relevant portions of the state required to advance the STF of a particular subsystem are included. 

In cases of "disputes" vectors, the entire ψ is necessary, while "reports" STF requires only ψₒ. I don't think that including items that are not strictly needed is beneficial, which is why for example, I have not included other state items here. 

I recognize that this approach is based on personal preference. However, since there is no formal specification for how to write vectors, I believe it is more efficient to exclude elements not required by the subsystem's STF. 

If anyone wishes to draft a mini-specification for writing vectors, I encourage you to open an issue on GitHub to address these considerations. Of course, I will eventually adapt my approach to the issue outcome. [edited]
  ↳ 2024-12-02 14:58 danicuki: Thanks for the conversation. For elements that are not needed, you don't need to include. In this case, you would just put: Psi: { offenders: [] }
You keep the consistency among different test vectors, while excluding unneeded elements.
I agree that these are not formally specified. What I am trying to propose here is something that helps teams to be more efficient when dealing with vectors. [edited]
2024-12-02 15:41 sourabhniyogi: Strongly prefer long Developer-friendly English attribute names in JSON over short greek letters from GP to reduce cognitive load.   Its best to have a single benevolent dictator have good consistent taste than have any inconsistency in this.   The style is roughly in place already, lets not change it!

For STF test vectors:

- raw k,v values in JSON with a little bit of metadata for service storage sufficient to derive the key and know its type will be best.
- having a comprehensive dump of raw k,v values for the "pre\_state" is necessary, ideally coupled with this metadata;
- for the post\_state, its a debate as to whether to have a comprehensive dump of k,v state along with this metadata.  Its easier to read/write but a tad harder to spot the differences without writing a little diff code.
- Having the post state root is desirable but not strictly necessary.
- Having a JAM codec version of an STF test vector might be useful or unnecessary.  But, in general, the W3F test vectors being in both JSON + JAM Codec shuts down unnecessary debates effectively.  In all cases, having W3F be the benevolent dictator is very useful so we don't have engineers bickering over formats. [edited]
2024-12-02 17:13 oliver.tale-yazdi: > <@davxy:matrix.org> I believe that reading the ASN.1 syntax file is more than enough to eliminate any ambiguity. Regarding the state, I’m open to renaming it if it helps. However, at the time of writing, I felt that `offenders` was a clearer choice compared to `psi_o_prime`. :-)

IMHO any naming is fine. I only write these things once into a translation map and never think about them again.
2024-12-02 20:48 danicuki: I had a doubt about the assurance bitfield interpretation in vectors:

I see in vectors we have values from 0x01 to 0x03, which would be:
\[0, 1\], \[1, 0\] and \[1, 1\]

My question is: what is the correct position for cores? Do we use the least significant bit order or the most significant? In other words, 
if bitstring is 0x01 for example, core\[0\] is 1 and core\[1\] is 0? Or the opposite?

Having some issues with af[c] with the presented bitfields [edited]
  ↳ 2024-12-03 01:47 jaymansfield: I have both the tiny and full vectors passing now. Here is how I converted them: 0x01 = 10000000
0x03 = 11000000
  ↳ 2024-12-03 01:48 jaymansfield: For the full vectors, convert each pair separately and make sure to pad each to 8 digits. [edited]
2024-12-02 21:01 jaymansfield: We have these vectors passing now in our implementation. For bitfield 0x01, the vectors seem to expect core[0]=1 core[1]=0, and 0x02 to be core[0]=0 core[1]=1. Had the opposite originally and had to reverse the binary we generated for it to pass. [edited]
2024-12-03 03:22 xlchen: Here is my RPC proposal draft: https://github.com/open-web3-stack/jam-rpc-spec pretty much copying the Substrate RPC with some minor tweaks
2024-12-03 04:28 amritj: In graypaper here https://graypaper.fluffylabs.dev/#/911af30/19e30019e600

It is mentioned that import spec could contain both segment root and work package hash and to distinguish between them the work package hash value are tagged 


But here according to jam official codec it is just a hash: 

https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/jam-types-asn/jam-types.asn#L121

So, how do we identify, if hash is tagged or not i.e. is it a segment root or work package hash?


 [edited]
  ↳ 2025-01-05 06:50 luke_fishman: Amrit Jain: any news on this? how you tell them apart? i am wondering the same
  ↳ 2025-01-07 04:58 amritj: https://graypaper.fluffylabs.dev/#/911af30/368602368602
2024-12-03 08:53 davxy: > <@amritj:matrix.org> In graypaper here https://graypaper.fluffylabs.dev/#/911af30/19e30019e600
> 
> It is mentioned that import spec could contain both segment root and work package hash and to distinguish between them the work package hash value are tagged 
> 
> 
> But here according to jam official codec it is just a hash: 
> 
> https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/jam-types-asn/jam-types.asn#L121
> 
> So, how do we identify, if hash is tagged or not i.e. is it a segment root or work package hash?

Ty for reporting, I'll fix it.

2024-12-03 09:01 davxy: @room If you are using GitHub, please report any issues related to test vectors directly [here](https://github.com/w3f/jamtestvectors/issues). I may overlook or forget about some messages shared in the chat. This request does not pertain to trivial questions but rather to issues you are confident you have identified. Ty
  ↳ 2024-12-06 01:10 sourabhniyogi: Added https://github.com/w3f/jamtestvectors/issues/26
2024-12-03 14:13 danicuki: I've been posting many questions related to test vectors here in this chat. Do you believe it is a good idea to have another room just for test vectors related questions, so we don't spam the main chat with these messages?
  ↳ 2024-12-03 14:48 rick: I think it's fine, there's not that much activity and people are generally good about threading the topics. 
2024-12-03 14:50 danicuki: for no_assurances_with_stale_report-1 vector, how can the cores[0] report be nullified on the next state if there are no assurances in the block (thus no new report available)? I am referring to Formulas 11.15 and 11.16 - am I missing something?
2024-12-03 18:18 jam_man: Question about starting an implementation. 

Is there any guide(s) to follow, or is the idea that we use only the gray paper as a guideline for how to create the implementation? 
2024-12-03 18:24 jam_man: More specifically. Is the idea that we read and interpret the gray paper and turn the core ideas into functional code.

Specifically making sure we hit the milestones from the web3 rules page.  [edited]
2024-12-03 18:52 danicuki: > <@jam_man:matrix.org> Question about starting an implementation. 
> 
> Is there any guide(s) to follow, or is the idea that we use only the gray paper as a guideline for how to create the implementation?

We all started like this: read the paper, start writing code. You will get surprised about how much you can do. I've presented a workshop last month that might give you some ideas: https://www.youtube.com/watch?v=8UT2akmxu4I
2024-12-03 18:53 jam_man: > <@danicuki:matrix.org> We all started like this: read the paper, start writing code. You will get surprised about how much you can do. I've presented a workshop last month that might give you some ideas: https://www.youtube.com/watch?v=8UT2akmxu4I

Awesome I will take a look at this. Thank you 
2024-12-03 20:09 sourabhniyogi: I tabulated the W3F Test Vectors concerning "block validation" errors (safrole, reports, assurances, disputes)  here:

https://docs.google.com/spreadsheets/d/1yizEboIB28AP1fZXVfcm7kI5CtKd12TepsUcTDV1auo/edit?gid=2118274177#gid=2118274177

I assembled this to address a "importblocks" implementation:
https://docs.jamcha.in/testing/import-blocks
but this may help others develop systematic error treatment (in response to the above, and thus pass M1 Import Blocks).  

If you see fixes or want to add 0.5.x links to GP sections, just update the sheet! [edited]
2024-12-04 03:32 luke_jamixir: [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org) any plans to add to safrole  vectors with proper header seal and vrf signatures?
That would be very useful 
2024-12-04 03:37 amritj: Question:

The segments are erasure-coded and distributed to the validators. Each validator receives a single shard out of the 1,023 shards, determined by their validator index. Therefore, the shard index of the shard they receive equals to their validator index.

According to the JAMNP protocol, to fetch data from the assurers, we need to provide each assurer with the shard index we require from them.

The exported segments are expected to remain available for 28 days. During this period, it is assumed that more than 341 validators will remain consistent. However, there is still a significant likelihood that validator indexes may change during this time due to the addition or removal of validators.

Given this, should we also maintain a record of the validator keys associated with each shard index? This would allow us to identify which validator holds a specific shard, regardless of changes in their validator index.

Finally, is the assumption that more than 341 validators will remain unchanged for 28 days accurate? [edited]
  ↳ 2024-12-04 03:39 sourabhniyogi: Join Gray Paper room for these great questions -- Recently a similar question was asked --  There is no mechanism to "hand over" import DA data to new validators. Thus far the assumption is that it doesn’t matter. (Ie churn will be sufficiently small)
  ↳ 2024-12-04 03:40 sourabhniyogi: Conclusion is likely that there no need to keep the validator key associated with the shard index.  But you can if you want =)
  ↳ 2024-12-04 03:46 amritj: Gotcha, so we assume most of the validators will remain the same.

But the validator indexes can still change.


For example, in the test vectors validator at index 0 in archive and active validator set is different

https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/safrole/tiny/enact-epoch-change-with-no-tickets-4.json#L17

https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/safrole/tiny/enact-epoch-change-with-no-tickets-4.json#L55  [edited]
  ↳ 2024-12-04 03:47 amritj: And yeah I am already in the Graypaper room will try to post these questions there from now on, I assumed this was related to JAMNP too so I posted it here [edited]
  ↳ 2024-12-04 09:57 dave: Yes, you need to remember historical validator sets to know who to request shards from. You may also want to remember the availability bitfield for each package so you know which validators claimed to have their data
  ↳ 2024-12-04 13:57 amritj: Gotcha, and in the case of a new validator added to the network, is there any mechanism to distribute this table to him? Otherwise he won't be able to compute work results
  ↳ 2024-12-04 14:34 dave: Ah good question. New validators will need to fetch the last ~28 days of block history anyway to build the SR->ER mapping. I believe this map can be built using _only_ the blocks, without requiring any state to be fetched. Unfortunately as-is I don't think the old validator sets can be determined just by looking at the blocks, as I don't think the epoch marker in the header includes all the necessary information. Seems like it might be a good idea to change this, but maybe there is a different way to make it work. We certainly won't require full state history to be kept for 28 days. [edited]
  ↳ 2024-12-04 17:50 amritj: We can also use DA system to store this type of data, it will allow to easily distribute and hand over data required by new validators [edited]
  ↳ 2024-12-04 17:55 amritj: Yeah, but the question remains the same in our case – we still need to know which validator has which shard, it doesn't solve anything 😅
  ↳ 2024-12-04 17:55 dave: There is possibly a chicken-egg problem there? Separately, given that all validators need this data anyway, I'm not sure about erasure coding it.
  ↳ 2024-12-04 19:34 amritj: If from the current validator set we know the validators that are active during the epoch the work package was executed, we can just send them the erasure root and ask them the shard they have and they will share the shard with it's index and ofcourse justification data so we can verify it.

And about knowing which validators were active during our work package epoch, I think we can store a status component like we do in preimages in the validator metadata which somehow tell us the epoch indexes the validator was active   


2024-12-04 03:50 clearloop: May I ask if the example in https://github.com/davxy/bandersnatch-vrfs-spec is outdated? both the latest on main and  @8c82722 could not be compiled [edited]
2024-12-04 04:23 luke_jamixir: > <@clearloop:matrix.org> May I ask if the example in https://github.com/davxy/bandersnatch-vrfs-spec is outdated? both the latest on main and  @8c82722 could not be compiled


Try to update the ark-ec-vrfs dependency to revision: e491b41
  ↳ 2024-12-04 04:31 clearloop: @8c82722 maches @e491b41, I'll try again about it anyway, thanks! [edited]
2024-12-04 04:37 luke_jamixir: Indeed, does not compile 
2024-12-04 04:44 clearloop: seems caused by ring-proof is broken via the update of w3f/fflonk
2024-12-04 04:50 clearloop: Screenshot 2024-12-04 at 11.49.25.png
2024-12-04 04:50 clearloop: okay yesterday...

in case anybody meet the same problem while playing around with it, you can add this patch to your local testing repo instead of updating the whole dependency chain

```
[patch."https://github.com/w3f/fflonk"]
fflonk = { git = "https://github.com/clearloop/fflonk", rev = "1e854f35e9a65d08b11a86291405cdc95baa0a35" }
``` [edited]
2024-12-04 07:42 davxy: mmm... I know. The problem is that these crypto backends are not yet published on crates.io. And stuff may break.
I'm going to anchor the ring-proof we're using to the previous fflonk revision.

2024-12-04 08:51 davxy: should be fixed. New reference ark-ec-vrfs rev: d90e180
2024-12-04 13:26 davxy: A smaller value for tiny makes sense BTW. I think we can change it 
2024-12-04 15:53 davxy: That will eventually be included in the vectors used to verify the block header. Safrole vectors are responsible for validating the Safrole STF.
2024-12-05 11:21 luke_fishman: Thank you, and apologize if I'm being pushy, but do you have a rough ETA for that? we in Jamxiir would really like to get some validations that we are signing/verifying correctly.

  ↳ 2024-12-05 13:50 oliver.tale-yazdi: You can just publish some signatures yourselves and ask other teams to cross-check?  
We could also define a JSON rpc function check it cross-client [edited]
2024-12-05 14:56 danicuki: > <@danicuki:matrix.org> for no_assurances_with_stale_report-1 vector, how can the cores[0] report be nullified on the next state if there are no assurances in the block (thus no new report available)? I am referring to Formulas 11.15 and 11.16 - am I missing something?

davxy afk: can you help with this issue? 
2024-12-05 15:09 danicuki: Also, from what I noticed, vectors are considering a report staled when Ht = ρ†[c]t + U, but the GP formula says:

af [c] ⇒ ρ†[c] ≠ ∅∧Ht ≤ ρ†[c]t + U 

(or vectors are using a value of U different then 5)
2024-12-05 15:29 danicuki:  https://www.youtube.com/watch?v=9EcjWd-O4jI - Blockcowboy  nostalgic reference
2024-12-05 15:46 davxy: > <@danicuki:matrix.org> Also, from what I noticed, vectors are considering a report staled when Ht = ρ†[c]t + U, but the GP formula says:
> 
> af [c] ⇒ ρ†[c] ≠ ∅∧Ht ≤ ρ†[c]t + U 
> 
> (or vectors are using a value of U different then 5)

Yeah looks like GP prescribes lazy deletion of stale reports. I asked [@gav:polkadot.io](https://matrix.to/#/@gav:polkadot.io) for confirmation.
Also I was considering a report stale if  H_t >= ... . Looks like should be H_t > ... instead. Probably I need to fix these assurances vectors. 
2024-12-05 22:08 danicuki: davxy afk: I just saw the new statistics vectors. Why do you use kappa_prime in the pre_state? shouldn't it simply be 
{
pre_state: { kappa: {}} 
post_state: { kappa: {}} 
}

kappa_prime in the pre_state seems very odd, and kappa_prime in the post_state seems redundant, as everything in post_state is prime :-)
2024-12-06 19:24 rustybot: I think we already discussed about this. Not sure if with you or someone else. 
- "input" is stuff found in the block: extrinsic and header
- "state" are the relevant bits found in the global state relevant to push forward the STF.

Said that,
- some of these state bits may be "prime", "dagger" or double dagger (see asn.1 for semantics)
- some of these bits are changed by the STF, while some others not. 

This may result in data redundancy. But otherwise I had to introduce a different struct for posterior state. I found this easier. [edited]
2024-12-07 11:18 olanod: Hello, don't know if it's of interest or too soon ... while y'all work hard on JAM implementations I'm getting interested in looking a bit higher up the stack(services) also following my interest of lower level embedded Rust(specially riscv). I've been toying around with a simple embedded/virtual OS that allows writing simple ink-like apps that can run on a riscv microcontroller(also linux, web and of course I also checked building against the pvm target ;)). I think I get now how to port this to run as a JAM service but the random idea I came to ask is to see if there would be interest in a **"pocket JAM"**, I'll buy this [dev kit](https://de.aliexpress.com/item/1005005128298189.html?spm=a2g0o.productlist.main.11.8183CxLGCxLGyZ&algo_pvid=7b0defc5-548f-44e6-96ac-ba5cd46302c2&algo_exp_id=7b0defc5-548f-44e6-96ac-ba5cd46302c2-5&pdp_npi=4%40dis%21EUR%2145.50%2126.39%21%21%2146.97%2127.24%21%402103917f17335688657033211e7482%2112000031770778647%21sea%21DE%210%21ABX&curPageLogUid=3yHiDQ0GYa4J&utparam-url=scene%3Asearch%7Cquery_from%3A) to experiment porting the os, it's interesting that has 3 different risc-v core including one rv64gcv and a rv32emc, I feel it would have enough juice to run a light client.
2024-12-07 21:46 gav: > <@davxy:matrix.org> Yeah looks like GP prescribes lazy deletion of stale reports. I asked [@gav:polkadot.io](https://matrix.to/#/@gav:polkadot.io) for confirmation.
> Also I was considering a report stale if  H_t >= ... . Looks like should be H_t > ... instead. Probably I need to fix these assurances vectors.

Reports are now actively removed on expiration: https://github.com/gavofyork/graypaper/pull/160/commits/3e99734afc3770b145539f20b1cfa2939bbecd80
2024-12-08 11:09 sourabhniyogi: Looking closely at the shape of [CE134: Work-package sharing](https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-134-work-package-sharing) and [CE135: Work-report distribution](https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-135-work-report-distribution) it appears that there continues to be an expectation that a guarantor has at most ~2 seconds to do its work eg "The third guarantor should be given a reasonable amount of time (e.g. two seconds) to produce an additional signature before the guaranteed work-report is distrubuted."   Is the max gas allotted to refine going to be matched to this ~2s expectation?

How does JAM's refine gas limit compare to the gas/weight available in a single block of Polkadot (Asset) Hub with revive-pallet? [edited]
2024-12-08 11:25 gav: There's no need to wait until the WR is computed before distributing the WP.
2024-12-08 11:26 gav: You just need to check the authorisation is reasonable.
2024-12-08 11:26 gav: And there's no need to synchronise with the block production.
2024-12-08 11:26 gav: The anchor block can be (IIRC) up to 8 blocks from the head of the chain at time of reporting. [edited]
2024-12-08 11:27 gav: JAM's gas limit is designed such that the WP should be able to be fetched and execute easily within the 6 seconds, the provisional gas limit is tuned to 5 seconds. [edited]
2024-12-08 11:41 sourabhniyogi: For both polkatool (usable to build contracts with refine-pallet, now on [Westend Hub](https://contracts.polkadot.io/tutorial/rust)) and the JAM Rust SDK, there is this idea that arbitrary Rust code can be put into contracts and JAM Services.  But in practice, in both cases, it appears there is a pretty serious "no\_std" requirement ... that makes it hard to put Rust packages using `std` into PolkaVM Contracts or JAM Services.  They quickly hit this "error\[E0463\]: can't find crate for `std`"!  This leaves us reaching out for a host function and a 'ecalli ___` as a "cheat code" to avoid rewriting the underlying dependencies on std packages, and thus get a revive-pallet based contract and/or JAM Service.  

Is there some trick that can be employed to overcome the no\_std limitation? [edited]
2024-12-08 11:44 gav: No. It’s there by design. This is consensus code. 
2024-12-08 11:44 gav: You get trustless bare metal. Not Windows.  [edited]
2024-12-08 12:14 sourabhniyogi: Its amazing how quickly the "you can run Doom with PolkaVM!" for the cameramen devolves into "how does info! work" 😅

How should non-Rust JAM implementations interface with Rust JAM SDK `info!` calls like [these](https://github.com/jam-duna/jamtestnet/blob/main/services/parity/jam-bootstrap-service/src/main.rs#L59) -- not talking about Windows here, just like printing stuff with caveman debugging -- is there a way? [edited]
2024-12-08 13:41 gav: Yeah - there’s an additional (unofficial) host call provided by polkajam which the logging system uses if enabled. [edited]
2024-12-08 13:42 gav: You can derive the details from the code in `jam-pvm-common` crate quite easily. Here's the relevant snippet:
2024-12-08 13:42 gav: ```
	#[polkavm_import(index = 100)]
	pub fn log(
		level: u64,
		target_ptr: *const u8,
		target_len: u64,
		text_ptr: *const u8,
		text_len: u64,
	);
```
2024-12-08 13:43 gav: So that takes 5 registers
2024-12-08 13:44 gav: The first is the log level, 0...5 which gives the severity of the item [edited]
2024-12-08 13:45 gav: then two UTF-8 strings passed as the usual offset/length combinations, the first for the subsystem name and the second for the message.
2024-12-08 13:45 gav: The subsystem name can by the null ptr, in which case it is in a "global" context without a specific subsystem.
2024-12-08 13:46 gav: I can copy/paste this into a JAM-community document.
2024-12-08 13:47 gav: Happy to consider other such unofficial host-calls if they make sense, though beware they'd only be for testing/debugging unless detailed in the GP.
2024-12-08 13:49 gav: There should be nothing which introduces non-determinism into the PVM, which basically means they have to be pure functions that could possibly have some useful side-effects (as long as they're transparent from the perspective of the GP).
  ↳ 2024-12-08 16:24 sourabhniyogi: Looking at `pallet-revive`
 
https://docs.rs/pallet-revive/latest/pallet_revive/trait.SyscallDoc.html#tymethod.ecdsa_to_eth_address

I would suggest literally the following:

ecdsa_recover
ecdsa_to_eth_address
hash_blake2_128
hash_blake2_256
hash_keccak_256
hash_sha2_256
sr25519_verify

Skeptical these should be interpreted PVM byte code, but putting that nag aside, having a whole host of them in bootstrap code and a idiomatic way of accessing them with invoke or similar seems justified.   It seems wild for everyone to have their own versions of these in their own service code, but this will lead to some nice performance tests a side effect.  

For pedantic reasons hope you will consider: 
block_number, code_hash, now, minimum_balance
own_code_hash [invoke?]
and for parity: 
xcm_execute, xcm_send [??]
depending on how transfer and xcm are related.

"info!" and debug_message could be massaged together.

All of this is deterministic but the first group has a lot of opinionated stuff on what is a worthy crypto primitive between edwards, bls and bandersnatch signature verification to consider.

Generally, from [this](https://contracts.polkadot.io/tutorial/rust/) we want JAM Service builders and Polkadot Hub contract builders to have minimal friction between {Rust, ...} code built with the JAM SDK vs revive, even though the former is meant for rollups and the latter is for end users.   
  ↳ 2024-12-08 17:30 gav: I'd be very careful before adding this stuff to JAM at the lowest level. Once added it must be supported as a protocol component forever. Inevitably it's heavily opinionated.
  ↳ 2024-12-08 17:31 gav: PVM is fast, and unless there's a great, ecosystem-wide need for it to be faster at doing specifically this stuff then it's just not worth dirtying the protocol with.
  ↳ 2024-12-08 17:32 gav: It's not too difficult to add pure host-calls down the line since they can be polyfilled with PVM implementations, averting the need for a messy hard-fork. All that is really needed is for implementations to recognise the new host-call and charge the right gas. [edited]
  ↳ 2024-12-08 17:32 gav: However, removing them is a big pain since you need to increase the gas-prices which services utilizing them are paying. [edited]
  ↳ 2024-12-08 17:35 gav: These "precompiles" make a bit more sense in a smart contract environment where execution is slow and the domains can be pretty specific. [edited]
  ↳ 2024-12-08 17:35 gav: > xcm\_execute, xcm\_send

These make no sense. XCM has nothing to do with JAM. [edited]
  ↳ 2024-12-08 17:37 gav: > block_number

This is contained as part of the refinement-context
  ↳ 2024-12-08 17:37 gav: > code_hash

This is part of the service info.
  ↳ 2024-12-08 17:38 gav: > now

This is the block number.
  ↳ 2024-12-08 17:38 gav: > minimum_balance

This is part of the service info
  ↳ 2024-12-08 17:39 gav: > own_code_hash

This is part of the service info.
  ↳ 2024-12-08 23:32 sourabhniyogi: Ok, hope JAM { Rust, ... } SDKs will get these out of the contexts/service info/...  into similar if not identical abstractions.  No specific request, thank you!

For "XCM has nothing to do with JAM", I had thought JAM's transfer memos and XCM/XCMP would be directly connected -- surely for Polkadot rollups but potentially also non-Polkadot rollups.  You must mean something much more particular here -- is it  "the content of the message [XCM] has nothing to do with messaging service [XCMP]" or something else? [edited]
  ↳ 2024-12-09 02:08 xlchen: XCM/XCMP are implemented on top of JAM but JAM shouldn't be aware of XCM/XCMP. for example, we can't require every services to support XCM
  ↳ 2024-12-09 11:33 sourabhniyogi: Brilliant =)  Got it.
  ↳ 2024-12-09 18:02 sourabhniyogi: > <@gav:polkadot.io> It's not too difficult to add pure host-calls down the line since they can be polyfilled with PVM implementations, averting the need for a messy hard-fork. All that is really needed is for implementations to recognise the new host-call and charge the right gas.

Understood about not adding these at the lowest level within the JAM protocol.
```
ecdsa_recover=101
ecdsa_to_eth_address=102
hash_blake2_128=103
hash_blake2_256=104
hash_keccak_256=105
hash_sha2_256=106
sr25519_verify=107
```
but what about
(a) for performance testing interpreted PVM implementations  ala/within JIP-1 101..107 -- we'd compare calling the "native" unofficial host implementation against a PVM implementation against whatever Westend Hub does in { clock time, gas } -- its apples to apples 
(b) for abstractions within the JAM (Rust) SDK that simply call some bootstrap "polyfilled" PVM code.
These are not JAM protocol additions forever etched in but abstractions and measurements.
  ↳ 2024-12-10 08:02 olanod: About non-determinism,  I was wondering about the feasibility of introducing yet another step between authentication and refinement, a "data sourcing" stage run by a single node, this step similar to an off-chain worker can access the network to fetch/load resources that are loaded into the DA and can be used during refinement. I suppose loading data into the DA layer can be done independently by the light client but some clients might be very light and won't even have the memory to hold and upload the resources they want for refinement.
  ↳ 2024-12-10 08:04 xlchen: GP (at current status) is really only for validator nodes. if for example your parachain/light client/collator node need to do extra step, sure no one is going to stop you
  ↳ 2024-12-10 08:17 olanod: Can't Polkadot validators do off-chain workers? I was thinking of a set up without the equivalent of a parachain with collators, for sure we would do that if there's no other option but if I understand correctly there will be services like CoreJAM where a light client directly connected to said validators could call a function of a JAM service? that service could have sourced data at an earlier stage.
  ↳ 2024-12-10 08:20 xlchen: I don't 100% get your requirement but data of a work package can come from 3 places: the work package itself, DA via a segment root, or preimage store via a hash.
  ↳ 2024-12-10 12:10 gav: Polkadot Relay chain validators are not meant to be using generally programmable off-chain workers. They’re application level things. Jam is “OS” level. [edited]
2024-12-08 18:08 gav: > <@gav:polkadot.io> I can copy/paste this into a JAM-community document.

https://hackmd.io/@polkadot/jip1
  ↳ 2024-12-08 21:25 sourabhniyogi: Permissions need granting.
  ↳ 2024-12-09 09:53 prematurata: yeah can't access it 
2024-12-09 06:34 weigen: Hello, I have a question about work package, is a work package limited to a maximum of four segment roots?
2024-12-09 11:28 gav: > <@weigen:matrix.org> Hello, I have a question about work package, is a work package limited to a maximum of four segment roots?

No
  ↳ 2024-12-09 11:41 weigen: I thought a work package have mostly four work items and each work item only has one segment root
  ↳ 2024-12-09 12:34 gav: There can be four work items, each work item has no individual limit on imports and exports. Each import requires either a segment root or a work package hash to define it (along with an index). There can be a maximum of 2048 imports. [edited]
  ↳ 2024-12-09 12:34 gav: The ensuing work report as a whole has a single segment root. This root commits to all of the exports of all work items. [edited]
  ↳ 2024-12-09 13:36 weigen: Thanks, I got it!
  ↳ 2024-12-10 09:59 weigen: Hi, I'm a little confused after reading the paged proof part.Can I confirm that I understand it correctly?

Focusing on the work package export part, work items will export segments, and these segments will form a Merkle Tree with a constant depth. The Merkle Root of this tree will become the segment root in the work report.
Paged-proofs function will page the Merkle Tree built by the export segments, and each page will have 64 segments. Each segment will have a Merkle Proof (paged-proof) to the subtree root (tree of each page). The paged-proofs function will output the leaves (hashes of each segment), and each segment's Merkle Proof to the subtree root.

Is this understanding correct?
 [edited]
  ↳ 2024-12-10 11:21 gav: See my message in the main chat
2024-12-09 11:56 oliver.tale-yazdi: doc is private
2024-12-09 12:08 amritj: In CE 144 Audit announcement of JAMNP, how can we verify the announcement of no show auditors without the full list of reports they announced to audit?

https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-144-audit-announcement [edited]
  ↳ 2024-12-09 12:37 dave: Not sure I understand the question. Do you mean when an announcement is made claiming some no-shows, how these no-shows can be proved/verified?
  ↳ 2024-12-09 12:48 amritj: Yes, we pass a list of no-show auditors for every WR we intend to audit after tranche 0

The no-show data contain validator index and their audit announcement, so we can verify that the auditor really announced if they will audit the WR.

https://github.com/zdave-parity/jam-np/blob/5d374b53578cdd93646e3ee19e2b19ea132317b8/simple.md?plain=1#L656

But to verify the announcement, we need the original message that contains the full list of reports the no-show auditor announced

https://graypaper.fluffylabs.dev/#/5b732de/1d7e011d7e01

So, my question was how to retrieve the report list and verify the no-show auditor announcement [edited]
  ↳ 2024-12-09 12:51 dave: Everything needed to verify the no-shows should be included
  ↳ 2024-12-09 12:53 amritj: Yeah, but the full list of the no-show auditor work reports, is not included in the spec, and that I believe is required to verify the no-show announcement
  ↳ 2024-12-09 12:53 dave: FWIW you can just verify the signatures of the no-show announcements
  ↳ 2024-12-09 12:55 dave: > <@amritj:matrix.org> Yeah, but the full list of the no-show auditor work reports, is not included in the spec, and that I believe is required to verify the no-show announcement

Maybe I am misunderstanding but they are included here? `Announcement = len++[Core Index ++ Work-Report Hash] ++ Ed25519 Signature`
  ↳ 2024-12-09 12:56 amritj: Aah, I got confused by the definition of announcement in the graypaper and thought only announcement signature was included
2024-12-09 18:55 gav: (a) could be done trivially without the trouble of defining a multi client standard host function to implement. 
(b) I see little point of this other than for code deduplication. In that case if it’s a serious issue we should allow for code-importing in a more sensible way. 
2024-12-10 00:40 celadari: Hi, I would like to ask some help debugging signatures in work report tests.

In `tiny/multiple_reports-1.json` (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/reports/tiny/multiple_reports-1.json), our signatures are failing. **Could someone with a passing test vector share the following in HexString please ?**
- The encoding of the first workReport
- The hash of that encoding

I post the full workReport definition in the thread to keep this message brief in the main chat.
Thanks!
  ↳ 2024-12-10 00:41 celadari: the report
```json
{
                "report": {
                    "package_spec": {
                        "hash": "0x63c03371b9dad9f1c60473ec0326c970984e9c90c0b5ed90eba6ada471ba4d86",
                        "length": 12345,
                        "erasure_root": "0x9fc7e637969aef1a95dfb560a914cf5161a76498db3aa19df131cea199ed6e44",
                        "exports_root": "0x5c9dca800c145685f052ce1ba343e2b66b4c333ee4c4ca3b29cb347b1009cb83",
                        "exports_count": 3
                    },
                    "context": {
                        "anchor": "0x39cb518983b02695034b3b92cb31a7334e1a2ec3ef7dbfa32c68e4e8444363f1",
                        "state_root": "0xd8c577816b629241676502d0461e4eae42a375461314d64484f35f4228da23d6",
                        "beefy_root": "0x71c150347dc035847d5944c864a2d3ed0fa410341b2ffbfdeeaa1c9d6aa9cacd",
                        "lookup_anchor": "0x16bda47e5a68daf53c39ddee8af4ecaced7e87f3f0ac9da5a6f4f9e41350d319",
                        "lookup_anchor_slot": 6,
                        "prerequisites": []
                    },
                    "core_index": 0,
                    "authorizer_hash": "0x9a3a97d1950356ef6d3c20acb5ab6699be454b1498ecd513bdc6d849497e42eb",
                    "auth_output": "0x",
                    "segment_root_lookup": [],
                    "results": [
                        {
                            "service_id": 42,
                            "code_hash": "0x6470fd21983eae8d706f1edd5e2dc5afe095980f8fb7bd4ebfd33550d8730246",
                            "payload_hash": "0x3cf2d09da453bbdd6b68d8a1acd5f15ba23ba46d4ff087592b3d319432500a50",
                            "accumulate_gas": 10000,
                            "result": {
                                "ok": "0x64756d6d792d726573756c74"
                            }
                        }
                    ]
                },
                "slot": 14,
                "signatures": [
                    {
                        "validator_index": 1,
                        "signature": "0xeef064e3973b71fa4b0ce0c69c6799cc9b0e1887a894a93559a4c3a3848f039df82de95c70218588134ac51c2a329936ec54bc320b4c97c5f29f46acd1f4860e"
                    },
                    {
                        "validator_index": 4,
                        "signature": "0x68e84d7253380e8beb1fb71a54a8a0a805c06ea756da74d79bcbf5b811306cea560f27abaca175f6908ab54e4acc7bb919ab87ac616e7df106d3b043b71bac04"
                    },
                    {
                        "validator_index": 5,
                        "signature": "0x2c369533280dcd2fbdc2efeaf9dd0e042363ad14a4dee64a0f539def799f488912c85743132c5966bf5f9e65ec4d13cda5281fbbbe0c705a22e00424c858bf0b"
                    }
                ]
            },
```
  ↳ 2024-12-10 08:26 danicuki: Do you fall into error? If so, which one?
  ↳ 2024-12-10 11:44 celadari: image.png
  ↳ 2024-12-10 11:44 celadari: At the moment, what is failing is equation (11.27) - GP version 0.5.2 Screenshot of the equation failing
  ↳ 2024-12-10 11:56 celadari: At the moment, for:

- encoding of this workReport we get `0x63c03371b9dad9f1c60473ec0326c970984e9c90c0b5ed90eba6ada471ba4d86393000009fc7e637969aef1a95dfb560a914cf5161a76498db3aa19df131cea199ed6e445c9dca800c145685f052ce1ba343e2b66b4c333ee4c4ca3b29cb347b1009cb83030039cb518983b02695034b3b92cb31a7334e1a2ec3ef7dbfa32c68e4e8444363f1d8c577816b629241676502d0461e4eae42a375461314d64484f35f4228da23d671c150347dc035847d5944c864a2d3ed0fa410341b2ffbfdeeaa1c9d6aa9cacd16bda47e5a68daf53c39ddee8af4ecaced7e87f3f0ac9da5a6f4f9e41350d319060000000000009a3a97d1950356ef6d3c20acb5ab6699be454b1498ecd513bdc6d849497e42eb0000012a0000006470fd21983eae8d706f1edd5e2dc5afe095980f8fb7bd4ebfd33550d87302463cf2d09da453bbdd6b68d8a1acd5f15ba23ba46d4ff087592b3d319432500a501027000000000000001a3078363437353664366437393264373236353733373536633734`
- hash of this workReport we get `0xba11d7c078f0f4a259bae20f2d6633613c9fdf10ca7c554b7aceec94ee71847a`

- I tested all signatures with all public keysboth in current validators and previous validators.

- I'm suspecting something is off with my workReport object.
**Can you tell me what you get in hex format on your side please booth for encoding of the work report and the hash ?** [edited]
  ↳ 2024-12-10 13:54 celadari: NEVER MIND 🙃
error was on my side as I was parsing the test vector.

ALL GOOD NOW
2024-12-10 11:02 gav: IMG_3845.jpeg
2024-12-10 11:03 gav: Here’s a simple diagram of it. 
2024-12-10 11:04 gav: So the first proof page would be formed as p0 with h1 h2,3 and h4,7
2024-12-10 11:04 gav: The second would be p1 h0 h2,3 h4,7 
2024-12-10 11:05 gav: The fifth would be p4 h0,3 h5 h6,7
2024-12-10 11:05 gav: And so on. 
2024-12-10 11:06 gav: Each page is made up of 64 segments, each hashed with the proper prefix. This is then appended with the subtree path proof (ie the complementary nodes) from the segment root’s first child down to the root of the subtree holding the 64 segments of the page.   [edited]
2024-12-10 11:09 gav: This is enough information to form a proof of inclusion for any segment in the page given the segment root commitment. 
2024-12-10 13:26 weigen: Thanks for the clear explanation!
2024-12-10 18:12 danicuki: davxy afk:  What value are you using for G_A on the high_work_report_gas-1 test? This tests seems to be over the total gas, but no error expected in the vector. The sum in work results is 10_000_000, much above the 100_000 limit (or you are using another value for G_A). 
2024-12-10 18:37 jaymansfield: > <@danicuki:matrix.org> davxy afk:  What value are you using for G_A on the high_work_report_gas-1 test? This tests seems to be over the total gas, but no error expected in the vector. The sum in work results is 10_000_000, much above the 100_000 limit (or you are using another value for G_A). 

This might help: https://github.com/w3f/jamtestvectors/pull/20#issuecomment-2526203035
2024-12-10 19:57 celadari: Regarding work report guarantees test vectors (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/codec/data/guarantees\_extrinsic.json) => is it normal that `alpha` gets updated ? (field `"auth_pools"` is not the same in pre_state and post_state)

I ask this because I know `alpha` should be updated using `phi'` and `E_G` but it should be done after accumulation, more precisely after computing `phi'` ? [edited]
2024-12-11 00:33 celadari: I'm gonna put here a few questions I have regarding work report guarantees test vectors (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/codec/data/guarantees_extrinsic.json)
2024-12-11 00:35 celadari: - I think there might be an issue with file `full/consume_authorization_once-1.json` because test vector passes if I don't sort the hashes when computing super peak but fails if I do. However, if I refer to the GP 0.5.2 - equation (E.10) => hashes should be sorted to compute super peak
2024-12-11 00:38 celadari: I'm actually gonna post them on the github PR, might be the right place for it [edited]
2024-12-11 08:48 danicuki: I don't see anywhere in the formula that the elements should be "sorted". They need to be "consumed" in the order they are served , but not sorted [edited]
  ↳ 2024-12-11 11:49 celadari: My bad, lack of sleep made my interpret the screenshot
as sorting them but it just means keep the same order as b
  ↳ 2024-12-11 11:49 celadari: Capture d’écran du 2024-12-11 13-39-59.png
2024-12-11 08:50 dakkk: I answered 4 of 5 on gh
  ↳ 2024-12-11 11:48 celadari: Thank you very much Davide.

Your namesake also replied and made some commits.

- I just have a doubt regarding `\nu` and `\xi` which I replied on github

  ↳ 2024-12-11 11:58 dakkk: \nu is a \theta; btw I replied there
  ↳ 2024-12-11 13:21 celadari: Indeed, good to know, maybe we can suggest the "standard theta" for the GP....
  ↳ 2024-12-11 16:30 dakkk: 20241211_173025_5869733150355889156.jpg
  ↳ 2024-12-11 16:30 dakkk: this is on my desk 😂 [edited]
  ↳ 2024-12-12 08:29 danicuki: > <@dakkk:matrix.org> sent an image.

Oh God! I should have this when I started to read the GP 6 months ago. 
2024-12-11 11:10 clearloop: may I ask about the progress of erasure\_coding, saw there is still a lot of TODOs in the implementation that generates the testvectors, shall we push the testvectors together or it's enough for our current stage? [edited]
2024-12-12 08:24 danicuki: About the test vectors, I would suggest to include in the post_state only the fields that are supposed to be tested. Including fields with incorrect post transition value can create confusion for us. Or explicit post somewhere else that these values should not be checked. [edited]
2024-12-12 12:50 davxy: > <@danicuki:matrix.org> About the test vectors, I would suggest to include in the post_state only the fields that are supposed to be tested. Including fields with incorrect post transition value can create confusion for us. Or explicit post somewhere else that these values should not be checked.

What do you mean with:

> include in the post_state only the fields that are supposed to be tested.

And

> Including fields with incorrect post transition value can create confusion for us. 

?
  ↳ 2024-12-12 12:57 danicuki: Eg: in reports vectors, there are block history in pre and post state. We need to use the pre state info to transition the reports. But block history itself in post state are not changing, so there is no need to add them to post state

  ↳ 2024-12-12 12:58 danicuki: As an implementar my assumptions Wil always be: Take everything from pre state, apply block, and compare my resulting full post state with the vector post state. If something differs, I did something wrong.  [edited]
  ↳ 2024-12-12 13:00 danicuki: If some field is excluded from the post state, I become aware that I don't have to match any value for this specific field on post state. 
  ↳ 2024-12-12 15:55 sourabhniyogi: We prefer the opposite end of this, where the pre state and post-state are exhaustive.  Its less code for all of us -- everyone can write their own difference check if they need one. [edited]
  ↳ 2024-12-12 16:11 sourabhniyogi: The existing STF vectors have been massively beneficial for educational purposes, along with English descriptions.  

But for large scale testing, a state_transitions format (pre_state [with state_root], block, post_state [with state_root]) (in both JSON + JAM Codec form) would likely be better across all STF test vectors: 

https://github.com/jam-duna/jamtestnet/blob/main/safrole/state_transitions/407402_000.json

Is it possible to cover both needs?

  ↳ 2024-12-12 17:55 celadari: From our perspective, having the same fields in both pre_state and post_state is the preferred option because:

- It simplifies implementation by requiring only one parser instead of two.

- It allows us to easily verify that fields expected to remain unchanged are indeed unaltered.
  ↳ 2024-12-12 18:29 danicuki: > <@celadari:matrix.org> From our perspective, having the same fields in both pre_state and post_state is the preferred option because:
> 
> - It simplifies implementation by requiring only one parser instead of two.
> 
> - It allows us to easily verify that fields expected to remain unchanged are indeed unaltered.

How can you differentiate these two cases when a field remais the same in post state:

case (a): the STF should not change the value
case (b): the transition for that particular field is not being executed in that particular test vector

About parser, you don't need to create two parsers. If a field is missing, your parser simply ignore all inexistent fields
  ↳ 2024-12-12 18:31 danicuki: sourabhniyogi:  I completely agree that if we had all complete fields in all pre and post state would be better. The point is that sometimes these fields are there in the post state, but with values that actually not correct if we execute the full transition.  [edited]
  ↳ 2024-12-12 18:33 danicuki: What remains confusing to me is:
"what parts of the full STF should I run for each vector". This is not clear at all. The GP specification doesn't have a distinction between running one or other parts of the state. All state components are always changed according to pre state and block.  [edited]
  ↳ 2024-12-12 18:36 celadari: If you go to chapter 4, part 4.2.1 *State Transition dependency Graph* it becomes clearer
  ↳ 2024-12-12 18:37 danicuki: The dependency graph doesn't say you should "ignore" some transitions [edited]
  ↳ 2024-12-12 18:39 celadari: What do you mean by "ignore" ?

The dependency graph says that only these state components should be used as input and only those are modified as output.

If one state component is in the input but not the ouput it means the stf doesn't change it
  ↳ 2024-12-12 18:51 danicuki: Ok. Thanks. I will try to use the dependency graph as a guide. 
  ↳ 2024-12-12 18:52 danicuki: I thinking we are talking about the same thing but in a different language :-D
2024-12-12 12:53 davxy: For the first statement I imagine you meant having a different struct for the posterior state? 
2024-12-12 12:54 danicuki: > <@davxy:matrix.org> For the first statement I imagine you meant having a different struct for the posterior state? 

No. Same structure
2024-12-12 12:55 davxy: So now it is even less clear. Can you elaborate? 
2024-12-12 15:00 tvvkk7: Hi, I would like to confirm the result of work report/work returned from PVM invocation. The result of the work report will be "ok" , "panic" or "oog" as in jamtestvectors ? 
The result codes of innver PVM invocation such as HALT=0  is for PVM itself ?  [edited]
2024-12-12 16:04 ycc3741: 
2024-12-12 16:08 ycc3741: davxy afk: When I used the validator from your "jam-test-vectors" library , the following error occurred. I suspect that something might be wrong: [edited]
2024-12-12 16:08 ycc3741: 螢幕擷取畫面 2024-12-13 000742.png
2024-12-12 17:34 davxy: > <@ycc3741:matrix.org> davxy afk: When I used the validator from your "jam-test-vectors" library , the following error occurred. I suspect that something might be wrong:

Are you using this fork? https://github.com/davxy/asn1tools/
2024-12-12 17:54 celadari: We believe it would be helpful to have a `miscellaneous` field that is not used for comparing `expected_post_state` and `pre_state`, but instead provides intermediary state values. This would make it easier to identify which parts failed when test vectors fail.

For example, in the case of work reports, the miscellaneous field could include guarantor assignments and previous guarantor assignments. This way, if someone encounters a failing test vector, they could check whether the issue is related to these assignments or something else.

**What is everyone opinion on that ?** [edited]
2024-12-12 18:09 sourabhniyogi: To make our own debugging life easier and to help teams compare state with others we are extending our representation of serialized (k,v) state from just

```
            [
                "0x00fe00ff00ff00ff4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b",
                "0x00000000000000000020009b0000000000808628110000002810000000281c000000287333073200140a0400fffe00000000330b24330732008b11f8711014070000fffe0000000076782033090020330a0010330b0030330c00400a09140b00e0fdfe00000000480b70b704140904e0fdfe00000000330804330a04140700e0fdfe000000000a038d77208e772078108b110832003307320021842a80540a2011110550024802282915",
            ],

            [
                "0xff00000000000000000000000000000000000000000000000000000000000000",
                "0xee4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b4bb7c7f85f60ba102700000000000064000000000000006400000000000000fb0000000000000002000000",
            ]

            [
                "0x7fc1b2006200c10015b4b5bb2060104268e1155884d8b5ab2aad3c12475c7e95",
                "0x01cfaf4b00",
            ]
```

to (k, v, type, k\_and\_v\_metadata)

```
            [
                "0x00fe00ff00ff00ff4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b",
                "0x00000000000000000020009b0000000000808628110000002810000000281c000000287333073200140a0400fffe00000000330b24330732008b11f8711014070000fffe0000000076782033090020330a0010330b0030330c00400a09140b00e0fdfe00000000480b70b704140904e0fdfe00000000330804330a04140700e0fdfe000000000a038d77208e772078108b110832003307320021842a80540a2011110550024802282915",
                "account_preimage",
                "s=0|h=0xee4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b4bb7c7f85f60ba|plen=170"
            ],

            [
                "0xff00000000000000000000000000000000000000000000000000000000000000",
                "0xee4105beb468bf2d38812fae29cac024f6bf1fd208b5adee5b4bb7c7f85f60ba102700000000000064000000000000006400000000000000fb0000000000000002000000",
                "service_account",
                "s=0|b=10000 g=100 m=100 l=251 i=2|clen=32"
            ]

            [
                "0x7fc1b2006200c10015b4b5bb2060104268e1155884d8b5ab2aad3c12475c7e95",
                "0x01cfaf4b00",
                "account_lookup",
                "s=3244470911|h=0xc4254ce54e9166133e4b84446c88bbce6d31324bbac003e7c72d39b4918a8d02 l=193 t=[4960207]|tlen=1"
            ]
```

This is valuable not merely because {s, h, ... } is "lossy" going into k, but because we can quickly reason about (really, grep for) keys, values over many states quickly.   This makes it easy for us to settle debates within our team quickly and others if we all post something similar.  Having 2 extra values in the k,v serialization is simpler than putting it in more verbose pre-serialized state representation.  We're not super wedded to any specific metadata format for the 4 service k,v - but prefer non-JSON to have simple "cut" work rather than complex json attribute extraction (so, as you can see above, |-separated, space separated, then =-separated).  What do you think about this? [edited]
  ↳ 2024-12-12 18:26 celadari: I don't have any format preference on my side.
Only thing I would say is not to break (as much as possible) current test vectors parsers
  ↳ 2024-12-12 18:36 sourabhniyogi: Since there aren't any test vectors outputting (k,v,type,k_and_v_metadata) yet, this should be easy.  With a 3rd and 4th value being optional except for debugging purposes, we could also have w3f test vectors be of length 2 for compactness and the 3rd and 4th optional values purely for informal debugging, similar to info! = 100  
  ↳ 2024-12-12 18:44 sourabhniyogi: We'll post basically the above early next week as an update of these:
https://github.com/jam-duna/jamtestnet/blob/main/assurances/state\_transitions/407413\_003.json
but hope to pass the reports (with new beefy root etc) and get our 64-bit life in order, amongst signature fixes and so many other things -- fast moving targets! [edited]
2024-12-12 18:49 ycc3741: I am using this: https://github.com/w3f/jamtestvectors [edited]
2024-12-12 19:52 davxy: > <@ycc3741:matrix.org> I am using this: https://github.com/w3f/jamtestvectors

No, what I mean is that the validate.py script relies on the asn1tools Python package. You need to use the version I shared with you, as it includes some modifications compared to the upstream version.

2024-12-12 20:11 davxy: My 2 cents regarding the test vectors format discussion. As the conversation seems to be getting somewhat scattered, I suggest moving it to a dedicated GitHub issue. Personally, (of course) I believe that the current one is the best format for the moment, but that's just my opinion. Naturally, **everyone has an opinion** and this can get fuzzy fast, especially in a chat. However, I'm not sure how effective it is in this context.

I plan to finalize the collection of vectors for the different STFs using current format, as we are quite close to covering the full on-chain requirements. If we find a better format later, a switch can certainly be considered. Of course, anyone is free to propose independent vectors in other formats, as Jam Duna is already doing (although would be more beneficial to remain aligned. And that is the main purpose of the GH issue) [edited]
  ↳ 2024-12-12 22:08 danicuki: You are doing great work with the vectors! Please, don't take any of my suggestions as complains or requirements. I trust 100% on your final judgements in doing the best for JAM implementors. And yes, any further suggestion, github issue. 
  ↳ 2024-12-12 23:30 boymaas: Personally, I appreciate the current format, as I don’t see any advantage in changing it. Any change would involve trade-offs. The current setup works well and feels intuitive. I don’t have any suggestions for improvement that would justify the effort required (for us) to adapt to a new format.
  ↳ 2024-12-13 05:52 clearloop: imo the current test vectors format are good enough for unit tests (test implementations separately)

apart from the unit tests, clients may need other format for integration tests ( mb for rpc or p2p ), however, even though **new formats**, I believe wrapping the current test vectors' format is the best choice for efficiency > <
2024-12-12 20:22 sourabhniyogi: > <@davxy:matrix.org> My 2 cents regarding the test vectors format discussion. As the conversation seems to be getting somewhat scattered, I suggest moving it to a dedicated GitHub issue. Personally, (of course) I believe that the current one is the best format for the moment, but that's just my opinion. Naturally, **everyone has an opinion** and this can get fuzzy fast, especially in a chat. However, I'm not sure how effective it is in this context.
> 
> I plan to finalize the collection of vectors for the different STFs using current format, as we are quite close to covering the full on-chain requirements. If we find a better format later, a switch can certainly be considered. Of course, anyone is free to propose independent vectors in other formats, as Jam Duna is already doing (although would be more beneficial to remain aligned. And that is the main purpose of the GH issue)

Awesome - which issue?  https://github.com/w3f/jamtestvectors/issues 
2024-12-13 09:03 dakkk: a new one
2024-12-13 10:55 danicuki: Good morning all!
I have doubt about a safrole vector "enact-epoch-change-with-padding-1"

My gamma\_z (epoch root) is not matching the vector's - may be something related with the zeroed offender key. From what I understood, we should zero the offender key before calculating the ring commitment root. This zero is a 32 zero bytes. Did anyone could make this vector pass?

gamma\_k (b):

```
["aa2b95f7572875b0d0f186552ae745ba8222fc0b5bd456554bfe51c68938f8bc",
"0000000000000000000000000000000000000000000000000000000000000000",
"5e465beb01dbafe160ce8216047f2155dd0569f058afd52dcea601025a8d161d",
"1ecc3686b60ee3b84b6c7d321d70d5c06e9dac63a4d0a79d731b17c0d04d030d",
"3d5e5a51aab2b048f8686ecd79712a80e3265a114cc73f14bdb2a59233fb66d0",
"7f6190116d118d643a98878e294ccf62b509e214299931aad8ff9764181a4e33"]
```
my gamma_z (doesn't match the vector):

```
81eaf0953ed7474a81fa5445616a141c4c1f54ebd3cd8bda932bf612fc7fa41a90ce8db077f4bc5a3f71336e98a57ea8a6385289d15586c18ff7f8f5661a00bb783afe07938431c77d8cccc3585612cf3461f987e01dadfec7aefbc2aa3bb31a92e630ae2b14e758ab0960e372172203f4c9a41777dadd529971d7ab9d23ab29fe0e9c85ec450505dde7f5ac038274cf
``` [edited]
2024-12-13 10:57 dakkk: you should use the bandersnatch padding point 
2024-12-13 10:58 danicuki: > <@dakkk:matrix.org> you should use the bandersnatch padding point

What is padding point? I am not aware of this? 🤔
  ↳ 2024-12-13 11:08 danicuki: dakkk | JamPy: is this the padding point you are referring to?

• Padding point in Twisted Edwards form:
□x =26690044630372444677440308098946018389016038587388751811165279176488605875833
□y =569559155228528470326092120674498621727733902430463954153034712442147510565
– Compressed: 0xf5399e03f2121ff4c5d33386cdc66d56a6c5132b739f753442f7bda6c7698c03
  ↳ 2024-12-13 11:10 dakkk: idk, but when a key is invalid you should replace it with the padding point
  ↳ 2024-12-13 11:11 danicuki: what is the padding point value?
  ↳ 2024-12-13 11:11 dakkk: it depends on the ring size, it is not a fixed value
  ↳ 2024-12-13 12:13 davxy: This is the padding value:

```
[Ring Padding]
X: 23942223917106120326220291257397678561637131227432899006603244452561725937075
Y: 1605027200774560580022502723165578671697794116420567297367317898913080293877
Compressed: 0xf5399e03f2121ff4c5d33386cdc66d56a6c5132b739f753442f7bda6c7698c03
```

Sorry but the one in the spec was outdated.
Now you can see the value by running the example here: 
https://github.com/davxy/bandersnatch-vrfs-spec/blob/c6288ddea8770eb81dc70b01c97b0a54fb595090/assets/example/src/main.rs#L228-L234
  ↳ 2024-12-13 12:13 davxy: Also the spec has been updated with the new value
  ↳ 2024-12-13 12:33 davxy: Generally, in JAM you keep Bandersnatch public keys in compressed form (i.e. 32 bytes). 
Not all 32 bytes variants represent valid points in the Bandersnatch curve. 
If you fail to deserialize it then you need to resort to the padding point. [edited]
  ↳ 2024-12-13 12:38 davxy: E.g. the [0; 32]  array (i.e. 32 zero bytes) doesn't deserialize to a valid point.
  ↳ 2025-03-03 16:20 decentration: regarding this situation, where it is not an offender but the key cannot be decompressed. Do we just make it a padding point, but still continue to include it in the set?

in this specfic situation, in [safrole/tiny/enact-epoch-change-with-padding-1.json](https://github.com/davxy/jam-test-vectors/blob/469018009df0e8fa7e34b105f448e6ab2db60fe3/safrole/tiny/enact-epoch-change-with-padding-1.json)

the key:

```
                "bandersnatch": "0x1ecc3686b60ee3b84b6c7d321d70d5c06e9dac63a4d0a79d731b17c0d04d030d",

```

does not seem able to be decompressed, using `ark-ec-vrfs`. [edited]
  ↳ 2025-03-05 11:11 decentration: ah yes the updated padding points in this thread. 

 [edited]
2024-12-13 10:59 dakkk: checkhe note at the end of apx G
2024-12-13 12:30 ycc3741: Thanks a lot
2024-12-14 15:33 ycc3741: davxy afk: Hi I wonder whether we should use [this one](https://github.com/davxy/ark-ec-vrfs) or [this one](https://github.com/w3f/ring-vrf/tree/master) for singature and verification if using the vector you provide to test. [edited]
2024-12-15 01:29 jam_man: Has phase one already been submitted by teams? 
2024-12-15 06:19 davxy: https://github.com/davxy/bandersnatch-vrfs-spec [edited]
2024-12-15 07:17 clearloop: hi there! anybody feel weird about the tests cases (tiny) related to formula 11.23 (11. reporting)?

```
// formula 11.23
let (e, k) = (tau' - R) / E == (tau' / E) ? (eta'2, kappa'): (eta'3, lambda')
```

most of the test cases (tiny) are using `tau=14` in both guarantee & reports, however, `tau=14` meets the case using (`eta'3`, lambda') instead of the `eta'2` pair while the current tiny test cases are expecting the eta'2 pair to be used [edited]
2024-12-15 10:50 prematurata: AFK now but check README. `R` is different for `tiny`
2024-12-15 10:57 clearloop: yes but still...

```
let (e, k) = if (14 - 4) / 12 == 14 / 12 ? (eta_2, kappa): (eta_3, lambda)
               = if 0 == 1  ? (eta_2, kappa): (eta_3, lambda)
               = (eta_3, lambda)
```

I can pass all test vectors via ignoring `/E` but I know it is not correct ))) and if I stick to this formula over 10 test cases will get bad signature xd
2024-12-15 10:58 prematurata: will get back in afew and can check if you want.... can you name one specific test?
2024-12-15 11:00 clearloop: yes! for example https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/reports/tiny/many_dependencies-1.json
2024-12-15 14:27 prematurata: 'm using p\_eta3 as well and test is passing [edited]
  ↳ 2024-12-15 14:28 clearloop: hmm, I'll re-check my implementation later, mb sth is wrong in my code
  ↳ 2024-12-15 14:29 prematurata: let me know if i can help
  ↳ 2024-12-15 15:39 clearloop: I still believe my implementation is correct 🫠 will get back to this problem after finishing other stuffs
  ↳ 2025-02-05 13:49 decentration: i see in `many\_dependencies-1.json`, that `input.slot` and `input.guarantees\[0\].slot` are both `14`, which could produce a false positive [edited]
2024-12-16 11:14 prematurata: davxy afk: can you tell me which lib you using to sign/verify bandersnatch?
  ↳ 2024-12-16 11:40 clearloop: I believe you're looking for https://github.com/davxy/ark-ec-vrfs
  ↳ 2024-12-16 12:08 prematurata: I am using that but only for ring related stuff
  ↳ 2024-12-16 12:09 prematurata: Didn't see any routines to perform "standard" signatures 
  ↳ 2024-12-16 12:45 prematurata: ok nevermind :)
2024-12-16 19:00 ycc3741: davxy afk: I want to use the w3f [Rust library](https://github.com/davxy/ark-ec-vrfs/tree/d90e1800d571f32163e6f7b5d956d065668c899f), but we’re implementing our project in Go. We’re wondering if it’s acceptable to write a Rust file to encapsulate your Rust functionality, then compile it for FFI so that we can use it in Go. What I mean is: would doing this be acceptable according to the rules, or would it violate any regulations about which implementation languages are allowed?
2024-12-16 19:25 davxy: acceptable (see rule 1 https://jam.web3.foundation/rules ) [edited]
  ↳ 2024-12-17 04:52 clearloop: Thought we need to implement the erasure-coding as well ))
2024-12-16 19:29 ycc3741: Thanks a lot [edited]
2024-12-17 18:37 davxy: I've opened an issue to gather opinions regarding the detection of duplicate packages in the "reports" STF vectors.
https://github.com/davxy/jam-test-vectors/issues/7
2024-12-17 18:38 davxy: Mostly to properly address https://github.com/w3f/jamtestvectors/pull/28#issuecomment-2535457582
2024-12-17 18:39 davxy: Please leave your feedback directly in the GH issue. Thank you.
2024-12-17 20:03 prematurata: heads up for anyone who relied on the PR 14 to implement trie https://github.com/w3f/jamtestvectors/pull/14#issuecomment-2549423040. Although as stated in the comment the implementation makes more sense than what has been written in the Graypaper, I believe that PR is out of spec.

Also considering several implementors said they aligned with the PR provided vectors (which again is not in spec of gp) made me appreciate even more the clean room implementation rule. In this specific case the implementation was provided along with the vectors which I'd say should be discouraged.

2024-12-18 15:15 fbranciard: Hi, I have 3 questions about Core Play vision and services compositions:

1- I wonder if, in a sense, it will look like CRDT (Conflict-Free Replicated Data Type) world state. Or it will not be at this level but rather at a low level like several VMs: (start, stop, resume, VM state) with ability to communicate together through exposed APIs.

2- Another question: is Solid (from Tim Berners-Lee), separation of concerns - data, app, identity - will be a guideline in the design of Core Play?

3- Last question: I envision here https://forum.nextgraph.org/#narrow/stream/3-devs/topic/ISCC.20metadata.20on.20Document/near/776 that Jam could be a notary anchor for a Document-based system, is that correct?

2024-12-18 21:19 gav: CorePlay idea is based around actors whose memory exist within DA, but are committed to on-chain. Async and sync interaction patterns are possible via message queuing and typical async programming techniques, as well as co-scheduling. To the outside world (like developers and blockchain inspectors) it’ll look a lot like a regular smart contract environment except that the contracts are actually actors and execute perpetually. I’m not knowledgable about these of TBL’s musings but given his other work cannot imagine they’re especially relevant.  [edited]
2024-12-18 21:22 gav: The forum post you link isn’t especially helpful but from what I can tell it is a DAG project without any definitive global state. JAM has global state albeit with a slightly weakened coherence compared to fully synch systems so I couldn’t imagine the architecture is comparable. 
2024-12-18 21:23 gav: CRDT has no relevance to CorePlay. 
2024-12-18 21:54 fbranciard: Thanks for the explanation, looking forward to see jam services.
2024-12-19 11:13 subotic: A heads up for those that are waiting for the 64-bit PVM test vectors. Here is my PR: https://github.com/paritytech/polkavm/pull/238 adding 64-bit test cases. Jan still needs to do the review, so no guarantees that everything is correct. Since Jan is now on his well deserved holiday break, it will be some time until this gets merge. If you have any questions or problems, don't hesitate to ask.
  ↳ 2024-12-19 11:15 subotic: To generate the test cases, go into the `tools/spectool` directory and run `cargo run generate`
  ↳ 2024-12-19 13:20 clearloop: btw I remember the opcode set are changed as well after 0.5.0, the exist PVM test vectors were generated with 0.4.x's opcodes XD spent a lot of time on detecting why my parser could not parse the test vectors correctly while working on it [edited]
  ↳ 2024-12-19 15:54 prematurata: thanks for saving me the time and headache :)
  ↳ 2024-12-19 19:06 sourabhniyogi: Wow you totally rock!
  ↳ 2024-12-19 20:12 sourabhniyogi: May I suggest a new PR just like this going into w3f/jamtestvectors repo  but based your 64-bit update

https://github.com/w3f/jamtestvectors/pull/3/files

We can check it and report our findings in that new PR?  Thank you for this! [edited]
  ↳ 2024-12-19 20:21 tomusdrw: https://github.com/FluffyLabs/jamtestvectors/pull/5 We've generated a bunch of 64-bit test vectors based on Ivan's PR last week. If there weren't any significant updates since then these should be valid.

Obviously, "official ones" would be good to have, but I'm sure they will come at the right time.  [edited]
  ↳ 2024-12-19 20:22 sourabhniyogi: Spectacular!  Thank you as well!
  ↳ 2024-12-20 13:27 sourabhniyogi: Not 100% sure but tomusdrw Ivan Subotic  here are a couple of dozen opcodes that need coverage:
```
LOAD_IMM_64 = 20 // 0x14
LOAD_I32 = 57    // 0x39
LOAD_U64 = 58    // 0x3a
STORE_IMM_IND_U64 = 73 // 0x49
STORE_IND_U64 = 113 // 0x71
LOAD_IND_I32 = 119  // 0x77
LOAD_IND_U64 = 120  // 0x78
CMOV_NZ_IMM = 138   // 0x8a
ADD_IMM_64 = 139 // 0x8b
SHLO_L_IMM_64 = 141 // 0x8d
SHLO_R_IMM_64 = 142 // 0x8e
DIV_U_64 = 183	// 0xb7
DIV_S_64 = 184	// 0xb8
REM_U_64 = 185	// 0xb9
REM_S_64 = 186	// 0xba
SHLO_L_64 = 187	// 0xbb
SHLO_R_64 = 188	// 0xbc
SHAR_R_64 = 189	// 0xbd
MUL_UPPER_S_S = 193 // 0xc1
MUL_UPPER_U_U = 194 // 0xc2
MUL_UPPER_S_U = 195 // 0xc3
CMOV_NZ = 199   // 0xc7
```

We were happy to learn that polkatool covered 64-bit smoothly and had to implement some of the new 64-bit only ones to repeat.  Also, we got to 96% coverage within a day (like 5-6 outstanding cases).  We'll sweat through the last 6 next week and report back hopefully.

  ↳ 2024-12-20 15:19 tomusdrw: The PR just updates the spectool/assembly so it's only the existing examples, but re-generated for new opcodes. Indeed it's not covering some of the new stuff.
2024-12-19 19:01 sourabhniyogi: It appears that this MMB ref was NAYed to oblivion --   https://polkadot.polkassembly.io/referenda/1317 
What does this mean for our MMB vs MMR implementation / Beefy life?   
2024-12-19 19:17 gav: > <@sourabhniyogi:matrix.org> It appears that this MMB ref was NAYed to oblivion --   https://polkadot.polkassembly.io/referenda/1317 
> What does this mean for our MMB vs MMR implementation / Beefy life?   

Nothing.
  ↳ 2024-12-19 19:22 sourabhniyogi: At least for now, does this imply 0.5.2's  E.2 is effectively done or should teams expect a new MMB spec to replace/augment E.2?  

It wasn't that big a deal to do E.10 here:
 https://graypaper.fluffylabs.dev/#/5b732de/39be0139be01
2024-12-19 19:27 gav: “At least for now” everything is “effectively done” except what is on milestone 5.  [edited]
2024-12-20 05:17 sourabhniyogi: What is the expected plan for Grandpa Messages https://spec.polkadot.network/chap-networking#sect-msg-grandpa ?  
  ↳ 2024-12-20 11:47 dave: Grandpa messages will probably be quite similar to those used by Polkadot today. We're working on this now, though I don't have an ETA for an SNP update.
2024-12-20 05:20 clearloop: May I ask if there is test data like a sequence of blocks ( from genesis ) for testing block importing? [edited]
  ↳ 2024-12-21 03:11 sourabhniyogi: We are sharing this:
https://github.com/jam-duna/jamtestnet?tab=readme-ov-file#import-blocks
(4 sets of blocks)

Its not official but we hope you will tell us why its not perfect so we can fix it -- we have improved 10 things in it already and hope others may post something similar!
  ↳ 2024-12-21 13:09 clearloop: we're about to author empty blocks directly now (for writing the tests of importing blocks XD), it would be interesting to see if we can verify each others' blocks! will share a docker of our binary and related docs here as well next week!
  ↳ 2024-12-21 16:03 sourabhniyogi: Terrific!  See if you can conform to this
https://docs.jamcha.in/testing/import-blocks
for mode={fallback, safrole, assurances, ...} [we are aiming for this as well]

Note that "tiny" is:
V	6
C	2
N	3
E	12
Y	10
K	3
R	4
O	2
Q	6
as per this:

https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=615049643#gid=615049643


  ↳ 2024-12-21 16:53 clearloop: My implementation currently just supports `tiny` since I have a handwrite jamcodec, don't want to reach the edge cases if don't have to atm 😂

excited about testing with other teams in the next weeks!
2024-12-20 22:24 rgekfd3e: What are the improvements in dApp UX design when using JAM instead of an EVM dApp?
  ↳ 2024-12-21 13:35 clearloop: I don't think UX improvement could be considered in the virtual machine level, some companies promoting their new layer2s with supporting EIPs not approved in ETH mainnet is because they can't improve the UX but they want people think they are working on it (so they give people something looks convinced while people will never read one line detail of them), if they can do it, they build better DApps directly in their centralized services instead of centralizing a copy of ETH

imo the end of UX of DApps is storing users' secret keys in projects' centralized service ))
2024-12-21 13:59 gav: > <@rgekfd3e:decred.org> What are the improvements in dApp UX design when using JAM instead of an EVM dApp?

JAM is far more general a platform than EVM and doesn’t put any limitations on user-interaction directly. All of the stuff that Ethereum is trying to work around due to design limitations in its transaction model don’t apply to JAM (or, indeed, to Polkadot). 
  ↳ 2024-12-21 19:59 sourabhniyogi: Will every day users interact with Coreplay?  
How is Coreplay related to revive vs frontier vs normal substrate pallets?
How can non-Polkadot rollups (e.g. OP Stack)  interact with Coreplay?
Is there a writeup/lecture on Coreplay?  The only thing we know of is:
https://github.com/polkadot-fellows/RFCs/blob/gav-coreplay/0000-template.md
but I imagine with Section 12 "effectively done" (??) its possible to go next level on this?
2024-12-21 16:25 wind.sixwings: signing_context_example.png
2024-12-21 16:25 wind.sixwings: When reading the GP ch6, I saw that (6.18) ~ (6.20) defined 3 Signing Contexts. I would like to ask whether these 3 Signing Contexts need to be defined by the implementation team themselves or are there other official sources of definition?

Another question raised by team members during the discussion is whether Signing Contexts are constant in most cases? Or will it be modified under certain circumstances?
  ↳ 2024-12-21 16:56 clearloop: they are just constants, see `Appendix I.4.4`

```
# the singing context is "jam_entropy"
X_E = $jam_entropy 
```

you can verify them with the test vectors [edited]
  ↳ 2024-12-21 17:31 wind.sixwings: So a piece of text starting with $ can be understood as a constant string. I understand, thank you.
2024-12-21 20:25 gav: Define everyday users. Define interact.
  ↳ 2024-12-21 22:24 sourabhniyogi:  I'll give it my best shot ... 😅

“Everyday users” are individuals who engage with dApps by signing transactions/extrinsics/messages using a wallet solely under their control, typically resulting in state changes to one or more chains.

To “interact” with one or more smart contracts (revive contract with Coreplay powers TBD) means to invoke a method they expose in order to effect those changes.

With Polkadot Hub pallet-revive deployed in 2025, everyday users will interact with revive-compiled smart contracts, yay!    There is a direct vs indirect qualification added on whether everyday users interact with JAM.   Users interact _directly_ with Polkadot Hub in that their signed extrinsics make it onto Polkadot Hub (revive or not) -- for revive, they could, if they chose, look at the material they are signing, go check out the methods in a verified revive contract and see how Solidity code map into storage changes in some Solidity contract interfaces on Etherscan PolkaVM block explorer.   But through these same interactions everyday users will _indirectly_ interact with JAM, through the JAM CoreChains service validating workpackages containing segments related to these signed extrinsics; but users will have absolutely no idea how JAM machinery works to do that -- its cognitively impenetrable except for the fellows.  This is how the "JAM services are not for everyday users _directly_" is accurate, how the "there are no transactions on JAM" makes sense, even though the bits of workpackages are _about_ them.  Did I get that right?

If Coreplay is both a JAM Service and an upgrade of pallet-revive, it would be great to have some comprehensible revision to the above ending up with "everyday users DIRECTLY interact with JAM through Coreplay/revive" that harnesses the INSANE amount of trustless supercomputing power available.  No idea what that means for the "Cloud vs Hub" vocab, and I don't want it to delay 1.0 ratification 😅.  But avoiding hard forks with xyz on integration/co-scheduling in prep for this supremely high impact 2.0 on the roadmap is critical?  
2024-12-21 20:28 gav: Coreplay might reasonably be an upgrade path from pallet revive. The rest of Polkadot could interact with it synchronously via co-scheduling and co-integration, or asynchronously in the usual way via XCM. Non Polkadot systems could interact using a bridge. Coreplay is an idea at present; there is no writeup or lecture.  
2024-12-21 23:10 gav: It’s not exactly an upgrade for pallet-revive but it might provide an upgrade path for whatever systems are using it. We’ll have to see. 
2024-12-21 23:11 gav: Taken at your definitions then yes it would be interacted with by everyday users.  [edited]
  ↳ 2024-12-22 15:50 sourabhniyogi: Super exciting, can't wait to see all this happen!   I'll bet I'm not the only one who would like to see a lot of investment _beyond_ the JAM Prize into CorePlay, CoreVMs, JAM Services that make JAM something that everyday users can interact with.  But your relatively rare (and honestly, grinchy, to senior people anyway) vote/comment on 1317 brought a few questions to mind.   

Questions:
1. How should JAM services, tooling, and related innovations (minor or major) be supported outside the JAM Prize between OpenGov, the fellowship funds and outside capital?   Is there some ideal allocation between these sources (of capital) and sinks (talent doing xyz innovations) that you could articulate?   

2. Does a JAM-centric collective separate from the Fellowship make sense? Or does a 2025 revision to the 1.0/Substrate-centric fellowship charter to cover JAM + JAM Services (CoreChains/CorePlay/CoreVM), PolkaVM/revive/polkatool/JAM SDK, related tools to name last 18-24 months innovations make sense instead?  

3. Latent questions related to Rule 12:  What does it mean to be a fellow who knows JAM super well but knows nothing about Substrate?  What does it mean to be a fellow who knows Substrate super well but knows nothing about JAM?  

4. Can you provide guidance on how better decision making / resource allocation to JAM/CoreXYZ/PolkaVM innovation and support should come from the general public in OpenGov especially given that the knowledge required to reason about these things is either so new (say, JAM SDK) or requires a lot of expertise (say, the effort/innovation level in MMB over MMR)?  

I believe your guidance on these types of questions generally would be valuable for everyone who want to plot a course beyond JAM implementation life for next year and beyond.
2024-12-21 23:11 gav: However I think those definitions are not especially helpful as they are so broad. 
2024-12-21 23:13 gav: That transactions get signed in a dapp is about as relevant as the fact that a TCP packet gets authored when fetching a webpage. We don’t say that people “send TCP packets” though.  [edited]
2024-12-22 20:33 gav: 2. As I already answered in the fellowship call a few days ago, no. 
2024-12-22 20:34 gav: 3. Not much. There are already fellows who are experts in one area and not others. 
2024-12-22 20:35 gav: 4. I don’t see all that much need for JAM development from the “general public”. It’s a complex protocol not Roblox. 
2024-12-22 20:36 gav: 1. I’ve no idea beyond the obvious “build it and they will come” mantra. Support of Polkadot is no different to support of JAM, since JAM will become Polkadot. Thus you may as well ask that question in the Polkadot forum but with “JAM” exchanged for “Polkadot”. No.  [edited]
2024-12-22 20:41 gav: Finally [@sourabhniyogi:matrix.org](https://matrix.to/#/@sourabhniyogi:matrix.org), please do not treat this room as a perpetual Gavin AMA. If you have something to contribute to the conversation, contribute it. If you wish to start a new topic do so. But quizzing me on non-technical, *financial* strategy is totally unacceptable and goes against the CoC. I’ve already warned you of this.  [edited]
2024-12-22 20:42 gav: I thought I had already made this clear to you. Apparently not. Consider this a final warning. [edited]
  ↳ 2024-12-23 00:58 sourabhniyogi: Apologies for all the questions, and thank you for being so accessible this year. It’s been a delight, but I can see I’ve tried your patience. I’ll take a break and contain my enthusiasm. Happy holidays!
2024-12-23 13:36 clearloop: as we can see in the jam-types spec, https://github.com/w3f/jamtestvectors/blob/master/jam-types-asn/jam-types.asn#L32, the bls public key has `144 bytes`, if I'm not mistaken, `bls\_12\_381` has `96 bytes` or `48 bytes` (compressed) in the public key, that this 144 bytes could be the combined version of the compressed and the uncompressed versions? if so, shall we place the compressed version ahead of the uncompressed version since it could be more frequently used? [edited]
2024-12-23 15:57 davxy: copy/paste of an old reply given in the GP chan some time ago:

The public key for the scheme consists of two public elements, each corresponding to one of the two groups used by BLS for pairing: G1 and G2. Specifically, it is represented as (g1 * sk, g2 * sk), where g1 is the generator of G1 and g2 is the generator of G2. Each point in G1 is compressed into 48 bytes, while each point in G2 is compressed into 96 bytes. This scheme allows both fast verification of aggregate signatures and (pairing less) single signature verification. The full scheme is detailed in this paper: https://eprint.iacr.org/2022/1611 and is implemented by this library: https://github.com/w3f/bls. [edited]
2024-12-25 15:37 jaymansfield: Merry Christmas everyone! As we refine and accumulate memories this season, let’s celebrate connection, innovation, and a unified vision for the future!
2024-12-25 16:29 terryhung: Hi davxy afk , 
Merry Christmas!

I want to test the data in bandersnatch_ed_sha512_ell2_ring.json via ring_vrf_verify flow.


I’d like to understand how to construct the `ring` from this data and how the Verifier should output `ring_pks_com`.

Here is the related issue I opened: https://github.com/davxy/ark-ec-vrfs/issues/39

thanks!
2024-12-26 17:17 tvvkk7: 螢幕擷取畫面 2024-12-27 011630.png
2024-12-26 17:17 tvvkk7: Hello, 

I have a problem with deserialization while implementing Eq. 6.26. I used the deserialization of Equation C.5 with l=4 to compute the result, but got different result with the testvectors. Am I using the wrong deserialization and which term of deserialization should I use? 
2024-12-27 01:55 luke_jamixir: > <@tvvkk7:matrix.org> Hello, 
> 
> I have a problem with deserialization while implementing Eq. 6.26. I used the deserialization of Equation C.5 with l=4 to compute the result, but got different result with the testvectors. Am I using the wrong deserialization and which term of deserialization should I use? 

We also used to have problems there and it turned out to be a problem with our H4(blake hash 4 bytes)
We also deserialize using l=4 so that's likely not your issue 
2024-12-27 04:00 tvvkk7: Got it!  Thanks
2025-01-01 12:03 0xjunha: Hey guys we're in JAM COMMON ERA!
2025-01-01 20:29 tvvkk7: Hello, I have a problem on slot key sequence(Eq. 6.24) and the fallback mode happens. In the condition, gamma\_s' will be updated by the F function. I got the same result using testvectors of W3F, but got different result using test data of jam-duna. I use eta\_2 in [epoch 425523\_011](https://github.com/jam-duna/jamtestnet/blob/main/fallback/state_snapshots/425523_011.json) (prior slot key sequence). I use gamma\_s' in [425523\_000](https://github.com/jam-duna/jamtestnet/blob/main/fallback/state_snapshots/425524_000.json) (posterior key slot sequence).
According to Eq. 6.24, in the first slot, gamma\_s' will be updated using eta\_1. The other slots wii be gamma\_s' = gamma\_s if e' = e. So, the result should be gamma\_s' is finally updated using eta\_1.
Is my understanding incorrect ? [edited]
2025-01-02 02:23 shwchg: the files in state_snapshots is the post_state after applying the corresponding block. If you would like to use it as the pre_state for the next block, you should use eta_0
2025-01-02 10:11 tvvkk7: Thanks a lot 
2025-01-03 09:33 vinsystems: Will JAM be able to support distributed validator technology?
2025-01-03 10:47 gav: Define "distributed validator technology"
2025-01-03 10:48 clearloop: hmm, interesting, in my implementation, the validator could be local and remote, however, I think this kind of stuff is not proper for the current stage since we need to make the network work first XD [edited]
2025-01-03 11:12 vinsystems: Basically I mean the same (or similar) approach used in Ethereum, which spreads out key management across multiple parties to reduce single points of failure.  [edited]
2025-01-03 11:46 gav: JAM makes no great requirements on how validators manage/store their secret keys, only that they provide an IPv6 endpoint and set of relevant public keys. [edited]
2025-01-03 11:47 gav: If you want to give a better definition than "will it be like Ethereum?", I'm happy to offer a more detailed commentary.
2025-01-04 04:36 jakechen: Hello, we are encountering an issue with header serialization. When the test data we use does not include epoch_mark and tickets_mark, we can correctly serialize the header data and compute the parent header hash for the next time slot using BLAKE2b-256. However, when the test data includes either epoch_mark or tickets_mark, the hash we calculate does not match the test data.
In addition to handling the discriminator encoding (Eq. C.9), does the serialization of epoch_mark and tickets_mark require any additional processing for the array data, such as epoch_mark.validators? 
We are troubleshooting using the test data files [425530_000.json](https://github.com/jam-duna/jamtestnet/blob/main/safrole/blocks/425530_000.json) and [425530_001.json](https://github.com/jam-duna/jamtestnet/blob/main/safrole/blocks/425530_001.json).
2025-01-05 11:20 gav: > <@amritj:matrix.org> In graypaper here https://graypaper.fluffylabs.dev/#/911af30/19e30019e600
> 
> It is mentioned that import spec could contain both segment root and work package hash and to distinguish between them the work package hash value are tagged 
> 
> 
> But here according to jam official codec it is just a hash: 
> 
> https://github.com/w3f/jamtestvectors/blob/90fcf9020fa269a3aecc23feac0d09e7fee9123b/jam-types-asn/jam-types.asn#L121
> 
> So, how do we identify, if hash is tagged or not i.e. is it a segment root or work package hash?
> 
> 
> 

There’s a proper encoding given in C.29
2025-01-05 14:58 tvvkk7: Hello, I wold like to make sure whether the condition will happen if the report is good, but the work report hash is not in the fault. As gray paper defines [good reports should be in the fault](https://graypaper.fluffylabs.dev/#/6e1c0cd/12fb0212fb02) If any good report is not in fault, do we need to take any measure like append the work report hash to fault ? [edited]
2025-01-05 14:59 tvvkk7: 
2025-01-05 18:00 gilescope: C.6 Are there any test vectors for the length encoding? Is number 12 really encoded as 0x30 as some test vectors suggest? Sorry for asking but something's not quite right and I'm soaking up a lot of time on C.6.
2025-01-06 07:15 gav: > <@tvvkk7:matrix.org> Hello, I wold like to know whether the condition will happen if the report is good, but the work report hash is not in the fault.(Eq. 10.13)  If this happens, do we need to take any measure like append the work report hash to fault ?

Best to provide a link with the gray paper reader. 
2025-01-06 07:16 gav: > <@gilescope:matrix.org> C.6 Are there any test vectors for the length encoding? Is number 12 really encoded as 0x30 as some test vectors suggest? Sorry for asking but something's not quite right and I'm soaking up a lot of time on C.6.

Which test vectors imply that?
2025-01-06 10:10 gilescope: > <@gav:polkadot.io> Which test vectors imply that?

https://github.com/w3f/jamtestvectors/blob/dc20cbce7d855974aa64301a4d952e22f277010f/safrole/tiny/skip-epoch-tail-1.json#L169 - the gamma_a is a variable length and is 12 long according to the json for the pre_state. But the byte is 0x30 when I look at the hex immediately before `11da6d1f761ddf9bdb4c9d6e5303ebd41f61858d0a5647a1a7bfe089bf921be9` in the corresponding scale file.
2025-01-06 10:26 gav: That's probably an old test vector: 0x30 is a SCALE Compact integer encoding for 12.
2025-01-06 10:28 gav: Best to use the vectors in https://github.com/w3f/jamtestvectors/pull/28
2025-01-06 10:30 xlchen: .scale is using the old/non-gp scale codec. you should reference .bin files
2025-01-06 11:29 piotrzwolinski: 
2025-01-06 11:30 piotrzwolinski: Hello JAMmers!

At Fluffy Labs, we build tools like the [Gray Paper Reader](https://graypaper.fluffylabs.dev/) and [PVM Debugger](https://pvm.fluffylabs.dev/) to support JAM development, and we’d love your feedback! 🙌

👉 Anonymous feedback: https://docs.google.com/forms/d/e/1FAIpQLSducTy9dgPd0FG0QyWH-QKuolf1Sfp8I8kI2vdkKghuu82JoA/viewform
👉 Non-anonymous testimonial: https://docs.google.com/forms/d/e/1FAIpQLSfP2Yf0cfcb5vtaNzqJb40i-H5_gVxeTpWCLactlSmPMydxiQ/viewform

Thank you for helping us improve and support the JAM community! 🚀
  ↳ 2025-01-08 09:29 clearloop: Thanks for your awesome work! both of the two tools are playing important roles in our development! [edited]
2025-01-06 11:33 tvvkk7: Thanks, got it!
2025-01-08 04:19 clw0908: Hello, I have a question regarding the **codec** part in **jamtestvector**:  

I’m wondering whether the **"extrinsic_hash"** in **block.json** is calculated using [**GP-0.5.3 equations 5.4, 5.5, and 5.6**](https://graypaper.fluffylabs.dev/#/6e1c0cd/0cc6000cf200), or if it is still calculated using the older version of the function. Since the calculation method hasn't been modified for a long time, I’d like to confirm.  

[The commit that added block.json](https://github.com/w3f/jamtestvectors/commit/7a96598b7ad7d079288a0043b0240894c9a33864#diff-81e841f65f02445b042e5186d09d489695ef99a0408535e28b72ea60b2961e61) was made on **September 18, 2024**. Since then, there have been no further modifications to **"extrinsic_hash"**.  
2025-01-08 09:17 tomusdrw: > <@clw0908:matrix.org> Hello, I have a question regarding the **codec** part in **jamtestvector**:  
> 
> I’m wondering whether the **"extrinsic_hash"** in **block.json** is calculated using [**GP-0.5.3 equations 5.4, 5.5, and 5.6**](https://graypaper.fluffylabs.dev/#/6e1c0cd/0cc6000cf200), or if it is still calculated using the older version of the function. Since the calculation method hasn't been modified for a long time, I’d like to confirm.  
> 
> [The commit that added block.json](https://github.com/w3f/jamtestvectors/commit/7a96598b7ad7d079288a0043b0240894c9a33864#diff-81e841f65f02445b042e5186d09d489695ef99a0408535e28b72ea60b2961e61) was made on **September 18, 2024**. Since then, there have been no further modifications to **"extrinsic_hash"**.  

It doesn't really matter. The codec test vectors are not meant to be semantically correct. They are just testing if you can decode the data given some schema.
2025-01-08 16:08 gav: I think it'd be good to request treasury support for 2 or 3 deliberately-produced JAM (services and authorizer) SDKs, aside from the SDK produced by Parity.

The best way I see this of happening is to ask teams who have passed M1 to submit proposals for an SDK framework, giving code examples for the sort of thing their SDK would allow to write. I would then get some initial treasury funding of ~$100k, possibly just from the Fellowship Treasury. From the proposals, we could fund up to 10 teams ~$10k each to make initial prototypes of their proposals and 2 or 3 of the most promising prototypes could be further developed into proper SDKs. [edited]
2025-01-08 16:09 gav: Is there any interest from teams close to M1 to put forward such a proposal and build a prototype?
2025-01-08 17:37 jaymansfield: ima_2c6a278.png
  ↳ 2025-01-08 18:21 clearloop: congratulations! 

btw may I ask are you queuing empty blocks or also have the transaction pool implementations as well XD
2025-01-08 17:38 jaymansfield: Happy to share a glimpse of JavaJAM’s first testnet utilizing QUIC messaging. Still a lot of tweaks to go but feels good to get to this stage.
2025-01-08 18:11 clearloop: Hi there, we just introduced a simple general testvectors runner, please feel free to try it out!

```
cargo install specjam
specjam dummy
```

https://github.com/spacejam-network/specjam [edited]
2025-01-08 21:09 gav: > <@jaymansfield:matrix.org> Happy to share a glimpse of JavaJAM’s first testnet utilizing QUIC messaging. Still a lot of tweaks to go but feels good to get to this stage.

Could you repost with a link someone other than here? Media inclusion doesn’t seem to work for me at all:(
2025-01-08 21:46 jaymansfield: > <@gav:polkadot.io> Could you repost with a link someone other than here? Media inclusion doesn’t seem to work for me at all:(

Realizing now I probably should have made it a video, but you can find the same screenshot here: https://x.com/javajamio/status/1877069057372881158?s=46&t=WteYIn3tg7gE1pCvJh1G2Q
2025-01-13 19:02 tvvkk7: Hello, I have a question about serialization.  We have to check the data types of the serialization target to choose which kind of the serialization we should use, is that right ?
All the int types should be serialized using [equation C.5](https://graypaper.fluffylabs.dev/#/579bd12/360102360102).
And only the up-down arrow serialization uses [equation C.6](https://graypaper.fluffylabs.dev/#/579bd12/365602365602) ? [edited]
2025-01-13 19:42 gav: Yes that’s right. We might see C.6 used a bit more in other parts of the protocol as time goes on but for now your reading is correct.  [edited]
2025-01-13 20:03 ycc3741: thanks a lot. We've been a bit confused for a while.
2025-01-14 17:41 yu2c: Hello, does anyone know how to join [this call](https://x.com/danicuki/status/1879180907636232527) ?
I couldn't find any public invite information
2025-01-14 17:44 dakkk: good question
2025-01-14 17:52 rustybot: > <@yu2c:matrix.org> Hello, does anyone know how to join [this call](https://x.com/danicuki/status/1879180907636232527) ?
> I couldn't find any public invite information

How was this call organized? Is there another channel dedicated to JAM that I am not aware of? I completely missed it 


2025-01-14 17:55 ycc3741: We have no idea, either.
2025-01-14 17:55 jaymansfield: Also was not aware of any meetup [edited]
2025-01-14 18:01 rustybot: It seems plenty of teams were in the loop about this meetup (https://x.com/danicuki/status/1879210677216379008?t=VCKJxGk4SEqM1uRGC0IFcA&s=19). So either I've been living under a rock, or there's a communication channel that some of us aren't privy to


2025-01-14 18:42 prematurata: I didn't know as well 
2025-01-14 18:51 oliver.tale-yazdi: It was in the JAM0 channel since it is not really canonical "Jam", just among implementors: https://matrix.to/#/!KKOmuUpvYKPcniwOzw:matrix.org?via=matrix.org&via=parity.io  
(not sure if you need an invite)
2025-01-14 19:08 yuchun: Could you invite me? thanks [edited]
2025-01-14 19:41 danicuki: The JAM0 channel was created during the Bangkok gathering. Nothing there is private, just we didn't wanted to spam the main JAM chat with conferences and meetups organization details. The meeting video will be shared with all implementors. Anyone is welcome to join.

About the twitter thread in particular, fill free to send me your blurb and X handle, and I add it to the thread.
2025-01-14 19:43 danicuki: Summary of the Meeting Outcomes:

1/ 💼 Meeting Frequency: We agreed on holding monthly meetings to synchronize our efforts and tackle obstacles together. This will ensure that everyone stays updated on progress and challenges.

2/ 🎥 Recording Sessions: The team discussed recording our calls for transparency and sharing knowledge. These recordings will be made available privately and potentially shared publicly for broader community engagement.

3/ 🗓️ Upcoming Meetup: A second JAM0 meetup is being planned in Lisbon, likely around May, coinciding with Ethereum Lisbon. This event will focus on collaboration and knowledge sharing among JAM implementers. Waiting for gav availability to define dates.

4/ 🛠️ Community Test Vectors: We emphasized the importance of developing community test vectors to streamline our testing processes. This will help ensure compatibility and foster collaboration among different implementations.

5/ 📈 Milestones Discussion: Teams shared progress on their individual milestones, with special attention on the transition from the first milestone to the more complex second milestone, which involves networking and consensus mechanisms.

6/ 🌍 Networking Implementation: There’s a strong interest in collaborating on networking implementations across teams, ensuring that different JAM clients can communicate effectively.

7/ 🤝 Overall, the meeting reinforced our commitment to collaboration, transparency, and continuous improvement within the JAM community. Together, we aim to drive innovation and success in our projects!
2025-01-15 02:51 jay_ztc: Can someone invite me to the JAM0 channel please? Thanks!
2025-01-15 11:21 gav: I've seen a couple of proposals for JAM node RPCs:
- https://docs.jamcha.in/basics/rpc
- https://github.com/open-web3-stack/jam-rpc-spec?tab=readme-ov-file
2025-01-15 11:22 gav: The first thing I'd like to say is _Death to RPCs_! 🫣
2025-01-15 11:22 gav: In general, all JAM interaction should happen, as with `smoldot`, through an in-process (light) node. [edited]
2025-01-15 11:23 gav: However, I accept it's probably helpful to have some sort of RPC defined either for local interactions or development/debugging.
2025-01-15 11:23 gav: So, a slight critique of these two.
2025-01-15 11:24 gav: The first suffers from `jam_getServiceStorage` and, probably, `jam_getState`.
2025-01-15 11:24 gav: The `jam_getServiceStorage` RPC call, and probably the other also, are not generally implementable. [edited]
2025-01-15 11:26 gav: The protocol doesn't track inserted keys; the node would have to. This requires specialised logic and a potentially very large shadow database and removes the possibility of light-client implementations and fast-syncing. Given that block-execution will likely take a very large portion of the 6 second block time, full-syncing a chain of any significance is going to be practically impossible, doubly so if you're also having to retain a database of all inserted keys as well as everything else. [edited]
2025-01-15 11:27 gav: Otherwise the first proposal looks pretty sensible.
2025-01-15 11:29 gav: The second proposal has typos (never a good sign) and is not especially clear in meaning. In particular, `state_getKeys` and `state_getStorage` are not 100% clear on the meaning of the term "keys". If the meaning is the key as it appears in the JAM chain Merkle tree, then the calls are fine and make sense. If the meaning is the key as appearing in the `read`/`write` host-calls, then not. [edited]
  ↳ 2025-01-15 20:31 xlchen: sorry about the typos. you might be the first reviewer of it. it is the merkle key, not the original key
  ↳ 2025-01-15 20:31 xlchen: the idea is to expose the db directly for debugging purpose
  ↳ 2025-01-15 20:33 xlchen: it is designed for node developers and node operators, not for end users/dapps, which as you suggested should use light clients not rpc
2025-01-15 13:36 danicuki: JAM Community Call #1 video is live: https://www.youtube.com/watch?v=ghjvdHzA1P0

2025-01-15 21:26 tomusdrw: Are there any estimates when `jam-sdk` supporting `0.5.4` opcodes will be released? Or maybe there is any way to contribute to make this happen? :)
2025-01-15 21:26 gav: Tomorrow. 
2025-01-15 21:26 gav: Actually…
2025-01-15 21:27 gav: Are they not already in place in the latest release from a few days ago?
2025-01-15 21:27 gav: If not then I guess it’ll depend on [@jan:parity.io](https://matrix.to/#/@jan:parity.io)
2025-01-15 21:33 tomusdrw: let me double check, but afaict last release was 7 days ago and last time I checked it was producing pre-0.5.4 opcodes
2025-01-15 21:40 tomusdrw: yeah, `jam-pvm-build=0.1.9` seems to be producing a bunch of jumps initially and then a bunch of `113` instructions which used to be `STORE_IND_U64` and now is invalid.
2025-01-16 05:41 jan: We will cut a release today.
2025-01-16 10:07 danicuki: 
  ↳ 2025-01-16 10:07 clearloop: cat input?
  ↳ 2025-01-16 10:07 boymaas: qwer(ty)?
  ↳ 2025-01-16 10:41 danicuki: cat input
2025-01-16 11:33 gav: polkajam-sdk v0.1.12 is released on crates.io https://docs.rs/jam-pvm-common/latest/jam\_pvm\_common/index.html [edited]
2025-01-17 18:48 danicuki: I've created an open source repo with some JAM media assets. It might be helpful to use on presentations, social media posts, etc. Contributions are welcome: https://github.com/jamixir/jam-media
2025-01-17 19:14 jaymansfield: > <@danicuki:matrix.org> I've created an open source repo with some JAM media assets. It might be helpful to use on presentations, social media posts, etc. Contributions are welcome: https://github.com/jamixir/jam-media

Thanks for this. Definitely useful.
2025-01-19 17:41 celadari: Hi everyone,

I have a question regarding the Safrole test vectors. Looking at this commit:
🔗 [Commit 2d71c3f](https://github.com/davxy/jam-test-vectors/commit/2d71c3f76ac89aaf57abd892cc691841fa225c87)

I noticed that the ring root values were changed, even for test vectors without offenders.

❓ Can someone clarify what changed at that point in the computation of the ring root?

At the moment, we are using the following code (this part is from primitives, so I can share it here in the thread)
  ↳ 2025-01-19 17:42 celadari: ```rust
let ring_size = public_keys.len();
    let ring_ctx = ring_context(ring_size, pcs_params_file_path)?;
    let padding_point = Public::from(ring_ctx.padding_point());

    let mut keys: Vec<Public<BandersnatchSha512Ell2>> = Vec::new();
    for key in public_keys {
        let mut cursor = Cursor::new(&key);
        let pub_key = Public::<BandersnatchSha512Ell2>::deserialize_compressed(&mut cursor)
            .unwrap_or_else(|_| padding_point);
        keys.push(pub_key);
    }


    let pts: Vec<_> = keys.iter().map(|pk| pk.0).collect();
    let verifier_key = ring_ctx.verifier_key(&pts);
    let commitment = verifier_key.commitment();

    let mut buf = Vec::new();
    commitment
        .serialize_compressed(&mut buf)
        .map_err(|_| VRFResult::SerializationError)?;

    Ok(buf)
```
  ↳ 2025-01-19 17:51 vinsystems: Maybe [this](https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/safrole/README.md?plain=1#L23)
  ↳ 2025-01-19 18:03 celadari: > <@vinsystems:matrix.org> Maybe [this](https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/safrole/README.md?plain=1#L23)

This is the version of ark-ec-vrfs but what changed because my code uses ark-ec-vrfs and even updating the dependency didn't do it 🥲
  ↳ 2025-01-19 18:17 vinsystems: Also changed [this](https://github.com/davxy/bandersnatch-vrfs-spec/blob/bdd1f4b7ccbad9227dc28c72660d438cf00b1b33/assets/example/src/main.rs#L38) data file 
  ↳ 2025-01-19 18:42 celadari: I took the one in Davide's repo jamtestvectors but I'm gonna try tomorrow the one in this repo you pointed out
  ↳ 2025-01-19 19:58 celadari: > <@vinsystems:matrix.org> Also changed [this](https://github.com/davxy/bandersnatch-vrfs-spec/blob/bdd1f4b7ccbad9227dc28c72660d438cf00b1b33/assets/example/src/main.rs#L38) data file 

What is the code you use to generate ring root commitment ?
  ↳ 2025-01-20 07:56 vinsystems: ```
let ring_set: Vec<Public> = bandersnatch_keys;
let verifier = Verifier::new(ring_set);
verifier.commitment.serialize_compressed(&mut proof[..]).unwrap();
return proof;
```
  ↳ 2025-01-21 07:13 celadari: - In my case, Verifier has only method `verify`

can you tell what is your import please for Verifier ?

- Also, shouldn't you also handle padding (array of 0 is not a valid bandersnatch curve point) ?
  ↳ 2025-01-21 07:30 vinsystems: Im importing the bandersnatch-vrfs-spec example, the commitment method is [here](https://github.com/davxy/bandersnatch-vrfs-spec/blob/main/assets/example/src/main.rs#L120-L126)

Yes Im also handling padding and it's in the "ring\_set" vector of the above pseudocode. [edited]
  ↳ 2025-01-21 14:00 celadari: So far that's also how we do 🤔

- do you do like this to generate the keys ?

```rust
let padding_point = Public::from(ring_ctx.padding_point());

let mut keys: Vec<Public<BandersnatchSha512Ell2>> = Vec::new();
for key in public_keys {
        let mut cursor = Cursor::new(&key);
        let pub_key = Public::<BandersnatchSha512Ell2>::deserialize_compressed(&mut cursor)
            .unwrap_or_else(|_| padding_point);
        keys.push(pub_key);
}
``` [edited]
  ↳ 2025-01-21 20:28 vinsystems: It's something like (I didn't test it): 

```
let padding_point = Public::from(ring_ctx.padding_point());
let public_keys: [u8; 32] = bandersnatch_keys;
let mut ring_set: Vec<Public> = Vec::new();

for key in public_keys.iter() {
        let point = Public::deserialize_compressed(key)
            .unwrap_or_else(|_| padding_point);
        ring_set.push(point);
}
let verifier = Verifier::new(ring_set);
...
```


  ↳ 2025-01-22 09:37 davxy: > <@celadari:matrix.org> So far that's also how we do 🤔
> 
> - do you do like this to generate the keys ?
> 
> ```rust
> let padding_point = Public::from(ring_ctx.padding_point());
> 
> let mut keys: Vec<Public<BandersnatchSha512Ell2>> = Vec::new();
> for key in public_keys {
>         let mut cursor = Cursor::new(&key);
>         let pub_key = Public::<BandersnatchSha512Ell2>::deserialize_compressed(&mut cursor)
>             .unwrap_or_else(|_| padding_point);
>         keys.push(pub_key);
> }
> ```

IIRC in that test you need to use the padding point twice: once for an invalid key and once for a key in the offenders list (which is zeroed out, so it becomes invalid as well). Are you using padding for both of these? IIUC you get a different ring commitment?

  ↳ 2025-02-15 16:12 heyitsstanoagain: hi davxy I think the OP's concern (and mine too) was about unrelated test cases. E.g. I was struggling with `safrole/tiny/publish-tickets-no-mark-9.json` and only now saw that its posterior gamma\_z changed from `0x95f3...` to `0xb375...` in the mentioned commit (`2d71c3f`) I think there are no offenders in this case but something in the computation of the ring commitment has changed. [edited]
2025-01-19 19:10 danicuki: Some people noticed that the Polkadot logo used for JAM/Polkadot mix is an old version of Polkadot logo. gav Should we update it using the new one?
2025-01-19 19:12 piotrzwolinski: Hi!

We have finalized the first "official release" of the Gray Paper Reader (https://graypaper.fluffylabs.dev), which most of you probably know.

We believe this tool will serve as a living documentation resource even beyond the JAM Contest, supporting ongoing development and understanding of JAM.

To keep the Reader freely available and open-source, we’re **submitting a proposal for retroactive funding** to the Polkadot Treasury.

We’ve started a discussion on Polkassembly to share details about the proposal and gather feedback: https://polkadot.polkassembly.io/post/2722. Your thoughts and questions are welcome!
2025-01-19 19:15 boymaas: Great work! ❤️ I’ve been using it with pleasure much appreciated.
2025-01-20 22:19 decentration: can i confirm which hashing algorithm we are using for mmr peak hashes? im assuming sha2-256 by default.

2025-01-20 22:20 dave: MMR uses Keccak, most other things use Blake2b
2025-01-22 15:48 charliewinston14: Having some difficulty finding an erasure coding library that could adhere to the GP specs. Was previously using a branch of paritytech's erasure-coding repo (branch: cheme/test_vecs) but the PR has been closed as it was non conforment.  What library are the other teams using for this?
2025-01-22 17:28 decentration: for M1, are there any conformance test vectors that we don't need to do until M2, in the davxy/jam-test-vectors repo?

or shall we pass every (tiny) test from within assurances, authorizations, disputes, history, preimages, reports, safrole, statistics...? [edited]
2025-01-22 17:38 dakkk: Take a look on this issue: https://github.com/w3f/jamtestvectors/issues/21 

I have doubt about erasure coding, since I'm not sure it is required for M1 [edited]
2025-01-22 18:01 gav: Edit: M2 is focussed on block authoring whereas M1 on block execution. The erasure coding, for example, will not be needed for M1 as it is not used in block execution.  [edited]
2025-01-22 18:03 dakkk: From what I see on the website (https://jam.web3.foundation/), M2 is focused on block authoring, 3 and 4 are focused on performances
2025-01-23 08:41 gav: > <@dakkk:matrix.org> From what I see on the website (https://jam.web3.foundation/), M2 is focused on block authoring, 3 and 4 are focused on performances

Yes indeed. Most test vectors will end up being useful for M1 but some are not relevant (such as erasure coding). In any case the actual conformance tests will be done privately and using a random fuzzer by the W3F to avoid the possibility of teams gaming their implementations to any blind spots in the published vectors. 
2025-01-23 08:43 gav: The test vectors are there as an aid only. Don’t rely on them to tell you what you should and should not implement for M1 or M2. There is no short-cut to total comprehension of the Gray Paper.  [edited]
2025-01-23 08:44 xlchen: is the confirmation test fuzzer going to be open sourced? so that we don’t need to invest too much time to integrate other fuzzers
2025-01-23 08:50 gav: The interface will be. 
2025-01-23 08:51 gav: But probably not the block-generation aspects. 
2025-01-23 08:51 gav: That would defeat the purpose. 
2025-01-23 08:58 xlchen: ok so it will be more or less the acm contest style? we submit, get some vague error message if failed, and repeat until pass?
2025-01-23 09:07 gav: Well, given that the W3F's throughput is not infinite, teams relying on this "grind" strategy will likely not get anywhere fast.
2025-01-23 09:08 gav: For failed entries we will try to add a test vector to the public repository demonstrating how the candidate failed (by giving what it should have done). This may not always be possible, but we'll do our best. [edited]
2025-01-24 12:05 jan: I have just updated the PVM test vectors here; grab them fresh from the oven here: https://github.com/w3f/jamtestvectors/pull/3

This is the biggest update yet; changes:
   * The tests now target 64-bit PVM, in alignment with GP 0.5.4. (Thanks to Ivan Subotic for helping out with these!)
   * The `trap` exit status is now called `panic` to align with the GP.
   * Added new exit status: `page-fault`; tests which previously panicked when accessing unpaged memory now generate page faults.
   * Added 106 new tests from the RISC-V test suite transpiled into PVM.

All of the tests starting with `riscv_` are ported from an external RISC-V test suite, hence they're named based on which original RISC-V instructions they were testing. I've just transpiled them to PVM (since PVM is derived from RISC-V) and left them mostly unmodified.

As always, please do let me know if there are any issues with these test vectors.
2025-01-24 12:06 boymaas: Nice! Thank you Jan Bujak 
2025-01-24 23:07 jaymansfield: > <@jan:parity.io> I have just updated the PVM test vectors here; grab them fresh from the oven here: https://github.com/w3f/jamtestvectors/pull/3
> 
> This is the biggest update yet; changes:
>    * The tests now target 64-bit PVM, in alignment with GP 0.5.4. (Thanks to Ivan Subotic for helping out with these!)
>    * The `trap` exit status is now called `panic` to align with the GP.
>    * Added new exit status: `page-fault`; tests which previously panicked when accessing unpaged memory now generate page faults.
>    * Added 106 new tests from the RISC-V test suite transpiled into PVM.
> 
> All of the tests starting with `riscv_` are ported from an external RISC-V test suite, hence they're named based on which original RISC-V instructions they were testing. I've just transpiled them to PVM (since PVM is derived from RISC-V) and left them mostly unmodified.
> 
> As always, please do let me know if there are any issues with these test vectors.

Are the instruction codes for the risc-v tests aligned with the GP?
2025-01-25 09:25 gav: Given the above message, I’d say the answer is “yes”
2025-01-25 12:13 luke_fishman: question about  import segments:
as a guarantor i receive a work package that includes a sequence of imported data segments

I need to import and reconstruct them, by fetching 342 shards.

looking here(https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-139140-segment-shard-request)

i see that in order to fetch a shard, i need to use the erasure root

is this a mistake in the hackamd document?
should it be fetched using the segment-root?


  ↳ 2025-01-26 11:55 dave: Not a mistake. You need to maintain a segment-root to erasure root mapping
  ↳ 2025-01-26 14:17 luke_fishman: is the current GP version considered complete in regards to DA specs? or is there more to come?
i find it hard to follow / understand what mapping are needed to be maintained

2025-01-26 13:42 decentration: 
2025-01-26 14:18 gav: It should be unambiguous already.
2025-01-26 14:19 gav: It won’t be as nearly as easy as M1’s block-execution logic because it isn’t a simple closed-form spec, but more of a constraint-optimisation problem. 
2025-01-26 14:20 gav: That’s just the reality of block authoring as opposed to block execution. 
2025-01-26 15:57 luke_jamixir: OK, maybe it's a silly or too open ended questions, but could you shed some light please on 

1.Why is the justification for a import segment is either a segment root hash OR a work package hash
2. Why is erasure root used to fetch segments and not the segment root? 
3.being given a wp from a builder, what is the process to find its erasure root? (seems that in order to know erasure root I need to know the imports and in order to do that I need to know the erasure root) [edited]
  ↳ 2025-01-26 17:15 dave: 1. To allow importing of recently exported segments where the builder only knows the hash of the exporting WP (not its segment root)
  ↳ 2025-01-26 17:16 dave: 2. Because the validators providing the segment shards can verify/prove to the erasure root but not the segment root
  ↳ 2025-01-26 17:21 dave: 3. Build bundle and exported segments, erasure code both, calculate the root from the shards as per the GP. For importing a segment you need the erasure root of the WP that exported it, not the root of the WP that is importing it, so there is no circularity there
2025-01-26 18:14 luke_jamixir: So the WP that exported it, do I get it's erasure root from the corrodponding WR (on chain, accumulated already) or? 
2025-01-26 18:54 dave: Yes, you will need to get it from the WR. The assumption is that nodes will maintain a database mapping SR to ER, which they will do by monitoring WRs that are included on chain
  ↳ 2025-05-22 11:43 dvladco: Do we also need to keep a mapping of work-report hash to segment-root? in case the import segment is referenced by work-report hash? Also to me it looks like these dictionaries are part of the state, is there a plan to add this in the state, or is this a minor implementation detail?
2025-01-26 19:33 tomusdrw: FYI: I've built a web app to encode/decode JAM objects: https://papi.fluffylabs.dev it's a fork of an amazing papi-console, so most of the credit should go there - I just plugged in the JAM codec. Hope you'll find it useful. [edited]
2025-01-27 00:51 luke_jamixir: > <@dave:parity.io> Yes, you will need to get it from the WR. The assumption is that nodes will maintain a database mapping SR to ER, which they will do by monitoring WRs that are included on chain

Thank you [@dave:parity.io](https://matrix.to/#/@dave:parity.io) 
2025-01-27 08:59 gav: Just a friendly reminder on clean-room requirements: don’t look at other implementation’s code (and that includes PolkaVM). Doing this will compromise you and your implementation. It’s not hard to see where code is copy-pasted (and use of the world’s most powerful plagiarism device, AI, is no different).

The rules are clear: if you submit a code base with content determined to come from anywhere other than official specs, you’ll likely be disqualified. 
2025-01-27 10:18 jan: To expand on what Gav wrote, in the context of PolkaVM (since that's a major piece of Parity's node implementation that is already open source and people may be tempted to look at) this should be obvious but let me explicitly state it - copying _any_ of these is not acceptable according to the rules (this list is _not_ exhaustive; these are just examples):

- PVM program blob deserialization
- instruction parsing
- interpreter implementation of what each instruction does
- exact interpreter architecture
- machine code which the recompiler generates for each instruction
- outer PVM memory map builder

It's better to err on the side of caution and not look at PolkaVM at all, but there are some thing I would find acceptable to look at/copy/contribute to as long as it's declared up front that you've looked at these things (note that this is not "official" and I'm only speaking in a purely personal capacity here, but I will defend anyone who does any of these):

- human readable disassembly pseudo code syntax (that is, the way instructions are printed out as seen in the TESTCASES.md in my PVM test vectors; there's no official way to disassemble PVM programs besides what they're named in the GP, but feel free to copy my pseudo code syntax if you like it),
- bindings to native Linux APIs (`polkavm-linux-raw` crate) and x86/AMD64 assembler (`polkavm-assembler` crate) - these are just general purpose libraries that only coincidentally live in the PolkaVM repository for convenience; the goal here is for people to become experts in the JAM protocol, and not become experts in how to write high performance x86 assemblers (which you need for a very fast recompiler, but by itself is not specific to the JAM protocol),
- high level API as shown on https://docs.rs/polkavm (this is just an interface, not an implementation; even PolkaVM's API was/is partially based on `wasmtime`'s API),
- high level techniques for implementing a fast parser or a recompiler, since it's unrealistic to expect 34 independent teams to rediscover these from scratch, especially since those are useful/used when implementing _any_ VM, not just PVM (but I emphasize the _high level_ part - just copying PolkaVM's code here is not acceptable; if there's interest eventually I'll host a workshop where I'll explain some of these independent of any particular implementation),
- the toolchain to build PVM programs (`polkavm-linker` crate, `polkavm-derive`, `polkatool`, etc.) - this takes care of translating RISC-V code to PVM; this runs offline and is not part of the GP,
- the format of the `.polkavm` blob - the on-disk format of what the toolchain emits by default; this is not part of the GP and will never be (note that this only applies to the parts of the blob that are specific to the `.polkavm` blob and are _not_ specced by the GP!),
- the format of the debug info inside of `.polkavm` blob (is not and will never be specced by the GP; this is needed to be able to debug PVM programs and it's useful for production-level VMs to support some form of debug info)

In general please use some common sense, and when in doubt please first ask. [edited]
2025-01-27 13:20 luke_fishman: > if there's interest eventually I'll host a workshop where I'll explain some of these independent of any particular implementation


just stating my interest. i would be very happy to join any workshop you may host on the topic
2025-01-27 13:21 boymaas: Good point Luke | Jamixir Would be very happy as well!
2025-01-27 17:10 yu2c: Hello, I have a question about PVM implementation. Since we chose a non-Rust language to implement the JAM protocol, I feel that using a higher-level language makes PVM implementation more challenging.
Are there any language restrictions for PVM implementation?
2025-01-27 17:11 dakkk: what do you mean with "language restrictions"?
2025-01-27 17:24 yu2c: If we choose Golang to implement the JAM protocol, does that mean our PVM implementation is also restricted to Golang? Or we can implement our PVM by Rust?
2025-01-27 17:58 gav: You are free to mix-and-match languages from the same language set. 
2025-01-27 18:01 gav: Things get complicated with mixed-language implementations from two (or more) different language sets. For this, the Fellowship and W3F will evaluate the footprint of each language in the implementation and a fractional prize may be taken from the according sets. This fraction will be *entirely* at the judges discretion.  [edited]
2025-01-27 18:02 gav: To avoid being at the mercy of such an arbitrary decision I’d suggest teams stick to a single language set. 
2025-01-27 18:19 yu2c: Clearly understood! But I have another question: 
if I use Rust for some low-level implementation of the PVM and construct the PVM's high-level part in Golang by leveraging FFI (Foreign Function Interface) from Rust to Go, would this operation potentially go beyond the single language set?

Let me broaden the question: for third-party libraries (e.g., VRF, erasure coding, ...) allowed under the JAM Prize rules, would using FFI to bridge two language sets also go beyond the single language restriction?

2025-01-27 18:36 yu2c: I understand your answer regarding FFI [here](https://matrix.to/#/!wBOJlzaOULZOALhaRh:polkadot.io/$ZjjyqHc0IAYY1QxedjEaHj_ZCJ5s02NpPbZ7am8PGUM?via=polkadot.io&via=matrix.org&via=parity.io), but I’d like to focus on the issue of language sets: would using FFI between two different language sets be considered mixed-language set implementation under the rules?


2025-01-27 18:49 gav: Language is unimportant and irrelevant for the third-party utility libraries for those portions of the logic not covered by the prize (crypto, erasure-coding, networking, ...). [edited]
2025-01-27 18:50 gav: Language only matters for that code written and submitted against the JAM Prize (commonly known as a "JAM Implementation"). [edited]
2025-01-27 18:52 gav: > if I use Rust for some low-level implementation of the PVM and construct the PVM's high-level part in Golang by leveraging FFI (Foreign Function Interface) from Rust to Go, would this operation potentially go beyond the single language set?

Yes. It would most certainly and very obviously go beyond a single language set: your implementation is using two languages! [edited]
2025-01-27 18:59 yu2c: Got it, thanks for the clarification!
2025-01-27 19:58 tomusdrw: Correct me if my take on this is wrong, but my understanding is that the interpreter preformance is pretty irrelevant anyway, since to reach anywhere near the rust implementation (for m3/m4) it will require some transpilation of PVM code to native code (compilation).
I have a pretty limited knowledge on this, but afaict compilation involves: a) bringing in something that can turn assembler into native code (most likely llvm) and just producing native code for the hardware you are running on. For languages with runtimes it will require FFI anyway and the language-of-choice can only orchestrate that process.
  ↳ 2025-01-27 20:00 jan: You don't really want to use LLVM. Any implementation which uses LLVM would definitely not pass any of the performance tiers because JAM *requires* linear time O(n) recompilation (otherwise security of the network breaks) which LLVM cannot do.
  ↳ 2025-01-27 20:13 jan: So there are essentially two major parts to a PVM recompiler VM implementation:

1) recompiler which will turn PVM into native machine code - technically can be done in *any* language, but will be too slow in some languages if we target performance anywhere close to what PolkaVM has; for some non-systems languages you might be able to pull it off if you use non-idiomatic code and carefully write it for performance, for some languages (Python, Ruby, etc.) it's most likely completely impossible without using another language (maybe you could pull it off with some "Python -> C" runtime/translator/whatever, but I'm not familiar with this space so I can't tell)

2) interacting with low level OS APIs to "load" and run that code and manage the VM state (using hardware for detecting page faults, etc.); this for the most part will need at least some FFI, because the required APIs are very low level and a lot of languages can't do this natively
2025-01-28 03:48 clearloop: curious about if it is possible to hit m3 with an interpreter [edited]
2025-01-28 03:50 gav: > <@clearloop:matrix.org> curious about if it is possible to hit m3 with an interpreter

Highly unlikely. 
2025-01-28 07:05 dakkk: Anyway there are various techniques to improve performance even on interpreted languages; for instance, for me using python I can rewrite critical sections of jampy using cython (which is python code translated to C and compiled)
2025-01-28 08:54 jan: Take a look at benchmarks here:

https://github.com/paritytech/polkavm/blob/master/BENCHMARKS.md#oneshot-execution-for-pinky

Compare "PolkaVM (64-bit, recompiler)" vs "PolkaVM (64-bit, interpreter)". My interpreter can still be optimized, but even if you look at state of art optimized-to-the-bone interpreters (e.g. wasm3) there's still an order of magnitude performance difference vs the recompiler.

So essentially I expect the M3 performance threshold will most likely be on the level of "a working but not necessarily optimal recompiler with okay compilation speed" and M4 to be "an optimized recompiler with high recompilation speed".
2025-01-28 18:03 sourabhniyogi: The "JAM requires linear time O(n) recompilation" has been an non-explicit (but deepseekly awesome) requirement it appears, for M3 -- check?  Can you explain what teams would be expected to do to achieve this O(n) linear compilation time, and how we could get started on this process in the next 2 months?

It would appear that once we go through the above transformation, the bulk of our [Appendix A](https://graypaper.fluffylabs.dev/#/579bd12)  PVM implementations are then expendable training wheels, save the infamous [`ecalli`](https://graypaper.fluffylabs.dev/#/579bd12/25b90025b900) (and thus as tomusdrw says, anyone's interpreter performance is in fact _irrelevant_), check?  If this is correct, we should like to understand how this ecalli / host function call process works in a post-recompilation era, soon? [edited]
  ↳ 2025-01-29 06:52 jan: > Can you explain what teams would be expected to do to achieve this O(n) linear compilation time

I'm not really sure what there is to explain here as it should be pretty much self explanatory. The process of turning PVM into a native machine code needs to take O(n) time, that is the formula `recompilation_time = a * size_of_program + constant` must hold.

> how we could get started on this process in the next 2 months?

Write a recompiler which turns PVM bytecode into machine code in a single pass (that is, you don't go over the bytecode multiple times; you generate machine code as you read it), then write a VM that can load it and execute it.

> It would appear that once we go through the above transformation, the bulk of our Appendix A PVM implementations are then expendable training wheels

No, you want to write an interpreter first simply because recompilers are so much harder to debug. If you have a correct interpreter you can then easily crosscheck your recompiler against it. Even I wouldn't write a recompiler right off the bat and first make an interpreter.

>  If this is correct, we should like to understand how this ecalli / host function call process works in a post-recompilation era, soon?

Sorry, I don't understand this question at all. There's nothing special about ecalli nor about calling host functions?
2025-01-28 19:15 gav: > as tomusdrw says, anyone's interpreter performance is in fact irrelevant

Almost certainly correct.
2025-01-28 19:17 gav: Jan Bujak is already planning on giving talks about how to achieve a high performance O(n) recompiler. Any team interested in delivering M3 or M4 would be well-advised to pay *very* close attention.
2025-01-28 19:18 gav: It won't just be about the recompiler though. Much performance will come with optimised databases, Merklisation and networking behaviour. M4's performance tests (which have yet to be written) will be stringent.
2025-01-28 19:19 gav: M3 is intended to be somewhat less stringent but still requiring a recompiler and sensible implementations for all of the above. Obviously, some languages will need to be less optimised than others in order to get to M3.
2025-01-28 23:03 decentration: do you mean don't use AI as a tool for plagiarism, or that AI is itself plagiarism?

it is a very clear rule not to look at anything related to JAM implementation except for the GP, these two channels, the JAM videos and the conformance tests.

But what is now less clear are AI tools use. i thought it was clear when you mentioned that AI should not be used to plagiarise someone else's work, in [June 2024](vector://vector/webapp/#/room/!wBOJlzaOULZOALhaRh:polkadot.io/$aA1-kjwr08g74hQ46SpIIBajbxSFsZl_hg5RfRcWvpQ), this makes sense and is an understandable concern, hence why commits must show a timestamped path of one's own coding journey.

But it has never been mentioned that it cannot be used at all. Can you confirm? Because the "Explain" button in the Fluffy Labs GP reader, signals that it can be used, but as an obvious caveat not to be used as a tool to rearticulate someone else's work. [edited]
2025-01-28 23:16 jimboj21: Hello, I have a question regarding the MMR super peak function (GP E.10). I thought I have an understanding of how this works, but am not getting the correct output on the reporting vectors test case for this.

Lets say the input to the function is: [a, b, nil, c]
I would expect the following behavior for this example:
- empty removed, giving [a, b, c]
- msg = $peak + a + b
- msg2 = $peak + H(msg) + c
- super_peak = H(msg2)
  
Does this seem like the correct flow (i reduced the details in the example, but can elaborate on steps if needed)? I'm not understanding where I am off in my logic here but like I said I am not outputting the correct value (unless its a bug elsewhere). 

Any input is appreciated, thanks!
  ↳ 2025-01-29 08:29 dave: This was changed in the GP recently, not sure the test vectors have been updated yet
  ↳ 2025-01-29 08:33 dave: See https://github.com/gavofyork/graypaper/commit/f9e72d79698077a2d21075f6d5555250a7c498b8
  ↳ 2025-01-29 08:36 prematurata: On my side they don't look like the tests have reflected the recent changes
  ↳ 2025-01-29 15:09 jimboj21: oh my gosh this is totally it! I was so confused, reminder to self to be careful with versions 😅 Thanks for help here
  ↳ 2025-02-08 21:40 decentration: this is helpful thread, thanks. so to pass conformance test use "node" instead of "peak" as prefix. 
  ↳ 2025-02-09 15:23 decentration: > <@rustybot:matrix.org> Vectors were regenerated to use "peak". Have you tried to pull the last rev?

oh no i didnt, ty 👍
2025-01-29 00:33 gav: > <@decentration:matrix.org> do you mean don't use AI as a tool for plagiarism, or that AI is itself plagiarism?
> 
> it is a very clear rule not to look at anything related to JAM implementation except for the GP, these two channels, the JAM videos and the conformance tests.
> 
> But what is now less clear are AI tools use. i thought it was clear when you mentioned that AI should not be used to plagiarise someone else's work, in [June 2024](vector://vector/webapp/#/room/!wBOJlzaOULZOALhaRh:polkadot.io/$aA1-kjwr08g74hQ46SpIIBajbxSFsZl_hg5RfRcWvpQ), this makes sense and is an understandable concern, hence why commits must show a timestamped path of one's own coding journey.
> 
> But it has never been mentioned that it cannot be used at all. Can you confirm? Because the "Explain" button in the Fluffy Labs GP reader, signals that it can be used, but as an obvious caveat not to be used as a tool to rearticulate someone else's work.

It is a slightly impetuous and controversial remark but my point was that current AI tools *are* fundamentally plagiaristic. 
2025-01-29 00:34 gav: Generally they are shallow reformulation of the work of others and usually devoid of original material.
2025-01-29 00:36 gav: We can’t really enforce the non-use of AI more than we can enforce not looking at, say, stackexchange. But if we see obvious similarities in two code bases we will assume at least one is plagiaristic. 
2025-01-29 00:37 gav: So beware of this if using ChatGPT to write your algorithms for you. 
2025-01-29 05:05 stanleyli: Hello everyone,

I just created a PR to jamtestvector, providing test vectors generated based on the definitions from the Gray Paper.
https://github.com/w3f/jamtestvectors/pull/35

I hope those interested can give them a try, and I look forward to contributing to the community
2025-01-29 07:49 dakkk: 
2025-01-29 07:50 dakkk: We talked about it in this channel in September, if I remember correctly
2025-02-03 11:08 emielsebastiaan: I found an error in testvectors for the `rem_s_64` instruction: 
https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2630619549
2025-02-03 12:35 decentration: do we have a tiny const for `L` (re: 11.34)? In GP (I.4) Values it's:

```
L = 14, 400: The maximum age in timeslots of the lookup anchor.
``` [edited]
2025-02-03 12:47 oliver.tale-yazdi: I dont think there was a value proposed for this yet, otherwise i will add it to https://docs.jamcha.in/basics/chain-spec/tiny  
We can probably calculate backwards from the toaster full spec (modulo any contraints)?
  ↳ 2025-02-03 12:58 decentration: ah ok thanks for these docs, i think for now i can infer it from the `report_before_last_rotation` test vector
  ↳ 2025-02-03 13:12 decentration: oh no, actually `rotation_period` = 4 is what i need for that test vector.

i just need to floor(22/4) - floor(6/4) = 4, which is greater than 1 rotation.

but for `L`, I will just use a small reasonable number, i will go with 60. [edited]
  ↳ 2025-02-03 19:12 sourabhniyogi: If you feel industrious, consider `L` (`max_age_in_timeslots` (?)) for other networks from tiny to full ?

https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=615049643#gid=615049643


As you can see, since most of us can't afford a JAM Toaster but can afford a few hours of `small` to `large`, or non-stop `tiny` to `small`, the simple-minded approach taken thus far is to have the same constants for `tiny` through `large` as `tiny`, and the same constants for xlarge through `full` as `full`.  If anyone has a better idea, just go for it!
2025-02-03 18:11 gav: IMG_4368.jpeg
2025-02-03 18:11 gav: IMG_4367.jpeg
2025-02-03 18:11 gav: IMG_4366.jpeg
2025-02-03 18:12 gav: IMG_4365.jpeg
2025-02-03 18:12 gav: IMG_4364.jpeg
2025-02-03 18:12 gav: IMG_4363.jpeg
2025-02-03 18:12 gav: IMG_4362.jpeg
2025-02-03 18:12 gav: IMG_4361.jpeg
2025-02-03 18:12 gav: IMG_4360.jpeg
2025-02-03 18:13 gav: Some new pics on the latest state of the Toaster.
2025-02-03 18:13 gav: We now have around half of the machines delivered for phase 1 (41 of them), and should have the remaining 45 in the next 2-3 weeks. [edited]
2025-02-03 18:13 gav: The first 6 are being configured now in a temporary server room, the others will be installed and configured in the dedicated space once that's ready. 
2025-02-03 18:14 gav: They've been installing some serious heat ducts to make sure that the jacuzzi gets toasty.
2025-02-03 18:18 gav: Once phase 1 is built out and going strong we can start to think about phase two, which will see an additional 85 machines for a total of 171 machines. That will take us to our goal of 16 AMD TR cores, each with 1MB L2 cache, for each of the 1023 nodes. [edited]
2025-02-04 20:09 decentration: > <@gav:polkadot.io> They've been installing some serious heat ducts to make sure that the jacuzzi gets toasty.

nice use case 👌
2025-02-05 13:54 decentration: Do we need to enforce a particular order for the Set of Ed25519 keys, Reporters (R)? 

from gp 11.26 i believe we don't, but just checking if we need it to go beyond and conform to the order of test vector exactly. e.g. r[eports_with_dependencies-1.json](https://github.com/davxy/jam-test-vectors/blob/553ba30d80d39f892fbd74806ba21152e01bd8a5/reports/tiny/reports_with_dependencies-1.json#L337)
2025-02-05 14:09 gav: Do you have a GP link?
2025-02-05 14:10 decentration: https://graypaper.fluffylabs.dev/#/4bb8fd2/15b80015b800

i ordered from ascending validator\_index but seems test vector is slightly different [edited]
2025-02-05 14:15 gav: 11.26 only provides constraints for the items.
2025-02-05 14:16 gav: 11.25 constrains the ordering of the items.
2025-02-05 14:16 gav: (by `v`).
2025-02-05 14:26 decentration: ok ty, yes i'm ordering by v \[0,1,2,3,4,5\] but seems test vector is doing something different, i.e. \[1,0,4,5,3,2\] in reports\_with\_dependendencies-1.json, will [pr in the repo](https://github.com/davxy/jam-test-vectors/issues/15).  [edited]
  ↳ 2025-02-05 15:11 decentration: ok i see now test vectors are ordered lexicographically and not by validator index, so i will go with that approach, ty. 
2025-02-06 13:23 clearloop: curious how many teams are now following jamnp? when will there be a stable spec for the network (p2p) implementation? will there be an official transaction sender client for testing & debugging? [edited]
  ↳ 2025-02-06 13:53 dave: JAM-SNP is stable modulo bugs, so I assume you mean the full protocol? Don't know the answer to that. For now you should just implement SNP. The conformance testing suite will almost certainly contain networking tests. This does not exist yet though so don't really have details.
  ↳ 2025-02-06 14:29 clearloop: I'm not pretty sure about some components of JAM-SNP so I was hoping those uncertain stuffs are not 100% required that I can hack or trim them 😂 
  ↳ 2025-02-06 16:06 gav: JAM-NP is scheduled to be added as an appendix in the 0.7/0.8 series. We'll need a decent amount of Toaster-experimentation to gain some confidence that the network protocol is capable of delivering the sort of performance we need. [edited]
2025-02-07 14:45 ycc3741: Does implementing BLS Signatures require a PoPs version, or is a non-PoPs version sufficient?
2025-02-07 14:45 ycc3741: Refer to https://eprint.iacr.org/2022/1611.pdf.
2025-02-07 16:09 wind.sixwings: Is there a bls signature length defined in GP? We need to ensure that the bls signature length is consistent
2025-02-08 23:22 rustybot: > <@decentration:matrix.org> this is helpful thread, thanks. so to pass conformance test use "node" instead of "peak" as prefix. 

Vectors were regenerated to use "peak". Have you tried to pull the last rev?
2025-02-10 11:38 sourabhniyogi: Here is our open source implementation of erasure coding in Go ([Appendix H](https://graypaper.fluffylabs.dev/#/5f542d7/3c11003c1100)) with a matching [erasure coding test vector](https://github.com/w3f/jamtestvectors/pull/35):
 https://github.com/jam-duna/jamtestnet/tree/main/erasurecoding
We would love others providing bug reports on this -- once its believed to be compliant by 2+ teams, we imagine other language implementations can match.

2025-02-10 19:10 lucy_coulden: Attended the first JAM Tour session at Cambridge University which was cracking!
I have a couple of questions…
- how do people apply to be involved as a builder?
- I believe there are 35 official teams. Is there a list of these teams and where they are based? We are doing a big push in the US and exploring a physical footprint which may be called a JAM space and where people could go to build and be together with others in the Polkadot ecosystem.
  ↳ 2025-02-10 20:06 jay_ztc: It's worth calling out there is a strict clean room requirement for validator implementations, love this as a long pole idea for post M5 
  ↳ 2025-02-11 01:25 lucy_coulden: Noted and thanks Jay ☺️
  ↳ 2025-02-11 14:32 philip.poloczek: You can always start a team as well. There is no limit of participating teams or "officially" approved teams. The list just includes teams which made it public they formed and started working on JAM. :) [edited]
  ↳ 2025-02-11 14:33 philip.poloczek: Not all of them might be ending up implementing all milestones or even one. It's quite the challenge after all, so everything is still up for grabs! :)
  ↳ 2025-02-11 14:57 jay_ztc: "Artificial limit of teams"?
  ↳ 2025-02-11 16:00 philip.poloczek: Meant to write "no artificial limiting of teams", updated my message 👍️
2025-02-10 19:12 xlchen: you can find registered teams here https://graypaper.com/clients/
2025-02-10 21:32 ascriv: +1 for jam hacker spaces post m5 
2025-02-10 21:56 sourabhniyogi: image.png
2025-02-10 21:56 sourabhniyogi: Some JAM implementers are getting together in a "JAM0 Meetup #2" call in the next 24 hours.  If you are implementing JAM, please add this to your calendar and DM me (@sourabhniyogi) and I'll you to the "JAM0" Element channel where a meeting link will be dropped.


2025-02-10 21:59 jaymansfield: > <@sourabhniyogi:matrix.org> Some JAM implementers are getting together in a "JAM0 Meetup #2" call in the next 24 hours.  If you are implementing JAM, please add this to your calendar and DM me (@sourabhniyogi) and I'll you to the "JAM0" Element channel where a meeting link will be dropped.
> 
> 

Looking forward to meeting the other teams tomorrow!
2025-02-11 01:25 lucy_coulden: Thanks Bryan! Is there anything that lists where in the world the teams are based? [edited]
  ↳ 2025-02-11 14:31 philip.poloczek: Hey Lucy, what's so interesting about the location is the contact not enough? This is often very rough as the teams just formed and not yet put a custom website up or anything which could inform about the teams location.
2025-02-11 01:27 lucy_coulden: 
2025-02-11 04:41 xlchen: I am not aware of any public list with team location. Some of the teams are remote / global also.
2025-02-11 12:25 alice_und_bob: can services pull in memory pages from other services?

I am asking because I wonder how separated different applications in JAM are across the service boundary. E.g. can a corechains chain's logic be based on the state of a coreplay agent? [edited]
  ↳ 2025-02-11 13:26 bkchr: Jam doesn't know the concept of memory pages. But yeah, you can put multiple items of different services into one `WorkPackage`
  ↳ 2025-02-11 13:52 alice_und_bob: thanks basti.

who then knows about the memory pages? is it an optional additional service? does JAM not know about the DDL?
  ↳ 2025-02-11 13:52 bkchr: DDL?
  ↳ 2025-02-11 13:53 alice_und_bob: distributed data lake
  ↳ 2025-02-11 13:53 bkchr: Yes there will be a service that handles these memory pages etc 
  ↳ 2025-02-11 13:53 bkchr: You mean the da layer? [edited]
  ↳ 2025-02-11 13:53 gav: Yes - D3L (decentralised, distributed, data lake) is what I'm calling JAM's DA [edited]
  ↳ 2025-02-11 13:54 alice_und_bob: I see. So JAM is like a microkernel that is completely stateless and then D3L is a service that listens to the outputs of cores and keeps it available for 28 days? [edited]
  ↳ 2025-02-11 13:54 gav: JAM is more like the virtual hardware.
  ↳ 2025-02-11 13:54 gav: And e.g. CorePlay would be more akin to the OS kernel which sits atop that.
  ↳ 2025-02-11 13:55 gav: And actors in CorePlay would be the software running on the OS.
  ↳ 2025-02-11 13:55 gav: the D3L has no concept of services. Once data it in there it's not associated with any service and thus any service may read it.
  ↳ 2025-02-11 13:56 gav: It is temporary and immutable, which means once data is added it cannot be altered and it only lasts for a limited period of time in there (28 days) before it must be re-added. [edited]
  ↳ 2025-02-11 13:56 alice_und_bob: and D3L as a service... who is it governed by? Is it immutable except for hardforks or is it under the control of an on-chain governance mechanism?
  ↳ 2025-02-11 13:57 gav: Some services probably won't make much use of it since they will need to have data in some other domain-specific format (e.g. the parachains service will use Substrate's Merkle structure).
  ↳ 2025-02-11 13:58 gav: JAM has no on-chain governance. [edited]
  ↳ 2025-02-11 13:58 gav: It's immutable.
  ↳ 2025-02-11 13:58 gav: It could host on-chain governance schemes of course, but they would be powerless to do anything to JAM's internal state beyond its own corner. [edited]
  ↳ 2025-02-11 13:59 alice_und_bob: hm, Basti refers to it as a service. As in "JAM service"?
  ↳ 2025-02-11 13:59 gav: Oh - it's not a service like that.
  ↳ 2025-02-11 13:59 gav: Call it a feature if you like.
  ↳ 2025-02-11 13:59 alice_und_bob: ah, so more low level. 
  ↳ 2025-02-11 13:59 gav: Yes
  ↳ 2025-02-11 14:01 alice_und_bob: so in theory I could co-sequence a corechain and a coreplay actor?
  ↳ 2025-02-11 14:01 gav: Yes.
  ↳ 2025-02-11 14:02 gav: Services' on-chain (fully synchronous and coherent) state may be read directly and more or less synchronously by other services during accumulate. They may also be read and written by the owning service during accumulate. But services cannot synchronously interact in accumulate.
  ↳ 2025-02-11 14:02 alice_und_bob: lovely
  ↳ 2025-02-11 14:02 alice_und_bob: thx a lot!
  ↳ 2025-02-11 14:04 alice_und_bob: oh but so services could only compose synchronously if they have a trust-relationship?
  ↳ 2025-02-11 14:05 gav: It makes little sense to do synchronous composition without trust. 
  ↳ 2025-02-11 14:06 gav: You pretty much need to be able to trust that they'd do the thing you expect if you're going to interact (directly) at all. [edited]
  ↳ 2025-02-11 14:07 gav: For synchronous composition, you need two things: 1. to establish, in Refine, some causally-entangled effects. [edited]
  ↳ 2025-02-11 14:08 gav: 2. To enact those effects within Accumulate if and only if you're certain that the counter-party will, at some point, do the same. I call this the Integration Gate. [edited]
  ↳ 2025-02-11 14:10 gav: Generally I'd expect that causality to be established by co-scheduling within the same Work Package, since this way you're more certain that they'll both get to the Integration Gate. It also means that both Refines have access to exactly the same information. [edited]
  ↳ 2025-02-11 14:11 gav: It could be done over multiple Work Packages, but then you'd need to extra logic to help establish what effect the Integration Gate should really be gating for (e.g. point 1 above). [edited]
  ↳ 2025-02-11 14:12 gav: Point 2 will likely be done through each services send the other a `transfer` message establishing that they will certainly integrate their part of the entangled effects once they receive the same message from the other side.
  ↳ 2025-02-11 14:13 gav: A simple way of identifying the entangled effects would be the hash of the work-package, which would easily fit inside the 64 bytes of the transfer memo. [edited]
  ↳ 2025-02-11 14:13 alice_und_bob: hm, and intuitively I would say it would create too much complexity to consider this for now
  ↳ 2025-02-11 14:14 alice_und_bob: does this have any impact on how we look at XCMP? or is XCMP constrained to corechains?
  ↳ 2025-02-11 14:14 gav: Well it's inherently buildable on top of what we have, and I'll probably try to write a simple service which shows it in action.
  ↳ 2025-02-11 14:15 gav: Unclear as yet. There's a few possibilities.
  ↳ 2025-02-11 14:15 gav: XCMP could be dropped and Hyperbridge used instead.
  ↳ 2025-02-11 14:16 gav: Or we could expand XCMP to a JAM-wide service and make it be able to deliver messages not just into the parachains service but also into CorePlay and whatever else. [edited]
  ↳ 2025-02-11 14:17 gav: Or we could keep it scoped as-is and potentially introduce another message-passing system specifically for inter-service messaging if it sufficiently desired.
  ↳ 2025-02-11 14:17 gav: For short, expensive messages, we could also keep HRMP as a backup option.
2025-02-11 14:27 danicuki: JAM Call link: https://meet.google.com/edd-nixn-mps?authuser=0 . Starts in 10  minutes
2025-02-11 15:24 alice_und_bob: so to summarize this conversation, JAM is a type 1 hypervisor
2025-02-11 15:26 gav: In some sense, but it would be a bit of an odd comparison as it's not clear what the hardware on which this hypervisor runs is. [edited]
2025-02-11 15:28 gav: I think the analogy of stating that JAM is a (virtual) machine is superior, but I suppose it's reasonable to suggest that it includes elements of not only the low-level "computer" but also some functionality associated with more OS/hypervisor-level software. [edited]
2025-02-11 15:54 danicuki: Here is the link for subscription to the JAM Experience event in May. Please, subscribe only if you have high chance of coming. As it will be a free event and we need to plan foods and drinks according to number of people. 

https://lu.ma/ob0n7pdy

This link is only for JAM teams. I will create another event for the JAM Party. 
  ↳ 2025-02-11 16:14 jay_ztc: Hi Daniel, thanks for helping organize this event! Our team isn't registered, but planning on having two in attendance. Will continue to keep tabs on event updates in the JAM0 channel. Thanks! [edited]
  ↳ 2025-02-11 17:57 danicuki: > <@jay_ztc:matrix.org> Hi Daniel, thanks for helping organize this event! Our team isn't registered, but planning on having two in attendance. Will continue to keep tabs on event updates in the JAM0 channel. Thanks!

What is your team name? I will add it to the list. 
  ↳ 2025-02-11 18:03 jay_ztc: Thanks! "ZTC" 
  ↳ 2025-02-11 19:00 danicuki: > <@jay_ztc:matrix.org> Thanks! "ZTC" 

Added. You can register now! 🤗
  ↳ 2025-02-11 19:00 danicuki: I took the list from the official gray paper website. I suggest to open a PR to add your team there. 
  ↳ 2025-02-11 20:01 danicuki: Please share your team / personal Twitter so I can mention on posts eventually
  ↳ 2025-02-11 20:53 jay_ztc: Not on socials, appreciate the thought tho
2025-02-11 19:21 danicuki: For those coming to "JAM Experience" in Cascais, I highly recommend to stay a couple more days and attend to ETHLisbon. We are planning a Polkadot / JAM booth there and will probably have some funding for a Hackathon prize  for JAMers. Subscribe here:

https://lu.ma/ETH-Lisbon-2025
2025-02-11 20:05 danicuki: Today's call Highlights and video: https://x.com/danicuki/status/1889402796723609833
2025-02-12 06:15 clearloop: May I ask if the transaction pool is totally open to implement or there is sort of spec WIP?
2025-02-12 10:47 decentration: could someone confirm with me what permutation they produced in this [issue](https://github.com/davxy/jam-test-vectors/issues/18)? i cannot seem to verify the validators assignment to cores. Though i was able to pass the [w3f/jamtestvectors/shuffle](https://github.com/w3f/jamtestvectors/tree/master/shuffle) test...

https://github.com/davxy/jam-test-vectors/issues/18 [edited]
2025-02-12 15:10 gav: > <@clearloop:matrix.org> May I ask if the transaction pool is totally open to implement or there is sort of spec WIP?

There is no transaction pool. 
  ↳ 2025-02-12 15:25 clearloop: hmm, if so, how do we pack the extrinsics to blocks )) for example the maximum number of tickets can be submitted in a single extrinsic is 16, what if my node received 20 extrinsics, then I need to sort them and get the first 16 which have better scores, if there are references from GP for this part?

also, on receiving extrinsics from other nodes, we may need to fast validate the upcoming extrinsics otherwise the node hardly can author blocks successfully once there are invalid & outdated extrinsics, besides, on waiting for finalization, we can preprocess the future extrinsics based on the predicted longest chain's state [edited]
  ↳ 2025-02-12 15:59 oliver.tale-yazdi: Are you implying that ticket extrinsics have something to do with transactions?  
Ticket extrinsics are to acquire an authoring slot, has nothing to do with TX
  ↳ 2025-02-12 16:00 clearloop: oh yeah I mean sort of extrinsic pool in memory comparing with db transactions, just sth handling the pending extrinsics, I have a problem about how to fast validate them before packing them into blocks & simulate state transaction, so if there is a spec for this stuff, it would save my ass [edited]
2025-02-12 15:29 dave: It looks like you are permuting the wrong thing. Please read the GP formulas that you linked carefully. The input to the permutation should look like [0, 0, 0, 1, 1, 1] for the tiny configuration.
  ↳ 2025-02-13 10:16 decentration: ok yes i was thrown by the fisher yates shuffle passing tests, i will shuffle by cores and not validator indices, ty 
2025-02-12 15:50 gav: B5B82264-C7ED-45C8-9076-D503D932B2ED.png
2025-02-12 15:50 gav: First JAM toaster server room getting deployment. 
2025-02-12 15:51 gav: The journey is arduous 
2025-02-12 15:51 gav: 300kW of power: on. 
2025-02-12 16:03 gav: There is not a spec for this - it is largely strategy since validators get rewarded for building blocks with full and correct extrinsic data. 
2025-02-12 16:04 gav: Note that there is a limited amount of extrinsic slots and all slots are limited in terms of what they can host. So it’s less about building a pool (where we would assume some degree of fungibility). 
2025-02-12 16:05 gav: In general you’ll just keep *all* reasonable extrinsic data you receive from other validators as long as it could help you build a block. 
2025-02-12 16:06 gav: There will be a sensible block-building deadline, at which point you’ll use whatever extrinsic data you know about. 
2025-02-12 17:49 decentration: oh yes gotcha [edited]
2025-02-13 00:51 sourabhniyogi: For pragmatic strategy choices where GP is silent, would it be useful for JAM implementers to make these strategy choices /  parameters adjustable for users and make our (maybe singular or maybe default) choices explicit amongst ourselves?

We are aware of a dozen pragmatic strategy choices we made (e.g. when and how often to send tickets, who to ask for D3L data in what order, whether to request/verify proofs when, etc.) but maybe there are 2 dozen others that we aren't aware that we made but also could justify "strategy" specified in client implementation.  Potentially having non-GP strategy default choices could be useful, so that nodes don't receive more tickets + requests + ...  than they actually need to from other implementations.  We could add a "strategy" component to docs.jamcha.in to make these 1-3 dozen strategy choices explicit and make it clear what it means to not only have a GP-compliant implementation but a "friendly" implementation (vs overly aggressive or overly conservative \[or lazy and maybe actually non-compliant \]). [edited]
2025-02-13 00:54 xlchen: I think it will be useful to define what is considered as "bad behaivour" (e.g. sending too much requests at once) so we can all avoid doing it. The nodes that is doing the bad behaviour should get detected and banned by other peers.
2025-02-13 12:46 hanayukii: For formula (A.16) https://graypaper.fluffylabs.dev/#/5f542d7/24e30224e302
under case a = 0  the formula would be -> x / (2^-1) * (2^64 -1) and seems weird, do I understand something wrong?
2025-02-13 13:55 alice_und_bob: is the JAM Bootstrap service mentioned here ( https://hackmd.io/@polkadot/jamsdk ) the thing that Gavin referred to as CoreBoot?
2025-02-13 15:45 sourabhniyogi: yes
2025-02-13 16:25 gav: > <@hanayukii:matrix.org> For formula (A.16) https://graypaper.fluffylabs.dev/#/5f542d7/24e30224e302
> under case a = 0  the formula would be -> x / (2^-1) * (2^64 -1) and seems weird, do I understand something wrong?

No - x is always zero and since the term is multiplied by it, the result is always zero which is what we want. 
2025-02-13 16:30 gav: > For pragmatic strategy choices where GP is silent, would it be useful for JAM implementers to make these strategy choices /  parameters adjustable for users and make our (maybe singular or maybe default) choices explicit amongst ourselves?

Most important aspects of strategy (e.g. extrinsic population, selection of WPs to guarantee) should be pretty straightforward to reason about optimal behaviour. We will likely, in due course, document strategies which we feel are sensible, and behaviour which we feel is crucial to deliver. I would invite teams to document their own approaches for discussion.
2025-02-13 16:32 gav: Network protocol should, and ultimately will, document "polite" behaviour. Technically this, like all network behaviour is not about "correctness" but rather an attempt to make a mutually-beneficial connection.
2025-02-13 16:33 gav: Politeness is defined as conventionally acceptable behaviour.
2025-02-13 16:34 gav: Like all strategy, nodes are of course free to be more restrictive or permissive, but it can be very helpful to have a clear convention.
2025-02-13 19:25 harshitc286: Hello GM gm
2025-02-13 19:29 harshitc286: 1000869038.jpg
2025-02-13 19:31 harshitc286: > <@harshitc286:matrix.org> sent an image.

From IITB, JAM Tour by, 
Dr. Gavin Wood
Amazing Event! 
2025-02-14 15:27 emielsebastiaan: Gavin, 

In this new Parity blog (https://www.parity.io/blog/JAM-experience) the JAM Grid is mentioned. 

This Parity blog references an article explaining JAM Grid (by Permanence DAO: https://permanencedao.medium.com/jam-and-the-jam-grid-the-subsequent-phases-of-the-polkadot-cloud-a79f416e5ec5).

This referenced article seems to suggest that JAM Grid will have a shared security (by DOT).

1. Could you shed some light on this?
2. Do you envision JAMs in JAM Grid to have a shared security?
3. And if so, how would this (on a high level) be achieved technically?
2025-02-14 15:33 gav: This is still under ideation and there are still unsolved questions. However, the main strategy is to draw all JAMs’ validators from the same set, partitioning it randomly on each epoch.  [edited]
2025-02-14 15:33 gav: With enough validators, this can be shown to keep the majority of the security. 
2025-02-14 15:35 gav: Eg two JAMs would have a single staking system which elected 2046 validators. Every epoch the two JAMs’ entropy would be combined to partition those validators randomly into two sets of 1023 and those validators would take over validating on their corresponding network. 
2025-02-14 15:35 gav: Communication would be achieved between JAMs via the usual bilateral bridging. 
2025-02-14 15:36 gav: Our bridge design is light enough and there’s enough processing power and data bandwidth that we can realistically afford to bridge every pair of JAM instances. 
2025-02-14 15:37 gav: The overall security in this model sits at 20% (rather than 33% as at present), which would lower the Nakamoto coefficient by around 40%. Not ideal, but Polkadot would remain well within its current practical security bracket.  [edited]
2025-02-14 15:38 gav: This model scales very well. 
2025-02-14 15:39 gav: Even with 1000 JAMs and thus 1023,000 validators, we’d still enjoy a somewhat similar level of both security and coherence.  [edited]
2025-02-14 15:40 gav: Exactly how similar is an open question. 
2025-02-14 15:41 gav: It is conceivable that a single service could be made to scale elastically over not simply one JAM’s worth of cores but many.  [edited]
2025-02-14 15:41 emielsebastiaan: Thanks great!! This gives me something to ponder about. 
2025-02-15 11:34 davxy: sourabhniyogi: We'd like to try importing Jamduna vectors. Would it be possible to provide the genesis files from this link (https://github.com/jam-duna/jamtestnet/tree/main/chainspecs/rawkv) in binary format as well?
2025-02-15 14:46 obnty: Hello implementers, if any of you are in town at the same time as the JAM tour is happening in HK, Taipei, Beijing, Shanghai, Hangzhou, Shenzhen, please let me or milaswords know. (already in touch with JAM DUNA and New JAMneration team based in Taipei)
  ↳ 2025-02-15 14:55 0xjunha: I'll be in HK and Shanghai (team RJAM)
2025-02-15 16:11 davxy: See also: https://github.com/jam-duna/jamtestnet/issues/71
2025-02-15 20:24 sourabhniyogi: Absolutely, will do!
  ↳ 2025-02-16 11:58 sourabhniyogi: Is [this](https://github.com/jam-duna/jamtestnet/blob/main/chainspecs/rawkv/README.md) what you had in mind?

If not, it might be easiest if you added a single array of kv codec example [here](https://github.com/w3f/jamtestvectors/tree/master/codec/data) that matched [this](https://github.com/jam-duna/jamtestnet/blob/main/chainspecs/rawkv/genesis-tiny.json) -- then we would publish json codec state\_snapshots like [this](https://github.com/jam-duna/jamtestnet/blob/main/data/safrole/state_snapshots/5_000.bin) in the same way?

Can discuss [here](https://github.com/davxy/jam-test-vectors/issues/22#issuecomment-2661399256) instead as you see fit! [edited]
2025-02-16 19:00 davxy: As we begin testing each other's block import vectors, it might be worth establishing clearer "standards" for these vectors to help collaboration.

I think that the format adopted by [jamduna](https://github.com/jam-duna/jamtestnet/blob/main/data/safrole/state_transitions) is quite practical (and is similar to the approach taken by [javajam](https://github.com/javajamio/javajam-trace/tree/main/state_transitions)).

Furthermore, could we explore defining community-wide values for the genesis header? For additional context, see these related issues:  
- https://github.com/jam-duna/jamtestnet/issues/71  
- https://github.com/javajamio/javajam-trace/issues/2  

It might also be beneficial to document the testing genesis header and import format outcome details here: https://docs.jamcha.in/
2025-02-17 00:26 xlchen: How are we going to deal DA/erasure coding related parameters regards to small size testnets? Are we still keep the same WG=4104 and still coded it into 1023 shards but just require each validators to hold multiple shards?
2025-02-17 10:21 danicuki: I created a spreadsheet to track which teams imported blocks from each other. Feel free to edit with your own team data:

https://docs.google.com/spreadsheets/d/1JVt_1daKJWslCaP9hfggKQSN4aGuV_le0XkKcsrjXDc/edit?gid=0#gid=0
2025-02-17 12:00 gav: We’ll want to keep segment size the same so yeah, increasing the number of shards stored makes most sense.  [edited]
2025-02-17 13:44 dave: For the "tiny" testnet we have 2052-byte segment shards rather than 12-byte segment shards. This results in the same 4104-byte segment size (2052\*2 = 12\*342) [edited]
2025-02-17 13:46 dave: EC produces 1 shard per validator, so 6 shards on the tiny testnet
2025-02-17 16:11 clearloop: process goes faster these days 🫠 still struggling with refactoring the network part though ( was implemented with libp2p XD )
2025-02-17 16:50 alice_und_bob: MEV-related question: what determines accumulation order of core work results?
2025-02-17 18:01 davxy: Proposal for a genesis header for block import interoperability testing:

https://github.com/JamBrains/jam-docs/pull/13

I'm mostly trying to achieve "consensus" on these values to make testing easier for everyone. Please feel free to share your thoughts directly on the GH issue
2025-02-17 18:03 davxy: FWIW these are the values currently used by jamduna and polkajam for testing [edited]
2025-02-17 21:03 oliver.tale-yazdi: LGTM, hash also verifies. will merge tomorrow if no objections until then
2025-02-17 23:04 gav: > <@alice_und_bob:matrix.org> MEV-related question: what determines accumulation order of core work results?

The service. 
  ↳ 2025-02-17 23:47 alice_und_bob: My understanding is that you can have work items from different services in one work package. 

Maybe a better way to phrase my question: how is the order determined in which work packages are processed?
  ↳ 2025-02-18 01:40 gav: > <@alice_und_bob:matrix.org> My understanding is that you can have work items from different services in one work package. 
> 
> Maybe a better way to phrase my question: how is the order determined in which work packages are processed?

Work packages can declare a prerequisite work package. This will be enforced for accumulate ordering. Other than that, there are no ordering guarantees between WPs. Within the same WP, you get a guarantee that the different work items will execute contemporaneously. But if they are different services, they will execute independently; transfers are asynchronous and state-reads outside of the service which is executing are fixed at the state from when execution began. 
  ↳ 2025-02-20 04:00 alice_und_bob: hm, so who decides on the ordering of the processing of work packages (or the resulting accumulations) in cases where there is no path-dependence constraining it?
  ↳ 2025-02-20 05:37 xlchen: for parachains, we still going to have collators and it will still be collators to determine the tx order
  ↳ 2025-02-20 05:39 xlchen: we might have super collator that is responsible for multiple parachains for sync crosschain interactions and in that case, there will be some cross chain MEV 
  ↳ 2025-02-20 05:56 gav: > <@alice_und_bob:matrix.org> hm, so who decides on the ordering of the processing of work packages (or the resulting accumulations) in cases where there is no path-dependence constraining it?

Refine is asynchronous, stateless and really has no order. 
  ↳ 2025-05-05 16:09 alice_und_bob: hey, coming back to this question. 

I try to understand who eventually determines to order of WP accumulation.

Let's say WPs don't define a pre-requisite other WP, is the order then determined in the accumulate stage from the leader?
  ↳ 2025-05-05 20:08 gav: It’s determined by the service’s Accumulate logic. From JAM’s perspective there is no order. Because it doesn’t impose any kind of sequence or loop like transactive systems.  [edited]
  ↳ 2025-05-06 08:18 alice_und_bob: so let's say there is a bunch of refined workitems/workresults that reach the service's accumulate logic with no defined order.

Is the accumulate stage eventually executed by the leader? Is it the leader who would pick an order if it is not otherwise given? [edited]
2025-02-17 23:46 sourabhniyogi: Does anyone have a  polkatool or JAM Rust SDK built "null authorizer" which matches https://x.com/the_seraya/status/1891521159209824381 that we can basically standardize on amongst ourselves
  ↳ 2025-02-17 23:50 dave: See https://crates.io/crates/jam-null-authorizer, though I'm not sure if the build is reproducible or not, so not sure if you will get the same hash every time
  ↳ 2025-02-18 00:04 sourabhniyogi: The latest "0.1.12" looks to have not changed in the last couple of months, thank you!  https://github.com/jam-duna/jamtestnet/blob/main/services/parity/jam-null-authorizer/src/main.rs
Will try with this again and attempt a polkatool equivalent to reduce byte count.. [edited]
  ↳ 2025-02-18 01:26 sourabhniyogi: Did you put this null authorizer in the genesis state (alongside the bootstrap service)?  Seems natural to do so... actually, is technically there any alternative? [edited]
  ↳ 2025-02-18 01:41 gav: Yes and no there is probably no alternative.  [edited]
2025-02-20 04:01 alice_und_bob: It's not very precise, but I am going to use this graphic today to explain the relation of Apps, Services, Work Packages and Cores today
2025-02-20 04:01 alice_und_bob: 2025-02-20 - Winning the Scalability Wars - Hack Seasons Side Event @ Consensus HK.png
2025-02-20 05:58 gav: There are a few factors regarding the order that inter-service accumulation happens for two different WPs if they don’t have any stated dependency. No one actor controls this. 
2025-02-20 06:02 gav: It depends on the guarantors, the builder at the time of reporting and the builder at the time of assurance. Builders have no direct control over ordering but they could hypothetically disregard a report or assurance-set at some cost to themselves which could (for the builder at report time) delay the WP compared to other WPs being reported at the time. 
2025-02-20 06:03 gav: Builders at assurance time don’t get the same ability - the best they can do is prevent any new WPs from becoming available and thus accumulating. 
2025-02-20 06:04 gav: > <@alice_und_bob:matrix.org> It's not very precise, but I am going to use this graphic today to explain the relation of Apps, Services, Work Packages and Cores today

Unfortunately pictures are totally broken on element/matrix right now. Is there a link?
2025-02-20 06:05 gav: It’s worth remembering that services themselves are asynchronous with regards to each other, limiting the possibility of inter-service race conditions. 
2025-02-20 06:09 mister_cole: I see the image fine. Can you see it when I post it?

2025-02-20 06:09 mister_cole: image.png
2025-02-20 06:12 gav: > <@mister_cole:matrix.org> I see the image fine. Can you see it when I post it?
> 

Nope
2025-02-20 06:13 gav: I’m on Element X which might not help. [@erin:parity.io](https://matrix.to/#/@erin:parity.io)told me there were widespread difficulties with images recently. 
  ↳ 2025-02-20 17:29 erin: i can take another look, perhaps they've fixed something else by now [edited]
2025-02-20 17:23 dvdplas: Polkadot wiki says: "JAM will provide synchronous composability across heterogeneous services, enabling new kinds of interoperability." [edited]
2025-02-21 14:03 gav: I didn't write the wiki; someone should probably clarify it. [edited]
2025-02-21 14:04 gav: JAM certainly makes it *easier* to provide synchronous composability across services, but it does not directly offer it as a feature.
2025-02-21 14:12 dvdplas: Alright, thanks for clarifying
2025-02-21 14:12 dvdplas: Created an issue on the wiki
2025-02-21 14:16 bill: I'll ping the tech ed team to clarify ASAP. Thanks for filing an issue.
2025-02-21 14:21 decentration: 
2025-02-21 17:52 danicuki: Hey Jammers, I have bad news for us: unfortunately our JAM Experience in Cascais proposal was rejected by the events bounties committee. If you have any idea of how we can get funded, please raise your hand! I attach for your appreciation the event proposal, as well the event bounties feedback. 
  ↳ 2025-02-21 17:52 danicuki: JAM Experience Portugal.pdf
  ↳ 2025-02-21 17:52 danicuki: ```
Hi Daniel,  Thank you for submitting your proposal, unfortunately it has been rejected. While we think that organising events which either support the implementers or wider reach of the technology, we are of the opinion that the budget and format of the event are not fitting. Regardless, we would still like to encourage you and even assist if necessary with planning a different type of event. 

Please find our reasons for rejection below: 

1. The Events Bounty is generally not in favour of standalone large events, as it is difficult to promote them and grow an audience. The location you choose would have also been proven difficult to attract further guests on the second day. 
2. We don’t see why you would be preparing devs for ETH Lisbon in a location outside of Lisbon, especially if the conference is centered around JAM. 
3. For this amount of attendees, the approximate agenda cost of the event is too high. 
4. It is expected that proponents use the attached budget sheet separately from the document so we can properly keep track of all entries. Every line item should be in USD, as well as the final price.  
5. We are not sure what “look and feel” entailed in the budget sheet. 
6. There is a full production team included in the budget, but it is not clear what the purposes of their roles are. Additionally, Adlib did not do the JAM Tour, nor the Grey Paper tour, this is done by Pala Labs and they are currently on the tour with Gavin. 
7. This event feels like multiple things: connecting implementers, sharing knowledge about JAM and preparing folks for ETH Lisbon. These are each an undertaking of their own, so we would propose organising only one of these formats. Additionally, aren't there around 30 teams of implementers // cca 100 people? The events bounty would not fund all these travel costs. 
8. We know that the Palace is currently under construction and don’t know when it would be open for people to come and actually go there. 
9. If you would like assistance from us on how to format your event we would be happy to help. 
``` [edited]
  ↳ 2025-02-21 17:54 danicuki: If you also have any idea of how I can improve the proposal, I am also open to collaboration

  ↳ 2025-02-21 17:54 danicuki: We need to act quick, otherwise the event will be cancelled. [edited]
  ↳ 2025-02-21 17:56 emielsebastiaan: I tend to agree. Focus on JAM implementers coordination. Do not focus on Ethereum event and audience. 
  ↳ 2025-02-21 17:57 emielsebastiaan: Scale down and focus on what is important. Palace visit would be nice, but not an absolute necessity. 
  ↳ 2025-02-21 18:02 danicuki: they use "head count" as a metric of success. This is the problem. We are just 30-40 

I was trying to do something more holistic 
  ↳ 2025-02-21 18:17 danicuki: But maybe Emiel are right. I was trying to hit two rabbits with one stone and in the end missed both. I will re-structure in a more modest format
  ↳ 2025-02-21 19:41 gav: > <@emielsebastiaan:matrix.org> Scale down and focus on what is important. Palace visit would be nice, but not an absolute necessity. 

Palace visit should be no problem at all. Just wont be an especially long stay. 
  ↳ 2025-02-22 00:32 sourabhniyogi: Suggestion is do this for May 7+8 for \< 10K EUR

- Meeting room, 2 days + coffee breaks + dinner - Venue €6,863.00
- Celebration Dinner Day 1 Food & Drinks €1,476.00
- Transportation to Toaster (40 pax) Ext Travel €645.00

What else do you really really need over than the above.

The JAM0 in Bangkok was ~ $11-12K (sponsored by us) for ~5 days --  the above gets us 2 days for a similar price, and probably JAM teams can meet on the 6th or the 9th on their own to connect implementations.  I'd like to believe we can to real tiny=>small stuff and have a Toaster summer plan by the end of this.

I've been amazed at how much we can quickly accomplish asynchronously with github given GP clarity, but I'm sure I'm not the only one who believes that its in part because we've met each other IRL that we are able to accomplish this.  So lets be sure to make this happen.

If it doesn't happen (sad!) [and also probably if it does], we can host a week at the end of the summer here in San Mateo California, though I imagine the total cost to all of you non-US people is way higher than just doing this type of event again in Europe. [edited]
  ↳ 2025-02-22 11:51 danicuki: Thanks all for the feedback. We will make it happen!! Will submit a less ambitious proposal soon. 
  ↳ 2025-02-24 09:25 danicuki: I just submitted a new proposal do the events bounty with a $18k budget. This is the budget breakdown spreadsheet. 

https://docs.google.com/spreadsheets/d/1GnWLxHMl9cj7lA3RkZMbqhH8XnVpN4nV81Xao95n\_m4/edit?usp=sharing [edited]
2025-02-21 17:54 danicuki: 
2025-02-22 00:57 gav: For Lisbon, parity office can be used. 
2025-02-22 00:58 gav: This is big enough for 50 people to work from easily and maybe up to 100 with a little creativity. 
2025-02-22 00:58 gav: Once the palace is completed then none of this will be a problem ofc:))
2025-02-22 11:55 danicuki: > <@gav:polkadot.io> This is big enough for 50 people to work from easily and maybe up to 100 with a little creativity. 

Great! Let’s do there then. I will coordinate with the office manager. 
2025-02-22 11:57 danicuki: Already started to create songs for the GP 1.0 JAM Party Playlist 🎉 . https://suno.com/song/44ed243a-232a-4ed6-be05-34becd213b4e [edited]
2025-02-22 16:32 davxy: danicuki | Jamixir: , I noticed [here](https://docs.google.com/spreadsheets/d/1JVt_1daKJWslCaP9hfggKQSN4aGuV_le0XkKcsrjXDc/edit?gid=0#gid=0) that Jamixir provides test vectors. Are these vectors the same as the ones listed in this repository: https://github.com/jamixir/jamtestnet? If not, how do they differ from the ones provided by JamDuna? [edited]
2025-02-22 16:39 dakkk: > <@davxy:matrix.org> danicuki | Jamixir: , I noticed [here](https://docs.google.com/spreadsheets/d/1JVt_1daKJWslCaP9hfggKQSN4aGuV_le0XkKcsrjXDc/edit?gid=0#gid=0) that Jamixir provides test vectors. Are these vectors the same as the ones listed in this repository: https://github.com/jamixir/jamtestnet? If so, how do they differ from the ones provided by JamDuna?

You should use the branch called "jamixir"
2025-02-22 20:45 junger0x: Hi, it's Jünger from Taiko, a based rollup on Ethereum. I want to analyse JAM for Ethereum perspective for potential new designs. what are the best sources other than the whitepaper?
2025-02-22 20:46 gav: There is no white paper - just the graypaper:)
2025-02-22 20:46 junger0x: Yeah, you're right 😆
2025-02-22 20:46 gav: But that is really the best and only proper source 
2025-02-22 20:47 gav: I’ve done some talks on it and the one I consider the best (Taipei last week) will be published in the next day or two. For a basic introduction to its premise this would be a good start. 
2025-02-22 20:48 gav: There are some overviews that people have written; you can find many of these linked on graypaper.com [edited]
2025-02-22 20:48 gav: But they’re not always up to date, complete or even correct. 
2025-02-22 20:49 gav: The graypaper is the definitive resource for doing any kind of rational analysis. 
2025-02-22 20:52 junger0x: Let me get my hands dirty with greypaper then. Thanks for the answers Gavin. 
2025-02-22 20:53 gav: Have fun!:)
2025-02-23 15:01 oliver.tale-yazdi: https://x.com/jam\_brains/status/1893662855334965306  

We went ahead with this idea from sourabhniyogi on adding an RPC for STF validation [edited]
2025-02-23 15:02 oliver.tale-yazdi: Let us know how helpful this is with validating your STF vectors. Currently our validation logic is probably too lenient, so some invalid blocks will import, but no valid block should be rejected. [edited]
2025-02-24 10:45 danicuki: We are still working to setup for the JAM Experience May/25 event in Lisbon. I would ask you please to subscribe [here](https://lu.ma/ob0n7pdy) if you plan to come. This is very **important**, so we can plan better with the approximate number of people.

As suggested by gav , we will make the event at the Parity's office in Lisbon, less complex and more affordable. [edited]
2025-02-25 14:57 danicuki: Trying to understand the flow of information from end-user to blockchain state in JAM, I created this "step-by-step" doc. I am still not 100% sure it is accurate, so any feedback is very welcome:

https://hackmd.io/@w_7Gu9yjR4q8dsYR89m4OA/ryIwYLj5kl
  ↳ 2025-02-25 14:59 dvdplas: Amazing!
  ↳ 2025-02-25 16:26 vinsystems: Interesting article Daniel 👌 after reading it I have a (maybe very basic) question: What kind of nodes running different software interact with Jam? My understanding is:

Guarantors: nodes running "Jam".
Validators: nodes running "validator software".
Auditors: nodes running "auditor software".
Data Lake: Nodes running "data lake software" [edited]
  ↳ 2025-02-25 16:34 danicuki: I believe JAM is the amalgamation of all these roles. Most JAM implementers are creating nodes capable of running all this node roles in the same box. I don't know if it will be economically interesting for anyone run only partially
  ↳ 2025-02-26 14:12 olanod: Thanks for the write up! As a service implementer that might not go through the details of the gray paper it helps to understand the different flows at a higher level. 
So Guarantors are the ones running the whole refine/accumulate pipeline in the code of the service the work package is referencing? or just refine ? it says guarantors run computation off-chain so no accumulate? sorry if it's stupid but I'm still trying to understand different concepts and draw a parallel with what I thought I understood from the refine/accumulate process. Is the off-chain code run by a Guarantor receiving a work package run only once? or does it need to be deterministic to be re-executed by other Guarantors or other actors?
  ↳ 2025-02-26 14:49 gav: > <@olanod:virto.community> Thanks for the write up! As a service implementer that might not go through the details of the gray paper it helps to understand the different flows at a higher level. 
> So Guarantors are the ones running the whole refine/accumulate pipeline in the code of the service the work package is referencing? or just refine ? it says guarantors run computation off-chain so no accumulate? sorry if it's stupid but I'm still trying to understand different concepts and draw a parallel with what I thought I understood from the refine/accumulate process. Is the off-chain code run by a Guarantor receiving a work package run only once? or does it need to be deterministic to be re-executed by other Guarantors or other actors?

These are protocol-level distinctions. They are not service-provider-level distinctions. Validators must have the capability of being a block author, guarantor, assurer and auditor. They must not be separated. 
  ↳ 2025-02-26 15:53 danicuki: The off-chain (refine) code is executed by 2 other validators (3 in total: remember off-chain code runs only on cores and each core has 3 validators). 
  ↳ 2025-02-26 16:30 danicuki: correcting: ~32 validators, including auditors: https://matrix.to/#/!wBOJlzaOULZOALhaRh:polkadot.io/$NZiNFgDQ172zoOlcyvrAZ4zyj1OW4DeDVfkV7UUOvDI?via=polkadot.io&via=matrix.org&via=parity.io
  ↳ 2025-02-26 17:32 dave: I've made some comments. There seems to be some confusion as to how WP execution is verified. Not sure if there is a good summary of this anywhere.
  ↳ 2025-02-26 18:44 danicuki: thank you so much! Will apply some corrections based on your comments.


2025-02-25 15:02 ascriv: Only going if there are jam themed snacks 
  ↳ 2025-02-25 15:03 danicuki: good idea! Let's make it a reality
2025-02-26 12:44 gav: It certainly shouldn’t be - if it is then it’s a protocol flaw. 
2025-02-26 15:59 gav: Actually executed by an average of about 32 validators. 
2025-02-26 16:00 gav: Between guaranteeing and auditing. 
2025-02-26 16:16 danicuki: Does auditing run full execution? I understood that auditors perform a more selective verification rather than executing the full computation of every work package
2025-02-26 16:20 dave: Guaranteeing and auditing do almost the same work, in particular they "fully execute" the refine function
2025-02-26 16:22 dave: One difference between the two is that guarantors fetch imported segments from DA directly, whereas auditors fetch these as part of the work-package "bundle"
2025-02-26 16:23 dave: And obviously guarantors receive the work-package and extrinsic data from builders or other guarantors on the same assignment, whereas auditors fetch this data from DA (though in the full network protocol there will likely be a "fast path" for fetching this data from the guarantors)
2025-02-26 18:42 jay_ztc: Does it make sense to enforce static branch/jmp target validations during program initialization? Or should we assemble & execute regardless?
  ↳ 2025-02-26 18:45 jay_ztc: I'm leaning on the side of stricter program initialization validations, assuming most pvm compilers will protect against generating this sort of flawed bytecode. Curious to hear the groups thoughts. [edited]
  ↳ 2025-02-26 18:51 jay_ztc: better not to "burn" the gas executing the valid parts of a program that we know has some invalid instructions that might be triggered? [edited]
  ↳ 2025-02-26 20:50 xlchen: I think it is unnecessary. people shouldn’t upload bad program at first place and if they did, well, why save cost for them with trade off of more overhead for everyone else?
  ↳ 2025-02-26 21:38 jay_ztc: I'm not sure it would be more overhead actually... If anything, I imagine it would be less overhead to validate at assemble-time. Validate once at assemble-time vs every time the instruction is called right?
  ↳ 2025-02-26 21:39 dave: As long as behaviour is as specified in the GP it doesn't really matter how you implement it. Of course there will be minimum performance requirements, but if you think you can implement optimisations to go faster than this then great
  ↳ 2025-02-26 21:44 jay_ztc: Throwing panic/error at assemble-time would be a different result than running the buggy bytecode right? I'm assuming the consensus would be different between these two approaches. Gas deducted comes to top of mind.
  ↳ 2025-02-26 21:48 dave: Sure, that just means you can't throw an error at assembly time. It doesn't mean you can't optimise the generated assembly according to this static analysis, for example omitting a runtime check if you have checked at assembly time.
  ↳ 2025-02-26 21:50 dave: If you think the specification in the GP should be changed, then feel free to make your case in the Gray Paper channel
  ↳ 2025-02-26 21:51 jay_ztc: good point, I think the original question still stands though
  ↳ 2025-02-26 21:52 jay_ztc: Yep, good callout. Was thinking I'd get peoples thoughts here first, since this isn't explicitly addressed in the GP.
  ↳ 2025-02-26 21:53 dave: The GP in general won't say how something should be implemented, it just defines the observable behaviour
  ↳ 2025-02-26 21:53 dave: Are you saying the observable behaviour is not completely specified in some case?
  ↳ 2025-02-26 21:59 jay_ztc: this is what I'm looking to gather thoughts on. GP can be discussed in the GP channel separately
  ↳ 2025-02-27 05:12 gav: I think you might get a better response if you put forward a concrete proposal for change to the GP together with an argument for it. [edited]
  ↳ 2025-02-27 07:24 jan: That's not how it works. A proper recompiler (and a well written non-naive interpreter) won't "validate every time the instruction is called"; it recompiles a piece of code once, and that's it.

There are roughly two strategies you can have:

1) Recompile the whole program ahead of time.
2) Recompile parts of the program just-in-time as they're executed.

Whether you reject programs with "invalid" bytecode (whichever way you define "invalid") has absolutely no bearing on whether you can do (1), but it prevents you from being able to do (2).

So while we're planning to essentially assume (1) in our gas cost model so far I've designed it so that the implementation has the flexibility to implement (2) and still be compliant (such an execution mode could be useful in certain cases, e.g. you have a huge program blob and you want to only execute a tiny chunk of it), and this means that you cannot require an O(n) pass to validate the program.
  ↳ 2025-02-27 07:56 jay_ztc: Thanks for sharing your thoughts in such a detailed response Jan Bujak . The design background provides great clarity as well. I had in mind something similar to the 2nd approach, but combined with jmp table validations that could be done using the bitmask- lighter weight than parsing out the whole program up front. But I missed that the invalid target resolutions could be done as part of the JIT design as well. I'm leaning towards the opinion of leaving this flexibility as-is in the spec given your points, especially since this type of program bug should be something caught in the process of compiling into pvm bytecode anyways. [edited]
  ↳ 2025-02-27 19:24 jay_ztc: Jan Bujak: are you accepting PRs to your pvm testvec repo? I modified a few of the existing branch/jmp vectors to create new tests for these edge cases that aren't currently covered by the suite. [edited]
2025-02-26 22:42 sourabhniyogi: https://github.com/jam-duna/jamtestnet/actions/runs/13554662679

Super spiffy!  Hope we can get more matrix endpoints soon
https://github.com/jam-duna/jamtestnet/blob/main/.github/workflows/deploy.yaml#L14-L17
2025-02-27 08:10 gav: > <@danicuki:matrix.org> Trying to understand the flow of information from end-user to blockchain state in JAM, I created this "step-by-step" doc. I am still not 100% sure it is accurate, so any feedback is very welcome:
> 
> https://hackmd.io/@w_7Gu9yjR4q8dsYR89m4OA/ryIwYLj5kl

Good that you're trying to get the word out and whatnot. I left some comments.
2025-02-28 10:23 clearloop: ima_90c7a16.jpeg
2025-02-28 10:24 clearloop: Jam Tour Live in Shanghai 🎶
2025-02-28 12:24 sourabhniyogi: https://github.com/jam-duna/jamtestnet/pull/109

is a first attempt at dumping out at the shape of some test vectors.  We need to get alignment on a erasure coding scheme that works for "tiny" V=6 network (and then "small" V=24) outside of Appendix H full V=1023 -- it would be awesome to get everyone's ideas on what is actually truly necessary to have multi-team tiny vs small testnet this Spring.
  ↳ 2025-02-28 15:47 dave: Re the erasure coding scheme for "tiny": In PolkaJam segments are the same size with V=6 as with V=1023 (4104 bytes). With V=6 each segment is split into _2_ shards of 2052 bytes (vs 342 shards of 12 bytes with V=1023). Erasure coding produces an additional 4 shards, giving 6 total (one per validator). [edited]
  ↳ 2025-02-28 16:55 sourabhniyogi: thank you — is it reasonable to post a sample 4104 original and the 6 total so we can put it back together with the same parity ffi ?  If not we will do it based on your hint, we do enjoy the exercise.   
  ↳ 2025-02-28 21:27 mkchung: https://graypaper.fluffylabs.dev/#/5f542d7/1b4c011b5701 

So in tiny setting matching shards of 2052 bytes, the C_6 here should be C_1026, correct? To generalize this, I think C_6 should perhaps be replaced with C_W_P? 
  ↳ 2025-02-28 21:43 dave: Yes, I think I agree with both
  ↳ 2025-02-28 21:48 dave: Though the definitions of C and C_k in the GP also assume V=1023 and need adjusting appropriately for the tiny config
  ↳ 2025-02-28 23:13 sourabhniyogi: image.png
  ↳ 2025-02-28 23:15 sourabhniyogi: Are all these 8 configurations reasonable looking ?
  ↳ 2025-02-28 23:19 dave: Looks plausible to me. I think the main thing we need is that the size of a segment is the same across all configs, and obviously that total # shards = # validators
  ↳ 2025-02-28 23:36 sourabhniyogi: https://github.com/jam-duna/jamtestnet/issues/112
2025-02-28 13:27 danicuki: Hey Jammers, we just published a PVM workshop we recorded yesterday:

https://x.com/luke_fishman/status/1895409726898467236

PS: Everyone is welcome to publish videos in the JAM Community Youtube Channel: 
https://www.youtube.com/@PolkadotJAM
2025-02-28 15:08 jay_ztc: Is there a scenario where a validator might accept tickets as part of stage1 jamnp distribution, but selectively drop peer tickets in favor of their own? Would a rewards/cooling mechanic based on the "tickets submitted" activity stat come into play here? 
  ↳ 2025-02-28 15:11 dave: Do you mean Safrole tickets? There is possibly scope for this happening, but each validator can only produce 2 tickets per epoch, and the VRF output must be "good enough" to be included in the accumulator, so not sure this scope is very large
  ↳ 2025-02-28 15:14 jay_ztc: yep, was wondering if it might be a possible scenario for validator to drop any (or some percent of) peer tickets that have higher priority than their own [edited]
  ↳ 2025-02-28 15:16 dave: They could plausibly include the lowest value tickets possible, but at some point some other validator will probably include the higher value tickets so not sure it ultimately makes much difference
  ↳ 2025-02-28 15:28 dave: In the case where not enough tickets are accumulated, author selection falls back to a round-robin thing. This limits how much you can gain by censoring tickets
  ↳ 2025-02-28 15:30 jay_ztc: good callout on the fallback, yep. Probably some game theory equilibrium formula that's of relevance here... Doesn't sound like a big concern at present though. Thanks for sharing your thoughts.
  ↳ 2025-02-28 15:37 dave: With 600-slot epochs, there could be an equilibrium where only 300 validators author blocks, and they refuse to include tickets for any other validators. Don't know if this is a legitimate concern or not
  ↳ 2025-02-28 15:38 dave: 300 is obviously a lot, but it's less than 1/3, which is the maximum number of byzantine validators for many other bits of JAM [edited]
  ↳ 2025-02-28 15:41 dave: There also wouldn't be any real way of punishing this behaviour, outside of some governance thing
  ↳ 2025-02-28 15:48 jay_ztc: Sounds like a good use-case for a "flexible-simulated-local-test-net"; accelerate the protocol and spin up a mock test net to race through epochs as quick as possible and see if particular equilibriums are reached. Maybe a number of test nets in parallel and the results are aggregated/joined/interpreted in some way.Just thinking off top of head here... 
  ↳ 2025-02-28 15:48 jay_ztc: Probably some others here who have thought a bit about this already, in the context of the toaster 
  ↳ 2025-02-28 15:49 prasad-kumkar: maybe we could multiply the tickets by eta1' before scoring? to bring even more randomness
  ↳ 2025-02-28 15:49 dave: Well this equilibrium will only happen with byzantine validators, which aren't including all the tickets they receive
  ↳ 2025-02-28 15:51 dave: In general only including your own tickets would be a bad strategy as this would reduce your reward
  ↳ 2025-02-28 15:52 dave: It's only a "good" strategy if you are colluding with many other validators to ensure you always get to author 2 blocks per epoch
  ↳ 2025-02-28 15:58 dave: My point being this kind of equilibrium will _never_ occur in a testnet where we're only running honest validators
  ↳ 2025-02-28 16:00 jay_ztc: Yes. Worth calling out that is a pretty big assumption in that statement though-> as far as parity between testnet and "real world"
  ↳ 2025-02-28 16:02 jay_ztc: hence, my thoughts went to not a "true testnet with many parties", but rather a the "flexible-simulated-local-test-net" where behavior/equilibriums can be tested and reached quicker- given the input is "node configurations across validators" type of thing. Probably not putting it into text as cleanly as possible here...
2025-02-28 16:02 gav: Even if 341 validators colluded and censored and didn’t include any tickets at all, that would only leave an expected 200 blocks per epoch without tickets. Even if those 200 tickets all fell in the first 500 blocks where tickets can be submitted, it leaves 300 normal blocks. With 8 tickets able to be introduced per block, there’s plenty enough room (8*300) for all the other legit validators to include all 600 winning tickets. 
2025-02-28 16:03 gav: There’s plenty of slack here. 
2025-02-28 16:05 dave: The point was if you are in a situation where there are 300 validators each producing 2 blocks in an epoch, they can just collude to include only their tickets for the next epoch, so no other validator ever gets a chance to author a block. Of course it might be practically impossible to get into this situation to start with
2025-02-28 16:06 gav: Statistically speaking that wouldn’t happen.  [edited]
2025-02-28 16:06 gav: Ever. 
2025-02-28 16:08 gav: The chance of there being only 300 block producing validators in an epoch is small enough. The chance of them happening to be the same 300 colluding out of the 1023 total is something magnificently small like (300/1023)^300 [edited]
2025-02-28 16:10 gav: It’s probably not quite that small (combinatorics being what it is) but I expect it’s vanishingly small regardless 
2025-02-28 16:11 gav: And if you control literally every block in an epoch you could also block audits too. 
2025-02-28 16:11 gav: So you’d have a lot more to worry about. 
2025-02-28 16:11 dave: You probably don't need to start with only 300 dishonest validators authoring, the dishonest validators could eg just fork to exclude blocks authored by other validators. Maybe even then it's unlikely you could get a foothold, dunno
2025-02-28 16:12 gav: You’d need to control over half of the slots. 
2025-02-28 16:12 gav: Again, vanishingly small. 
2025-02-28 16:13 gav: I expect the paper on Sassafras has this better modelled though. 
2025-02-28 16:14 gav: Davide at the foundation can probably give a link for anyone interested 
2025-02-28 17:07 danicuki: Updates about the JAM Experience event in Portugal 🇵🇹:

We’ve got approved budget for a modest event 💥🎉. It will happen at Parity’s office, with a closing party open to broad crypto community. 

The budget we have is for 40 pax, so if you plan to come, register asap here: https://lu.ma/ob0n7pdy

Dates: 6th and 7th May 

ETHLisbon is right after, 9-10th. Would be a plus to have you all there too, jamming along the hackathon. Subscriptions here: https://lu.ma/ETH-Lisbon-2025?tk=xlyRJ9

  ↳ 2025-03-04 16:48 p1sar: On luma, it says the JAM event is 7-8 
  ↳ 2025-03-07 14:13 danicuki: Yes, it was wrong. I fixed it now.
2025-03-01 02:27 sourabhniyogi: Adjusted https://docs.google.com/spreadsheets/d/1ueAisCMOx7B-m\_fXMLT0FXBxfVzydJyr-udE8jKwDN8/edit?gid=723798716#gid=723798716 based on the idea that all 8 configurations from tiny to full should have the same W\_G=4104 and be basically "corevm" friendly -- if anyone has wishes on what they should instead please share your thoughts! [edited]
2025-03-01 15:53 tushar_kumar: can we know the approx date for milestone submissions?? 
2025-03-01 15:59 ascriv: Latest info as of a week ago ish is that v1.0 of the gp is estimate at end of Q3 of this year, but with a decent error margin
2025-03-01 15:59 ascriv: Milestone 1 submissions won’t be accepted until 1.0
2025-03-01 16:03 tushar_kumar: 
2025-03-01 16:07 tushar_kumar: thanks for reply, do you know from where can i be aware of latest updates on jam [edited]
2025-03-01 16:08 tushar_kumar: as you said Q3, its much time for v1.0
2025-03-01 16:08 ascriv: AFAIK the single source of truth is the gray paper and secondarily gav/ the gray paper chat
2025-03-01 16:09 tushar_kumar: thanks!
2025-03-01 16:19 tushar_kumar: wait, in the jam experience event description, its says the launch of GP v.1.0.https://lu.ma/ob0n7pdy. 

check it
2025-03-01 16:25 ascriv: Latest estimate is by end of Q3. But will depend a lot on the outcome of Toaster and initial service development. 
2025-03-01 16:26 ascriv: ^quote from gav in the gray paper channel. Either they moved it up a lot since that message, or the jam experience event description is wrong, or I’m otherwise mistaken 
2025-03-01 16:27 tushar_kumar: can i get the link for gray paper channel
2025-03-01 16:30 dakkk: https://matrix.to/#/!ddsEwXlCWnreEGuqXZ:polkadot.io?via=matrix.org&via=parity.io&via=web3.foundation
2025-03-01 16:55 tushar_kumar: gav: will be great if you can clarify.
2025-03-01 19:06 danicuki: To avoid speculation, we removed GP1.0 from the JAM Experience Event description. Off-course we would love to have 1.0 ready by then, but this is just a wish. With 1.0 or not, the event will be awesome. Everybody is working hard, and milestone estimations don't help to accelerate things.
2025-03-02 04:27 gav: > <@danicuki:matrix.org> To avoid speculation, we removed GP1.0 from the JAM Experience Event description. Off-course we would love to have 1.0 ready by then, but this is just a wish. With 1.0 or not, the event will be awesome. Everybody is working hard, and milestone estimations don't help to accelerate things.

Indeed they do not.
2025-03-02 05:03 gav: I was going to prepare an implementors' update for JAMXP, but I may as well give the gist here.

The conditions for 0.9 are that we credibly expect to be able to run the Polkadot-compatible parachains service _and_ CorePlay at a speed which our best modelling implies. This is an art and not a science - don't forget JAM is bleeding edge tech - so it will depend on the outcome of empirical experiments/analysis with the Toaster. I'd say this will probably (P>0.5) happen by EOQ3. The GP will need to be audited; this I expect (P>0.5) to take around 3 months and not to throw up too many issues. We may be able to audit implementations at the same time to shorten the TTL.

Regarding M1 submissions, my feeling is to get to 0.7 or 0.8, probably calling it in mid-April, and then open submissions for M1. Any milestone submission should be made for the most recent GP release at the time, this obviously includes submissions by teams who have already submitted for milestones on older GP versions.

Finally, I expect to introduce two additional paths for implementors to go down beyond the initial 5 milestones of the "validating node":

- Non-PVM-recompiler validating node: This implementation allows teams who do not wish to build a recompiler to shortcut to M5 and thus become viable network validator nodes. Basically such teams would be able to integrate with any PVM recompiler of their choice through FFI or native linking. This would come at the cost of only being able to claim **HALF** of each milestone prize as well as accordingly less of some other benefits. Such teams would have the possibility of eventually resubmitting M4 and M5 with their own recompiling PVM impl to claim the rest of the prizes/benefits.
- Light-client implementations; these would retain M1 (dumb full node) but their own M2-M5 milestones each worth half of the regular prize, giving overall rewards at 60% of the regular recompiling, validating full-node. Milestones 2, 3 and 4 would be based on resource usage over time (CPU, storage, memory and networking) as well as synchronisation time from zero, partial synchronisation time and time to service a random basket of requests. No recompiler would be needed and resource usage expectations would likely be in line with Smoldot. [edited]
2025-03-02 05:06 gav: None of this is decided yet and in particular we may need an incentive structure to avoid too many people switching to light-clients or getting too many low-power light-client implementations, but I do believe JAM will need a solid light-client community to be successful.
2025-03-03 01:04 ascriv: Is there a recording somewhere of gav’s taipei jam tour talk?
2025-03-03 01:29 obnty: It will be published today if there's no network issue. There has been a delay as the video crew has been in China after Taipei (we had to use mobile network with a vpn).
2025-03-04 01:13 xlchen: where can I find the jam tour recordings? if they are not yet uploaded, where will it be uploaded to?
2025-03-04 02:12 wabkebab: Jam implementors, technologists and Web3 enthusiasts, here you can find one of the videos of the JAM Tour, filmed during the lecture at Taipei University. More content coming! [edited]
2025-03-04 02:12 wabkebab: https://www.youtube.com/watch?v=aTS4yjFsJd0
2025-03-04 12:11 ultracoconut: Hello guys what do you think about the idea of ​​a Jam OS similar to Eliza OS but for smart contracts and services?🤔
2025-03-04 13:18 gav: Maybe it could use JAM/CorePlay directly. 
2025-03-04 17:39 jaymansfield: If any other JAM teams are interested in erasure coding vectors I've published a few. There are just 4 right now which cover JAM's basic requirements. It includes encoding a work package at both the tiny and full chain specs, and encoding a segment at both tiny and full chain specs. Once at least one other team can confirm they are working correctly I will generate a bunch more to have a larger suite. https://github.com/javajamio/javajam-trace/tree/main/erasure_coding
2025-03-05 14:57 davxy: STF test vectors updated to GP 0.6.3 
https://github.com/davxy/jam-test-vectors
2025-03-05 18:10 davxy: A couple of test vectors for single segment erasure coding.

https://github.com/davxy/jam-test-vectors/pull/28
2025-03-06 07:37 gav: Phase 1 is about 70% complete..
2025-03-06 07:37 gav: signal-2025-03-05-042811_002.mp4
2025-03-06 07:38 gav: image.png
2025-03-06 17:18 sourabhniyogi: Is it reasonable to have the package versioning details eg https://docs.rs/reed-solomon-simd/3.0.1/reed_solomon_simd/ and a snippet of the test vector process generation at least for this 4104 tiny case -- with Rule 1, similar to bls + bandersnatch FFIing into w3f libraries, most implementers will likely do FFI into the exact package version.  This erasure coding test vector would then stand as a check of correct FFI behavior rather than some kind of interpretation of GP Appendix H problem to solve.
  ↳ 2025-03-06 23:59 dave: We're working on EC test vectors, they'll be posted here when they're ready
  ↳ 2025-03-07 16:55 sourabhniyogi: That's awesome, in the meantime here is a start consistent with the W_G = 4104 choice
https://github.com/jam-duna/jamtestnet/tree/main/erasurecoding
It doesn't have transformations like in Appendix H though so it is desirable to see actual Rust code for the transformation and an explanation of why it is actually necessary in non-full chain specs to actually include the transformation
  ↳ 2025-03-07 18:31 greywolve: The test vectors above don't seem to include the Appendix H transforms, looks like it's purely testing the C function that does the actual encoding.

They might be using some sort of pre-transform before encoding that isn't mentioned in the GP and that forms part of C for SIMD purposes. Version 3.0.1 of reed-solomon-simd does [this](https://github.com/AndersTrier/reed-solomon-simd/blob/74f48e20636f80c43d0e8884ff7a87669bfd8be6/src/engine/shards.rs#L36-L73) to handle smaller shards. Maybe there's another way to do that which is why we aren't matching the recovery shards.
2025-03-07 13:47 danicuki: Here are some updates for the JAM Experience event

- The dates will be **6th-7th** May (it was wrongly configured in lu.ma
- The JAM Toaster visit will be in one of these two days
- The event will be at Parity's office - R. Serpa Pinto 12, 1200-443 Lisboa, Portugal
- Full schedule yet to be defined, probably in the next couple of weeks.
- We already have 35 confirmed jammers. If you didn't register yourself, hurry up, there are only 10 places left: https://lu.ma/ob0n7pdy
- If you registered and won't be able to come, please release your place for someone else
- We will create a separate luma event for the closing Party - if you are registered in the main 2 days event, you **don't need** to registry for the party.
- The party is open for all crypto community, so you can share the [party link](https://lu.ma/6monb9f9) with anyone might be interested in JAM.
- ETH Lisbon is 9th-11th - Registry here: https://ethlisbon.org/ for an extra couple of days together [edited]
2025-03-08 08:10 gav: I think it would be no bad thing if anyone well-familiar with JAM's internals happened to have a speaking slot at an event ETH Lisbon
2025-03-08 14:30 clearloop: May I ask has any team tested that how many non-ticket sealed blocks could be produced generally in tiny testnet?

I found that I have to author blocks on `forks` first otherwise the chain will never get finalized (tickets have distributed in nodes' own forks which won't get finalized), while maintaining the state of fork may increase the complexity of state management significantly

or, have to produce ticket sealed blocks only and this is obvious incorrect according to the graypaper since it hardly can maintain the 6-secs timeslot of block production [edited]
2025-03-08 14:53 ycc3741: I would like to ask if there is a specific required version for PKCS.
  ↳ 2025-03-08 15:04 clearloop: I believe pkcs#8 will be chosen since it's stable with ed25519
  ↳ 2025-03-08 17:37 ycc3741: cool. so does our team.
2025-03-08 17:38 ycc3741: Also, just curious—I watched the Jam Tour in China and wanted to ask if there’s an estimated timeline for the release of coreVM, or if there’s a place where I can find more details or advanced information?
2025-03-09 12:27 danicuki: > <@gav:polkadot.io> I think it would be no bad thing if anyone well-familiar with JAM's internals happened to have a speaking slot at an event ETH Lisbon

Some of us can fill this form with talk proposal:

https://airtable.com/appTaYsacDkPPrePJ/pagd1QKEO2r3i2idK/form

We can also ask for budget to events bounty to sponsor ETHLisbon as Polkadot. I can’t do it myself because I already asked money for the JAMXP event. 
2025-03-10 10:49 dvdplas: Does that mean that one core can only run one service per block?
2025-03-10 10:54 dvdplas: As for synchronous interaction between parachains in one core, how are they co-located? Can there be synchronous interaction for more than 2 "interactions" (apologies, don't know what the correct terminology for this is), in other words chain x interacts with chain y and responds back to chain x (i.e. three "interactions")
  ↳ 2025-03-10 10:56 dvdplas: And how will this look like from the parachains' perspective, how can they ensure their work is scheduled to the same core in the same block (to have synchronous interaction)? [edited]
  ↳ 2025-03-10 10:57 bkchr: Such a block would need to be build by a collator that can build for both chains X & Y 
  ↳ 2025-03-10 10:58 dvdplas: Something like that doesn't exist / we haven't seen as of now in Polkadot right? [edited]
  ↳ 2025-03-10 11:01 bkchr: Yes we don't have done this yet in Polkadot 
  ↳ 2025-03-10 11:02 dvdplas: Do those work items, submitted by this collator, include anything that co-locates those work items or are they submitted in a way that ensures the work items are executed after each other?
  ↳ 2025-03-10 11:02 bkchr: None of this code exists yet :) 
  ↳ 2025-03-10 11:03 bkchr: Also parachains are quite heavy in their functionality, so if they get co-located is a little bit questionable 
  ↳ 2025-03-10 11:04 dvdplas: And I assume that xcmp is necessary?

In other words, it is impossible to implement this on Polkadot right now?
  ↳ 2025-03-10 11:04 bkchr: Also AFAIK this is not really planned to develop this feature for parachains. Everyone could for sure, but will probably not be a top feature 
  ↳ 2025-03-10 11:04 bkchr: To implement what? Co-scheduling? 
  ↳ 2025-03-10 11:05 dvdplas: Yes, because with hrmp you need it to be processed through the relay
  ↳ 2025-03-10 11:07 dvdplas: I don't understand, is this not one of the big selling  points? Having synchronous composability between chains?
  ↳ 2025-03-10 11:08 dvdplas: > Also AFAIK this is not really planned to develop this feature for parachains

For what is it planned if I may ask?
  ↳ 2025-03-10 11:09 bkchr: If you don't send messages or receive messages you could probably build something like this right now already. 
  ↳ 2025-03-10 11:09 bkchr: CorePlay. I mean JAM will provide this feature for any service 
  ↳ 2025-03-10 11:10 dvdplas: Yes but using what cross chain message protocol ? [edited]
  ↳ 2025-03-10 11:12 bkchr: I mean all of that is quite hypothetical 
  ↳ 2025-03-10 11:20 dvdplas: Is CorePlay going to be a service or a feature of JAM?

And will it provide synchronous interaction between services or work items of the same service (in one core)? [edited]
  ↳ 2025-03-10 11:20 bkchr: It will be a service 
  ↳ 2025-03-10 11:20 bkchr: JAM will come with no batteries included :D 
  ↳ 2025-03-10 11:54 dvdplas: And will it provide synchronous interaction between work items of multiple services or work items of the same service (in one core)? 

This comes back to my first question I guess, can one JAM core only run one type of service per block? [edited]
  ↳ 2025-03-11 07:17 xlchen: each work package can have up to 4 work item, and the work items can be different services
2025-03-10 16:08 danicuki: Screenshot 2025-03-10 at 13.08.11.png
2025-03-10 16:09 danicuki: These are ETHLisbon Sponsorship packages: https://encodeclub.notion.site/ETHLisbon-2025-1436c123e77d801bbf02e2b9dce2b43d

What do you guys think about having a Polkadot / JAM booth? 
2025-03-10 16:18 jay_ztc: Has documentation been released yet about the specific scope for M1 conformance? I'm curious what layer the testing will be at- since DA systems are out of scope for M1. Are there any specific APIs we should be conformant with, to make M1 acceptance testing across many implementations more streamlined?
2025-03-10 19:28 philipdisarro: Hello all, thanks for the invitation. I just want to clarify a few things. First off, I am a big fan of the enshrined-rollup centric architecture, I think monolithic scaling is a dead-end and a honeypot for centralized chains. I think JAM is an incredible innovation on the forefront of modular scalability (scalability without compromising L1 decentralization), and I think L1s as DA layers with minimal computation capacity (mainly for validating rollup state-commitments and fault proof resolution). That said, is JAM not what I am describing above? A state-of-the-art DA layer with a coherent data-sharing solution that addresses DA fragmentation. 

From my perspective, the goal is not to have all logic ran natively with the full security of the L1, it is to instead achieve scalability via enshrined rollups (in some sense equivalent to sharding) with fault proofs to inherit the full security of the L1 under the 1 honest live actor assumption. It is a mechanism for horizonal scalability. [edited]
  ↳ 2025-03-10 19:37 bkchr: But JAM is not using fault proofs
  ↳ 2025-03-10 19:37 bkchr: It re-executes the candidates 
  ↳ 2025-03-10 19:55 philipdisarro: AFAIK, it re-executes the candidates with a subset of L1 validators (enshrined-rollup). The only way to inherit the full base layer security is by raising an issue (ie. fault proof).  [edited]
  ↳ 2025-03-10 19:57 bkchr: https://x.com/jeffburdges/status/1898690774704771498?s=19 did you read this answer? 
  ↳ 2025-03-10 20:04 philipdisarro: Yes, and again from what I understand JAM is still a base layer for enshrined rollups. I don't argue against the degree to which those enshrined rollups inherit the base layer security. ELVES seems like a very sane design for rollups, with a very high degree of security inheritance, but at the end of the day there is still an objective difference in security between execution in a rollup and execution directly on the base layer with the security of the entire validator set. The difference in that security with respect to the enshrined rollups is a separate matter entirely, but it does exist.
  ↳ 2025-03-10 20:06 philipdisarro: IE ELVES & JAM are an improvement upon other rollup-centric architectures, and the post you have referenced explicitly mentions:

> ELVES could be described as a twisted non-zk cut n choose roll up, which some shorten to pessimistic roll up.

Which again, furthers my understanding that indeed Doom executed on a rollup and not on the base layer. I don't dispute the degree to which the rollup inherits the base layer security, but it doesn't objectively inherit the full security of L1 validation. [edited]
  ↳ 2025-03-10 20:08 bkchr: It is more likely that you get hit by meteoroid, but we still don't assume that you already got hit :) You are saying because there is a chance that is smaller than getting hit by a meteoroid, the security is less than just running it as part of the state transition function of JAM.  
  ↳ 2025-03-10 20:11 philipdisarro: Indeed, it is. There is a difference in security. I don't argue that the difference is large, and relative to the scalability that is achieved I don't argue that this is not a sensible choice, but at the end of the day, the computation is still executing on a rollup and settling to the L1 right? 

As stated: 
>ELVES could be described as a twisted non-zk cut n choose roll up, which some shorten to pessimistic roll up.

It is even described as a rollup. I don't disagree that the rollup inherits maximal security from the L1, but that don't mean it isn't a rollup.
  ↳ 2025-03-10 20:12 philipdisarro: Strictly speaking, from my perspective it is correct to say that Doom executed on a rollup. 
  ↳ 2025-03-10 20:13 philipdisarro: That rollup inherits maximal security from the L1, and probabilistically equivalent security, but this is not the same as executing natively on the L1.
  ↳ 2025-03-10 20:16 philipdisarro: Originally, the only reason I even began this discussion is because someone posted:
https://x.com/csaint02/status/1897864223382011954

and then went on to claim that Hydra Doom does not count because it was executed in a L2, and that on Polkadot it was executed on the base layer. 
  ↳ 2025-03-10 20:17 philipdisarro: To me this is an unfair claim. At the end of the day, both Hydra Doom and Doom on Polkadot executed in L2s, it is just that with JAM the degree to which the L2 inherits the L1 security is much higher. 
  ↳ 2025-03-10 20:19 bkchr: Reading into Hydra, only the results are returned back to the main chain
  ↳ 2025-03-10 20:19 bkchr: The operations in between are not checked 
  ↳ 2025-03-10 20:19 bkchr: https://hydra.family/head-protocol/ at least from what I can read here 
  ↳ 2025-03-10 20:21 philipdisarro: Agreed, but Hydra is a state channel, not a rollup, the goal of a state channel is for participants of the channel to inherit the full security of the L1 (because the computation is entirely irrelevant for non-participants). That means if you played in the Hydra Doom tournament (ie. were a participant in the Hydra Head) you have equivalent security guarantees of the L1.
  ↳ 2025-03-10 20:21 bkchr: > By providing more efficient means of processing transactions off-chain for a set of users
  ↳ 2025-03-10 20:22 bkchr: > That means if you played in the Hydra Doom tournament (ie. were a participant in the Hydra Head) you have equivalent security guarantees of the L1.

This contradicts the beginning of your message
  ↳ 2025-03-10 20:22 bkchr: How do you get the L1 security guarantess
  ↳ 2025-03-10 20:22 philipdisarro: If 10 people bet $100 on a Doom game, and the game is executed in a Hydra head where all ten are participants in the channel, then the game has the full security of the L1, because a participant would never willingly defraud themselves. 
  ↳ 2025-03-10 20:23 bkchr: If the Hydra head just does the computation off chain? 
  ↳ 2025-03-10 20:23 philipdisarro: https://iohk.io/en/research/library/papers/hydra-fast-isomorphic-state-channels/
  ↳ 2025-03-10 20:24 philipdisarro: Hydra requires unanimous consensus amongst participants, so as a participant you will never willingly defraud yourself. 
  ↳ 2025-03-10 20:26 philipdisarro: I agree that enshrined-rollups are a more general purpose scaling solution, and that for adversarial cases the fact that it doesn't require unanimous consensus amongst participants is obviously a massive strength. I'm not arguing that Hydra is better in any way. I am just arguing that both Hydra, and JAM's enshrined rollups are indeed L2s. [edited]
  ↳ 2025-03-10 20:27 philipdisarro: Personally, I think JAM's enshrined rollups are much better L2s for 99% of task domains, but still they are both L2s. [edited]
  ↳ 2025-03-10 20:30 bkchr: As I skimmed the paper it also requires that parties report to the main chain if someone closed a head on a wrong state. 
  ↳ 2025-03-10 20:32 bkchr: Also this tweet said:

> Cardano recorded DOOM stats on chain

> Polkadot ran the entire MFing game on chain

Which is correct, even from what you said above. (on chain doesn't mean that the on chain was JAM itself and it is more the L2) 
  ↳ 2025-03-10 20:32 bkchr: But every L2 transition is checked by the JAM validators 
  ↳ 2025-03-10 20:33 bkchr: With the very very very very.... small likelihood that you paid enough validators to cheat 
  ↳ 2025-03-10 20:33 bkchr: We can agree on that both run on L2's (Cardano + Jam), but each with very different security guarantees. 
  ↳ 2025-03-10 20:34 philipdisarro: Closed a head on a previous state*

You cannot close a head on an invalid state because to initiate a close you need to provide the state snapshot that is unanimously signed by all participants, it's just that the snapshot you provided might not be the most recent snapshot, and in that case others can begin a complaint processes which allows them to provide a more recent state (and the most recent state at the end of this process is considered canonical). 
  ↳ 2025-03-10 20:34 philipdisarro: Yes, that's the only thing I wanted to clarify.
  ↳ 2025-03-10 20:35 philipdisarro: Thank you for your time. I think JAM is a novel of engineering and a clear advancement in horizontal scalability in the blockchain domain as a whole.
  ↳ 2025-03-10 20:36 bkchr: Yeah maybe you did not like the future output and just stopped at some state. Generally sounds to me like you could build some exploits around it
  ↳ 2025-03-10 20:36 bkchr: Or I buy my croissant 
  ↳ 2025-03-10 20:36 bkchr: And then pretend this never happened  [edited]
  ↳ 2025-03-10 20:36 erin: > <@philipdisarro:matrix.org> Yes, that's the only thing I wanted to clarify.

state channels are sooooooo far away from rollups though, and even further away from parachains, and even further away from JAM running DOOM on CoreVM. But sure.
  ↳ 2025-03-10 20:37 erin: If you want to be pedantically correct yes, but if you want to be intellectually honest for the people you are speaking to then realistically no.
  ↳ 2025-03-10 20:38 philipdisarro: Right, but that's the purpose of the L1 resolution phase, if you attempt to do so, any of the other participants will just provide the most recent signature. 
  ↳ 2025-03-10 20:39 philipdisarro: Again, I am not arguing that Hydra is some amazing general purpose technology. It is a different scaling solution with its own set of tradeoffs, specifically tailored to maximal scalability between non-adversarial participants (ie. B2B micro-payments)
  ↳ 2025-03-10 20:39 bkchr: I would just dos you until this phase is over :D 
  ↳ 2025-03-10 20:42 philipdisarro: I didn't design Hydra haha, I don't even particularly like the design of Hydra, personally I think the versatility of rollups intending to directly inherit maximal L1 security is a much better approach (which is why my firm is building a rollup stack on Cardano). [edited]
  ↳ 2025-03-10 20:43 bkchr: You can always come and build some rollup stack on Jam :) 
  ↳ 2025-03-10 20:43 philipdisarro: My only point is that the Doom was not executed directly on the L1, it was executed on a rollup that settles to the L1 and inherits maximal security of the L1.
  ↳ 2025-03-10 20:44 jam_man: Philip DiSarro:  could you explain how exactly Hydra Heads Ran Doom? Because from my understanding the game logic was not actually run in the heads themselves? 
  ↳ 2025-03-10 20:44 bkchr: "Settles" sounds so innocent and leaves room for a lot of interpretation.
  ↳ 2025-03-10 20:44 philipdisarro: I might take you up on this after we finish the stack on Cardano. Eventually the goal is to have settlement layer be modular so it can be swapped for JAM or EthDA or Celestia or whatever else.
  ↳ 2025-03-10 20:45 philipdisarro: > Doom was not executed directly on the L1, it was executed on an enshrined rollup that inherits maximal security of the L1.\*

That better? [edited]
  ↳ 2025-03-10 20:52 jam_man: So are yo you still sticking to this statement, because I would really love to know if I was wrong in my initial assessment that Hydra Heads did not actually run DOOM. They only verified game states. 

https://x.com/phil_uplc/status/1898142394345787428?s=46
  ↳ 2025-03-10 21:01 philipdisarro: Run the game in what sense? Cardano validators are not actors, they simply validate. On Cardano, a chess dApp for instance, takes the move (and the transaction inputs, outputs etc) as inputs, and returns true if the move is legal (and the resulting state is stored in a UTxO), or false if the move is illegal (and the transaction fails). 

In the case of Doom, the game state is stored in UTxOs, and when the player interacts with the game they are sending a transaction to replace that UTxO with a new updated game state and validating that the transition is honest. This ensures that if you play Hydra Doom as a participant, if you are hit by a bullet, it with reflect that in the game state UTxOs, and if you attempt to cheat by violating any of the game rules you will be unable to because your transaction would be rejected (and your character / health etc, will remain where it was prior to the transaction)  [edited]
  ↳ 2025-03-10 21:03 philipdisarro: Do you mean like execute the graphics engine onchain? In that case, no, the graphics rendering is not considered, it was only game logic and state that is executed in the Hydra head\*.  This ensured that if you play a hydra doom tournament, none of the participants can cheat, all players must obey the game rules (cannot do more damage than they are supposed to, cannot no-clip, cannot move faster or jump higher than the game logic allows, cannot avoid taking damage when they are supposed to, and so forth). [edited]
  ↳ 2025-03-10 21:07 jam_man: So you retract the statement that 

“Cardano also ran Doom, the entire 
game, on Hydra, an L2”
  ↳ 2025-03-10 21:07 jam_man: Because you spent 2 days making this claim to me and eveyone else 
  ↳ 2025-03-10 21:11 philipdisarro: I stated that once in the OP, from there almost everything I said was regarding the definition of native execution vs L2s. 

Did Polkadot run Doom entirely on a rollup? As in the graphics engine rendering state was done entirely inside the rollup? How is the output rendered? If two players move, is it immediately reflected to both players? How is no-clipping / cheating handled?  [edited]
  ↳ 2025-03-10 21:21 philipdisarro: From what I gather the goal was different, the goal of Hydra Doom was to allow a multiplayer hydra tournament where the blockchain was used to ensure the integrity of the multiplayer tournament (all game logic is obeyed, and cheating is prevented).

From what I gather, JAM Doom was a compilation of Doom to Polkadot execution bytecode without modification? So for instance no-clips / cheating in general was not considered, as the goal was not about ensuring integrity, instead it was about showcasing the computation and bandwidth capacity of JAM services / enshrined rollups.
  ↳ 2025-03-10 21:24 jam_man: from my understanding yes, all aspects of the game were run directly on JAM cores (or "enshrined rollups" as you keep calling them). where the game logic was split onto two parallel cores. where both cores were both processing the doom executable, and there was another process running monitoring the JAM chain and the JAM DA, this process was feeding frames out of the DA and displaying them in real-time. 
  ↳ 2025-03-10 21:29 philipdisarro: If this is the case, I am happy to write a revised statement on that, as in that case, JAM Doom directly executed the transpiled binary unmodified, where-as Hydra Doom reimplemented the game logic in smart contracts that validated the integrity of game state progression to ensure the security of the multiplayer tournament.
  ↳ 2025-03-10 21:31 philipdisarro: That's a very impressive showcase of bandwidth / computational capacity indeed.
  ↳ 2025-03-10 21:33 jam_man: I would love to have some other developers back up my conceptual understanding of this. But I am 95% sure that this is how it worked. for now i can point you to this video covering it https://x.com/pala_labs/status/1898040116528238780?s=46
  ↳ 2025-03-10 21:34 erin: > <@jam_man:matrix.org> from my understanding yes, all aspects of the game were run directly on JAM cores (or "enshrined rollups" as you keep calling them). where the game logic was split onto two parallel cores. where both cores were both processing the doom executable, and there was another process running monitoring the JAM chain and the JAM DA, this process was feeding frames out of the DA and displaying them in real-time. 

JAM services are different than rollups; they do not have to adhere to the properties of a blockchain. Polkadot parachains are only one such possible way to inherit this security, and thus services are something else entirely - they can be more generic than just running rollups as we know them.
  ↳ 2025-03-10 21:43 erin: And you can run 20-30 DOOMs per core (currently). This is a single core. No splitting was done. [edited]
  ↳ 2025-03-10 21:45 oliver.tale-yazdi: Is the logic in those channels a generic WASM blob or is it only a predefined set of games?  

  ↳ 2025-03-10 21:52 sourabhniyogi: Philip DiSarro: Its really awesome that you took the time!   In the end, we should go back to "show us the JAM service code" ethos to replace the "If this is the case..." -- with JAM it is now obvious many of us will be able to do this with simpler (but less titillating) demos of JAM's CoreVM/CorePlay services involving tiny code bases where experienced people can understand what is going on in less than a couple of minutes rather than take everyone elses word for it =).  
  ↳ 2025-03-10 21:59 philipdisarro: The smart contract logic was implemented by hand, not transpiled, because the Doom multiplayer code itself does not prevent no-clipping / speed hacks / most forms of cheating. The Doom smart contracts used in Hydra took the game logic and implemented it into smart contracts which ensured the correctness of game state progression (player & NPC & bullet location / velocity / direction, health, items etc).  [edited]
  ↳ 2025-03-10 22:02 philipdisarro: Also cheating aside, it wouldn't be possible to transpile, because there is no WASM to PlutusCore compilation pipeline. 
  ↳ 2025-03-10 22:03 philipdisarro: I believe they are currently working on a RISC-V compilation pipeline, so once that is released it may be. 
  ↳ 2025-03-10 22:04 xlchen: One of the key takeaway of the demo is that JAM is capable to run arbitrary program. Specifically the one not build for blockchains. This is not the case for all existing blockchain platforms.
  ↳ 2025-03-10 22:08 philipdisarro: Yes, that's what I gather, the goals were quite different. JAM Doom is not designed to showcase the use of blockchain to ensure the integrity of the game, it was used to illustrate the ability to run arbitrary WASM programs on the blockchain, and to show-case the capacity and bandwidth of Polkadot services. Doom itself would still be vulnerable to the same exploits that the WASM is, but that's beside the point because the goal had nothing to do with Doom in the first place. 
  ↳ 2025-03-10 22:09 erin: > <@philipdisarro:matrix.org> Yes, that's what I gather, the goals were quite different. JAM Doom is not designed to showcase the use of blockchain to ensure the integrity of the game, it was used to illustrate the ability to run arbitrary WASM programs on the blockchain, and to show-case the capacity and bandwidth of Polkadot services. Doom itself would still be vulnerable to the same exploits that the WASM is, but that's beside the point because the goal had nothing to do with Doom in the first place. 

JAM does not use WASM.
  ↳ 2025-03-10 22:09 xlchen: Yes (except WASM wasn't used, it is PVM / RISC-V)
  ↳ 2025-03-10 22:09 philipdisarro: It compiles the WASM to RISC-V to Polkadot VM right?
  ↳ 2025-03-10 22:09 philipdisarro: Or was the native implementation used in RISC-V?
  ↳ 2025-03-10 22:10 erin: > <@philipdisarro:matrix.org> It compiles the WASM to RISC-V to Polkadot VM right?

It compiles C directly to RISC-V.
  ↳ 2025-03-10 22:10 xlchen: the source code is compiled to RISC-V and then transcoded to PVM bytecode
  ↳ 2025-03-10 22:11 philipdisarro: Ah so C to RISC-V to PVM, not WASM. I didn't know there was a RISC-V backend to C that's cool.
  ↳ 2025-03-10 22:13 erin: You can target C and Rust directly to PVM which is most of the point. Polkadot has been running WASM for years :). The entire idea is you can compile a program which can be targeted to RISC-V and run it directly (yes directly) on JAM.
  ↳ 2025-03-10 22:16 erin: Perhaps we have different pedantic opinions on what "directly" means, but JAM is not a strictly L1/L2 defined system, it is a secret third thing in the current understanding of how blockchain systems work.
  ↳ 2025-03-10 22:16 philipdisarro: directly* as in on an enshrined rollup right, executed by a subset of validators (equivalent to  a shard in sharded networks), not by the L1 validator set unless you "raise an issue" which is an optimistic fault proof type security mechanism right?
  ↳ 2025-03-10 22:18 philipdisarro: Or can you just pay more to directly run it with the full base layer validator set?
  ↳ 2025-03-10 22:19 xlchen: it is somewhat correct but for most existing optimistic fault proof system, there is no guarantee someone will check it. we have an audit system and with proof that the result will be checked
  ↳ 2025-03-10 22:19 emilkietzman: > <@philipdisarro:matrix.org> Ah so C to RISC-V to PVM, not WASM. I didn't know there was a RISC-V backend to C that's cool.

I wrote a thread on this today, there are more languages available

https://x.com/emilkietzman/status/1899048987237224711?s=46
  ↳ 2025-03-10 22:19 xlchen: it is possible (but that lose the points)
  ↳ 2025-03-10 22:19 erin: > <@philipdisarro:matrix.org> directly* as in on an enshrined rollup right, executed by a subset of validators (equivalent to  a shard in sharded networks), not by the L1 validator set unless you "raise an issue" which is an optimistic fault proof type security mechanism right?

It is not optimistic nor is it fault proof based. It is checked every single state transition and this is how finality is reached so quickly on polkadot vs Ethereum. As for the execution, it depends on the service; the service running DOOM here is CoreVM, which is different than polkadot and how polkadot runs parachains.
  ↳ 2025-03-10 22:21 philipdisarro: It is still a form of fault proofs right? Someone "raises an issue" claiming that there was fault with the result confirmed by the subset of validators that re-executed the rollup state-commitment, and once an issue is raised, the full security of the L1 consensus is invoked (all validators) to re-execute the state commitment and determine the correct result? [edited]
  ↳ 2025-03-10 22:22 philipdisarro: The result will be checked by whom? The subset of validators that re-execute it or the entire L1 validator set, or just a proof that one honest live party checked it? 
  ↳ 2025-03-10 22:23 philipdisarro: Is the assigned subset of validators responsible for raising an issue or is it open to all validators in the base layer (even those not assigned in the re-execution subset)?
  ↳ 2025-03-10 22:23 erin: A group of randomized validators (rotated frequently) checks the STF directly and if it doesn't match, it raises a dispute, which is further checked by all other validators. This is how polkadot works today. Perhaps people more close to JAM protocol implementation can chime in here. [edited]
  ↳ 2025-03-10 22:23 erin: The rotation is also random.
  ↳ 2025-03-10 22:24 xlchen: assume > 1/3 honest validators, a random set of validators will be selected to audit incore executions
  ↳ 2025-03-10 22:25 philipdisarro: So the subset needs to come to consensus to raise an issue or any validator in that subset can raise an issue?
  ↳ 2025-03-10 22:25 xlchen: with right parameters, we can calculated that the chance of missing proof check
  ↳ 2025-03-10 22:25 philipdisarro: Also are we assuming 1/3 honest validators total or 1/3 honest validators in most random subsets of size N?  [edited]
  ↳ 2025-03-10 22:26 philipdisarro: Probabilistically if 33% of total validators are honest, you might randomly have chosen a subset where only 30% of validators are honest will that subset still be able to raise an issue? 
  ↳ 2025-03-10 22:26 xlchen: it is a 2 stage thing. there is 1023 validators, 3 validators per core. for anything goes to the chain, it needs 2 signatures for the out of the 3 random selected one. and then another ~30 random validators will be selected to do audit
  ↳ 2025-03-10 22:27 xlchen: I didn't do the math but here is a paper showing it is secure. let me see if I can find it
  ↳ 2025-03-10 22:28 philipdisarro: So, a single validator cannot raise an issue? It needs to be done via consensus of the subset of randomly selected validators assigned for the audit?
  ↳ 2025-03-10 22:28 xlchen: I think it is this one https://eprint.iacr.org/2024/961
  ↳ 2025-03-10 22:29 xlchen: I think any single validator can raise issue, but a random set of validators are required to do the check and submit a statement that they did the check
  ↳ 2025-03-10 22:30 xlchen: if a work is not required/incentivized, then we can only assume it won't be done (which is the issue of many existing optimistic system) [edited]
  ↳ 2025-03-10 22:32 philipdisarro: That's great then, so the assumption is only 1 honest validator in the randomly selected subset.
  ↳ 2025-03-10 22:35 xlchen: in order to perform an attack, all 3 validators in the core must be malicious (or 2 malicious and last one down due to DDOS or some other attack). And then the auditors are still going to identify the bad work report and slash it [edited]
  ↳ 2025-03-10 22:40 dave: > <@xlchen:matrix.org> in order to perform an attack, all 3 validators in the core must be malicious (or 2 malicious and last one down due to DDOS or some other attack). And then the auditors are still going to identify the bad work report and slash it

This isn't really true; 2 need to be malicious, they can simply not send anything to the third. Though as you say the security comes from auditing anyway
  ↳ 2025-03-10 22:45 bkchr: > <@bkchr:parity.io> https://x.com/jeffburdges/status/1898690774704771498?s=19 did you read this answer? 

We are turning in cycles 
  ↳ 2025-03-10 22:47 philipdisarro: That seems incorrect, if the elves paper is to be believed it does not assume 2/3 honesty (at-least for correctness) it assumes at-least 1 honest party in the fixed size audit committee.
  ↳ 2025-03-10 22:47 philipdisarro: Because if one auditor determines fault, they raise a dispute.
  ↳ 2025-03-10 22:50 philipdisarro: IE. the same extremely valuable, "secure under the assumption of at-least one live honest actor monitoring the state" assumption of optimistic rollups, except improved with the notion that now there is an incentive scheme for "honest live actors" and that it actually forces at-least N actors (audit committee size) to review the state and made a claim (so if at-least 1 of N of those is honest then security is guaranteed).
  ↳ 2025-03-10 22:52 philipdisarro: From that I see though, it appears that only those randomly elected in the subcommittee are able to make a claim (a validator that was not elected in the audit committee or a random third party cannot initiate a dispute). I'm sure it could be extended to allow non-auditors to initiate a dispute, and it was just designed like that for simplicity. 
  ↳ 2025-03-10 22:53 dave: > <@dave:parity.io> This isn't really true; 2 need to be malicious, they can simply not send anything to the third. Though as you say the security comes from auditing anyway

If you're referring to this then I wasn't talking about the auditing process but the guaranteeing process by which things-to-be-audited are introduced. For auditing yes you need only one of the randomly selected parties to be honest
  ↳ 2025-03-10 22:55 dave: Moreover the random set cannot be determined in advance, so as an attacker you can't wait until the slim odds are in your favour
  ↳ 2025-03-10 23:02 dave: > <@philipdisarro:matrix.org> From that I see though, it appears that only those randomly elected in the subcommittee are able to make a claim (a validator that was not elected in the audit committee or a random third party cannot initiate a dispute). I'm sure it could be extended to allow non-auditors to initiate a dispute, and it was just designed like that for simplicity. 

In JAM it is possible for any validator to initiate a dispute. So plausibly if you had spare processing power as a validator you could use it to check reports that you haven't actually been assigned. I expect you wouldn't receive any compensation for this so not sure it would be a great idea
  ↳ 2025-03-10 23:04 philipdisarro: I see. The solution in other rollup-centric ecosystems is that the publisher of a state commitment must be bonded (ie. have slashable value locked) and if a third party (not even necessarily validator) decides to review state commitments of a given rollup and detects fraud and submits a successful fraud proof then the publisher of that state commitment has their bond slashed and the party who successfully submitted the fault proof receives a portion of it as a reward.
  ↳ 2025-03-10 23:05 philipdisarro: I guess in the above case, you could reward the validator (with spare compute who decided to review the incoming state commitment associated with a rollup that they were particularly interested in) with a portion of the bond only if fraud indeed did occur and the audit committee did not report it (very low chance).
  ↳ 2025-03-10 23:07 philipdisarro: A lot of the time though, third parties (non-validators) will likely be reviewing the state commitments of a given rollup anyway for a myriad of reasons (ie. they are an indexer, or web-based blockchain explorer, or dApp, or otherwise running any service that depends on monitoring the state of that rollup).
  ↳ 2025-03-10 23:09 dave: In JAM validators are both the "publishers of state commitments" _and_ the parties responsible for reviewing these. When acting as publishers we call them guarantors and when acting as reviewers we call them auditors, but they are the same actors. Validators in practice will be slashable, for misbehaviour in either role
  ↳ 2025-03-10 23:10 dave: I say "in practice" because slashing is not really part of JAM itself but will be managed by a service running on JAM
  ↳ 2025-03-11 10:51 gav: Well, the point that Elves brings is bounded security.
  ↳ 2025-03-11 10:55 gav: Because there only needs to be one honest auditor to raise a dispute, because the fork-choice and finality subsystems are explicitly tied into the disputes mechanism, and because Elves is able to properly reason about the chances that each and every work-report of a block (roll-up state-delta commitment) has been audited by at least one such validator, we are able to reach a statistical certainty (within economic bounds, as with all crypto-economic systems) over the correctness of any given block's state-transition fast and ensure that any finalised chain contains only correct state-changes. And we can do this without forcing all validators to compute everything. [edited]
  ↳ 2025-03-11 10:58 gav: "Fast" here means generally within 10 seconds after the work was initially done. [edited]
  ↳ 2025-03-11 11:00 gav: As Dave says, this only works because it's all happening within a closed network of validators whose behaviour we can reason about and thus can actually model these probabilities correctly.
  ↳ 2025-03-11 11:09 gav: > From my perspective, the goal is not to have all logic ran natively with the full security of the L1

This very much depends on what is meant by "full security". I would argue there's not really a useful way of reasoning about this. The security of an L1, any L1, is not insurmountable. Like all crypto-economic systems, the best we can do is measure _the cost_ of breaking it. And there are multiple ways to break a system (censorship, stalling, reversion, invalid state transition, to name just four). The costs of breaking each of these are typically different and change between L1s and over the course of time of an L1. So the concept of inheriting any particular aspect of any particular L1's security guarantees at any particular time is pretty much meaningless. [edited]
  ↳ 2025-03-11 11:09 gav: What is meaningful is to be able to state the actual cost of breaking a system, in what way, and with what assumptions.
  ↳ 2025-03-11 11:17 gav: In any case, Elves is specifically designed not only to construe the security of the L1 to ensure correctness of co-processing units, but also to ensure that those who attempt to thwart it are heavily punished. [edited]
2025-03-10 20:33 ascriv: Maybe L1.0001?
2025-03-12 10:52 alambicco: hi all. Is there a testnet for JAM ?
2025-03-12 15:44 gav: Coming soon(tm)
2025-03-12 16:25 alambicco: let's say I want to start building a service ... where to start ?
2025-03-12 16:41 sourabhniyogi: https://docs.rs/jam-pvm-common/latest/jam_pvm_common/index.html
2025-03-12 16:51 sourabhniyogi: If this seems bizarre, and you want to build user facing applications, with probability 1, there will be a "CoreVM" service written with the above and you just write a normal-ish [Rust/...] program as a guest program of *that* general service serving users.   I believe JAM ran DOOM (and maybe will Quake next haha!) as an illustration of this idea in a proto-CoreVM -- we should all like to know how to demonstrate this with our friends!
2025-03-12 17:57 alambicco: is there any resource to understand what a "service" is ? 
  ↳ 2025-03-12 18:34 danicuki: https://graypaper.fluffylabs.dev/#/85129da/0ba2000ba200?v=0.6.3
  ↳ 2025-03-12 18:57 alambicco: ok tahnks
2025-03-12 17:58 alambicco: from a philosophical and design perspective
2025-03-12 22:32 ycc3741: I’m very curious about how JAM runs DOOM without delay.
What I mean is that JAM itself has a six-second finalization time.
So my inputs go through:
Input (mouse or keyboard) → corevm → JAM → corevm → Output (monitor)
Logically, wouldn’t that result in a six-second delay?
  ↳ 2025-03-12 22:40 sourabhniyogi: My guess is that the DOOM demo has the "user" computing the work packages FIRST (and as a result, knowing the exact exportCount), and then what you see in the demo is the stream of work packages submitted by the user into a core (or some number of them), the "frames" going through DA, and the claim that "JAM is running DOOM" is actually "JAM is doing guaranteeing/assuring/auditing AFTER the user has submitted their work package" -- its a streaming demo and a test of N cores doing (a) DA throughput (of the "frames") (b) the same computational process in refine that the user.  So, no jerkiness, but yes, a 6-12 second delay technically between what the user has done in creating N exported segments (representing video frames) and polkavm replicating the same computation.

Just a guess, hope someone can correct it 
  ↳ 2025-03-12 22:41 ycc3741: yeah
  ↳ 2025-03-12 22:42 ycc3741: there should not be jerkiness
  ↳ 2025-03-12 22:42 ycc3741: but lantency might be a issue QQ
  ↳ 2025-03-12 22:44 ycc3741: Because when I saw Dr. Wood's demonstration, he didn't directly play DOOM but instead showcased the output. So, I'm not sure how the delay issue was handled.
  ↳ 2025-03-12 22:46 sourabhniyogi: Its just a playback of the user-generated work packages from a real user (or a bot, doesn't matter) done at some time before.  
  ↳ 2025-03-12 22:47 ycc3741: yeah. I think so, too. 
  ↳ 2025-03-12 22:50 sourabhniyogi: You can eliminate the user input with https://playgameoflife.com/ - we'll have this as a corevm-like refine test vector dataset that is easy to turn into a hellow world and more exciting than likecomputing primes.  Not as sexy as shooting things though.  [edited]
2025-03-12 22:33 ycc3741: Or did I misunderstand something?
2025-03-12 22:45 ascriv: Maybe more accurate to say it ran some tool-assisted gameplay playback
2025-03-13 10:15 ultracoconut: Is possible to build a mini Jam toaster with Raspberry pi? [edited]
2025-03-13 10:16 ultracoconut: 1000001546.webp
2025-03-13 10:19 ultracoconut: I guess the arm architecture is a problem🤔
2025-03-13 10:39 danicuki: The architecture should not be a problem. If it is a smaller validator set, with less capacity, I believe it is possible to run. The assumed node capacity for a full network is "a modern 16 core cpu with 64gb ram, 8tb secondary storage and 0.5gbe networking." 
2025-03-13 11:06 ultracoconut: > <@danicuki:matrix.org> The architecture should not be a problem. If it is a smaller validator set, with less capacity, I believe it is possible to run. The assumed node capacity for a full network is "a modern 16 core cpu with 64gb ram, 8tb secondary storage and 0.5gbe networking." 

Great!
2025-03-13 11:40 wabkebab: this could be a good open-source hacker/enthusiast project [edited]
2025-03-13 11:44 jan: Would be way too slow for production, but as a fun test net, sure.
2025-03-13 12:00 ultracoconut: It is for fun🥳 Could 6 Raspberry Pi 5s 16gb ram model run Jam faster than a single Mac Notebook?🤔
2025-03-13 12:23 gav: > Logically, wouldn’t that result in a six-second delay?

Probably more than a 6-second delay; the Work Package must first be computed, sent to a guarantor; two of them must then compute the work-report and send it to the author; they must then place the report in the block and accumulate it. At peak usage the pipeline will normally take somewhere around 12-18 seconds, though if refinement is very fast, you have core affinity, you get lucky on the block phase and there's not much to accumulate, it could be less than a second. [edited]
2025-03-13 12:25 gav: So if you wanted to actually run DOOM _through_ JAM and watch JAM's output (i.e. the display) before making your next input (i.e. shooting), you'd probably experience too much lag for an enjoyable session on a game like DOOM. [edited]
2025-03-13 12:26 gav: However, it's conceivable that certain kinds of games (e.g. turn-based, card games &c.) could make use of a pipeline with this kind of latency.
2025-03-13 12:27 gav: The demo was to show off the generality, computation & DA capabilities of JAM. JAM is not going to put Nintendo out of business.
2025-03-13 12:27 gav: JAM could also possibly be "overclocked" (i.e. have a reduced block-time), which would further increase playability of games needing lower latency.
2025-03-13 12:28 gav: And, of course, nothing stops you from peeking at DOOM's output at the package-builder stage and devising sensible inputs "just-in-time" then. That wouldn't involve JAM as a critical part of the "look-aim-shoot" cycle, but would utilize JAM as a guarantor of game-correctness and could be quite an interesting possibility for things like gaming tournaments where you want players' (inter-)actions checked by a neutral platform. [edited]
2025-03-13 12:32 gav: We're already preparing the tooling and code so that anyone with a vaguely viable M2 implementation will be able to demo it on their own testnet.
2025-03-13 12:33 gav: For us, it runs fine in the PVM interpreter; no recompiler needed.
2025-03-13 12:38 gav: I'd recommend you watch one of my recent talks; I spend some time talking about services.
2025-03-13 12:39 gav: You can think of a service as a highly-parallelisable, pipelined and high-throughput smart-contract.
2025-03-13 12:40 gav: It has a somewhat atypical multi-stage execution model, which makes it highly optimal to be executed on a decentralised, distributed platform like JAM.
2025-03-13 12:41 gav: As sourabhniyogi says, writing a service directly is probably not particularly sensible for anyone wanting to make anything user-facing.
2025-03-13 12:41 gav: You can think of JAM as the decentralised equivalent of a bare-metal supercomputer.
2025-03-13 12:43 gav: Services are the basic operating systems that sit on top of JAM. Most of them will allow programmable code to be "loaded" and executed in richer or more "normal" execution model (much like like DOS, Windows, Linux &c provide a richer execution environment for software to run than the bare metal of a machine). A few services might be highly domain-specific with fixed-functionality (e.g. a storage or bridge service). [edited]
2025-03-13 12:45 gav: We can already see some services like CoreVM which provides a docker-like continuous execution VM environment, and imagine a CoreChains service which provides an environment for L2 blockchains to execute, much like Polkadot's Relay-chain. [edited]
2025-03-13 12:46 gav: Much like there are far fewer operating systems than there are pieces of software which run on them, we'll likely not see so many services compared to the amount of software deployed on to them (smart contracts, CoreVM inner software, L2 chains). [edited]
2025-03-13 20:56 xlchen: where can I find the service code showed in the JAM talk?
2025-03-13 22:34 ultracoconut: > <@danicuki:matrix.org> The architecture should not be a problem. If it is a smaller validator set, with less capacity, I believe it is possible to run. The assumed node capacity for a full network is "a modern 16 core cpu with 64gb ram, 8tb secondary storage and 0.5gbe networking." 

I think I said it wrong. What I wanted to build was actually a core jam. One validator per raspberry pi.
2025-03-13 22:35 xlchen: for a small testnet with reduced gas limit and related parameters, I see no reason why it wouldn't work
2025-03-14 08:55 olanod: A small hardware can be a helpful development tool, a tiny rpi powered testnet sounds good, like a plug and deploy device? To be familiar with bare metal RV64 for service development I'm also thinking of a smaller "service emulator". e.g. this [board](https://wiki.sipeed.com/hardware/en/maix/m1s/m1s_dock.html) I got with a RV64GCV core at 480MHz will be helpful while developing a service.
2025-03-14 09:02 olanod: And speaking of services, JAM will be an interesting platform for new kinds of operating systems. If anyone has any thoughts, I wrote a bit about [VOS](https://forum.polkadot.network/t/virtual-operating-system-for-jam-program-with-wink-and-zink/11973), an OS to run WASI programs, the idea is to appeal to non blockchain developers and attract them to our ecosystem(e.g. the many Rust devs that hate to just hear the word blockchain mentioned ;P)
  ↳ 2025-03-14 09:09 jan: We're not bound by WASM's limitations, so you don't necessarily need WASI here. With a proper libc port and a service that emulates a subset of Linux syscalls you could run essentially any normal program unmodified just by recompiling it. (Of course that'd probably not be very useful because you still need JAM-specific I/O to do anything useful.)
  ↳ 2025-03-14 09:25 olanod: What I like about WASI is the ecosystem, it will have better tooling, compiler support, etc. Wouldn't it be great if we can mix the good parts of WASI with PVM? the SI without the WA ... wasmtime supports no_std not too long ago, the prerequisite is to precompile WASM ahead of time to the target architecture, I think that limitation could be an advantage as we could transpile WASM to PVM so no WASM interpreter is used in the JAM service ... haven't got there yet but it's worth a try ;)
  ↳ 2025-03-14 09:39 olanod: I find it very convenient to enable a regular rust program with a main function that reads from stdin or a file and writes an output with regular os primitives for example, any non blockchain dev can do that, it's a program that can be `cargo run` without any extra set up. Wouldn't it be great to enable this kind of development? We could try to contribute a standard library to rust for a `riscv32emac-unknown-someos-polkavm` target but if somebody already did the work with WASI why not use that instead? 
  ↳ 2025-03-14 09:49 olanod: like a fake libc, VOS would translate things like reading/writing from files into things that could make sense in the context of JAM, if like Linux we abuse the *everything is a file* to expose JAM I/O as "files" then it can become useful :)
  ↳ 2025-03-14 10:06 jan: Yes, that's literally what a libc port + emulation service would do, but without the WASM -> PVM recompilation step. It is a tradeoff - with a WASM -> PVM recompiler you could use existing WASI backends, but you'd get more bloated binaries and worse performance; with a libc port you'd have to reconfigure each compiler to use it (which is extra work, although it's relatively easy to do) but you'd get higher performance and smaller binaries.
  ↳ 2025-03-14 10:07 jan: But, in general, I'd love to see a WASM -> PVM recompiler. If you write one please make sure to ping me and let me know. (:
  ↳ 2025-03-14 12:56 olanod: I'll first focus on the developer experience, i.e. wink!(we'll use it for regular backend services) but will see what can be done with Cranelift that supports riscv64. Any special considerations you foresee? 
  ↳ 2025-03-14 12:57 jan: You won't be able to use Cranelift, as it doesn't support rv64e.
  ↳ 2025-03-14 13:00 jan: You'd have to add support for rv64e to Cranelift (which probably shouldn't be too hard, as it's mostly just forcing it to not use the upper 16 registers), but even then it probably won't be a simple job to emit something that can be turned into PVM bytecode (you need to use a very specific memory model with full relocations, and I have no idea whether Cranelift supports all that).
  ↳ 2025-03-14 13:00 jan: A much simpler way to do it would be to go through the wasm2c route, that is, convert the WASM bytecode into Rust or C and compile it with a normal compiler.
  ↳ 2025-03-14 13:01 olanod: thanks that's helpful!
2025-03-14 09:59 ultracoconut: > <@olanod:virto.community> A small hardware can be a helpful development tool, a tiny rpi powered testnet sounds good, like a plug and deploy device? To be familiar with bare metal RV64 for service development I'm also thinking of a smaller "service emulator". e.g. this [board](https://wiki.sipeed.com/hardware/en/maix/m1s/m1s_dock.html) I got with a RV64GCV core at 480MHz will be helpful while developing a service.

Great idea to use risc-v hardware. The Core Jam Pi could be a cluster of 3 Raspberry Pi 5s  16 GB RAM model, each with its own 1TB NVME SSD. Each would function as a validator. What do you think?
2025-03-14 10:23 ultracoconut: 1000001561.jpg
2025-03-14 13:34 jay_ztc: also related:

https://www.sifive.com/boards

https://github.com/chipsalliance/rocket-chip (much lower layer than our use case but love to see this direction in the hdl scene)
2025-03-14 13:38 jay_ztc: makes me wonder if there's any gas-metering designs on opencores, integrating one into rocket core would be sick (bit beyond this specific scope, but cool to dream about) [edited]
2025-03-14 15:57 ultracoconut: I have more ideas for marketing the Core Jam Pi. If anyone is interested, send me a DM on Twitter.✌️
2025-03-16 10:20 ultracoconut: Well, I have an update on the concept. Mermelada cubes. Each cube is a Jam core pi. You can add cores by connecting cubes.This is useful if your application needs more than one core.
2025-03-16 10:23 ultracoconut: For example, you can create your rollup and test it in 3 local physical cores.
2025-03-17 08:03 clearloop: hey teams, may I ask if you are requesting the full blocks right after receiving their valid headers?

I found that for only storing headers & communicating with neighbours, we may miss sort of blocks when are about to author blocks (in tiny network, 3 of the neighours only have the headers, they may do best chain selection later then, but when they get the expected block the current node may have already authored a new block), and then, fork occurs even in my local testnet ))

e.g. after receiving a valid block header, as a validator: we announce it & request the full block data [edited]
  ↳ 2025-03-17 09:16 clearloop: okay we just got it is caused by our implementation of ce128
2025-03-17 13:38 mnaamani: from Jam prize rule no.20 - "Prizes are paid to the earliest Polkadot/Kusama account IDs stated in the repository's README. In the case of a tie, payment is split equally" - Does that mean that a prize is only allocated to a specific language?

So if I'm considering starting a new implementation, would it make more sense to pick a language that not many teams are currently working on? [edited]
2025-03-17 15:02 gav: No and yes.
2025-03-17 15:03 gav: Prize pool is split between language sets, so it makes sense to select a language from one of the less popular language sets (C and D, currently). [edited]
2025-03-17 15:04 gav: The account ID rule is there to ensure that someone doesn't wait for an implementation to be nearly complete, fork the repo, finish the impl and submit it to collect the entire prize. [edited]
2025-03-17 15:08 gav: As already stated, the JAM prize is intended to incentivize and seed a diverse, distributed, decentralised knowledge base of the JAM protocol. This precludes the substantive use of AI to generate or translate code. We already have some rules to preclude the substantive use of AI, but others may be introduced to help police against it and ensure that implementations are actually clean-room.
2025-03-17 15:08 gav: > Any Jam-implementation code which is viewed before or during implementation must be declared.

Since AI models may be trained on code from other implementations, this precludes the substantive use of AI-generated code.
2025-03-17 15:10 gav: > Interview may be requested after submission to ensure team members are the legitimate authors of the code.

Again, here for the sake of argument "legitimate" means without the assistance of generative AI. [edited]
2025-03-17 15:10 gav: Remember: the purpose is to decentralise. AI is fundamentally centralising.
2025-03-17 15:12 gav: Expect a hard grilling at interview. I (and perhaps others in the Fellowship) will want to see that not only did you write the code but that you *understand* the code and how it relates to the GP. Being able to produce a conformant implementation is not enough to win the prize. It must be convincingly written from scratch by the team behind it without assistance from others, not even if intermediated by an AI model.
2025-03-17 15:15 gav: Happy to answer any questions on the above. [edited]
2025-03-17 15:27 jan: In general when working on something novel AI is pretty much useless in the vast majority of cases. If you need to write a bunch of boilerplate code that was already done a million times - that's where using an LLM shines, but if you're doing novel work it's either going to sabotage you because the code will just plainly be wrong, or waste a bunch of your time because you'll have to rewrite it anyway. Not sure if Gav would agree, but personally I wouldn't care if you'd use AI to help you write some boilerplate unrelated to JAM (e.g. spinning up an RPC server in your language of choice; that has been done a million times already and I see no reason to waste time reinventing it yet again - without an LLM you'd copy-paste it from the library's docs or StackOverflow anyway) or get it to generate some unit tests for you, but everything related to the protocol itself and its implementation should be written entirely manually. [edited]
2025-03-17 18:55 mnaamani: Thanks that was very clear and comprehensive, Glad I asked because I was considering a less popular language from set B (D lang), but given that I'm a bit late to the game, it might make most sense to pick something even more rare from the "Mad" category? But if I was not solely focused on the prize, an implementation in D could still be valuable. I'll ponder on it.
2025-03-17 22:30 ascriv: In the case that N > 5 teams submit milestone 1s at the same time for the same language set, is the prize pool split N ways or are the 5 best chosen, or some other method?
2025-03-19 10:10 gav: It's a first-come-first-serve basis.
2025-03-19 12:09 prematurata: > <@gav:polkadot.io> It's a first-come-first-serve basis.

Was it always like this? I think I remember a discussion about splitting in case more than 5 submit a valid impl.

Wouldn't a change (if any) towards a first come first serve cause a "click day" basically adding more value to the "social posting timing" than the implementation itself?
2025-03-19 13:11 jay_ztc: I think you're making an assumption that M1 secures future payments. Based on the submission rules & milestone delivery repo, completing m1 doesn't "reserve your spot" for future milestones. Currently there is (up to) 100k dot per milestone and 2.5 mil dot per lang pool. It could be the case that 10 teams for a single pool complete & collect m1 and m2 payments- meaning 20x100k dot has been paid out (75% of it linearly vesting). In that case there would only be 500k left in that prize pool.

Someone please correct me if I'm wrong.

https://github.com/w3f/jam-milestone-delivery/blob/main/README.md?plain=1#L31 [edited]
2025-03-19 13:23 ascriv: My question is more like, what do we do in the (maybe unlikely) case that we get 15 (lang set A) valid M1s right when M1 submissions start getting accepted? Or are we tiebreaking by millisecond timing of submission? [edited]
2025-03-19 13:25 jay_ztc: Doesn't say anywhere about the prize being evenly split between milestones. I assume (up to, pending judging) 100k paid to 15 teams meaning only 1 mil dot left in that pool.

Again, not a fellow or w3f member- someone correct me if I'm wrong.
2025-03-19 13:29 dakkk: Would be fun if after working on Jampy for 8 months full time I miss the timing for submission because I was sleeping 
2025-03-19 14:05 clearloop: spacejam-localnet.mov
2025-03-19 14:05 clearloop: spacejam can finally maintain the block finalization in localnet, so much pain debugging with logs these days 😭
  ↳ 2025-03-19 14:45 jaymansfield: Congrats!
2025-03-19 14:45 gav: Well, each language set can support the M1 payout of 25 teams, so I don't think there's going to be significant competition there. [edited]
2025-03-19 14:46 gav: And this would assume all submissions passed all (secret) M1 conformance tests perfectly first time.
2025-03-19 14:49 gav: The published test vectors are obviously not comprehensive (nor are they designed to be) and I find it quite unlikely that all candidates will pass all conformance tests first time.  [edited]
2025-03-20 04:33 waterreptile19: hey all... how do I get started? Is there any codebase I can refer to?
2025-03-20 07:06 mnaamani: There is no codebase, the whole idea is that there is a detailed specification, they gray paper, based on which you would independently create an implementation of jam. https://graypaper.com/
2025-03-20 16:13 eclesiomelo: hey guys, we are fixing some bugs on our PVM implementation and one of it is related to the standard program initialization (definition A.36), more specifically we are trying to run the accumulate test vectors and its test service blob starts with the bytes `0x47000c` (here is one example -> https://github.com/davxy/jam-test-vectors/blob/038bd899ff7e387d61a46a8d509486179ef2efac/accumulate/tiny/accumulate\_ready\_queued\_reports-1.json#L418) and in definition A.37 the 3 first bytes should be the lenght of the `o` term (`E3(|o|)`), but when  decoding them using a normal integer decoding function we get decimal `786503` which is bigger then the accumulate test service blob, so we cannot read the bytes relative to `o`, did anyone face the same problem? The graypapper says `Given some p which is appropriately encoded together with some argument a`, this argument is also in the test service blob? I would appreciate any clarifications, thanks in advance. [edited]
2025-03-20 18:58 gav: Which version of GP are you working from - 0.6.3 saw the introduction of the metadata prefix to program blobs.
2025-03-20 19:06 eclesiomelo: 
2025-03-20 19:06 eclesiomelo: 
2025-03-20 19:09 eclesiomelo: We are using the most updated version, 0.6.4, and the definition is this one https://graypaper.fluffylabs.dev/#/68eaa1f/2bc1022bc102?v=0.6.4, right?
2025-03-20 19:29 gav: That’s the program blob but not purely what is stored. There is also a metadata prefix 
2025-03-20 19:31 gav: You can see in eg eq. (9.4)
2025-03-20 22:30 eclesiomelo: Oh, we have missed that prefixed metadata, after reading it from the blob we are able to correctly parse the standard program defined at A.37! Really thanks! 😊
2025-03-21 15:29 emielsebastiaan: ima_792adcf.jpeg
2025-03-21 15:29 emielsebastiaan: Big day!! Today we achieved full milestone 1 conformance for the JAM Implementers Prize.

PyJAMaz will be open-sourced when the prize rules allow for it.

https://x.com/jamdottech/status/1903106367826677887?s=46&t=ThX7Y87rr1MIKyk6af4OXg
2025-03-21 17:11 gav: We’re at 0.6.4!:)) [edited]
2025-03-21 17:49 emielsebastiaan: > <@gav:polkadot.io> We’re at 0.6.4!:))

Development branches for 0.6.3 & 0.6.4 are pending review. They did not make our weekly ‘Merge Friday’. 
2025-03-22 11:25 davxy: Test vectors updated to track GP 0.6.4

https://github.com/w3f/jamtestvectors/pull/28

  ↳ 2025-03-22 17:30 jaymansfield: Hey davxy, was it intentional that "exports" in CoreActivityRecord is U16, but "exports" in ServiceActivityRecord is U32? Just wanted to make it wasn't an oversight.
2025-03-22 11:32 davxy: https://github.com/davxy/jam-test-vectors/pull/30
2025-03-22 15:58 ultracoconut:  Mermelada Cubes 

🍓 Mermelada Core → The main validator cube (Core JAM Pi).
🫐 Mermelada Parachain → Additional cube with a collator for parachain testing.
🍊 Mermelada RPC → RPC node to interact with the network and visualize data.
🔥 Mermelada Extra! → A high-performance version with upgraded hardware, storage, and connectivity.
😋😅


2025-03-22 16:23 danicuki: > <@davxy:matrix.org> Test vectors updated to track GP 0.6.4
> 
> https://github.com/w3f/jamtestvectors/pull/28
> 

Awesome. Thanks for this. I see that you didn’t put any statistics for cores and services besides zeroes. Do you plan to add some vectors for those as well? 
2025-03-22 16:26 danicuki: > <@davxy:matrix.org> Test vectors updated to track GP 0.6.4
> 
> https://github.com/w3f/jamtestvectors/pull/28
> 

Did you update the Bandersnatch library in these tests? Many of our safrole tests are failing now. 
2025-03-22 17:12 yu2c: Small question: Why do you use `U64` for the [gas_used](https://github.com/davxy/jam-test-vectors/blob/fb3ce3ffa82833cc780338e9ab128e834e72b26e/jam-types-asn/jam-types.asn#L184) type instead of `Gas`, even though they have the same meaning? I know in the Graypaper, it's noted as `uint64`
2025-03-22 19:25 gav: It is intentional, though not important at present [edited]
2025-03-22 19:45 davxy: Probably yes. But that is not at the top of my task list right now [edited]
2025-03-22 19:46 davxy: Yes that is expected. Please update to v0.1.2 (now also available on crates.io). See https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/safrole/README.md#%EF%B8%8F-warning-%EF%B8%8F [edited]
2025-03-22 19:48 davxy: Do you mean in the asn1 syntax file? I suppose because in that context it is just an alias. I can change it btw [edited]
2025-03-23 06:14 yu2c: No, I think it works well as it is. Thanks for the clarification!
2025-03-24 12:35 amritj: A thought, not important for JAM development, but still want to send it out:


People do mock blockchains for not having any use cases except maybe cryptocurrency. The reason for success of cryptocurrencies and what made them different is there is a singular verifiable database, not millions of small databases for each bank that require and trust third-party solutions like SWIFT to securely transfer information between these databases.

But that's only one type of data being transferred daily - health care records, educational records, financial records, property deeds, and million other fucking important records that are still broken up in these mini databases. 

All these Important information is still fragmented, still requiring trust on these third party solutions.

Companies have been trying to build private blockchains for this, but their problem is the same - they are private, most of them are not more than a few nodes of the same company in different locations. They are not secure; an attack on just few nodes not only bring the whole network down but also compromise the integrity of all the data.

JAM is what they need. JAM is what will allow all these private blockchains to be secure and interconnected. These private blockchains could remain private and borrow the security guarantees from JAM by using ZK proofs or maybe some other tech. Even if some company nodes get compromised, it will only make the data of that specific company public but not have any affect on the integrity of the data 

I believe this is what required next.


I know this is not related to JAM development, but just a thought for other devs building on top of it to build strong tooling and support to make this possible, and maybe also for the marketing team :) [edited]
2025-03-24 14:42 decentration: in `reports.results.refine_load` the zero values encode to 1 byte. For `gas-used` it is u64, given that 0 encodes to 1 byte, can you confirm that we now encode with C.6 serializer? without serializer i am expected there to be 8 bytes of zeroes. 
2025-03-24 17:20 jaymansfield: I think you have to use compact encoding for those new fields
  ↳ 2025-03-25 02:11 qiwei: where in GP does it say these fields need to use compact encoding?
  ↳ 2025-03-27 11:50 decentration: i believe it is referring to C.6
2025-03-24 19:51 danicuki: Are you a JAM implementer and PBA alumni? Let me know!  
2025-03-25 10:52 danicuki: We are planning to have a Polkadot / JAM booth at ETHLisbon. We will need JAM implementors volunteers to be there to spread the word of JAM. React with ❤️ and reach out to me if you are willing to help.
  ↳ 2025-03-25 11:29 wabkebab: In general, is this something that JAM implementors would like to  help representing JAM in different events? [edited]
  ↳ 2025-03-25 11:30 wabkebab: I mean _you_ are making JAM a reality also
  ↳ 2025-03-25 11:31 wabkebab: we - Pala Labs, organisers of JAM Tour - are drafting some "JAM evangelist" initiative we would share soon [edited]
  ↳ 2025-03-25 18:04 sourabhniyogi: Can "JAM evangelists" get your assistance on having the DOOM (or Quake) demo at "foreign" places like this?
  ↳ 2025-03-25 18:51 gav: I'm sure we can make that happen
  ↳ 2025-03-31 18:41 sourabhniyogi: Can we get a set of work packages (or bundles), exporting the frame buffers as segments, relative to some version (0.6.4 or ___) so we can set an April goal of refining them in time for May meet up?
  ↳ 2025-03-31 18:43 sourabhniyogi: Ideally this would come with the exact way to show the demo of rendering the exported DOOM/... segments that even non-implementers could run following some top-level README.
2025-03-25 12:00 milawords: 
2025-03-25 20:13 leonidas_m: Can someone confirm that the encoding of refine_load in the codec vectors is correct? Because I am also confused regarding this
2025-03-25 20:24 gav: As per the GP, the new statistic-related items in work-reports are compactly encoded. [edited]
2025-03-25 20:24 gav: fwiw, this is to save some very valuable space in work-reports.
2025-03-25 20:25 gav: there's already an issue in the GP repo to look for other possible items which can reasonably be compactly encoded
2025-03-25 20:29 leonidas_m: by compact you mean general encoding C.6 right?
2025-03-25 22:16 mkchung: https://graypaper.fluffylabs.dev/#/68eaa1f/1b7c011b7f01?v=0.6.4
https://graypaper.fluffylabs.dev/#/68eaa1f/139c00139c00?v=0.6.4

Is there a specific ordering for segment-root lookup L (or dictionary "D⟨K → V⟩" in general)?
2025-03-25 22:16 danicuki: Please share your team logos here: https://github.com/jamixir/jam-media

This is for the JAM Experience merch. 
2025-03-25 22:37 gav: ~Segment root lookup is never serialised so ordering it is moot~. Dictionaries in general can be serialised and that is defined in the relevant appendix section.  [edited]
2025-03-25 23:33 sourabhniyogi: By C.24 https://graypaper.fluffylabs.dev/#/68eaa1f/379b02379b02?v=0.6.4 -- the segment root lookup l in the work report (included in the guarantee) is serialized and is important since 2 or 3 guarantors have to sign perfectly identical work reports.  Since we don't need to map segment roots to identical segment roots, the only entries in the serialized segment root lookup within the serialized work report would be work package keys mapping to segment roots by this here https://graypaper.fluffylabs.dev/#/68eaa1f/1b78011ba101?v=0.6.4 -- check?  So implementers faced with this segment root lookup ordering question must order by work package hash as described in https://graypaper.fluffylabs.dev/#/5f542d7/37bf0037bf00?v=0.6.4 -- check? [edited]
2025-03-26 07:27 gav: Yes indeed, the previous answer is corrected. The second part still stands: dictionaries are encoded as per the appendix.  [edited]
2025-03-26 22:59 sourabhniyogi: Thank you for clarifying -- We are currently using the segment root lookup within the work report to actually verify the justifications within the bundle and understand the segment root lookup piece of the work report to be absolutely critical to auditing.  If that's wrong, we'd appreciate being corrected as we think we have all the pieces fitting together finally.

In particular, we put some "guarantee test data" together in a new [0.6.4.0 guarantees dataset](https://github.com/jam-duna/jamtestnet/tree/0.6.4.0/guarantees), where we believe we have both generated and verified the self-justifying bundle exactly in the above audit situation.

I wrote up a doc on what we think implementers should do with this [guarantees dataset here](https://github.com/jam-duna/jamtestnet/issues/139) and hope we + others can slog through the heart of this central "puzzle" together soon.

Earlier I was concerned about implementers coding to the test vectors and didn't want to share this kind of writeup (and give away the wrong puzzle answer, and superspread a JAM "mental disease", so to speak, in addition to taking away the delights of solving your puzzle in the first place), but _this_ puzzle is so layered and from our month on getting [0.6.2.x alignment](https://github.com/jam-duna/jamtestnet/releases/tag/0.6.2.12), I've concluded implementers are so independent and puzzle-solving oriented that I'm not concerned anymore:  instead, I'm seeing lots of independent implementations against the same GP produce the anti-fragility you aimed for.

However, if you are concerned, I'd appreciate what you think we should to do to modulate our collective activity a bit. [edited]
2025-03-27 12:32 danicuki: Hi jammers, we are trying to set up a booth at  ETHLisbon to present JAM to event devs. We need a few volunteers to stay there during ETH Lisbon dates (9th-11th). LMK if you want to help
2025-03-28 12:59 stsoen: ​Actually, it makes sense. Moreover, if we look at the current Rollup Landscape, it appears as a patchwork quilt of different pieces. And the quilt is made not only of fabric but also of other materials that may be poorly compatible with each other. In most cases, there is no idea for existence other than "we made it, come here."​

JAM, on the other hand, offers a unified approach with reasonable modularity. Instead of immediately creating something complex with a large number of features unnecessary for most users, instances can be made more targeted for specific cases.​

And this applies not only to cases for companies and enterprises but also to more global and widespread things such as payment systems, data verification, creating common economic layers for a series of games or games from one studio. This also includes cases similar to Hyperliquid, and so on.​

At the same time, unlike AVS (Networks, and so on in different protocols) for restaking, which is actually properly developed only in EigenLayer, there is no need for an extra layer of "restaking." Moreover, the idea of restaking over the long term seems somewhat questionable because economically it does not work as expected.​

And JAM looks like something that is in superposition relative to all these options: it does not have the disadvantages of the above options but at the same time possesses their advantages.
2025-03-28 15:21 gav: The JAM `top` is coming on - hope to release it soon along with a provisional node RPC spec so it can be used on all conformant JAM impls.
2025-03-28 15:21 gav: image.png
2025-03-28 15:24 boymaas: Aaah this is why we are implementing 6.4 😀 😉
2025-03-28 15:24 gav: Indeed:)
2025-03-28 17:59 sourabhniyogi: Schelling point request: should we consider host calls to log as having gas 10 or gas 0 --  https://hackmd.io/@polkadot/jip1 -- totally arbitrary choice right now, just want to pick one of the two. [edited]
2025-03-28 18:14 gav: gas zero - updated hackmd [edited]
2025-03-28 18:29 emielsebastiaan: > <@sourabhniyogi:matrix.org> Schelling point request: should we consider host calls to log as having gas 10 or gas 0 --  https://hackmd.io/@polkadot/jip1 -- totally arbitrary choice right now, just want to pick one of the two.

Non zero gas would potentially alter the flow of anything you’d wish to debug. So 0 gas please. 
2025-03-29 06:37 clearloop: may I ask what's the correct version of `ark-ec-vrfs` at 0.6.4? the [README](https://github.com/davxy/jam-test-vectors/tree/polkajam-vectors/safrole) specified 0.1.2 while it is yanked on crates.io

---

we are now using https://github.com/davxy/ark-vrf/tree/main?rev=bf2d1cf, everything works now [edited]
2025-03-29 07:33 davxy: > <@clearloop:matrix.org> may I ask what's the correct version of `ark-ec-vrfs` at 0.6.4? the [README](https://github.com/davxy/jam-test-vectors/tree/polkajam-vectors/safrole) specified 0.1.2 while it is yanked on crates.io

`ark-ec-vrfs` v0.1.2 works with 0.6.4.
However, future development will be done on [ark-vrf](https://github.com/davxy/ark-vrf) which is currently basically the same.


2025-03-30 16:21 snowmead: For the PVM definition A.1, is it intentionally left up to the implementor to avoid calling `deblob` for every subsequent recursive call for the same program blob `p`? 
2025-03-30 16:22 snowmead: or is there some reason behind this?
2025-03-30 17:15 gav: > <@snowmead:matrix.org> For the PVM definition A.1, is it intentionally left up to the implementor to avoid calling `deblob` for every subsequent recursive call for the same program blob `p`? 

How would you imagine a recursive call into a program blob?
2025-03-30 17:23 snowmead: couldn't we just `deblob` once before and call a recursive function (which internally calls `psi_1` single step function)? 
2025-03-30 17:26 ascriv: > <@snowmead:matrix.org> couldn't we just `deblob` once before and call a recursive function (which internally calls `psi_1` single step function)? 

Should still fit the gp specifications I think, happy to be corrected
2025-03-30 17:30 ascriv: This is how I ended up interpreting it so I’m particularly eager to be corrected lol
2025-03-30 18:32 gav: The Gray Paper only states observable behaviour. The performance tests, when benchmark requirements are published, may imply certainly implementation optimisations.
2025-03-30 18:33 gav: For M1/M2 such optimisations are not *required*, but might be sensible to do regardless.
2025-03-30 18:40 gav: signal-2025-03-26-164136.mp4
2025-03-30 18:40 gav: Almost finished!
2025-03-30 19:01 emilkietzman: That’s amazing, can’t wait for the results. The real question is the jacuzzi ready to handle the heat!
2025-03-31 08:06 gav: > <@gav:polkadot.io> Almost finished!

I should say, almost finished phase 1 of 2. This is 80 machines of 87 for phase 1. Phase 2 will double that to 173. Each machine has 96 threadripper cores in it. 
  ↳ 2025-03-31 10:22 sourabhniyogi: There are many teams with tiny testnets (all independently) producing blocks that are now likely ready to have pair wise interactions with other teams. Should we do this outside of the toaster this spring / summer (because we haven’t even passed M1) or be trying to get teams to do this within it (so as to get teams get jamnp networking right well before M1/M2 have been formally passed)?  [edited]
  ↳ 2025-03-31 10:43 gav: Evaluating and passing M1 should start before end of June; davxy is working hard on getting those conformance tests and 0.7.0 is [within sights](https://github.com/gavofyork/graypaper/milestone/3).
  ↳ 2025-03-31 10:44 gav: I don't think running on the Toaster makes much sense until both M1 and M2 functionality exists, and also certain RPC and structured logging functionality is in place.
  ↳ 2025-03-31 10:46 gav: We can probably publish a draft spec for tooling-facilitating RPCs quite soon (maybe this week, if it's a high-enough priority). Structured logging format is not yet started AFAIK but should be on the horizon as the Toaster comes online and erin and Arkadiy begin writing the relevant tooling to analyse and visualise it.
  ↳ 2025-03-31 11:18 sourabhniyogi: Looking forward to RPC + structured logging functionality details!  Can we aim to make this coordination a central topic in the May Lisbon meetup?
  ↳ 2025-03-31 13:20 gav: https://hackmd.io/@polkadot/jip2
  ↳ 2025-03-31 13:20 gav: It really needs putting in a more standard form, but hopefully it's helpful as-is.
  ↳ 2025-03-31 13:20 gav: If these RPCs are properly implemented then the JAM tooling I've been writing should work with the node.
  ↳ 2025-03-31 13:21 clearloop: seems this week just passed in minutes ...
  ↳ 2025-03-31 20:54 xlchen: is this JSONRPC or HTTP GET? how are the parameter and responses encoded? JSON or JAM codec?
  ↳ 2025-03-31 20:55 xlchen: given the subscriptions methods, looks like JSONRPC over WebSocket?
  ↳ 2025-03-31 20:58 xlchen: the types reads like thing should be JAM codec encoded? because otherwise Hash/Blob should really be encoded as hex string instead of array of numbers
  ↳ 2025-03-31 22:14 sourabhniyogi: Looks comprehensive but the big "obvious" objects appear to be missing:

1. _block_ - Returns block with the given header hash, or null if this is not known.
2. _state_ - Returns C1-C15 with the given header hash, or null if this is not known.
3. _workPackage_ - Returns work report (including availability spec) with the given work package hash
4. _segment_ - Returns back segment given (requestedHash, index) (either work package hash or exported segments root) from Segments DA

Are these meaningful to add to jip-2?
 [edited]
  ↳ 2025-03-31 22:16 sourabhniyogi: Surely, everyone will naturally want content-type choice (JSON vs JAM Codec) in the responses and expect JSON to match up with w3f / davxy choices.
2025-03-31 14:54 gav: I updated my (unofficial) Prize notes: https://hackmd.io/@polkadot/jamprize
  ↳ 2025-03-31 21:12 xlchen: can I confirm that generative AI is ok (or not) for:
write documents
write tests
code review
help reading GP
doing research (e.g. how to write a recompiler)
write code that's not covered by GP (e.g. RPC or CLI handling). In theory, those code should not be judged? [edited]
2025-03-31 14:55 gav: They now include the two additional paths for prizes (non-PVM and light-client)
2025-03-31 14:55 gav: This will still need to be discussed and ratified at W3F level. But should give the right flavour.
2025-03-31 14:58 gav: I gave the non-PVM path a conversion option to get almost the same prize as the regular path; it's not quite the same (450,000 vs 500,000) since there's a slight desire to get at least one or two teams building a recompiler soonish.
2025-03-31 14:58 gav: It would be helpful to have a show of hands how many teams plan to go for which prize path. Maybe 🪶 for light-client path, 🎸 for authoring including PVM and 🤠 for non-PVM authoring. [edited]
2025-03-31 15:02 gav: Note that for teams who use one language for business logic but another for specific subcomponents in order to achieve sufficient performance, your language set will be that of the business logic as long as the second language is very clearly limited to the subcomponents and the subcomponents are properly scope-limited. [edited]
2025-03-31 15:06 emielsebastiaan: Most likely 🤠 too many performance related research unknowns at this point to aim for 🎸. 
2025-03-31 15:10 ascriv: ^similar boat aiming for guitar but may go cowboy at m3
2025-03-31 15:13 oliver.tale-yazdi: JamBrains is working on authoring with PVM-interpreter, recompiler is currently not planned
2025-03-31 15:16 jay_ztc: I'm very excited to open source my pvm recompiler implementation soon(ish). Following the naturally emergent api boundaries from the GP & reusability across different projects & languages have been design priorities since day 1.
2025-03-31 16:19 jaymansfield: Is there still a talk planned about how to achieve a high performance recompiler? I think I recall seeing something mentioned here in the past.
2025-03-31 17:45 finsig:  Time permitting Martlet will try for 🤠, otherwise 🪶.
2025-03-31 19:24 tomusdrw: Would be cool to get confirmation if I'm getting the incentives & options for non-fast-set languages right. I'd love to target 🎸 however it might be just impossible to reach the performance requirements, and by investing time&effort into this I'm risking being outpaced by 🤠 & 🪶, right? So with 50k DOT penalty it seems just safer to go 🤠, isn't it? (450k DOT vs 0) [edited]
  ↳ 2025-04-01 05:29 clearloop: cowboy in avatar & emojis
  ↳ 2025-04-01 11:22 gav: Yeah it'll depend on how much confidence you have in your language(s) of choice. There's only a limited number of spaces for 🪶 in each language set and they only fetch half the amount, so being outpaced by them at least seems unlikely.
2025-03-31 19:42 danicuki: This is an optional (but I highly recommend) after activity for those who come to JAM Experience in Lisbon:

On May 8th, there will be a very talented and high quality Brazilian music gig at the Lisbon Colosseum. Buy your tickets if you wanna go:

https://www.bol.pt/Comprar/Bilhetes/155009-diogo_nogueira-coliseu_de_lisboa/Sessoes
2025-04-01 06:02 clearloop: our team have good background in compiler and super interested in implementing a re-compiler for fun, however we'd like to target 🤠 first since it's safer, we may implement a re-compiler only after passing ~~M4~~ MN4 (else if we can finish it in one week) [edited]
2025-04-01 06:04 jan: You most likely won't be able to pass M3 without a recompiler, nevermind M4. (Unless you mean the non-validating MN4 milestone.)
2025-04-01 06:05 clearloop: can't we use polkaVM for M3 & M4? the non-PVM path? [edited]
2025-04-01 06:08 jan: So you meant the non-validating milestones. Those are called `MN3` and `MN4` in Gav's document. Please use proper unambiguous naming, otherwise it's very confusing.
2025-04-01 06:10 dakkk: > <@jan:parity.io> So you meant the non-validating milestones. Those are called `MN3` and `MN4` in Gav's document. Please use proper unambiguous naming, otherwise it's very confusing.

Which document?
2025-04-01 06:11 jan: The one that Gav posted a few message ago here: https://hackmd.io/@polkadot/jamprize
2025-04-01 06:11 dakkk: > <@jan:parity.io> The one that Gav posted a few message ago here: https://hackmd.io/@polkadot/jamprize

Thx
2025-04-01 06:58 vinsystems: What are the incentives for people to run a light node? What do they bring to the JAM network?
2025-04-01 07:00 bkchr: Light nodes are being run by the people wanting to interact with Jam/services on top of it 
2025-04-01 07:00 bkchr: Not by any other operator 
2025-04-01 07:01 bkchr: And you get trustless access to the chain, as you are verifying the signatures of the blocks etc. 
2025-04-01 07:01 xlchen: there won't be RPC nodes for JAM chain. you have to run a light node to access jam chain data like best block hash etc [edited]
  ↳ 2025-04-01 07:03 chungquantin: I'm curious where this info is mentioned? Would love to read more about it.
  ↳ 2025-04-01 07:04 xlchen: somewhere in this room 💁‍♂️
  ↳ 2025-04-01 07:04 xlchen: we don't have much docs about the non GP part as nothing is finalized. we have some ideas of how things should look like, but until some PoC, we can't say for sure it will work
  ↳ 2025-04-01 07:07 xlchen: https://hackmd.io/0gSmXyElT2iKawymS5jJKw?view this maybe useful
  ↳ 2025-04-01 07:07 chungquantin: I see, thanks for the resource! 
  ↳ 2025-04-01 07:15 bkchr: With polkadot we tried to be light client first, but if you don't force people to use it, no one is gonna do it. Or ultra slow 
2025-04-01 11:15 gav: yes!
2025-04-01 11:17 sourabhniyogi: JAM Game of Life demonstration (from www )
 https://www.youtube.com/watch?v=lvkF7i6pmR8

2025-04-01 11:32 ascriv: > <@sourabhniyogi:matrix.org> JAM Game of Life demonstration (from www )
>  https://www.youtube.com/watch?v=lvkF7i6pmR8
> 

Neato 
2025-04-01 13:35 qinwenwang: Hi everyone, I am thrilled to release the Chinese Version of JAM Gray Paper DRAFT 0.6.4. on https://www.lollipop.builders/JAM-Graypaper-Chinese.pdf ；I look forward to feedback, discussions, and further support Mandarin speaking dev community for JAM 
2025-04-01 22:08 jay_ztc: is the repo for the jam-types crate public? noticed the transfer memo length doesn't match the GP spec and was going to open an issue. The gh link on crates.io is 404. [edited]
  ↳ 2025-04-03 15:36 jan: Not currently. It's released from our private polkajam repo.
2025-04-03 15:28 clearloop: curious about how do you like your PVM interfaces so for? after following the invocation interfaces strictly, my PVM interpreter turns into functional style finally, it's cool but the function signatures just have too many arguments, I'm thinking of that we may need more composed types defined in GP for the PVM part
2025-04-03 15:48 jan: Do you want to know how my interfaces look like, or are you looking for suggestions? :P If so I'd probably suggest a traditional fetch + eval interpreter loop at a bare minimum, plus a stateful interface to control it. The GP isn't really an implementer's guide and its equations have no bearing on how something should _actually_ be implemented; sure, you can translate its equations directly into code, but you'll be killing your performance by doing that, so for any non-toy implementations I'd probably suggest not to do that (especially for PVM, where you can make your situation potentially orders of magnitude worse even compared to a basic straighforward traditional interpreter design). :P [edited]
2025-04-03 16:02 clearloop: while considering supporting both interpreter and re-compiler in the same interface, we have an abstraction layer for PVM interfaces ( also it is caused by the design of our runtime, things like PVM, validator, storage, and even the network implementation are modular ), so I'd like to confirm if the PVM interfaces in the GP has already been the standard, if so, I'll keep following it atm, otherwise my hands are not tied
2025-04-03 16:09 jan: The GP doesn't define any PVM interfaces in the sense of an interface in a programming language; again, it describes the visible *behavior* of a JAM implementation, but doesn't specifically require *how* that behavior should be achieved. There's no standard PVM interface, and even if there were one it'd most likely look very very different than what the equations in the GP suggest, assuming its intended use would be as an abstraction layer over multiple PVM implementations for a production JAM node.
2025-04-03 16:17 jan: If you want some inspiration on how to structure your interfaces I'd suggest to look at some of the production VMs out there and see how they do it.

For example, some of the WASM VMs:

wasmtime - https://docs.rs/wasmtime/latest/wasmtime/
wasmi - https://docs.rs/wasmi/latest/wasmi/
wazero - https://pkg.go.dev/github.com/tetratelabs/wazero

Or even just look at my interfaces:

https://docs.rs/polkavm/latest/polkavm/struct.Module.html
https://docs.rs/polkavm/latest/polkavm/struct.RawInstance.html

(Feel free to copy them if you want; it's just an interface, and I wouldn't consider it collusion or plagiarism - there isn't really anything super JAM specific in there, and all of it is fairly straightforward if you have any experience with working with VMs.)
2025-04-03 16:19 clearloop: I'm mainly following the interfaces of wasmtime as well since I used to be a WASM developer 🙈
2025-04-03 16:26 sourabhniyogi: How shall teams get started with PVM recompilation?  We are ready to plunge into this to get the 50x gains.
2025-04-03 16:30 jay_ztc: clearloop | SpaceJam: I would consider the idea of a "naturally emergent api"-> a product of the GP api & what is practical given todays hardware. I'm actively working on this, more to come soon. [edited]
  ↳ 2025-04-03 16:38 clearloop: sounds dope! I'm about to stop talking about PVM here today otherwise I'd like to implement a re-compiler as well now xd, can't afford to race with you since we haven't even finished the runtime part yet 🫠
2025-04-03 16:36 sourabhniyogi: For [CE128 Block request](https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-128-block-request) I _strongly_ agree that a 4-byte (or compact) length prefix preceding each block would be useful.  The additional bandwidth savings from _not_ having this length-prefix is %-wise not meaningful -- if bandwidth savings mattered _that_ much, you could get those savings much more easily (and a bit less work!) by changing the "little-endian 32-bit unsigned integer" [here](https://github.com/zdave-parity/jam-np/blob/main/simple.md#messages) to compact form.   What do you think?
  ↳ 2025-04-03 16:38 sourabhniyogi: image.png
  ↳ 2025-04-03 16:38 sourabhniyogi: ^ context from last year
  ↳ 2025-04-03 16:42 dave: Would rather not change SNP without a really good reason. It's just a temporary protocol; it's not intended to be the final protocol used by JAM. If you open an issue in the repo we can address things like this in the full protocol
  ↳ 2025-04-03 16:46 sourabhniyogi: The really good reason is that its not "simple" and creates a lot of pointless busy work.
  ↳ 2025-04-03 16:46 dave: How is it not simple?
  ↳ 2025-04-03 16:46 dave: Just read the message into a vector and then decode blocks from it
  ↳ 2025-04-03 16:46 dave: This is what polkajam does and it's not particularly complicated
  ↳ 2025-04-03 16:47 sourabhniyogi: It should not be a requirement to force implementations to decode with streaming when you can just add a length prefix.  Why is this so important to NOT have the length prefix?
  ↳ 2025-04-03 16:48 dave: There is a length prefix on every message
  ↳ 2025-04-03 16:49 dave: There isn't one for each block in this case. This is something I'm happy to change in the full protocol but it doesn't seem like a big issue honestly
  ↳ 2025-04-03 16:51 sourabhniyogi: I am asking for a length prefix for each block in the array of blocks in the CE128 response.  
```
<-- [Block]
```
so that the boundaries between Block X and Block X + 1 are trivial to identify, and don't require decoding the individual pieces of each block just to identify that boundary.  

We are happy to do the busywork, as will a dozen other teams, but just to save a few bytes seems quite unnecessary.
  ↳ 2025-04-03 16:52 dave: It's not to save a few bytes, I'm not sure why anyone thinks that is the case. It's simply to avoid the protocol being a moving target. Of course if there are actual issues with the protocol that need to be fixed we can do that, but things like this don't seem particularly important to me [edited]
  ↳ 2025-04-03 18:37 sourabhniyogi: Ok its great to know at least one thing is not a moving target!
  ↳ 2025-04-04 13:28 tomusdrw: That's a bit weird of an argument imho. if the protocol stated it's a var-len sequence of blocks there wouldn't be any boundaries either.

The only issue I see with this particular encoding is that it's neither var-len sequence nor fixed-len sequence (we don't know the length upfront) as specified in GP, but rather a concatenation of block encodings. [edited]
  ↳ 2025-04-04 13:29 sourabhniyogi: It doesn't matter, we'll take the "its not a moving target" to be a relief =)
  ↳ 2025-04-04 18:43 gav: > <@tomusdrw:matrix.org> That's a bit weird of an argument imho. if the protocol stated it's a var-len sequence of blocks there wouldn't be any boundaries either.
> 
> The only issue I see with this particular encoding is that it's neither var-len sequence nor fixed-len sequence (we don't know the length upfront) as specified in GP, but rather a concatenation of block encodings.

That’s a regular sequence encoding as specified in the GP. 
  ↳ 2025-04-04 19:40 tomusdrw: Sure, it is, but the receiver does not know how many elements is there.
From that perspective a variable-length sequence encoding (with a length discriminator) is not needed at all.
Obviously there is a much better-defined boundary of the items in sequence (end of the byte stream vs not-matching encoding), but still I'd argue that this kind of usage of fixed-length encoding is rather a peculiar case. [edited]
2025-04-04 18:46 gav: GP requires the double-end-vertical-arrow prefix notation in order to prepend a length. GP doesn’t state that it *must* be used when the sequence length may not be static, and indeed there are instances (like hashing) where it may reasonably be omitted even if the sequence is of variable length. 
2025-04-04 18:47 gav: Streaming, or decoding from a known size container, would be other such instances. 
2025-04-04 20:26 gav: Again would not be correct to call it a “fixed length encoding”.  [edited]
2025-04-04 20:26 gav: It’s  just not prefixed with the number of elements. 
2025-04-04 20:27 gav: So most of the time the length prefix will be used when there isn’t a fixed number of elements but correlation is not equivalence. 
2025-04-04 20:28 gav: As for the wisdom of prefixing with the sequence length or not in this case, I agree it is arguable. 
2025-04-04 20:29 gav: But it’d be wrong to characterise it as literally incorrect on the mistaken basis that the length prefix strictly *implies and is implied by* the condition of the underlying data being defined as have a fixed length.  [edited]
2025-04-04 20:33 gav: There are already multiple instances in the GP where sequence term with non-fixed length is encoded without the length prefix.
2025-04-04 20:35 gav: And on a more general note, the GP doesn’t use any kind of formal typing; 42 is 42 whether it is in N_{256} or N_{2^32}. With this set theoretic syntax it is not actually possible to reason about whether the data is fixed or variable length from the perspective of the value itself. 
2025-04-04 20:36 gav: So it’s best to use terminology that reflects the formalism. 
2025-04-07 10:59 emielsebastiaan: Hello all,

I'd like to kick off a little discussion we had internally in our team meeting recently regarding our collective approach in working towards a public testnet.
Last October in Bangkok those attending JAM0 have initiated an initiative to converge towards a community testnet, called the JAMduna Testnet.
Me and my team believe this is an admirable objective, however we have some worries about potential conflicts with the JAM-prize rules, that may warrent discussion and ideally clarification from W3F and/or Gavin.

The official rules state the following: 
- Rule 6: "Clean-room implementation using the Graypaper and public implementers' channel as the only resources."
- Rule 8: "Relevant private (not in the public implementers' channel) conversations with other implementers must be declared and summarised in reports to the Fellowship."
- Rule 18: "Implementations must pass all relevant public and private conformance/performance tests. These will be shared in the near future."

Gav's Unofficial notes add to rule 6:
- Additional materials may be added here at a later stage.

What we like about the Testnet:
- We believe some coordination is absolutely necessary in order to get to the minimum necessary agreement on practical testnet setups.
- Coordination towards a testnet in our opinion is no different than coordination around the W3F Test Vectors. Like the community findings of W3F Test Vectors, the community findings in the testnet repo lead to higher quality implementations, findings of errors and ambiguities in Graypaper and findings of errors in the W3F Testvectors.

What we are concerned about with the Testnet
- Discussions and thus coordination activities are increasingly happening on other channels like Telegram and Discord (read: NOT the public implementers' channel on Matrix). These channels are arguably public since they were once referenced on the Matrix channels, but these are separate channels that could potentially unlevel the playing field or create an entry barrier.
- Rule 6 and 18 do not explicitly state the Testnet resources to be accepted as a source of coordination (as for the W3F Testvectors for the record).
- Obviously any resource outside Graypaper allows for potential blindspots to emerge (collective misinterpretations). There is however a trade-off to be made here.

Questions we have:
- Is there a risk of JAM-price penalty when a team collaborates on the initiative towards a public testnet?
- Can we classify the JAMDUNA testnet repository in the same category as the W3F Testvectors? And perhaps add this to the (unofficial) rules ("Additional materials may be added here at a later stage"). Or agree on what needs to happen to make this so.
- Can we agree on some do's and dont's in working towards the testnet?

Let's use this thread to have a discussion about this.
2025-04-07 12:22 gav: The rules are there for a reason. Disregarding them, in particular with setting up additional semi-private, invitation only or even merely difficult to discover channels for teams to exchange notes and ideas would endanger those teams ability to claim the prize. [edited]
2025-04-07 13:01 emielsebastiaan: Thank you. Nothing new here, but this strengthens our concern regarding the additional channels.
We are of the opinion that participating in Telegram and Discord channels might not be smart (free advice) when discussing findings, GP-ambiguities, and similar things.

Follow-up question I have:
1. Are current W3F Test Vectors considered public conformance tests? These have proven to be a source of finding Graypaper mistakes and ambiguities.
2. Can JAMDUNA testnet traces (https://github.com/jam-duna/jamtestnet) be considered public conformance tests equally? These have proven to be a source of finding Graypaper mistakes and ambiguities.
3. Can JAM-Docs (https://github.com/jambrains/jam-docs) be considered a public resource for JAM Implementor teams?

When considering (2) and (3) these in contrast to (1) are not listed in the Resources section on Graypaper.com.
There is a collective payoff in these initiatives (better graypaper) and individual payoff (additional source of finding mistakes in your implementation).

4. IMO it would be smart to keep a good accounting record of the list of things your team got from these unofficial resources and the list of things your team contributed to the community due to these unofficial resources.

5. Is working towards to public testnet (JAMDUNA initiative) in its core an activity that might conflict with JAM Prize rules?
2025-04-07 13:16 gav: With regards to a testnet, it’s a little complicated. In principle I think it is admirable and wonderful to see teams so keen on pushing things forward. It’s a good “problem”to have. But indeed it could be a problem. My main concern is over the accessibility of such a network - there are perverse incentives because of the (regrettably necessary) first come first serve nature of the prize. A secondary concern is that those partaking in it may inadvertently get extra “knowledge” over conventions and customs which others do not. This is exasperated by communications happening outside of the two official channels. 
2025-04-07 13:16 gav: 1. Yes, this is the aim. 
2025-04-07 13:18 gav: 2. Feel free to report GP ambiguities or clarification questions that arise from this. Feel very free to publish them.  They cannot be considered official requirements though as there is no W3F review process in place. 
2025-04-07 13:19 gav: 3. No it cannot. It may very be a helpful resource but only the GP is official for the JAM prize. 
2025-04-07 13:20 gav: Even JIPs/RFCs are unofficial conventions until/unless they move or are referenced by the GP. 
2025-04-07 13:21 gav: 5. Potentially yes. 
2025-04-07 13:23 emielsebastiaan: I get your concern about a public testnet, which given your statement may not be smart to pursue.
That said, so far no such public testnet exists only coordination on how such testnet could be set up. 
Is this where a line should be drawn? 

One interesting snippet from my team meeting:
Team member: Gavin's team was looking at the JAMDUNA testnet repository. So it is okay.
My paranoid response: Gavin's team might not be pursuing JAM Prize payout.

2025-04-07 13:23 gav: In so much as conformance to an unofficial testnet has no direct relevance to the GP and thus could be considered either a distraction or outright dangerous for consensus (by forming sub-dialects of the protocol). 
2025-04-07 13:23 gav: Well, naturally I’m interested to see!
2025-04-07 13:25 gav: But the purpose of the prize is to maximise team independence and expertise. To the extent that an unofficial testnet works in favour of this, I’m in favour. But it’s a judgement call, and ultimately i believe it possible for teams to cross the line in pursuit of *their* consensus. Resulting in a case of structurally reduced consensus among JAM impls as a whole.  [edited]
2025-04-07 13:27 gav: I think provided the testnet is 100% open, zero-barrier and responsible to W3F/Fellowship it’ll be fine.
2025-04-07 13:29 gav: Which is precisely why I’d prefer to limit testnets to the toaster and meet-ups where all teams get an invitation, open access is clear, and communications are recorded for those not present to benefit from
2025-04-07 13:32 emielsebastiaan: Yes I agree fully. I was concerned enough to ask for clarifications. Dropped this here so we can have an open discussion about these things. Thank you Gavin!
2025-04-07 13:44 gav: Without making any promises, I’d say that outside of the get-togethers, 0.7.0 would be the time to start a persistent, open access, public testnet. It will likely need to be reset on subsequent GP releases (with an appropriate delay to give teams a chance to catch up to any changes).
2025-04-07 14:19 oliver.tale-yazdi: The jam-docs website explicitly mentions to only contain information that is _not_ part of the GP. Which is how I hoped to avoid any controversy around it.  
But I guess the intro sentence still contains the prize link, which can be misinterpreted [edited]
2025-04-07 14:22 sourabhniyogi: This repo has been 100% open for a while -- and we (and many other teams) have learned a ton, not via private communications but via several dozen issues referencing GP equations and derivations (and in a few cases, asking for clarifications)

https://github.com/jam-duna/jamtestnet/releases/tag/0.6.4.4
https://github.com/jam-duna/jamtestnet

So far, there is nothing much in the way of teams actually connecting to each other
https://github.com/jam-duna/jamtestnet/issues/69
Last week was the only connection we made, with the primary discovery that we had to lowercase our SAN, and that we needed to address CE128 multiblock responses.  These conversations can definitely be 100x noisy and require a "did you get header hash 0x4e37..." type level real time communication pattern -- WAY too noisy for a room with several hundred people and I think, a few dozen teams in a "jamtestnet" room, whether for the toaster or just for 2 teams to figure out wire format bugs and QUIC connectivity.   

So far the "jamtestnet" is a total misnomer -- more accurately it can be called "importblocksalignment" but, with a half dozen having achieved that alignment, its possible to achieve real "accumulate-side" testnet alignment, with actual import blocks happening from genesis onwards!

From [this](https://github.com/jam-duna/jamtestnet/issues/69) there are actually only a few teams actually both wanting and ready to participate in a testnet.  Given the "the testnet is 100% open, zero-barrier" requirement, we can quell any "could you make this a little less noisy" type complaints by doing all this testnet work in a public room.  Does it matter if its Discord, Telegram or Matrix?  Or should we just shut down the jamduna/jamtestnet repo and wait for the Toaster? [edited]
2025-04-07 14:28 sourabhniyogi: If Matrix is best, we currently have a "JAM Implementers" room with 59 people -- I have made that public and this could be used to have super noisy testnet work all done in public to meet the "the testnet is 100% open, zero-barrier" goal -- is that the best answer? [edited]
2025-04-07 14:29 emielsebastiaan: My concerns are a reflection of my team’s internal discussions. It is not a critique of any kind. Simply a note of caution and an attempt to open the discussion of avoiding consensus blind spots. Some great takeaways for everyone in this thread. 
2025-04-07 14:35 rick: can confirm, i'm (goberryjam) a ways from being able to participate in a testnet.. I expect to not be the first in my category but hopeful to make useful contribution in the form of some high quality golang components folks can work into their implementations once we go more open. 
2025-04-07 15:15 p1sar: With all due respect, the concern that participants might "inadvertently gain extra 'knowledge'" not shared by others could just as easily apply to someone attending the PBA or other University, for instance, compared to someone who did not.
2025-04-07 15:48 emielsebastiaan: The PBA example does not have the effect of a slippery slope of compromising implementation/team independence.  
2025-04-07 16:01 sourabhniyogi: I suggest we make this a topic on next weeks call =)
2025-04-07 16:08 sourabhniyogi: For JAM Implementers who may not be aware, this room is now public: 
 https://matrix.to/#/!KKOmuUpvYKPcniwOzw:matrix.org?via=matrix.org&via=parity.io
PARTICIPATE AT YOUR OWN RISK =)


2025-04-09 03:23 xlchen: I am confused about CE128 block request https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-128-block-request

> Note that blocks directly contain only the hashes of included work-reports and preimages. If unknown, the actual work-reports and preimages should be requested using protocols 136 and 143 respectively.

and

> Block = As in GP

but blocks defined in GP already contains the work report and preimages, not just the hashes of them?
  ↳ 2025-04-09 08:52 dave: Yeah I think this and/or the GP needs updating. Blocks requested via CE128 are not intended to include reports/preimages. The idea is that the vast majority of the size of a block will be reports, and in practice these are distributed to all validators in advance, so it's a waste of time and bandwidth to distribute them again with new blocks
  ↳ 2025-04-09 08:54 xlchen: I see. So is not `As in GP` at current version. It will be a LightBlock or something that the preimages and work reports will be replaced by a hash?
  ↳ 2025-04-09 08:54 xlchen: I will do full block for now until the light block is defined
  ↳ 2025-04-09 08:56 xlchen: but this is the simple protocol... so maybe just keep it simple? or we are expecting the simple protocol should be as close as possible to the final protocol?
  ↳ 2025-04-09 09:30 dave: Full block for now is reasonable. It's effectively what is specified and is what eg Polkajam is currently doing. I'll remove this wording that implies light blocks for now. Light blocks are still the plan for the full protocol, and _may_ be necessary to add to SNP for performance reasons
2025-04-09 15:15 snowmead: quick question: is it ok to rely on the ASN type definitions in the test vectors to quickly create the basic objects and types in our implementation? Obviously I would be validating these types as I implement the protocol and correct any mismatch [edited]
2025-04-09 16:40 codingsh: Hi guys! Is it possible for coretime to become a governance model on JAM? 
2025-04-09 16:46 erin: > <@codingsh:matrix.org> Hi guys! Is it possible for coretime to become a governance model on JAM? 

coretime is not a governance model, it is a market for allocation of blockspace. governance is much more nuanced and can control many more things than blockspace allocation 
2025-04-09 16:56 codingsh: > <@erin:parity.io> coretime is not a governance model, it is a market for allocation of blockspace. governance is much more nuanced and can control many more things than blockspace allocation 

Thank you, I’ve been thinking about PVM, and the need for coretime to be executed today is very cheap, but when we have global adhesion. who has coretime could determine what will be executed?
2025-04-09 16:59 erin: It is a permissionless system. With both coretime and JAM whoever pays for the computation time is able to run what they would like to.
2025-04-09 17:02 codingsh: Awesome, Perfect! 
2025-04-09 19:25 davxy: The ASN.1 module included with the test vectors **should** map one-to-one with the types defined in the GP. If you notice any discrepancies:

- The GP is the authoritative source of truth.
- Please open an issue to report it :-) [edited]
2025-04-09 19:25 snowmead: thanks for letting me know
2025-04-09 22:05 sourabhniyogi: image.png
2025-04-09 22:05 sourabhniyogi: Can we get whoever did these Polkadot Icons here
 https://icons.polkadot.network/ 
to do a refresh for JAM?  I did some placeholders

2025-04-10 06:04 clearloop: interesting, however, seems the repo is outdated now https://github.com/w3f/polkadot-react-icons
2025-04-11 09:54 decentration: just to confirm for M1 in accumulate do we execute separate services in parallel or sequentially? i think i read somewhere that parallelizing services (in accumulate) will be a later version. [edited]
2025-04-11 09:58 clearloop: if I'm not mistaken ,we haven't had the test vectors for PVM integration in accumulate yet, mb ur talking about https://graypaper.fluffylabs.dev/#/68eaa1f/17b90017bb00?v=0.6.4 ? [edited]
  ↳ 2025-04-11 10:11 decentration: hmm, but on the jam website:

```
5. PVM instancing, execution and host-functions
```

im interpreting this as do the pvm invocation using current pvm library such as `jam-pvm-common` (in my case using an FFI)... we dont have the vectors yet, but i imagine we should be expecting them to come for M1.  [edited]
  ↳ 2025-04-11 10:13 decentration: yes re: sequential or parallel im talking about that part of the GP. where it says execute parallel, but i think i heard in a recent lecture that its currently sequential only... could be mistaken. 
2025-04-11 10:15 xlchen: m1 don’t have performance requirement so it is not possible to require parallel execution. it is not possible to tell if you generated the output in a single thread or 50
2025-04-11 10:17 decentration: ok makes sense
2025-04-11 11:45 jan: If I don't get screwed over by the airlines I should be able to join the JAM Experience, so I could probably host a talk about writing recompilers during it if there's interest.
2025-04-11 12:35 gav: 
2025-04-11 14:02 jimboj21: This would be super rad I would love to have this happen
2025-04-11 14:22 charliewinston14: I hope that you can record this and share online (or publish live) as not all teams have the funding to fly to portugal. Some of us are on the other side of the world and would benefit from this as well.
2025-04-13 12:44 sourabhniyogi: Can a JAM equivalent of this be put together now? https://spec.polkadot.network/sect-lightclient I believe this is valuable to set in motion this Spring with jip-2 paving the way for storage value proofs and "warp" and not-warp syncing (ie CE128) being a key thing to execute on with paths that jump over M3+M4. It appears natural to chart light client implementation plans first without GRANDPA and then with. [edited]
2025-04-13 13:37 sourabhniyogi: Instead of adapting "7.4.4 Remote Read Messages", I suggest a more proactive jip-2 method `subscribeBlock(withJustifications=true)` explicitly designed for light client verification that returns _all_ the storage value justifications needed to actually reexecute a JAM state transition.

Full node implementations responsive to light clients `subscribeBlock(withJustifications=true)` must track all storage values that are read from state trie and provide justifications of:
(a) pre-state C1-C15 that are actually read
(b) pre-state storage keys/values (including preimages + lookup) accessed via  host function calls: `read`, `lookup`, `solicit`, `forget`, `info`, `eject`, `query`, `transfer`, ...
(c) code in preimages referenced in all ordered accumulation

Light clients can verify all storage value justifications (a)-(c) (or some subset of them), then reexecute ordered accumulation (including PVM using verified code of (c)) just like full nodes do, and if they derive the same state root, the light client considers the individual JAM state transition valid.

To preserve "7.4.4 Remote Read Messages" JAM equivalent so that the light client just requests justifications for _some_ of the pre-state storage keys/values, presumably to not have a lot of bandwidth used up for justifications, then we would still want some parameter input of `subscribeBlock` enable returning _all_ the storage keys+values read in the state transition.

What else is needed?

All of this can be done without GRANDPA and warp syncing in one half of implementation, and then with.  Does that make sense? [edited]
  ↳ 2025-04-13 22:30 dave: Maybe I'm not understanding but light clients shouldn't need to execute blocks or even need to fetch enough state to be able to do this. I understand you want to get something working without GRANDPA but that can be done by simply having the light client trust finality without verifying.
  ↳ 2025-04-13 22:35 dave: Light clients will use the JAM network protocol (SNP or its successor). The RPC interface is really only intended to be used to connect to locally running nodes. This is for example to make it easy to write tools; instead of incorporating a node tools can just use the RPC interface of a standalone node. Long term it's possible that these tools will just incorporate a light client. In any case I think light client and RPC are probably mutually exclusive things.
  ↳ 2025-04-13 22:41 dave: Of course SNP as it stands is not suitable for light clients. If you want something now you can make up your own extension to SNP, but bear in mind that this might not become the standard...
  ↳ 2025-04-13 22:46 xlchen: speaking of extensions, it will be great if SNP support some basic implementation name / version discovery so that we can have some feature discovery / telemetry ability
  ↳ 2025-04-13 22:53 dave: You can use QUIC/TLS ALPN for this. Obviously that's not going to work very well if there are many extensions, don't think we really want to get to that point though
  ↳ 2025-04-13 22:56 xlchen: my main goal is know which implementation/version is the other side running. this can be helpful to for example workaround some bug in some legacy version or know where to report bugs if found out the other side is sending bad data
  ↳ 2025-04-14 07:47 gav: Then ALPN should be fine, no?
  ↳ 2025-04-14 07:50 xlchen: unless I missed something, ALPN is for protocol version negotiation, how can we use it to discovery the implementation version of peers? [edited]
  ↳ 2025-04-14 08:02 gav: I think you can have a fairly arbitrary ID sequence, can't you?
  ↳ 2025-04-14 08:02 gav: https://github.com/quicwg/base-drafts/wiki/ALPN-IDs-used-with-QUIC
  ↳ 2025-04-14 08:02 gav: E.g. `http/2+quic/NN` allows specification of two protocols and their versions. [edited]
  ↳ 2025-04-14 08:04 gav: We currently use `jamnp-s/V/H`, (`V` is protocol version and `H` is genesis hash) but we could extend this to include the impl ID and version? [edited]
  ↳ 2025-04-14 08:05 xlchen: well, I am using `msquic`, and it requires a known list of ALPN https://github.com/microsoft/msquic/blob/e2a994c9dc91240147c9d079436d4e6daba75e79/docs/api/ListenerStart.md#parameters
  ↳ 2025-04-14 08:05 gav: Sounds like that's not in line with JAM-SNP
  ↳ 2025-04-14 08:05 gav: https://github.com/zdave-parity/jam-np/blob/main/simple.md
  ↳ 2025-04-14 08:05 xlchen: I can fork it and do the necessary changes, but that's something I want to avoid if possible
  ↳ 2025-04-14 08:06 dave: If you want an impl ID/name ALPN is not suitable
  ↳ 2025-04-14 08:06 dave: We can add some protocol to request this if necessary
  ↳ 2025-04-14 08:07 gav: Ahh I see it's a pattern match thing.
  ↳ 2025-04-14 08:09 xlchen: yeah the purpose of ALPN is for protocol version negotiation. I don't think add impl name/version is the right choice
  ↳ 2025-04-14 08:10 gav: Yeah then we can try to introduce this to JAM SNP.
2025-04-13 19:40 danicuki: > <@charliewinston14:matrix.org> I hope that you can record this and share online (or publish live) as not all teams have the funding to fly to portugal. Some of us are on the other side of the world and would benefit from this as well.

All content will be recorded and shared 
2025-04-14 00:13 sourabhniyogi: Hmm, for "shouldn't need to execute blocks or even need to fetch enough state to be able to do this" I think we should get on the same page about what a JAM light client should be.   I thought light clients re-execute the minimal state transition logic but _without having to store anything or process every state transition_ -- this means they need to get storage proofs, verify these storage proofs, and verify recent headers ( including the state root which requires doing PVM accumulation, and ordered accumulation at that ), in order to be a _trustless_ light client.   There is surely some 'I'm actually only interested in _my_ services' smarter approach to verifying the storage proofs, but to verify the state root it appears essential to do the PVM accumulation.

Light clients:

- download **and verify** block headers to stay in sync with the chain’s head. This includes the state root, which requires doing ordered accumulation, including PVM.
- verify that blocks have been finalized (which are GRANDPA finality proofs in both Polkadot+JAM).  I assume the last 28 days will be warp synced
- request storage proofs needed to validate a transition, which is/was the purpose of 7.4.4.

If you have low-powered light clients they can choose to pick some _subset_ of storage proofs (e.g. in a self-centered way, biased to just the services the light client cares about) for reduced security, but as you go from verifying all to verifying nothing, you go from "trustless" light client to "trust me bro, I'm infura" light client.

CE129 could be adjusted to fill the role of 7.4.4 but as of this moment it doesn't return Justifications and is optimized for range queries.  Another CE could be created for light clients to get storage proofs, but there still needs to be a source of which state trie keys have been read. [edited]
2025-04-14 07:48 gav: No.
2025-04-14 07:48 gav: Light clients sync to the most recent finalised block through a GRANDPA proof.
2025-04-14 07:49 gav: They do no re-execution of on-chain logic. Theoretically they could but it's super-cumbersome and it is not generally what is meant by "light-client".
2025-04-14 07:50 gav: Instead, they accept proofs of on-chain state through the (prior) state-root found in the header.
2025-04-14 07:50 gav: They trust this header/state-root because of the GRANDPA finality proof. [edited]
2025-04-14 07:51 gav: > as you go from verifying all to verifying nothing, you go from "trustless" light client to "trust me bro, I'm infura" light client

No.
2025-04-14 07:51 gav: You've totally missed the whole point of JAM/Polkadot's finality. [edited]
2025-04-14 07:53 gav: The point of finality is not merely to avoid reversion. It is also to place economic weight behind _correctness_. With our assumption of no more than 1/3 malicious nodes, GRANDPA will only finalize valid transitions, _including in-core logic_. [edited]
2025-04-14 07:54 gav: This means that trusting in GRANDPA gets a similar degree of security to trusting "JAM" more generally.
2025-04-14 07:56 gav: Now, of course, this is not (quite) as high a confidence level as actually executing everything yourself. But then this isn't practically viable anyway on a system as scalable as JAM/Polkadot firstly as the in-core computation has extrinsic data which is not made indefinitely available (e.g. parachain transactions in Polkadot's case); and secondly you'd need near Toaster-level hardware to re-execute all of the work-packages going through every core. [edited]
2025-04-14 07:57 gav: But this idea of (re-)executing everything in order to gain confidence in correctness is a Bitcoin mind virus.
2025-04-14 07:58 gav: It's not true. The Elves paper is an example of how it's possible to argue for correctness from first principles whilst not presuming (indefinite) ability to re-execute. zk-SNARKS offer another means for doing this.
2025-04-14 08:00 gav: In short, when GRANDPA finalises some state and you have a state-proof for some storage value against it, you can assume one of three things:
1. Elves/JAM/Polkadot has a design flaw nobody knows about.
2. More than 1/3 of validators are misbehaving.
3. It's correct.
2025-04-14 08:01 gav: It's certainly categorically better than your characterisation of "trust me bro, I'm infura". [edited]
2025-04-14 08:11 gav: [JIP-2](https://hackmd.io/@polkadot/jip2) is updated with a new `parameters` RPC.
2025-04-14 08:11 gav: This is intended to allow RPC clients to understand the parameters of the node's chain including number of cores and validators. [edited]
2025-04-14 08:31 xlchen: > <@gav:polkadot.io> I updated my (unofficial) Prize notes: https://hackmd.io/@polkadot/jamprize

can I confirm that generative AI is ok (or not) for:
write documents
write tests
code review
help reading GP
doing research (e.g. how to write a recompiler)
write code that's not covered by GP (e.g. RPC or CLI handling). In theory, those code should not be judged?
2025-04-14 08:32 gav: Most should be fine, yes. The only slight concern would be for GP interpretation.
2025-04-14 08:33 gav: Again, it's generally best to treat genAI as an indirect (and lossy) comms system.
2025-04-14 08:35 gav: And comms concerning GP interpretation is generally best done in easily-discoverable forums visible to all to maximise the chances of clean-room impl and minimise the chances of sub-dialects (inadvertently) forming. [edited]
2025-04-14 08:37 gav: It's written in both English and formal logic in order to minimise the chance of linguistic issues for non-native speakers; I would not expect genAI to help much here and it may easily introduce translation artefacts. In any case, I fear genAI has less of a chance of knowing what I intend the GP to mean than you would. [edited]
2025-04-14 08:57 xlchen: is there any disassembler works with output of `jam-pvm-build`? I tried `polkatool disassemble` and it doesn't work
2025-04-14 08:58 xlchen: ok tried this and looking good so far https://pvm.fluffylabs.dev/?#/
2025-04-14 09:01 jan: Yes, that currently doesn't work. It's just a matter of making a JAM blob -> `.polkavm` blob converter, which is on my TODO list (but PRs are welcome; it should be very simple to do, just do the reverse of what the `jam-pvm-build` does, since it converts a `.polkavm` blob into a JAM blob)
2025-04-14 09:15 sourabhniyogi: After JAM light clients sync to the most recent finalized block through a GRANDPA proof, and receive a set of unfinalized blocks, what verification does the light client do when there is no GRANDPA proof for those unfinalized blocks, if anything at all?  It appears that JAM light clients only will be verifying GRANDPA proofs, and would trust the node that they receive their unfinalized block.  

What was 7.4.4 for?   [edited]
2025-04-14 09:18 gav: > if anything at all?

None.
2025-04-14 09:19 gav: Light-clients are not intended to use unfinalized blocks.
2025-04-14 09:19 gav: User interfaces might interpret them and display them with some sort of "unconfirmed" annotation if there's any serious economic implication of them.
2025-04-14 09:19 sourabhniyogi: Ok thank you for clarifying!  Indeed, I have had a Bitcoin mind virus =)
2025-04-14 09:20 gav: But light-clients generally have no means of knowing.
2025-04-14 09:20 gav: Even re-executing the block doesn't help here - that's the Bitcoin mind virus. You'd have to not only re-execute the block but also re-execute all the cores (at least those that have causal-implications on the service storage you care about, which given the ability for transfers to happen in a block means, theoretically, all of them which can send messages to your service). [edited]
2025-04-14 09:22 gav: To re-execute the cores, you'd need to fetch all of the DA data they require and this is obviously waaaay too much to be doing for a *light*-client. It'd take > 6 seconds and then you may as well wait for GRANDPA. [edited]
2025-04-14 09:23 gav: So yeah, there's really no way around this, and that's by design. We want to off-load correctness entirely into the game-theoretic (staked) machinery. Not have it done by clients on the edges, light or otherwise. [edited]
2025-04-14 09:24 gav: Only this way can we expect to be able to scale to the levels we need (and still not be centralised). [edited]
2025-04-14 09:27 gav: One thing that we can almost certainly do, though not necessarily pre-1.0, is have GRANDPA finalize not only the block but also its posterior state-root. This should be a pretty trivial addition and would mean light-clients are able to get proofs over storage one block earlier than otherwise. Alistair is also considering introducing some other lightweight consensus over blocks produced, but not necessarily correct (i.e. not yet having passed Elves). This wouldn't help all that much for applications which have high economic implications but could help lower apparent UI latency for lesser applications especially if the finalised information included posterior state-root rather than just the header-hash. [edited]
2025-04-14 10:34 sourabhniyogi: Would you expect JAM light nodes going through [the light node path](https://hackmd.io/@polkadot/jamprize#Light-node) to verify this new (not necessarily ELVES-correct) lightweight "GRANDPA 2.0" consensus at the bleeding edge?

The "best vs finalized" bits in jip-2 is causing us to want to fill in the GRANDPA related pieces of JAMNP (which has no vote/commit/... GRANDPA yet so we made some up earlier) and go from little syncs to warp syncs.  Having the GRANDPA 1.0 proof and 2.0 path would be terrific as we are happily auditing WPs now and can connect the dots to "best block" now. [edited]
2025-04-14 10:47 gav: > Would you expect JAM light nodes going through the light node path to verify this new (not necessarily ELVES-correct) lightweight "GRANDPA 2.0" consensus at the bleeding edge?

Possibly, assuming it is in the GP. But given it's presently little more than an idea, it's hard to say for sure if it would be in the GP by 1.0. [edited]
2025-04-14 10:49 gav: > The "best vs finalized" bits of in jip-2 is causing us to want to fill in the GRANDPA related pieces of JAMNP

Sure. Already there's the [GRANDPA paper](https://research.web3.foundation/Polkadot/protocols/finality) if you want to begin implementing the internals. I expect we'll be able to introduce the protocol elements in the near future. [edited]
2025-04-14 10:49 gav: It's not yet amalgamated in to the GP but there's not all that much to do on that front as GRANDPA is quite self-contained.
2025-04-14 15:35 sourabhniyogi: Ok!  So that we may plan our GRANDPA execution, which milestones [there are now 5+5(+1)+3=14] require { GRANDPA finality, GRANDPA proof verification, warp syncing }?

Can you speak to how we may instrument our implementations to measure and report on required performance at the Lisbon meetup for all 3 paths?
2025-04-14 15:36 gav: Yeah I’ll try to state it as well as possible. But for a basic idea it’ll be in line with smoldot. 
2025-04-14 18:29 p1sar: Hello everyone!

This month’s JAM Implementers Call is happening a bit later than usual due to PBA — but we're back! 🎉
As always, this call is a space to foster knowledge sharing and collaboration among JAM developers.

📝 General notes & purpose of the call:
https://hackmd.io/@P1sarb/HJkLHpIwyl

📅 Agenda & invite link for this week’s call:
https://hackmd.io/@P1sarb/rkcn_pc0kl
Feel free to suggest update to the agenda directly on the page (you’ll need to be signed in 😉).

📍 Join us on Tuesday, April 15 at:
{7:30am PT, 8:30am Denver, 10:30am NY, 3:30pm Lisbon, 4:30pm Berlin, 8:00pm India ST, 10:30pm Beijing, 11:30pm Tokyo, 2:30am New Zealand (Apr 16)}

Everyone is welcome—see you there!

PS: All calls are recorded and uploaded to YouTube!
2025-04-15 00:37 clearloop: may I ask when is the Lisbon meetup? where can I find more information about the upcoming events of Jam?
2025-04-15 00:40 sourabhniyogi: https://lu.ma/ob0n7pdy
2025-04-15 14:24 jay_ztc: can someone share the call link for this months session? Thanks!
2025-04-15 14:26 p1sar: The JAM Implementers Call is starting in 5 minutes!
https://meet.google.com/rbb-cxhi-idp — Even if you don’t have anything specific to discuss, come by and say hi! [edited]
2025-04-15 14:36 sourabhniyogi: https://meet.google.com/rbb-cxhi-idp?authuser=0
2025-04-15 16:07 jay_ztc: Was this the room mentioned on the call for coordinating about JAMX? Will any critical messages/updates in the implementors room about jamx be bubbled up to this room (Let's JAM)? I would like to stay in the loop since I will be attending, but not looking to participate in the DAO at this time. [edited]
2025-04-15 17:41 sourabhniyogi: Daniel is hosting the event and will surely be the source of all critical message/updates -- is there a schedule we can look at and try to get ourselves aligned on danicuki | Jamixir since we're starting to get our travel plans together now?
2025-04-15 18:14 wabkebab: So, very quick as I have read “travel plans” , tomorrow, we - Pala Labs - will do a more official announcement but as a appetiser, the JAM action will continue in ETHLisbon with a JAM dedicated booth and a - probably in Sat as it is a moving target - keynote about JAM by Daniel C. [edited]
2025-04-15 18:15 wabkebab: Stay tuned to the usual JAM channels!
2025-04-15 23:17 danicuki: Unfortunately I missed today’s call to give some updates. The event agenda (beta version) was sent by email to all attendees last week. The organization team is very open to suggestions and ideas of anything different from what was sent. DM me anytime. The event is for everyone. I am just a mere enthusiast organizer. [edited]
2025-04-15 23:18 danicuki: > <@sourabhniyogi:matrix.org> Daniel is hosting the event and will surely be the source of all critical message/updates -- is there a schedule we can look at and try to get ourselves aligned on danicuki | Jamixir since we're starting to get our travel plans together now?

Unfortunately I missed today’s call to give some updates. The event agenda (beta version) was sent by email to all attendees last week. The organization team is very open to suggestions and ideas of anything different from what was sent. DM me anytime. The event is for everyone. I am just a mere enthusiast organizer.
2025-04-16 07:43 gav: JAM SDK 0.1.21 is out and with it `jamt` and `jamtop`, usable by any node which has implemented jip2. [edited]
2025-04-16 08:10 xlchen: I have some questions about JIP2:
- Can you confirm if it is JSON RPC over WebSocket? or something else?
- What encoding format is used? e.g. for Hash, is it hex string or JSON array of numbers?
- Only subscribe methods are defined but not unsubscribe?
- JSON RPC subscriptions requires another notification method as parameter, which is not included in the document
  ↳ 2025-04-16 08:28 dave: It's JSON RPC over WS yes. We're using Parity's jsonrpsee crate + serde to implement it. I believe hashes are arrays of 0-255. Unsubscribe methods exist, I believe they're named eg unsubscribeX for subscribeX
  ↳ 2025-04-16 08:31 xlchen: those details are crucial for others to follow. can someone update the docs? best to have some example request/response 
  ↳ 2025-04-16 08:48 clearloop: I was trying to indicate these stuffs via a mock server XD, however, the panic messages of jamtop 

```
RUST_BACKTRACE=1 jamtop --rpc ws://0.0.0.0:6789
Error: Parse error: invalid type: map, expected a tuple of size 2
```
seems not yet well wrapped with helpful context

  ↳ 2025-04-16 09:14 gav: Yeah, that'll be some invalid response data I expect.
  ↳ 2025-04-16 09:14 gav: To debug you'll probably want to dump communications
  ↳ 2025-04-16 09:15 gav: Bryan Chen | Laminar & Acala: Already stated in JIP2:

> - `Hash`: a 32 item array with each item numeric between 0 and 255 inclusive.
  ↳ 2025-04-16 09:15 gav: See the text immediately below the section "RPC Specification":
  ↳ 2025-04-16 09:16 gav: image.png
  ↳ 2025-04-16 09:16 xlchen: ok. that wasn't the most efficient encoding method so I had to confirm
  ↳ 2025-04-16 09:16 gav: It's pretty explicit :P
  ↳ 2025-04-16 09:16 gav: I'm not sure how I could have made it more so...
  ↳ 2025-04-16 09:17 xlchen: any reason it is not hex encoded just like substrate rpc?
  ↳ 2025-04-16 09:17 gav: Yeah - this is the simplest way.
  ↳ 2025-04-16 09:20 gav: jip2 updated with the other clarifications. [edited]
2025-04-16 09:58 clearloop: I can see the dashboard of `jamtop` now, from my case, it has no stdout on launch, but after `ctrl+c`, the dashboard shows

```
Services: 0 total, 0 active, 0 refining, 0 acc'ing                         0                                                                                                                        20:00:00
APU: 0% acc/0% xfer/100% idle;  Cores: 0%/0%/100% idle                     1                                                                                                                               0
Processed: 0 refines/0 gas; 0 accs/0 gas; 0 memos/0 gas                    A                                                                                                                       00000000…
D3L: 0 imports; 0 exports; 0 extrinsics/0B; 0 prov/0B                      X

ID       NAME                 FLGS ITMS REFS %RGC  ACCS %AGC  XFRS %XGC  PRVZ PRVS  IMPS EXPS XTS  XTZ   STRS STRZ  BAL   FBAL  MBAL
```

it's currently empty with my RPC, to make it alive, seems we have to fullfill the service features now
2025-04-16 15:05 jimboj21: Hey hey, I have a question about the accumulation test vector's pvm execution:

Why do the accumulation test vectors not result in a change to the service storage state? I dont believe the storage attribute is included in these tests. Unless I am mistaken, based on the test service code there should be a host write call which if executed correctly should update the jam state for that service. If the service storage state isn't tested here, isn't the pvm invocation in these tests basically just a no-op then as far as passing the tests is concerned? Am I missing something here?
2025-04-16 15:20 dakkk: > <@jimboj21:matrix.org> Hey hey, I have a question about the accumulation test vector's pvm execution:
> 
> Why do the accumulation test vectors not result in a change to the service storage state? I dont believe the storage attribute is included in these tests. Unless I am mistaken, based on the test service code there should be a host write call which if executed correctly should update the jam state for that service. If the service storage state isn't tested here, isn't the pvm invocation in these tests basically just a no-op then as far as passing the tests is concerned? Am I missing something here?

Have you tried to execute the pvm running those tests? 
2025-04-16 15:25 jimboj21: Yeah I have. I am working to fix a bug in my pvm right now, so I am not 100% on my execution. This is partly why I ask, maybe i am missing context from the correct execution, however, I still pass all the test vectors. 
2025-04-16 16:19 sourabhniyogi: For the notion of structured logs (which we can do some set up for), what do you think it should cover out of these:
(a) PVM execution: (i) auth/refine execution (ii) acc/transfer execution (iii) auditing (iv) jip-1 logs
(b) Refining \[superset of (a)(i)\] (i) bundle details (ii) work report/work result/availability spec generation
(c) Accumulation / Transfer (i) wrangled results (ii) ordering (iii) MMR / Beefy accumulation roots (iv) statistics  (v) C1-C15 state changes (vi) service storage/preimage/lookup changes
(d) Block authoring \[superset of (a)(ii), (c)\] (UP0) (i) sealing (ii) ticket generation (CE 131/132)
(e) Block Validation errors
(f) Audit Announcements [CE 144] / Judgement Publication [CE 145]
(g) Preimage Announcements [CE 142] / Requests+Responses [CE 143]
(h) _Selected_ JAM NP sends/receives not well covered by the above:
* CE 133: Work-package submission, 
* CE 134: Work-package sharing,  
* CE 135: Work-report distribution. 
* CE 136: Work-report request, 
* CE 137: Shard distribution
* CE 138: Audit shard request,
* CE 139/140: Segment shard request, 
* CE 141: Assurance distribution
 [edited]
  ↳ 2025-04-16 16:33 jimboj21: For me personally I am currently focusing on M1/block importing so a) and c) and i think e (if i understand what validation errors means) are the most useful to me at this moment.

The others all seem useful as well, but I will let others speak to that. I imagine the log level can be specified to determine which of these we wish to see? 
2025-04-16 16:56 0xjunha: I just tested with my implementation, and I could find the PVM code blobs of the accumulate test vectors include `ECALLI`. This is what we can guess from the test service code, which includes `jam_pvm_common::accumulate::set_storage`.

However, when I actually ran all accumulate test cases, and tracked trace of all executed opcodes, no single `ECALLI` was executed.
So my guess is that either `items` argument for the test service `accumulate` function is an empty vec, or `item.result` is not `Ok` and therefore no host function is executed even `accumulate` is invoked. (https://github.com/davxy/jam-test-vectors/blob/562f11d129d3a6ab35bfb91ad5973358ae0654fa/accumulate/test-service/src/main.rs/#L27C48-L27C74)

And I think this is just for simplicity, mainly focusing on Accumulate Queue/History STFs for now and I expect host function test cases might be added in the future.
My implementation is not complete yet, so there could be bugs in mine as well.\
2025-04-16 17:01 gav: > <@sourabhniyogi:matrix.org> For the notion of structured logs (which we can do some set up for), what do you think it should cover out of these:
> (a) PVM execution: (i) auth/refine execution (ii) acc/transfer execution (iii) auditing (iv) jip-1 logs
> (b) Refining \[superset of (a)(i)\] (i) bundle details (ii) work report/work result/availability spec generation
> (c) Accumulation / Transfer (i) wrangled results (ii) ordering (iii) MMR / Beefy accumulation roots (iv) statistics  (v) C1-C15 state changes (vi) service storage/preimage/lookup changes
> (d) Block authoring \[superset of (a)(ii), (c)\] (UP0) (i) sealing (ii) ticket generation (CE 131/132)
> (e) Block Validation errors
> (f) Audit Announcements [CE 144] / Judgement Publication [CE 145]
> (g) Preimage Announcements [CE 142] / Requests+Responses [CE 143]
> (h) _Selected_ JAM NP sends/receives not well covered by the above:
> * CE 133: Work-package submission, 
> * CE 134: Work-package sharing,  
> * CE 135: Work-report distribution. 
> * CE 136: Work-report request, 
> * CE 137: Shard distribution
> * CE 138: Audit shard request,
> * CE 139/140: Segment shard request, 
> * CE 141: Assurance distribution
> 

It should be primarily for the various off-chain events (ie not accumulate) - the on-chain stuff is easily discoverable already. 
2025-04-16 17:02 gav: Receiving a block, importing, authoring and publishing are all sensible things to be cataloguing too. But this is perhaps something to discuss in-person in Lisbon. 
2025-04-16 17:05 rustybot: > <@jimboj21:matrix.org> Hey hey, I have a question about the accumulation test vector's pvm execution:
> 
> Why do the accumulation test vectors not result in a change to the service storage state? I dont believe the storage attribute is included in these tests. Unless I am mistaken, based on the test service code there should be a host write call which if executed correctly should update the jam state for that service. If the service storage state isn't tested here, isn't the pvm invocation in these tests basically just a no-op then as far as passing the tests is concerned? Am I missing something here?

I need to check. If not I'll add a couple 
2025-04-17 06:42 emielsebastiaan: Can anybody direct me to the specification jip2 please. 🙏🏻 [edited]
  ↳ 2025-04-17 06:43 clearloop: https://hackmd.io/@polkadot/jip2
2025-04-17 09:11 danicuki: A sneak peek of the JAM Experience event T-Shirt
2025-04-17 09:11 danicuki: Screenshot 2025-04-17 at 10.09.52.png
2025-04-17 13:19 wabkebab: **JAM Toaster visit & JAM presence at ETHLisbon !**

Hey JAM fam!

We've got some exciting news - Pala Labs is bringing JAM to **ETHLisbon** (May 9-11)! Since many JAM-ers will already be in Lisbon for the **JAM Experience**, we thought: why not introduce JAM to the Ethereum crowd too?

**Quick highlights**

- A keynote session dedicated to JAM on ( tentatively) May 10
- We'll be having a cool JAM booth with some surprises …
- For builders, there's also a Smart Contract hackathon on Kusama from 9 to 11 of May

**Exclusive invite for JAM Implementers!**

We're planning an exclusive JAM Toaster visit just for JAM implementers on 6th May, 4 to 9 PM - free transportation, toaster visit, and poolside drinks & canapés.

Limited spots available! ([Sign up here](https://lu.ma/jamtoastervisit) )

And of course, cool JAM merch with fantastic designs, like the one just on top of these lines, from the inkwell of xylodrone  - our talented inhouse designer.

Want to help at the booth or just hang out? Reach out to us!

See you in Lisbon! 🚀 [edited]
2025-04-17 21:03 sourabhniyogi: Here is a wishlist for a workshop agenda:
(1) From Tiny Testnets to Everyone in the Toaster: jip2 \[jamtop\] + Telemetry, Structured Logging -- and how to do this in an "anti-fragile" way
(2) Recompiler 101 + Advanced topics (must have Jan Bujak)
(3) Building services with SDK + polkatool, CoreVM + guest programs
(4) Mind Viruses in the World and how to combat them
(5) DOOM Dissection and how to sell JAM [edited]
2025-04-17 21:35 jay_ztc: Will the Node RPC from JIP2 be used in milestone acceptance testing? I wonder if some full node implementations will choose to forego implementing the spec, given that light clients are the stated preference & their development is now incentivized directly from the prize pool. [edited]
2025-04-18 04:12 gav: Agreed we need to do a seminar on structured logging - I thnk this will be a crucial next step for making serious use of the Toaster erin arkadiy David Emett ... [edited]
2025-04-18 04:13 gav: We're pretty much ready to go with the tiny testnet for any teams who want to try connecting; getting 1023 node active might be a challenge... [edited]
2025-04-18 04:15 gav: I'll be happy to talk about SDK (minimal as it is right now) and hopefully a walkthrough of CoreVM. We're working hard on getting CoreVM releasable (along with PVM Doom) by May.
2025-04-18 04:16 gav: If you're at M2 with a high-efficiency interpreter PVM you might be able to run DOOM on your own JAM. (We can with PolkaVM interpreter.) [edited]
2025-04-18 04:17 gav: I'll give a presentation on the Polkadot Palace if people are interested, too.
2025-04-18 04:19 gav: Parity PolkaJAM team (including myself) are having a longer retreat based out of the Lisbon Parity office for the following week and a half after the JAMXP; any teams who want to stick around and try to continue to get interop are ofc welcome to work from the Parity office too.
2025-04-18 05:19 jtxmp: 
2025-04-18 05:25 boymaas: That’s amazing news. Just to confirm, is it permissible under the rules for teams to begin coordinating the networking aspects with one another in advance, provided all communication takes place through public channels?
  ↳ 2025-04-18 05:55 sourabhniyogi: Opening a thread right here so we can prep before during and after 😀
  ↳ 2025-04-18 06:48 gav: Yes, provided comms are open and easily discoverable by other teams/newcomers, and of course that it doesn't impact the nature of the clean-room rules, then it's fine. [edited]
  ↳ 2025-04-18 06:49 gav: Generally speaking, if discourse happens openly and in easily discoverable channels and it's solely about getting the interop working then there shouldn't be a problem. [edited]
  ↳ 2025-04-18 06:52 gav: Also, I'm cogniscant that forcing everything to happen in these two channels isn't ideal. So I've a bit of a plan here:

1. Get some sort of automation to periodically archive these two channels.
2. Host the archive in one or more obvious places (graypaper.com, jamcha.in, others?)
3. Request that others who want to have discourse away from these channels offer up the same thing and provide linking/hosting on these central spots for it.
4. Have some AI guy train an "official" AI model periodcally on the content of these channels as well as any lectures of mine, the Gray Paper &c.
5. Provide the model as a download for anyone to use with e.g. Jan. [edited]
  ↳ 2025-04-18 06:54 gav: As long as *all* non-official channels data gets into this central easily-searchable/discoverable knowledge base in a timely fashion, then I don't see a huge problem with expanding out from the two official channels.
  ↳ 2025-04-18 06:54 gav: Of course I won't necessarily be monitoring other channels.
  ↳ 2025-04-18 08:34 boymaas: Thanks gav , that’s clear. We’ll make sure all coordination stays open and easy to find, and respects the clean-room principles.
  ↳ 2025-04-18 12:18 sourabhniyogi: image.png
  ↳ 2025-04-18 12:18 sourabhniyogi: https://discord.gg/aEhVqngM
  ↳ 2025-04-18 12:20 sourabhniyogi: How would you improve on this:
"100% public channel for JAM Implementers to set up JAM testnets with each other in prep for participation in a JAM Toaster testnet.   

IMPORTANT:
This channel will be periodically archived and may be freely used to train an AI model and form a searchable/discoverable JAM knowledge base.    If you are not comfortable with this, do not participate in this channel.

See also: https://hackmd.io/@polkadot/jamprize
"
3/4/5 is super reasonable and easy to execute on 


  ↳ 2025-04-18 13:12 sourabhniyogi: https://github.com/davxy/jam-test-vectors/issues/40
  ↳ 2025-04-21 09:01 gav: Yes, just needs proper linkage from community centrepoints like graypaper.com and jamcha.in
2025-04-18 07:15 gav: As a start to this I initiated https://hackmd.io/@polkadot/jip3 as a collaborative doc, which teams are welcome to add their own messages to. [edited]
2025-04-18 12:22 subotic: Hey gav, as I'm looking into how to best approach implementing the recompiler and PVM native execution, I'm trying out different things. Regarding the prize, some time ago you mentioned, that as long as more than 50% of the codebase is in one language (in our case Scala), it would be ok to write small parts of it in another language. In our case, the PVM interpreter is implemented in Scala, but I'm looking at using Rust to implement the native execution parts for the PVM. Would that be fine, or would the Rust code fall under a different language category, irrespective of the size?
2025-04-18 12:33 jay_ztc: according to https://hackmd.io/@polkadot/jamprize#Language-Sets, pvm is one of the components that doesn't impact an implementations language set categorization [edited]
2025-04-18 12:36 subotic: Thank you very much! Great to hear.
2025-04-19 12:45 ascriv: Is it possible to get more clarity on what the M1 validation process will look like? Will it be a set of test vectors a la jam-test-vectors? Will they have the same format?
2025-04-19 17:22 gav: > <@ascriv:matrix.org> Is it possible to get more clarity on what the M1 validation process will look like? Will it be a set of test vectors a la jam-test-vectors? Will they have the same format?

Best check with [davxy](https://matrix.to/#/@davxy:matrix.org). 
2025-04-19 18:47 davxy: The conformance testing tool will engage directly with your implementation (the target) in a more interactive fashion.

Naturally, passing all test vectors is a prerequisite, as the tool may expose your implementation to more complex or unforeseen scenarios. 

The overall process is relatively straightforward. Once the tool communicates the genesis state to the target, it will begin submitting procedurally generated blocks, which your implementation should attempt to import. It will then validate the resulting state root against the expected one. 

On failure, a test vector is produced (prior raw state kv + block + posterior diff with expected state).

The content of these blocks is pseudo-random and determined by a specific seed. To reproduce a particular run, the corresponding seed must be known.

The format of the state will align with the trace format adopted by the community, i.e. the whole state raw key-value (refer to the jam duna traces, also see https://github.com/davxy/jam-test-vectors/issues/40). 

The communication between the conformance testing tool and the target implementation will occur over a simple pipe.

Additionally, the tool is capable of instructing the target to adopt a specific state, after which it can function as a pure fuzzer submitting millions of mutated versions of the same block (currently via libfuzzer, but we may experiment AFL as well)

Nothing is written in stone btw. The tool is currently a work in progress, and new ideas may emerge to refine it.  Further details can be discussed in Lisbon.

Some initial ideas were also drafted here:
https://github.com/w3f/jamtestvectors/issues/21 [edited]
2025-04-20 00:42 jaymansfield: Screenshot 2025-04-19 at 8.41.23 PM.png
2025-04-20 00:42 jaymansfield: Are there any teams that have implemented JIP-2 and have jamtop working with their implementations? I finished off all functionality for JIP-2 and running into some difficulties with jamtop. For me it starts up and requests parameters, best block and service info (data and preimages), subscribes to statistics, and then basically stops updating the interface and sending requests. No errors or anything are shown. [edited]
2025-04-20 04:06 gav: > <@jaymansfield:matrix.org> Are there any teams that have implemented JIP-2 and have jamtop working with their implementations? I finished off all functionality for JIP-2 and running into some difficulties with jamtop. For me it starts up and requests parameters, best block and service info (data and preimages), subscribes to statistics, and then basically stops updating the interface. No errors or anything are shown.

The interface updates are driven by updates from the statistics subscription, which should come once per block. Are you sure your node is sending these?
  ↳ 2025-04-21 15:46 jaymansfield: Yes it is sending statistics for each block. I noticed one thing not defined in JIP-2 and I'm wondering if it’s related to that.

Initial subscription:
{“jsonrpc":"2.0","id":1,"method":"subscribeStatistics","params":\[false\]}

Response:
{“jsonrpc":"2.0","id":1,"result":"7c0f6de3-75f6-4056-b24f-da377bb00a09"}

Notification:
{“jsonrpc":"2.0","method":"subscribeStatistics","params":{"subscription":\["7c0f6de3-75f6-4056-b24f-da377bb00a09"\],"result”:\[\[0,0,0,……\]\]}}

For the actual notifications/subscription events, what should the “method” be populated as? Right now for these I’m using the original method they subscribed too , for example: “subscribeStatistics” as there doesn’t seem to be a standard set in the JSON-RPC spec for this and seems it's up to the implementation. I also tried just "statistics". Some other RPC implementations use method: “subscription”, “notification”, “event”, etc but not sure what jamtop is expecting here. [edited]
2025-04-20 18:45 sourabhniyogi: I suggest we reuse JAMSNP's exact encoding method to the fullest extent possible, and do every single CE -- modeled here

https://hackmd.io/@sourabhniyogi/jip3-recommendation

Any changes going from JAMSNP to JAMNP, including codec encoding of the JAM representations, would be expected to follow in JIP3, making telemetry be a "whatever you do in QUIC, you send to the telemetry server".

This enables each team with a working \[tiny\] testnet to simply share their entire logs with another team prior to working with them by simply providing their telemetry server endpoint (and their genesis state, which includes the validator set). This can be used as a prerequisite to enter into a larger network, including the "full" JAM Toaster.

What do you think of this?

And... Happy Birthday JAM Gray Paper! =) [edited]
2025-04-21 09:03 gav: Loggin the receipt (and even transmission) of network messages can be helpful, but it's only scratching the surface. [edited]
2025-04-21 09:04 gav: Really what we care about is uncovering and describing internal state of the off-chain mechanisms and visualizing them in aggregate [edited]
2025-04-21 12:13 danicuki: > <@sourabhniyogi:matrix.org> I suggest we reuse JAMSNP's exact encoding method to the fullest extent possible, and do every single CE -- modeled here
> 
> https://hackmd.io/@sourabhniyogi/jip3-recommendation
> 
> Any changes going from JAMSNP to JAMNP, including codec encoding of the JAM representations, would be expected to follow in JIP3, making telemetry be a "whatever you do in QUIC, you send to the telemetry server".
> 
> This enables each team with a working \[tiny\] testnet to simply share their entire logs with another team prior to working with them by simply providing their telemetry server endpoint (and their genesis state, which includes the validator set). This can be used as a prerequisite to enter into a larger network, including the "full" JAM Toaster.
> 
> What do you think of this?
> 
> And... Happy Birthday JAM Gray Paper! =)

Happy Birthday JAM. It is amazing to see how much we’ve built in just one year. And we are just getting started! Let’s JAM 
2025-04-21 14:27 sourabhniyogi: To support M3 PVM interpretation => recompilation, we should desire the timing (# of microseconds) spent executing all the timings of the key PVM operations + then do similar erasure encoding + justification generation

- 0 \[block announcement for authoring\]
- 131/132 \[ticket generation\]
- 133/134/145 \[work package refinement/auditing\].
- 137/138/139/140 \[DA encoding\]
- 224/225 \[BLS Signature Generation\]

The telemetry server can usefully pipe this into Jaeger tracing (or similar) for visualization, but from attempting multihop XCM visualization, it probably helps to also have work package hash (133/134/145/137/138/139/140) and header hash (0/192/193/224/225) so the telemetry server doesn't have to do any JAM-specific indexing -- then you can see a "trace" for any workpackage (refining and auditing) or a header hash (authoring, validating, finalizing).

Having data streams to attack bottlenecks that motivate [RFC-139 - Faster Erasure Coding](https://github.com/ordian/RFCs/blob/main/text/0139-faster-erasure-coding.md) and  [super-I/O centric NOMT](https://github.com/thrumdev/nomt) would be cool.

With benchmark workpackages + services, a implementer leaderboard should be developed, focussing on KPIs central to meeting M3/M4 "Kusama-performance" and "Polkadot-performance" -- where we need guidance on what this means exactly so it falls out of the telemetry server dataset.  What else is required? [edited]
  ↳ 2025-04-21 15:00 jaymansfield: What is 224/225 referring to here?
  ↳ 2025-04-21 16:16 sourabhniyogi: Some placeholders for [Section 18](https://graypaper.fluffylabs.dev/#/5f542d7/1e78011e7801?v=0.6.2) that haven't been fully worked out yet.  Just a total guess on my part but its been modeled in the GP some already.
  ↳ 2025-04-21 16:17 jaymansfield: Thanks!
  ↳ 2025-04-21 16:18 jaymansfield: Btw, gamifying the optimization process for M3 with a leaderboard is a great idea.
  ↳ 2025-04-21 23:19 sourabhniyogi: Ok, thanks for the encouragement -- I'll make a Dune dashboard out of it before Lisbon. 
2025-04-22 14:10 jay_ztc: Many thanks for organizing this event 🙏. When can we expect approvals to start being processed for this registration?
2025-04-22 19:58 wabkebab: I don't have the exact date but it will be very soon. You can approach Mila | Pala Labs as she can provide you more details about it
2025-04-23 04:47 ewaddicor: I'm thinking about submitting a JAM interest form... does anyone know which programming languages have not yet been used?
  ↳ 2025-04-23 04:51 xlchen: this is a non-complete list of what languages are used https://graypaper.com/clients/
  ↳ 2025-04-23 04:54 ewaddicor: thank you
2025-04-23 04:54 ewaddicor: 
2025-04-24 08:53 xlchen: Does PolkaVM already have some benchmarking script that we can reuse to check the performance of our PVM implementation? I don't expect our current interpreter to be fast but I want to know how slow it is
2025-04-24 09:00 jan: Yes, I have some benchmarks, but they might be tricky to run for you. (Making a universal harness for PVMs to be able to run them is on my TODO list.)

The benches are here: https://github.com/paritytech/polkavm/tree/master/guest-programs

The number are here: https://github.com/paritytech/polkavm/blob/master/BENCHMARKS.md

Here's the binary I use to run them: https://github.com/paritytech/polkavm/tree/master/tools/benchtool

I run these benchmarks across a lot of different VMs, so the tool has multiple backends: https://github.com/paritytech/polkavm/tree/master/tools/benchtool/src/backend
So in theory you could add your VM there.
2025-04-24 09:09 jan: You could parse the `.polkavm` blobs with https://docs.rs/polkavm/latest/polkavm/struct.ProgramParts.html and https://docs.rs/polkavm/latest/polkavm/struct.ProgramBlob.html and load them into your VM.  Here's some code for reference how a JAM blob is made from a `.polkavm` blob: https://docs.rs/jam-pvm-builder/0.1.21/src/jam_pvm_builder/lib.rs.html#282
2025-04-24 10:37 oliver.tale-yazdi: The code to parse those blobs is not relevant for the GP, right? So we can take a look at it? [edited]
2025-04-24 10:46 jan: Correct.
2025-04-24 10:50 jan: Here's a pastebin of the relevant code to parse them: https://pastebin.com/L2CsuVNR
2025-04-24 10:59 jan: Essentially the format looks like this:

```
struct Blob {
    magic: [u8; 4],
    version: u8,
    length: u64,
    sections: [Section]
}

struct Section {
    kind: u8,
    length: varint,
    body: [u8; Self::length]
}

struct MemoryConfigBody { // kind == 1
    ro_data_size: varint,
    rw_data_size: varint,
    stack_size: varint,
}

// RO_DATA and RW_DATA sections just have the raw byte payloads

struct ImportsBody { // kind == 4
    import_count: varint,
    import_offsets: [u32; Self::import_count],
    import_symbols: [u8; ...until end of the section...]
}

struct ExportsBody { // kind == 5
    exports: [Export; ...until end of the section...]
}

struct Export {
    program_counter: varint,
    name_length: varint,
    name: [u8; Self::name_length]
}
```
2025-04-24 11:01 jan: It's somewhat similar to how `.wasm` blobs look internally. Basically it's a preset header + list of sections where each section has an ID and a length, the sections must always be given in order (so you don't have to write a loop to parse this format because e.g. you always know that memory config section must *always* come before the ro data section, etc.), there is a list of imports and exports (so unlike the JAM blob the imports and exports are *not* hardcoded), and it also supports debug info (which the JAM blobs don't).
2025-04-24 18:24 erin: hello all, I've created hosted archives of the JAM and graypaper chats with plaintext versions also available at https://paritytech.github.io/matrix-archiver/

there are a few quality of life improvements still to be done but any feedback or comments are welcome if you find this useful. This is also now linked on the jamcha.in site.
2025-04-24 18:25 erin: These are updated daily at ~3am UTC.
2025-04-24 18:29 erin: Other JAM-related channels are welcome to be archived - they need to be unencrypted and world-readable (history available to "Anyone"). Please open an issue [here](https://github.com/paritytech/matrix-archiver) with the internal room ID if you wish to archive a channel. [edited]
2025-04-26 14:17 clearloop: just found that the archiver is even easier than matrix to search chat history lmao, hope we can integrate more sources into the static site asap

it even supports links to messages, threads with paddings, great work, direct and efficient [edited]
  ↳ 2025-04-26 14:23 erin: thank you!
2025-04-27 21:59 decentration: Just working on the pvm implementation i just want to confirm with what is the minimum requirement for M1... in the article (https://hackmd.io/@polkadot/jamprize) it references PVM for M3 but not M1. 

1. Is it enough to expose the JAM host-function interface while stubbing the RISC-V runtime?
2. Or do we already need full RISC-V sandbox execution (load blob -> run -> trap -> return ephemerals) in M1?
3. If execution is required, may we rely on an existing impl such as PolkaVM as a temporary backend and postpone a custom PVM to M3?
4. Alternatively, is all PVM work evaluated only from M3 onward?
5. And, is there a difference between M1 and MN1? [edited]
  ↳ 2025-04-28 06:58 subotic: You need a working PVM for M1 (accumulate needs the PVM). For M1 and M2 it can be an interpreter, while from M3 on it needs to be more performant and thus recompiler based. There are different paths described in the linked HackMD, and from what I understand, an original PVM is needed for the first milestone for all paths, as you cannot import a block without.
2025-04-28 13:36 wabkebab: **JAM _action_ next week**

The following week comes with a packed JAM schedule. JAM Experience, Toaster visit and ETHLisbon JAM weekend (booth and keynote during ETHLisbon) will keep you engaged for the whole week.

For those who have not confirmed their presence on the Toaster visit, please sign up on the following link: https://lu.ma/jamtoastervisit

Limited spots! [edited]
2025-04-28 14:01 jay_ztc: Hi Mila | Pala Labs , hope you're doing well. Are you able to share if registration approvals for the toaster tour have started to be processed yet? My teammate & I still see our registration as pending.
  ↳ 2025-04-28 14:49 milawords: Hi Jay | ZTC thanks for reaching out. We will review all outstanding registrations today and tomorrow. [edited]
2025-04-28 15:07 milawords: Your support needed: JAM’s first official sponsorship; JAM Booth at ETHLisbon

Dear Implementers,

We are excited to organise JAM’s first official sponsorship of an Ethereum conference - the JAM booth at ETHLisbon.

We would love your support in representing JAM at the booth as you are the faces behind JAM. You won’t need to be there the entire time but rather flexible time slots based on your availability.

As a thank you, we are organising a dinner for everyone who helps with the booth. It will be a great opportunity to meet the Pala Labs team and discuss how we can better support JAM implementers moving forward.

Please feel free to reach out to me directly and looking forward to hearing from you!

Mila

2025-04-28 15:39 oliverb: Mila | Pala Labs: Hi - hope you're well. Have you invited Parity people to this separately? I know you probably want lots of non-Parity people as well but happy to help spread the message internally...
2025-04-28 23:47 sourabhniyogi: Here is a JAM Implementer Dune Dashboard Proof-of-Concept 
 https://dune.com/substrate/jamtestnet
Earlier thought we should log all of JAMSNP activity but after thinking about what was really important to a implementer leaderboard and M3 performance, ended up at the above instead -- hope we can discuss how to make this really work next week!
  ↳ 2025-05-01 20:29 jaymansfield: This is cool. Will be very useful once we can test on standardized hardware (toaster for example). 
  ↳ 2025-05-01 20:29 jaymansfield: For the analytics to be a valid comparison, we'd need some standard test cases defined for each. For example block authoring we need to all be including the same items in the block (same number of tickets, assurances, etc) otherwise the completion times would not be comparable
2025-04-29 13:18 dave: FYI A small behavioural change has been made to SNP. Previously the SNP spec stated that validators should _not_ announce preimages to each other. This has been changed to state the opposite: validators _should_ announce preimages to each other. See https://github.com/zdave-parity/jam-np/commit/ebc6139eb89dfaa49f5fa12a5a0abdc1af0bd578. The wire protocol is unchanged.
2025-05-01 11:55 danicuki: I will present JAM at ETHLisbon next week. Open for ideas of things to share with the ETH community. It will be a 30min talk. Since we still don’t have a full stack running node in Jamixir, I won’t be able to make a quick demo. But I can easily add video snippets / screen recordings to my presentation if anyone sends it to me. 
2025-05-01 11:58 gav: I expect we can provide a Linux binary for a PolkaJAM testnet if desired. 
2025-05-01 16:59 sourabhniyogi: We desire a "how to run DOOM with the PolkaJAM testnet" workshop (which we should all like to replace the PolkaJAM part with our own ASAP of course!), which can dual as a "how to sell JAM in a world of mind viruses".    It is a very good conversation starter as to what really really is going on since most people are naturally like "oh yeah? but what about ethproofs/zkVM/SP1/...?"   Must this be public?
2025-05-01 17:16 danicuki: We still have a Workshop slot available on May 7th. If gav or anyone else in the PolkaJAM team could give this DOOM on JAM workshop , I can use it on my presentation at ETHLisbon (and other scheduled talks to come). 
2025-05-01 17:25 sourabhniyogi: That would be terrific.  We have enough stuff to transform https://docs.jamcha.in into a more direct competitor of https://docs.succinct.xyz/docs/sp1/getting-started/quickstart (this is the "competitor" I know and understand, probably you all have others) and similar -- Not sure if this transformation should be done by JAM implementers in community-driven way (any binary should be able to replace or compose with the other) OR from W3F+Parity central. 

A little push and coordination to turn that "OR" into an "AND" would go a long way?

Our 2-core testnet can do 12-16 hours processing thousands of fib/fib2/gameoflife/megatron WPs (486 work packages per hour) and then something bad happens =(  but its not very sexy to lookat relative to DOOM =) [edited]
2025-05-01 20:30 jaymansfield: 
2025-05-02 10:17 gav: jambrains guys: https://github.com/JamBrains/jam-docs/pull/39
2025-05-02 10:19 gav: Note that we use PVM, short for Polkadot Virtual Machine, to mean the ISA specification which JAM implementors implement. PolkaVM, on the other hand, is the first implementation of it (and indeed what it was pretty much entirely derived from), currently developed under the Parity umbrella (but historically a side project of Jan). [edited]
2025-05-02 10:41 gav: They're confusingly similar (ugh), but I'm not sure that JAM Virtual Machine/JVM would be much less confusing ;)
2025-05-02 10:42 clearloop: JAM VM (JVM) is too similar to JavaVM (JVM)
2025-05-02 10:42 xlchen: our PVM module is currently named PolkaVM. I guess we need to rename it to avoid confusion 
2025-05-02 11:10 danicuki: JⱯM - pushing to the limit... 😖
2025-05-02 11:38 oliver.tale-yazdi: Thanks for the clear up. I was actually unter the impression that they meant the same 😅  
Cisco put one review comment and then I can subsequently rename the page to PVM
2025-05-02 15:34 jaymansfield: Think we all may have did that 😀
2025-05-03 20:23 sourabhniyogi: erin: arkadiy David Emett  Would one of you (who is around at the Lisbon meeting) like to lead a "workshop" discussion on structured logging + jamsnp + docs.jamcha.in along these lines  https://x.com/byteboro/status/1902037543274553631 -- I can scribe / orchestrate with you as much or as little as you'd like ?
2025-05-03 21:41 dave: Sure, I'd be happy to do that
2025-05-04 06:53 clearloop: Hope there will be record for the events and the workshops! I'm not able to join the events since my visa has not been approved yet 🥲
2025-05-04 13:28 boymaas: Hey danicuki | Jamixir , we are already in your hometown since two days :-) Nice place. I have a question: is there still a small slot available for a short presentation of 5 to 10 minutes on JamZig?
2025-05-04 16:50 danicuki: > <@boymaas:matrix.org> Hey danicuki | Jamixir , we are already in your hometown since two days :-) Nice place. I have a question: is there still a small slot available for a short presentation of 5 to 10 minutes on JamZig?

Sure! 
2025-05-04 16:50 danicuki: ima_bf46e03.jpeg
2025-05-04 16:51 danicuki: JAM Experience - all set! 
2025-05-05 15:36 sourabhniyogi: JAM Doom replication:
 https://www.youtube.com/watch?v=ltWMjg2EHS8
  ↳ 2025-05-05 15:48 clearloop: just watched 5 times to confirm that wu ignored the second enemy 
2025-05-05 15:55 ascriv: Unwatchable 
2025-05-05 16:10 alice_und_bob: hey, coming back to this question --> https://matrix.to/#/!wBOJlzaOULZOALhaRh:polkadot.io/$tMICwJ4QJLhbaG4P0gH7DyDM8j67XmiHbs\_dheO\_hGM?via=polkadot.io&via=matrix.org&via=parity.io

I try to understand who eventually determines to order of WP accumulation.

Let's say a WP doesn't define a pre-requisite other WP, is the order then determined in the accumulate stage from the leader? [edited]
2025-05-05 17:16 krystian50: 
Hi everyone!
At Fluffy Labs, we’ve recently kicked off a new project aimed at searching though JAM resources.

It already includes a few features:
    •    Integration with the JAM Channels Archive (thanks to erin !)
    •    Integration with the Graypaper
    •    A few search options to explore the data

We’re still in the early development phase and actively experimenting, so the UI is evolving quickly - features may appear and disappear. If you have any feedback, we’d love to hear it!

tomusdrw , mateuszsikora and hey_im_stas will be at JAM Experience, so feel free to give them the feedback directly 🙂

🔎  https://search.fluffylabs.dev
2025-05-06 08:22 kianenigma: order within the WPs of the same service, or of different services?

Within the same service, it is up to the accumulate code. Each service is accumulated just once during each block. It receives all possibly parallel refines as input, and has to decide what to do with them, and in which order. [edited]
2025-05-06 08:24 alice_und_bob: what I understand is that there can be an unordered set of WPs reaching the (same) service. So the accumulate logic is confronted with an unordered set. But somehow an order needs to be chosen. What I try to get down to is if the order can be set arbitrarily by the leader or how the order is eventually chosen
2025-05-06 08:25 gav: The block builder has no relevance. 
2025-05-06 08:26 alice_und_bob: I have an unordered set of WPs. How is the eventual order of accumulation decided? If it is decided by the service, how does it decide the order of the unordered set? And on which machine (set of machines) does this happen?
2025-05-06 08:27 gav: It isn’t
2025-05-06 08:27 gav: Accumulation happens on all full nodes. 
2025-05-06 08:28 gav: And as Kian says, service code executes once per accumulation round, being given access to all work results. 
2025-05-06 08:28 gav: It is up to that code to do something with them. 
2025-05-06 08:28 alice_und_bob: so when the service iterates through the set, it has to pick its own ordering logic? e.g. asc by wp hash?
2025-05-06 08:29 gav: In principle it could be a commutative operation. 
2025-05-06 08:29 gav: Eg addition. Order in that case wouldn’t matter.  [edited]
2025-05-06 08:29 gav: If some sequential processing were needed, then it could randomise the processing order  [edited]
2025-05-06 08:30 gav: > <@alice_und_bob:matrix.org> so when the service iterates through the set, it has to pick its own ordering logic? e.g. asc by wp hash?

Yes
2025-05-06 08:31 alice_und_bob: okay, I guess my confusion was coming from the assumption of having a transaction-based system; while a service can in principle be transactionless.

but any transaction-based service will pick an ordering-mechanism.

Does the service have access to randomness provided by JAM? [edited]
2025-05-06 08:39 gav: It does as of 0.6.6. 
2025-05-06 15:18 rick: Hi All -- I'll be on a panel at Decentralized Lugano on Thursday.

Will also be around on the 9th and 10th for ethDAM. 

 If anyone is attending either event please reach out, would love to meet in person. 
2025-05-06 17:14 erin: Reminder for anyone in Lisbon, event link for tomorrow: https://lu.ma/6monb9f9
2025-05-07 13:57 kianenigma: Jan Bujak I missed your recompiler talk this morning, would it be possible for you to share the slides here or in a JAM chat to be able to save it for later? thanks!
2025-05-07 16:27 jan: talk_recomp.pdf
2025-05-07 16:27 jan: Yes, that was the plan. Here are the slides.
2025-05-07 16:41 dave: The HackMD for JAM "TART" brainstorming is here: https://hackmd.io/@zdave/rJts9T_lxl. This is all about gathering and visualisation of statistics/events/etc from testnets running on the JAM toaster. Please comment there if there's some data you'd like to see exposed, if you have ideas on how to visualise things, etc.
2025-05-07 22:08 danicuki: > <@kianenigma:parity.io> Jan Bujak I missed your recompiler talk this morning, would it be possible for you to share the slides here or in a JAM chat to be able to save it for later? thanks!

We have the recording that will be available soon on the JAM Community YouTube channel. 
2025-05-07 22:10 danicuki: Thank you everyone for coming to JAM Experience. I hope you all had a great time in Lisbon. Enjoy the rest of your stay and have a safe trip back home. See you soon! 
2025-05-07 22:13 danicuki: Those others who have slides, please share them here and I will organize to make them publicly available somewhere 
2025-05-07 22:16 sourabhniyogi: Thank you for organizing JAMXP and everyone who made the visit to the Polkadot Palace so special -- nothing beats meeting people in real life and getting each other psyched about Polkadot/JAM's future together!

https://docs.google.com/presentation/d/13YUumFSMPXT8085GwwVe0YCoOVjjCaBm/edit?slide=id.g353759b2ff6_0_18#slide=id.g353759b2ff6_0_18
2025-05-07 22:17 jay_ztc: Thank you for arranging the event!  danicuki | Jamixir:  It was great to meet the community of builders. jamstatus.xyz
2025-05-07 23:10 sourabhniyogi: gav: If you can kindly post the PolkaJAM binary \[Mac binary ok,  Linux whenever ready?\] along with any needed instructions about how to launch it with our own implementations in a tiny testnet targeting 0.6.6 and beyond (something like `jam -spec tiny -v 5 --quic-port 9900 --rpc-port 10800 -start-time +2025-05-08 00:05:56`), this will kick off a lot of us basically doing the same (and probably adapting "flags" pseudo standards to match to keep us sane)!  

With not too much luck, I believe we can have a tiny multiclient testnet this month.  

We definitely want to kick ourselves into high gear by matching PolkaJAM linear recompilation with doom demo before the start of Summer =). [edited]
2025-05-07 23:26 jaymansfield: Does this break any clean-room implementer rules? Since I wasn’t able to make jam experience I’m not really sure what was discussed there regarding this. If it is confirmed to be allowed within the rules, I’d be willing to share a binary of mine that has all of M2 implemented (except grandpa) but obviously will wait for official confirmation [edited]
2025-05-08 07:04 subotic: Hey Jan Bujak, thank you very much for slides. Would have been great to talk to you again in person. I hope some other time. The slides are very much appreciated and really helpful. Many questions that I had are now resolved and even questions that I didn't know that I had :). Thank you very much! ❤️👍️
2025-05-08 08:23 danicuki: gav: could you share your presentation slides? I would like to use some of the content for my talk at ETH Lisbon tomorrow. Tks!
2025-05-08 09:37 gav: Right now the binary is targeted towards 0.6.5, but I'll put the mac single-node and tiny-testnet binaries on the GP release page. [edited]
2025-05-08 09:37 gav: Maybe one of the linux people can upload their pair of binaries there too
2025-05-08 09:38 gav: If anyone else wants to share, please send a link and I'll upload to the GP page. I'd say 0.6.5 minimum for now to reduce leg work.
2025-05-08 09:49 clearloop: we'd like to share spacejam binaries but it is currently at 0.6.4, also the network part was a fast implementation so worried about if it contains too many bugs > <

willing join it after connecting to PolkaVM successfully!
2025-05-08 10:32 clearloop: may I ask if it is possible to checkout a tag or branch for 0.6.5 in the test vectors repo ? davxy 
2025-05-08 14:22 danicuki: Anyone who has photos or videos from the event, please share them here: https://drive.google.com/drive/folders/1SLDSDjSDkVs-qoiDyRO0R0UHY9aw4ur5?usp=sharing
2025-05-08 21:14 xlchen: any plans for M2 testvectors?
  ↳ 2025-05-09 04:02 clearloop: ref https://github.com/w3f/jamtestvectors/issues/41
2025-05-09 12:09 arkadiy: We've created a repo for the JIPs:
https://github.com/polkadot-fellows/JIPs
2025-05-09 12:09 arkadiy: gav: Could you publish the RPC spec there?
2025-05-09 12:10 arkadiy: There's also a common chain spec file format proposal:
https://github.com/polkadot-fellows/JIPs/pull/1
2025-05-09 12:27 jan: Here are polkajam binaries (+ some of the tooling) for you to play around:

macOS (aarch64):
https://drive.google.com/file/d/1VzCbIUA7RYmsVD8VZwoSnfjgRXlE9b8D/view?usp=sharing

macOS (x86\_64):
https://drive.google.com/file/d/1OnbpSWeMVA1LrUk6y3Td-Vp4AIjQP9Q7/view?usp=sharing

Linux (x86_64):
https://drive.google.com/file/d/1q\_v-YoVUd21ZHKWQcFGlLgR04H5n2uB-/view?usp=sharing

Linux (aarch64):
https://drive.google.com/file/d/1Oj1AICgG6ZDpv7stC6xXkwfyMfXqY4Ko/view?usp=sharing

Windows:
https://drive.google.com/file/d/1Op1ZNUVsy-ek5PUwHUwQANE2MUHXyQr3/view?usp=sharing

Please do let us know if they are any problems with them. (Also, Windows binaries are untested and unsupported; I cross-compiled them because I could in case someone finds them useful, but we only intend to "support" Linux and macOS binaries as no one at Parity uses Windows) [edited]
  ↳ 2025-05-09 12:35 oliver.tale-yazdi: `VmEngine(EngineInitializationFailed(Error(Owned("failed to initialize Linux sandbox: not all required userfaultfd features are available; you need to update your Linux kernel to version 6.8 or newer"))))`  
I guess this is expected? Or can i disable the sandbox?
  ↳ 2025-05-09 12:46 rotarur: Did you try update your kernel? 
  ↳ 2025-05-09 12:47 jan: This is expected. What's your Linux kernel version?
  ↳ 2025-05-09 12:48 jan: you can check it with `uname -a`
  ↳ 2025-05-09 12:49 oliver.tale-yazdi: `5.10.0-32` 😅 okay I will nuke the server.  
But it is not possible to run it without sandbox?
  ↳ 2025-05-09 12:50 jan: You can run it with the interpreter, in which case it doesn't need a newer kernel.
  ↳ 2025-05-09 12:52 jan: IIRC, there should be a command line argument to do it
  ↳ 2025-05-09 14:02 davxy: Aside from referencing the GP, perhaps we should explicitly list the tools and node versions in the package?
I assume we'll be publishing updated versions quite often.
For example, we recently integrated gas charging for host calls, and I’m assuming the shared binary doesn’t yet include that.
  ↳ 2025-05-09 17:38 jan: I've updated the binaries. Changelog:

- macOS binaries were added
- chain ID was removed from app protocol, as this is not (yet?) part of the spec
- gas is now charged for the host calls
  ↳ 2025-05-09 21:07 sourabhniyogi: This is awesome --  Ok attempting first contact with PolkaJam "--dev-validator 0..4" , with us as "--dev-validator 5" being 1/6! [edited]
  ↳ 2025-05-09 21:12 sourabhniyogi: https://github.com/polkadot-fellows/JIPs/pull/1
  ↳ 2025-05-09 21:13 sourabhniyogi: What are the dev seeds for `--dev-validator 0` through `--dev-validator 5`

```
./polkajam -d /tmp/d0 -c /tmp/c0 --chain dev --parameters tiny run  --dev-validator 0 --rpc-port=19800 &
./polkajam -d /tmp/d1 -c /tmp/c1 --chain dev --parameters tiny run  --dev-validator 1 --rpc-port=19801 &
./polkajam -d /tmp/d2 -c /tmp/c2 --chain dev --parameters tiny run  --dev-validator 2 --rpc-port=19802 &
...
```

I believe knowing this will enable us to achieve first contact =) [edited]
  ↳ 2025-05-10 07:02 dave: I believe they should match the keys here https://docs.jamcha.in/basics/dev-accounts
  ↳ 2025-05-10 07:02 dave: So dev validator 0 is alice, 1 is bob, and so on
  ↳ 2025-05-10 09:04 sourabhniyogi: will triple check!

  ↳ 2025-05-10 09:12 sourabhniyogi: Where is this "Inserts the keys for the validator into the keystore before running." described for `--dev-validator` in `./polkajam help run` going? [I was expecting these dev seeds to go `.config/polkajam/dev/keys` but no luck]
  ↳ 2025-05-14 05:54 shwchg: David Emett Jan Bujak Is there an official chainspec file available for use?
I attempted to generate one myself, but it couldn't be decoded by your binary.
2025-05-09 14:30 danicuki: 10MB binary for PolkaJAM? Impressive! Can I try to run it on my old Atari?
2025-05-09 14:40 clearloop: and 4 MB of the 10MB could be rocksdb if using it ... while we are surprised by the compact binary of polkajam, polkajam guys may confused about why our binaries are larger than 10 MB 🥲 [edited]
2025-05-10 09:04 sourabhniyogi: Thank you for posting the `polkajam` binaries!  I believe this `polkajam` binary creates a model for how all our binaries should work at a minimum down to flag interfaces, and probably a lot of us will follow almost all of the polkajam flags model.  It shouldn't restrict our binaries from having other flags as we like of course, but some early conventions would help a lot.

Notes/Ideas/Questions:

- We should have a standardized way of doing fuzz testing of refine (work bundle since its self-contained) and accumulate (exactly [traces](https://github.com/davxy/jam-test-vectors/pull/45)) with flags as an input, and supporting both .json and .bin as per w3f jamtestvectors
- Having a flag for _optional_ pvm execute trace generation for the above in standardized form programmatically comparable will be enormously valuable to see when implementations differ on pvm traces - pc, step, gas, registers cover 99% of this -- the first diff is enough.  (Its what people have asked each other for, most commonly, usually for fixing host function implementations).  Since refine pvm traces can get super huge, a "show only on every N steps" flag parameter would be excellent to have as well.  I think this flag should be an output file destination with a line of JSON for each step separated by newlines where "diff" does all the work.
- Having `polkajam-testnet` be _multiclient_ with a testnet config would be wonderful.   Can we make it open source or should we start rolling our own opensource `jamtestnet`?
- Having clarity on the timing of the first authored block's slot would help a lot!  What is the testnet wide approach to this if its not a flag?
- Having each client with verbosity control flags standardized (warn, info, debug, trace) would support the above, with jamtestnet having the same verbosity flag passed into each client.
- Running the client with `--dev-validator` (eg `./polkajam --temp --chain dev --parameters tiny run  --dev-validator 2 --rpc-port=19802`) should follow "Inserts the keys for the validator into the keystore before running." and put 32 byte seed into the same place ( `.config/{client}/dev/keys/`) in a way that can scale from `tiny` to `full`
- Perhaps each client can have unique multiclient seeds instead of the Alice/Bob/... "dev seeds" as [here](https://docs.jamcha.in/basics/dev-accounts) using the name we registered [here](https://jamcha.in/clients).  This could be used for JAM TART `sender_id`?
- Having "jamxyz -V" show the GP version we are using as a convention probably will save us all a lot of grief.  Similarly, we should NOT have our binaries all be named `jam` but something in obvious relation to our team name (jamduna, jambrains, jamixir etc.) starting when we publish it.  An optional git commit should help a lot as well!
- Could stub `-t, --telemetry` https://hackmd.io/@polkadot/jip3 as a flag even though its under design, and similarly for any other "we definitely expect to have this" (refine/accumulate/auth testing, benchmarking) sections so we stub it all out and then have our own short flags for other things, since there are only so many letters in the alphabet ;) [edited]
2025-05-10 10:26 boymaas: Thank you, Jan. If possible, could we also have a Linux aarch64 version?
2025-05-10 10:53 danicuki: I will start uploading videos to our YouTube Channel:
https://www.youtube.com/@PolkadotJAM

Already added many media files to our open github repo:
https://github.com/jamixir/jam-media/ (you can PR there as well with any relevant media you would like to share)
2025-05-10 14:32 jan: Added a link to my original post.
2025-05-10 14:33 boymaas: Thank you Jan Bujak 🚀
2025-05-12 15:48 james.wilson: Hey guys! Just curious; is there any summary of which teams are currently implementing the JAM spec (and in which languages)? I'm curious to know if there's any interesting space that hasn't been covered already :) 
2025-05-12 15:49 dave: Hey, there's a list of teams here: https://graypaper.com/clients/, not sure how up-to-date it is
2025-05-13 12:35 johnnyb42: Hey, everyone! I've just started learning JAM and trying to understand the possible applications. Especially real-time scenarios.

I've heard about CoreVM and continuous computation without having to worry about the internals of JAM, but I'm still not entirely sure what level of real time I can expect.

Let's say I have a sensor that publishes data at 10 Hz. I want to process this data using a some service on JAM cores.

1) Is there any way I can deliver and process data at this rate in the core? Or am I limited by the fact that the data have to go through DA, be registered in a work-package, and only then enter the core (in 6 s timeslot)?

2) If I pay for several cores, can I parallelize, say, the proccessing data flow of hundreds of MB/s and do it with the same frequency 10 Hz? Or am I limited by the fact that the cores have to generate work-reports, which have to go through the Accumulate stage, etc — that is, I need to wait for the next timeslot? So, additional cores != now I can quickly process a large data in one Refine stage and get the result right away.

3) So did I understand correctly that the cores are isolated from each other at the Refine stage and they can only computate their own piece of data (specified in the work-package)?
2025-05-13 16:25 dave: I'll do my best to answer these...

1. It's certainly possible to process 10 Hz data, the more important questions are (a) how much data and (b) what are the latency requirements. Currently a JAM core can accept ~12MB of input data per 6-second slot, so ~2MB/s. Regarding latency, accumulation should typically occur 12-18 seconds after submission of a work-package. If you want to wait for finality, you will typically need to wait an additional 20-30 seconds. There may be protocol changes in the future to improve latency.

2. Yes, JAM is explicitly designed to support scaling in this way: in theory _every_ JAM core could execute a particular service's refine function in one time slot. Hundreds of MB/s would require many cores but should be feasible with the current JAM parameters. Note that when parallelising in this way, your accumulate function will see the results of each refine and be able to combine them together however you see fit, but the refine executions on each core are independent.

3. Yes, the cores are isolated from each other during the refine stage. Each core can access only its own package's extrinsic and imported data. Each core/package can output ~48kB of data to the accumulate stage, and ~12MB to DA. The accumulate stage sees the ~48kB output from every package/core and is free to combine this data however it likes, though note that there is much less accumulate gas available in total than refine gas as accumulate is always executed on every validator.
2025-05-13 16:36 dave: To clarify the latency point a bit: JAM is pipelined, so although there will be quite a few 6-second periods between a work-package submission and the results of this work-package being finalized, a new work-package can be pushed into the pipeline on every core every 6-second slot. Your accumulate function will execute every 6-second slot with whatever new refine outputs are available.
2025-05-14 04:19 tony_lollipop: 
2025-05-14 05:28 tony_lollipop: Is there any guide documents for the polkajam-repl tool?
2025-05-14 05:56 tony_lollipop: Hi, Jan
Is there any guide document about polkajam-repl? We wonder how to load, start, debug a JAM service with it.
2025-05-14 07:59 danicuki: For those who came to JAM Experience Lisbon, your feedback is really important. Please, give us 5 minutes to fill this feedback form?

https://docs.google.com/forms/d/e/1FAIpQLSeJPAATC6Y76RNvvUWo4KHzZqeC4zIkyyb8T9ng_6L5fE0UPQ/viewform
2025-05-14 08:38 johnnyb42: Thanks for the explanation! 

So, I can only send *new* data only once per 6-second timeslot, right? I mean, if new data comes more often and I need to process it right away (in a dozen milliseconds) to get the result, I can't do it in the core. Or am I missing something?
2025-05-14 08:41 dave: Right, if you need milliseconds of latency then JAM is not suitable
2025-05-14 08:45 ascriv: I wonder if it’s possible to mathematically prove some sort of latency lower bound within some reasonable (secure, decentralized etc) regime/model of blockchain
2025-05-14 08:46 boymaas: We are experimenting with the repl to create a very simple service and send a work package to it. This is not trivial since we do not have access to any source code. For example, we are struggling with the initial step of loading the simplest service. We are trying:

```
t+0 0> boot-create-service 0x5edc11abc426e8906bd52de205d3c57ea7fbcbbb9a5780e29eee69cb14c47ea3
Integer parse error: invalid digit found in string
t+0 0>
```

If anyone could provide a simple walkthrough on creating a service with a code hash, including how to provide the code preimage, set a null authorizer, and send a work package, it would save us a lot of time figuring out the basics.

Another error we are encountering is using jamt to deploy a service to a local devnet. We receive an indication that the max-refine-code-size is missing there. 🤔 [edited]
2025-05-14 10:19 bkchr: This is not completely true. It really depends on what latency you are interested in. Are you talking about latency until finality or work package getting guaranteed? Yeah, milliseconds are not possible. However, it depends on your economical requirements. It is maybe enough to trust the guy building the work package and this guy could give you the result in milliseconds. You just need to be aware that later in the process it can be found out that this guy was lieing to you and then you would need to revert stuff.

Simple example, if I gonna buy a coke for 3 euro. The terminal can directly trust the server that accepts it, because no one will scam you for 3 euro. If I'm buying a TV for 3K, maybe I should wait for work package being guaranteed. If I'm buying a house, I should clearly wait for finality :) 
2025-05-14 10:29 johnnyb42: Yes, I thought about this too, these considerations also need to be kept in mind.

I'm thinking more about technical latency here, how much can be squeezed out of the protocol so that it still makes sense to use it.
2025-05-14 11:00 gav: -h/help can be helpful. Otherwise, I’m afraid these tools don’t (yet) come with user support :) [edited]
2025-05-14 11:17 gav: FWIW `jamt` will have (has already?) distributed source code.  [edited]
2025-05-14 11:20 boymaas: We already realized that user support would be limited. 😁 We have found the source for `jamt`. For others working on it, it can be obtained using `cargo clone`. It seems we need to keep fiddling until we get it to work.
2025-05-14 12:25 davxy: Something worth keeping an eye on: https://github.com/PolkadotOpenSourceGrants/apply/pull/14
Especially useful as a future reference point for other potential implementations 
2025-05-14 14:04 ascriv: Hmm.. until that server or system is handling coke purchases worldwide, then there would be incentives to hack? Or maybe we could have a federated system of work package builders  [edited]
2025-05-14 17:40 danicuki: > <@kianenigma:parity.io> Jan Bujak I missed your recompiler talk this morning, would it be possible for you to share the slides here or in a JAM chat to be able to save it for later? thanks!

https://youtu.be/iXsng4YCDQg?si=-wOBXhLKHnYxO5nA the first minutes got lost in the recording, but it doesn’t compromise to understand the full presentation. 
2025-05-14 18:30 sourabhniyogi: We updated our jamduna binary to more or less match the polkajam binary in terms of having the same flags, and hope other teams will do the same.

For us to make first contact with PolkaJAM we need the PolkaJAM JIP-4 chainspec, and the following Quic TLS nitty gritty nailed down:

- Using polkajam's "Best final block: 0x0259fbe9b7dd6f3c..." output from running `./polkajam -d /tmp/d0 -c /tmp/c0 --chain dev --parameters tiny run  --dev-validator 0 --rpc-port=19800` we spoofed the ALPN protocol string 0259fbe9, which got the polkajam instance opening a connection to our jamduna instance and the TLS cert's `ed25519_public` key indeed match the [dev accounts](https://docs.jamcha.in/basics/dev-accounts)
- However, the peerIDs/SANs/dns\_alt\_names do not, which you can see varying --dev-validator from 0 to 5
"This node is e3r2oc62zwfj3crnuifuvsxvbtlzetk4o5qyhetkhagsc2fgl2oka@127.0.0.1:40000"
"This node is ecjn4brac2kgu25kiykefww6p6ai7noueo6p5af5tnwjgra4eisya@127.0.0.1:40001"
..
"This node is ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005"
none of which match up with the `dns_alt_name` of https://docs.jamcha.in/basics/dev-accounts.
- The UP0 handshake process errors out with "invalid peer certificate" errors, we speculate, due to the SAN issues.
I put together a `go test -run TestPolkajam`  case [here](https://github.com/jam-duna/jamtestnet/tree/main/client)
Can you assist on this? [edited]
  ↳ 2025-05-14 19:31 dave: Will take a look tomorrow. The SAN is supposed to be a very simple translation of the public key, almost certainly a trivial bug somewhere...
  ↳ 2025-05-15 01:01 sourabhniyogi: Here are the 2  sort-of-competing formats:

1. https://github.com/jam-duna/jamtestnet/blob/main/tiny-00000000.json
2. https://github.com/jam-duna/jamtestnet/blob/main/chainspec.json

Is there some consensus or advice on which one implementers should target -- 1 is very M1-implementer friendly, 2 is very extensible, but not quite sure what implementers should do with the bootnodes attributes
  ↳ 2025-05-15 10:38 dave: Support for 2 will likely be required for running on the toaster
  ↳ 2025-05-15 10:40 dave: Bootnodes can probably be ignored for now; you can just connect to the validators specified in the state. On a long-running network, the genesis validator nodes would not be expected to be up still, hence the provision of separate bootnodes that you can use to sync the chain and acquire the latest validator set etc
  ↳ 2025-05-15 12:22 dave: I'm not sure how the SAN stuff on docs.jamcha.in has been computed. The computation was not specified particularly precisely in the SNP doc, so I'm guessing the computation used for docs.jamcha.in was slightly different to what we have. I've updated the SNP doc to include a precise definition, which should match what PolkaJam does (although I might have made a mistake :)
  ↳ 2025-05-15 12:22 dave: https://github.com/zdave-parity/jam-np/commit/222139da2a2393e142c921c7699dd90569c04d33
  ↳ 2025-05-15 13:55 shwchg: David Emett: I got our SAN matches, but still have the ALPN mismatch problem

```
2025-05-15 21:43:21 Chain ID: dev
2025-05-15 21:43:21 Config dir: /home/shawn/.config/polkajam/dev
2025-05-15 21:43:21 Data dir: /tmp/.tmpQ5NxZG
2025-05-15 21:43:21 Reading state...
2025-05-15 21:43:21 Writing genesis block.
2025-05-15 21:43:21 Best final block: 0x0259fbe9b7dd6f3c...
```

I saw your log of genesis block is 0x0259fbe9b7dd6f3c... ?
so we adjust our ALPN to

```
alpn=jamnp-s/0/0259fbe9 
alpn_builder=jamnp-s/0/0259fbe9/builder
```

but still got

```
"CRYPTO_ERROR 0x178 (remote): peer doesn't support any known protocol"
``` [edited]
  ↳ 2025-05-15 14:15 dave: If you run `polkajam` under `env RUST_LOG=jam_node::net=trace` you should get a log message printed containing the expected application protocol
  ↳ 2025-05-15 14:15 dave: Something like:

    2025-05-15 15:13:41 main TRACE jam_node::net  Using application protocol jamnp-s/0/0259fbe9
  ↳ 2025-05-15 14:16 dave: This is what I got running `polkajam` just now. Seems to match what you expect, so I guess some deeper debugging required.
  ↳ 2025-05-15 14:19 dave: I guess one possibility is that you have a newline character at the end of your protocol string or something like this?
  ↳ 2025-05-15 14:26 shwchg: ```
2025-05-15 22:24:01 main TRACE jam_node::net  Using application protocol jamnp-s/0/dev/0259fbe9
```
  ↳ 2025-05-15 14:27 dave: Ah. This was fixed very recently on the polkajam branch, I thought the latest release included this change
  ↳ 2025-05-15 14:29 shwchg: ok!
If possible, please let us know whether you can use our chainspec file or genesis STF file. 
if you can provide one for us to use, that would work as well.
  ↳ 2025-05-15 14:29 dave: AFAICT the binaries most recently posted by Jan have this change
  ↳ 2025-05-15 14:29 dave: Linux binaries here: https://drive.google.com/file/d/1q_v-YoVUd21ZHKWQcFGlLgR04H5n2uB-/view
  ↳ 2025-05-15 14:30 shwchg: oh ok! let me try it
  ↳ 2025-05-15 14:30 dave: If you have a chainspec file you should be able to use it with `--chain <path-to-chainspec-file>`
  ↳ 2025-05-15 14:32 dave: It's possible to generate one with `polkajam gen-spec` though the input to that is not really documented yet! 😅
  ↳ 2025-05-15 14:32 sourabhniyogi: Can you post the chainspec for `dev` in a gist matching up with 0259fbe9 in whatever form?  Or should we do CE128+CE129 basically after first contact?
  ↳ 2025-05-15 14:33 dave: Yeah I'll do that, give me a few mins...
  ↳ 2025-05-15 14:49 dave: https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d
  ↳ 2025-05-15 14:49 dave: You can make `dev-spec.json` from `dev-config.json` with `polkajam gen-spec dev-config.json dev-spec.json`
  ↳ 2025-05-15 14:50 dave: We'll hopefully document the `dev-config.json` format at some point, but hopefully it should be fairly self-explanatory [edited]
  ↳ 2025-05-15 14:51 dave: `dev-spec.json` should match JIP-4 (https://github.com/polkadot-fellows/JIPs/pull/1), pass to `polkajam` like: `polkajam --chain dev-spec.json`
  ↳ 2025-05-15 14:55 dave: `dev-config.json` is quite limited in what it can control; most of the state is just fixed by `gen-spec`. In particular, `gen-spec` always includes a null authorizer (https://crates.io/crates/jam-null-authorizer) and a bootstrap service (https://crates.io/crates/jam-bootstrap-service)
  ↳ 2025-05-15 14:55 sourabhniyogi: Thank you!  We'll check it out and report back soon!
  ↳ 2025-05-15 15:24 shwchg: David Emett: 
Is it possible to provide a more detailed explanation of the TLS handshake? We encountered the following issue in our implementation:
```
from polkajam
2025-05-15 22:36:18 tokio-runtime-worker DEBUG jam_node::net  [::ffff:127.0.0.1]:35615: Incoming connection failed: the cryptographic handshake failed: error 42: invalid peer certificate: UnhandledCriticalExtension

from us
WARN [05-15|22:36:18.072] sendQuicBytes-length                     peerID=2 err="CRYPTO_ERROR 0x12a (remote): invalid peer certificate: UnhandledCriticalExtension" code=0 msgLen=73 
```

It’s possible that some verification checks have been added or removed by us or by you.
  ↳ 2025-05-15 15:26 dave: Hmm this means you have some extension in your certificate that is marked critical but is not understood by polkajam
  ↳ 2025-05-15 15:26 dave: At the moment the only extension we expect is the SubjectAlternativeName extension
  ↳ 2025-05-15 15:31 shwchg: ok! thanks!
I will remove the verification from our side for now
  ↳ 2025-05-15 15:31 dave: I think this is coming from our implementation, not yours
  ↳ 2025-05-15 15:32 dave: You need to remove whatever extension you have from your certificate, or mark it as non-critical
  ↳ 2025-05-15 15:34 dave: Possibly we could be more lenient here
  ↳ 2025-05-15 15:39 shwchg: I removed some extensions, and it looks like the connection was successful.
We’ll start trying to sync with your node.
If we encounter any issues, we’ll reach out to you.
Thanks for your response!
  ↳ 2025-05-15 15:40 dave: Nice!
  ↳ 2025-05-16 07:42 shwchg: David Emett: 
Did you support to use the genesis block to do the block request?
  ↳ 2025-05-16 07:44 dave: There is no genesis block, only a genesis header
  ↳ 2025-05-16 08:38 shwchg: so the only way to catch up is using direction = 1 ? [edited]
  ↳ 2025-05-16 08:52 dave: Sorry I think I misunderstood the original question. I think you should be able to request "ascending" starting from the genesis header
  ↳ 2025-05-16 08:52 dave: You can't request the block with the genesis header itself though as there is no such block
  ↳ 2025-05-16 09:00 shwchg: ok I see!

one more question
are you guys using the same stream for all of the request?

I got this
How do you determine a peer's poor rating?
```
2025-05-16 16:54:48 tokio-runtime-worker TRACE jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:58178: New incoming connection
2025-05-16 16:54:48 tokio-runtime-worker TRACE jam_node::net::peer_manager::peer  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Poor rating
```
  ↳ 2025-05-16 09:07 shwchg: the good news is we got the up0 handshake success and got the new block header!
  ↳ 2025-05-16 09:32 dave: > <@shwchg:matrix.org> ok I see!
> 
> one more question
> are you guys using the same stream for all of the request?
> 
> I got this
> How do you determine a peer's poor rating?
> ```
> 2025-05-16 16:54:48 tokio-runtime-worker TRACE jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:58178: New incoming connection
> 2025-05-16 16:54:48 tokio-runtime-worker TRACE jam_node::net::peer_manager::peer  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Poor rating
> ```

Poor rating is likely to be caused by not following the protocol. We're planning to change this behaviour so we don't disconnect so aggressively, but obviously protocol bugs should be fixed. The first time a peer is disconnected the QUIC "reason phrase" should contain an error message
  ↳ 2025-05-16 09:33 dave: The protocol bug could be on our side of course 😅
  ↳ 2025-05-16 09:35 dave: Re "using the same stream for all requests": we use streams as described in the SNP doc, so generally a separate stream for each request
  ↳ 2025-05-16 09:36 dave: Note that the block announcement stream is an exception to this: it is stateful and should be kept open
  ↳ 2025-05-16 09:40 shwchg: we get `Application error 0x4 (remote)` from our log

and got this from yours
```
2025-05-16 17:25:23 tokio-runtime-worker ERROR jam_node::sync  Failed to receive Block: Stream half closed error: Half stream killed
2025-05-16 17:25:23 tokio-runtime-worker TRACE jam_node::net::peer_manager::peer  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Misbehaviour: network i/o failed: timed out (5000ms)
2025-05-16 17:25:23 tokio-runtime-worker TRACE jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:54499: New incoming connection
2025-05-16 17:25:23 tokio-runtime-worker TRACE jam_node::net::peer_manager::peer  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Poor rating
```

and I didn't see our node pop in this kind of log (I guess this is from the server side?)
```
2025-05-16 17:25:18 tokio-runtime-worker TRACE jam_node::net  e3r2oc62zwfj3crnuifuvsxvbtlzetk4o5qyhetkhagsc2fgl2oka@127.0.0.1:40000: Opening BlockRequest stream
```
  ↳ 2025-05-16 09:41 shwchg: Maybe we could standardize some error codes
would that be helpful?
  ↳ 2025-05-16 10:01 dave: It looks like polkajam requested a block then there was a timeout reading it from the stream. Probably we shouldn't disconnect in this case, but I would look into what's going on there anyway
  ↳ 2025-05-16 10:05 dave: > <@shwchg:matrix.org> Maybe we could standardize some error codes
> would that be helpful?

Yes I think we will include error codes in the network protocol eventually. QUIC supports a "reason phrase" on connection close, which polkajam fills with a human-readable error message. I would recommend printing this in your logs
  ↳ 2025-05-16 10:09 shwchg: because we fail to request the block from the other node
I will look for the reason
  ↳ 2025-05-16 10:11 dave: You shouldn't announce blocks before you have them yourself
  ↳ 2025-05-16 10:11 dave: And have verified them
  ↳ 2025-05-16 10:12 dave: We could maybe relax the verification requirement for validator<->validator connections
  ↳ 2025-05-16 10:20 shwchg: yes! let me check it
thank you!
  ↳ 2025-05-16 10:44 shwchg: Is there a way to get the logs related to stream dispatch or incoming bytes?
  ↳ 2025-05-16 10:51 dave: I think RUST_LOG=trace will give you everything. We use Quinn for QUIC which produces a lot of logs, not sure exactly what as I haven't yet spent much time looking through them
  ↳ 2025-05-18 06:05 sourabhniyogi: Can you explain the semantics of this error, or Polkajam's [temporal] requirement for incoming tickets 

```
2025-05-18 05:56:24 Error processing incoming ticket: finality lagging (final: 1969160, curr: 1969164)
```

  ↳ 2025-05-18 06:27 sourabhniyogi: We moved our ticket sending operation to the 5th phase of the epoch to avoid the above and I gather from 

```
2025-05-18 06:23:18 Error processing incoming ticket: current node is not the proxy for the ticket
```

it means all implementations _must_ do the proxying of CE131/132, check?
 [edited]
  ↳ 2025-05-18 12:11 dave: Yes you should implement the proxying stuff described in the SNP doc. Without this the tickets aren't really anonymous, kind of defeating the point of Safrole.
  ↳ 2025-05-18 12:14 dave: > <@sourabhniyogi:matrix.org> Can you explain the semantics of this error, or Polkajam's [temporal] requirement for incoming tickets 
> 
> ```
> 2025-05-18 05:56:24 Error processing incoming ticket: finality lagging (final: 1969160, curr: 1969164)
> ```
> 

The timing requirements are described in the SNP doc, though with the really short epochs we have with the "tiny" params some of the constants need adjusting. Will post these later.
  ↳ 2025-05-18 22:59 sourabhniyogi: image.png
  ↳ 2025-05-18 23:00 sourabhniyogi: An explanation would be useful -- it was simple to change to send tickets on phase 4/5 and get 131/132 working. 


  ↳ 2025-05-19 23:01 dave: https://github.com/zdave-parity/jam-np/commit/ec45e7ce0e0c1e239b2d7c123f6f688f06a40b00
  ↳ 2025-05-19 23:03 dave: Not sure what you mean by phase 4/5 but hopefully that change makes sense; for the "tiny" network it means each wait is basically just one slot instead of minutes...
  ↳ 2025-05-19 23:47 sourabhniyogi: Will incorporate (by phase 4/5 I just meant the 4th/5th slot of the epoch) - thank you!

We have all the different weights 2+4, 3+3, 4+2, 1+5, 5+1 working well in fallback+safrole-- so now have to get into the real work of work packages.

I'm having a hard time getting polkajam to recognize our chainspec -- it appears to basically ignore our input and continue to use `dev` no matter what

```
# ./polkajam --chain k.json --temp run --dev-validator 3 --rpc-port=19803
2025-05-19 23:45:02 Chain ID: dev
2025-05-19 23:45:02 Config dir: /root/.config/polkajam/dev
2025-05-19 23:45:02 Data dir: /tmp/.tmphmRvKD
2025-05-19 23:45:02 Reading state...
2025-05-19 23:45:02 Writing genesis block.
2025-05-19 23:45:02 Best final block: 0x0259fbe9b7dd6f3c...
```

Is there some other requirement I've missed?
2025-05-15 02:56 sourabhniyogi: Published jamduna binaries:

https://github.com/jam-duna/jamtestnet/releases/tag/0.6.6.1
2025-05-15 07:25 prematurata: is the repl interface shown in some of the jam sessions public? looking forward building a repl interface that matches the same commands/args to keep compatibility
2025-05-15 10:36 dave: We've released a binary here. Source will be released at the same time as polkajam.
2025-05-15 14:26 shwchg: 
2025-05-16 14:05 davxy: @room

After reviewing the open issues related to compatibility with GP-0.6.5, I've tagged the test vectors for version 0.6.5.
Everyone is welcome to try them out and report any issues they encounter.
We'll begin integrating 0.6.6 shortly.
From now on, all changes between tags will be listed in the changelog explicitly.

https://github.com/davxy/jam-test-vectors/releases/tag/v0.6.5
2025-05-17 14:02 sourabhniyogi: image.png
2025-05-17 14:04 sourabhniyogi: First contact successful, thank you David Emett Jan Bujak for all your help and posting the binaries.  In a 5 Polkajam + 1 jamduna tiny testnet, we can import Polkajam-authored blocks and Polkajam can import jamduna-authored blocks.
2025-05-18 16:08 stsoen: I have studied Gray Paper closely, I have also scrutinized all the comments in the issues in https://github.com/gavofyork/graypaper

Further, I was confused by this mention of XCMP in the context of JAM here: https://wiki.polkadot.network/learn/learn-jam-chain/#:~:text=run%20excessively%20long.-,XCMP,%C2%B6,-Moving%20on%20to

And I have a question. I understand that JAM cores should be able to communicate with each other in asynchronous mode. So I assumed that JAM would use XCMv2 and higher versions.

But how will the cores actually communicate with each other?
2025-05-18 17:05 gav: Cores don’t communicate. 
2025-05-18 17:06 gav: Services and things which run on top of them may interoperate/communicate. 
2025-05-18 17:06 gav: Cores are stateless and isolated with the exception of D3L access. 
2025-05-18 20:56 stsoen: gav Thank you very much! I would really appreciate it if you could help me clarify this:

Do I understand correctly that a service running in core1 can communicate with a service running in core2?

Will there be some framework to connect services and dApps to each other?

For example, I am considering this kind of usecase:
- core1 is running a perp protocol (similar to Hyperliquid) or a lending protocol. Dedicating all processes related to their engine in a separate Core allows more speed for platform computation.
- core2 launched a oracle protocol, whose participants (e.g. providers/reporters/oracles etc) provide price feeds and are responsible for correct calculation of clearing prices based on on-chain and off-chain data sources. 
- core3 launched a service that holds an auction for liquidator bots (OEV extraction and maximization of profit from liquidations). In addition, it can also run auctions for the best acquiring transactions (like CoW, UnswapX, 1inch Fusion etc).

Will these cores be able to exchange prices and positions information with each other? Or should the connection method for services running in different cores be developed separately?

For example: core1 and core3 receive data from core2, then core3 interacts with positions ( liquidate them) in core1
2025-05-18 20:58 xlchen: core is like cpu core, we don't usually talk about communication between cpu cores during application development. instead, IPC mechanism will be used for that, e.g. XCMP
2025-05-18 20:59 xlchen: and an app can be multi core, or sharing a core with other apps etc
2025-05-18 21:00 xlchen: and like PC, a core can't really send a message to another core. it is done via register or memory. same thing here
2025-05-18 21:02 stsoen: Thank you!

In that case, can different services running in different cores communicate with each other in any standardized way?

For example, as in the case I described above, when different services/protocols are created by different developers
2025-05-18 21:03 xlchen: services can send token + memo to other services. this is defined by GP
2025-05-18 21:10 stsoen: Do you mean Authorize token that includes opaque data that are included in the work package? Or do you mean a token as a ticker?

I'm interested in whether any data can be transferred between different services in different cores as messages or something similar (like price feeds).
2025-05-18 21:11 xlchen: by token I mean DOT. basically the answer is yes. how depends on the exact use case
2025-05-18 21:15 stsoen: Thanks for the clarification! So, does JAM have any built-in native protocol for inter-service messaging similar to how it is implemented in XCM?
2025-05-18 21:16 xlchen: I already said, service can send DOT token + a memo message to other services for message passing
2025-05-18 21:19 stsoen: So JAM will use a DOT or other native token for JAM, right? Because it looks like it should be some kind of basic gas token for the ecosystem. 

And let's say a minimum amount of DOT (0.00001 for example) can be used to transfer information between services (in memo)?
2025-05-18 21:19 xlchen: DOT is the native token / gas token
2025-05-18 21:23 xlchen: I think it is possible to send 0 DOT and still attach a message with it but someone need to read the GP to confirm [edited]
2025-05-18 21:30 gav: > <@xlchen:matrix.org> I think it is possible to send 0 DOT and still attack a message with it but someone need to read the GP to confirm

Indeed it is. 
2025-05-18 21:52 stsoen: Am I correct in understanding that spam exclusion will occur during the Auditing and Judging process?
2025-05-19 08:27 gav: > <@stsoen:matrix.org> Am I correct in understanding that spam exclusion will occur during the Auditing and Judging process?

Spam exclusion? 
2025-05-19 08:28 gav: Perhaps you’re under the misapprehension that JAM processes transactions?
2025-05-19 08:29 gav: (Zero-value transfers still must be processed and thus still cost gas - this is not a spam vector)
2025-05-19 09:51 danicuki: I know it may be boring, but spending 5 minutes filling this feedback form will really help us to organize more events like JAM Experience. We had only 15% of attendees filling it. Thanks for your help: 
https://forms.gle/dK1xPhx3rBZq8gpg9 
2025-05-19 12:00 stsoen: 
2025-05-19 12:01 stsoen: I’m considering the following situation:

- There is a certain service1 that performs some important functionality, which, for example, makes it a target for an attacker.
- It is mentioned that JAM has ultra-low gas costs, so the attack shouldn't become expensive.
- service2, running on top of core2, starts sending a huge number of DOT tokens to service1 in the form of separate chunks (since the token has to be sent from somewhere and delivered somewhere, right? A token transfer from one address to another can be called a transaction, correct? I don't know how else to refer to transactions between cores other than as transactions).
- This service1 starts receiving a lot of incoming zero-value DOT transactions from service2, and it has to include them in the work package, which interferes with other ongoing processes.

Situations that have occurred, for example with Inscriptions, clearly demonstrated that even high-performance networks can experience significant issues due to something trivial and temporary.

And I’m trying to understand where the filtering of such malicious coordinated spam will happen. Will this be prevented at the Authorizer level? Or will it be rejected on-chain during work packages validation? [edited]
2025-05-19 12:37 dave: > zero-value DOT transactions from service2, and it has to include them in the work package

This is a misunderstanding. Any transfers triggered by service2's accumulate function are "paid for" out of service2's accumulation gas limit and are handled as part of block execution. They are not included in service1's work packages or anything like this.
2025-05-19 15:01 dvdplas: Our team would like to ensure the developer experience for JAM application builders is as best as it can be when the first hackathons will be held.

What would be the first service, apart from CoreChains, that devs most probably want to build on top of?

Is it expected that more devs build services or applications on top of an existing service?

  ↳ 2025-05-19 17:33 kianenigma: a good staring point for this would be to look at JAM SDK aka https://docs.rs/jam-pvm-common/latest/jam_pvm_common/ and try it out
2025-05-19 15:07 stsoen: Service 1 receives tokens, albeit zero-value and with a memo message. It should change its state, right?
2025-05-19 15:08 dave: That's totally up to what service 1 does in its on-transfer function. It might just ignore the memo.
2025-05-19 15:11 stsoen: All of my questions are specifically about the ability to pass messages between services running in different cores. 
Accordingly, if a service can ignore certain memos - it needs to include the allowed whitelist of memos that it considers correct and available for processing, right? [edited]
2025-05-19 15:13 dave: If you write a service which expects to be sent memos from other services, I expect you would document the expected format of these memos yes. Not sure if that's what you mean.
2025-05-19 15:14 stsoen: Yes, that's what I meant, thank you! It's similar to administration with creating allowed domains and allowed requests/commands [edited]
2025-05-19 15:22 dave: FWIW I wouldn't think about services running on or being assigned to particular cores. Services are somewhat orthogonal to cores. You will be able to buy core time and submit work-packages using this core time which run any services you like. Of course what effect these work-packages have is up to the author of the service code. You will be able to create services without paying for any core time, leaving it to some other party to pay for core time and submit work-packages.
2025-05-19 15:26 sourabhniyogi: stsoen@Lollipop: If you want one service A to communicate with another service B, you can design a mailboxing system *outside* the transfer memo process, where 
(a) Service A writes (using the host function `write`) into a certain set of keys designated for B 
(b) Service B reads (using the host function `read`) from the above set of keys from Service A's storage
(and in the reverse direction.) JAM does not impose constraints on service A + B on how to do this except that the `write` and `read` could only be in the `accumulate` invocation of the service.  So for the services `refine` operation done in core, the content of what is written in these keys have to be output in work results.   This requires some degree of getting used to but I would recommend you just jump in and just write your service A and B to explore this -- the testnets are basically ready for experimentalists to post work packages and see this kind of messaging happen.

You could imagine a bunch of interoperable services having a structured way of doing this, and perhaps a JIP could and should be devised specifically for this purpose, informed by HRMP's Queues or something else.  There are no real constraints for this, and it doesn't have to be put into XCM/XCMP formats/protocols -- you are free to just work directly with writes and reads.  With some luck, you'll have "here is how we did inter-service messaging" story to report back with. 
2025-05-19 15:28 stsoen: For some reason, I got the impression that different Cores may have machines (servers/nodes) with different characteristics. For example, some core might include machines with simplified specs for performing basic tasks. And some cores might have machines with powerful GPUs and TEE chips for handling highly specialized, resource-intensive tasks. (TEE for RISC-V is currently under development, but given the openness of RISC-V, this will require separate specifications)

Or is this incorrect, and all cores will have the same set of hardware?


2025-05-19 15:33 gav: > <@dvdplas:matrix.org> Our team would like to ensure the developer experience for JAM application builders is as best as it can be when the first hackathons will be held.
> 
> What would be the first service, apart from CoreChains, that devs most probably want to build on top of?
> 
> Is it expected that more devs build services or applications on top of an existing service?
> 

CoreVM quite possibly, but maybe there will be other more transaction-orientated services. 
2025-05-19 15:36 gav: It is incorrect. Cores are homogeneous and fungible. They have a specific and fixed amount of I/O bandwidth and processing power specified in 6-second intervals.  [edited]
2025-05-19 15:38 stsoen: So all Cores have the same hardware requirements? 

And if I want to get Core AI-oriented computing - I can't deploy GPU-based nodes there? [edited]
2025-05-19 15:38 gav: The hardware *requirement* for a core isn’t really a thing. 
2025-05-19 15:39 gav: JAM guarantees correctness of all of the compute which is done on its cores. Exactly what the hardware requirements were for any given core varies and in some sense is unknowable.  [edited]
2025-05-19 15:40 gav: However the theoretical specifications of its cores are well-defined. 
2025-05-19 15:41 gav: There is no affordance to increase the capabilities of individual cores. This is a basic implication of the JAM correctness mechanism, where any validator may be called upon to audit any piece of work. 
2025-05-19 15:42 gav: In the future we may see JAM instances whose cores are more substantial than that which the GP presently defines. For example we may introduce a GPU invocation host call. 
2025-05-19 15:42 gav: This might be quite helpful for AI inference workloads. 
2025-05-19 15:44 gav: It won’t be part of 1.0 but it could make it into eg 2.0, however it must be balanced against making all validator nodes’ hardware & running costs substantially higher. 
2025-05-19 15:44 gav: The running costs imply a baseline pricing for core time. For an economy around JAM to be sustainable, pricing and costs must be aligned with each other. 
2025-05-19 15:45 gav: If validator costs double, then Coretime revenue must also double or the system is not economically sound.  [edited]
2025-05-19 15:51 gav: For this reason cloud compute services (where different servers provide different capabilities) don’t make an ideal point of comparison.
2025-05-19 15:53 stsoen: Yes, that's exactly the problem with modern cloud computing: modern tasks, due to poor optimization, require such a huge amount of resources that the cost of renting hardware either breaks the economics or makes the product unnecessarily expensive.

That's why I'm impressed with the RISC-V integration, because maybe it will finally allow for a more rational treatment of optimization capabilities. And maybe it will make processes more optimized instead of constant power inflation with loss of process execution quality due to bloated libraries and frameworks.
2025-05-19 22:33 sourabhniyogi: Can someone publish the { bootstrap, null_authorizer, ... } services included in polkajam genesis state (and compilation Makefile, if it exists)?  Goal is to test multi-client workpackage submissions.   We can then retire our [bootstrap](https://github.com/colorfulnotion/polkavm/tree/dev/services/bootstrap) and [null authorizer](https://github.com/colorfulnotion/polkavm/tree/dev/services/null_authorizer) -- this way there is just one `dev` JIP-4 chain spec for multi-client tiny testnet setups and process to create new services.
2025-05-19 22:34 dave: These are published on crates.io: https://crates.io/crates/jam-null-authorizer, https://crates.io/crates/jam-bootstrap-service
2025-05-19 22:35 jan: Regarding the possibility of JAM having GPU compute capabilities built-in - as Gav alluded there is a _possibility_ of it being part of JAM 2.0, but I would suggest to not get too excited for now. It would require significant design work and most likely some major changes/improvements to the protocol, as GPU compute is _fundamentally_ very different than CPU compute. You can't really guarantee determinism with GPUs (even a different version of the same GPU driver can make your GPU kernels produce different results!), gas metering is pretty much impossible, and for e.g. workloads like AI the I/O requirements are _extreme_ so without at least some support for having a ton (_gigabytes_) of persistent local data (for storing the weights pinned to the same core) across blocks it would be so insanely expensive that practically it'd be completely useless.

If you're interested in decentralized GPU compute there are people currently doing some pioneering work on it here: https://www.primeintellect.ai/blog/intellect-2

So _if_ we're going to do GPU compute on JAM it would probably be _something_ like that, except we would try to make it as general purpose as possible instead of just hardcoding it to a single type of workload. Just as we took the fundamental mechanism of what makes parachains possible from Polkadot and now with JAM we've generalized it so that you can implement parachains _on top_ of JAM, we could maybe also generalize what the prime intellect people are doing for GPU compute. But, again, this would require significant design work to be practical/economical.

That said, of course you could have an _offchain_ GPU compute provider and use JAM as-is to facilitate that/buy GPU compute time on it even _today_. [edited]
2025-05-19 22:35 dave: Not sure if they're up-to-date
2025-05-19 22:35 dave: They can be built into a PVM binary using https://crates.io/crates/jam-pvm-build
2025-05-19 22:38 dave: The JIP-4 chainspec I posted before (https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d) contains this null authorizer and bootstrap service, though possibly more recent versions than currently released on crates.io
2025-05-19 22:43 sourabhniyogi: The repo/source for both are in https://github.com/paritytech/polkajam only and thus invisible?  Is it possible to move these out of closed source `polkajam` and into open source `jam-services` ?
2025-05-19 22:48 dave: You can fetch the source from crates.io using something like this https://crates.io/crates/cargo-clone
2025-05-19 22:49 jan: You can also create a dummy project, and use `cargo add` + `cargo vendor` to download the sources without any extra tools.
2025-05-19 22:55 dave: I've updated the SNP doc so that it makes sense for eg "tiny" network parameters, see https://github.com/zdave-parity/jam-np/commit/ec45e7ce0e0c1e239b2d7c123f6f688f06a40b00
2025-05-19 22:57 dave: This isn't intended to change anything in the "full" 1023-validator parameters case, but hopefully avoids guesswork in other cases
2025-05-19 22:59 dave: In particular the ticket distribution timing is now based on the epoch length and so should make sense with the really short epochs you get with the tiny params
2025-05-19 23:08 jaymansfield: Does the published polkajam binary use these settings already?
2025-05-19 23:08 dave: Yes it should do
2025-05-19 23:56 sourabhniyogi: Is there some `polkajam`  env variable that reveals that `polkajam` is (or is not) reading the `--chain k.json` input of `./polkajam --chain k.json --temp run --dev-validator 3 --rpc-port=19803\` -- we cannot get it to read our JIP-4 chainspec =( [edited]
2025-05-20 00:16 jaymansfield: I noticed if —dev-validator is set it ignores —chain and always defaults to dev instead. Would be nice if they could be used together though. [edited]
2025-05-20 00:29 sourabhniyogi: How do we supply a seed manually then?
2025-05-20 00:32 dave: `--dev-validator` forces `--chain dev` yeah, this is documented in `--help`. Guess it would be useful for it to only change the default.
2025-05-20 00:39 dave: Not sure it's actually possible to load the keys for a dev validator without `--dev-validator` as they are unfortunately not derived from the seed in the same way as the on-disk seeds generated by `gen-keys`! Might be a good idea to fix this, though I expect many teams have implemented the dev validator key stuff so this could be fairly disruptive
2025-05-20 00:43 dave: The difference is that on-disk seeds are hashed to produce different seeds for Ed25519 and Bandersnatch, to avoid any issues that could arise from using the same seed for both. This hashing is not currently done for the dev validator keys.
2025-05-20 00:45 dave: I'll put together a fix for this tomorrow anyway and release some new binaries.
2025-05-20 00:50 dave: I'll also document how key seeds are currently handled by PolkaJam; guess this can go in a JIP. The extra hashing goes like `ed25519_seed = blake2b(personal = b"polkajam-ed25519", seed_from_file); bandersnatch_seed = blake2b(personal = b"polkajam-bsnatch", seed_from_file)`
2025-05-20 00:51 sourabhniyogi: Terrific!  FYI we also could not get polkajam to parse your provided `dev-spec.json` [here](https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d) which can serve a a controlled test case?

```
# ./polkajam --chain chainspecs/dev-spec.json run 

thread 'main' panicked at crates/cli/src/lib.rs:81:58:
Error loading chain spec file: "Error decoding genesis_header: Could not decode `Header::epoch_mark`:\n\tCould not decode `Option::Some(T)`:\n\t\tCould not decode `NextEpochDescriptor::validators`:\n\t\t\tCould not decode `EpochKeySet::bandersnatch`:\n\t\t\t\tCould not decode `Public.0`:\n\t\t\t\t\tNot enough data to fill buffer\n"
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Aborted (core dumped)
```
2025-05-20 00:51 dave: If you're keen it should be possible to `gen-keys` a bunch of keys and generate a chainspec using these
2025-05-20 00:53 dave: Ah. I might have made the mistake of testing this with `--dev-validator` 😅, will look into tomorrow
  ↳ 2025-05-20 05:00 shwchg: David Emett: 
Could you please explain more about how to use jamt?
For example, how do you choose the TCP port, and how do the parameters work?
```
~/Desktop/colorfulnotion/jam/bin/polkajam_bin$ ./jamt create-service <some hex bytecode> 1000000 
Bootstrap service #0 identifies as jam-bootstrap-service v0.1.21 by Parity Technologies <admin@parity.io>
Work package submitted at slot 1997397. Monitoring...
Service eeeb3531 created at slot 1997398
Providing service code...
Submitted. Waiting for provision...
Service code provided at slot 1997399
```
  ↳ 2025-05-20 05:14 shwchg: and we got this 
```
thread 'tokio-runtime-worker' panicked at crates/node/src/lib.rs:131:27:
not implemented
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

thread 'tokio-runtime-worker' panicked at crates/node/src/lib.rs:131:27:
not implemented
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

thread 'tokio-runtime-worker' panicked at crates/node/src/lib.rs:131:27:
not implemented
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
Can u also help me check this?
  ↳ 2025-05-20 18:41 dave: `jamt` uses RPC, as defined in JIP-2. The RPC endpoint is specified with `--rpc`. `--help` should cover usage. If you have any specific questions that aren't answered by `--help` feel free to ask in this channel.
2025-05-20 02:13 jaymansfield: JavaJAM now works running alongside polkajam nodes and they can import each others blocks (safrole and fallback) 😀
2025-05-20 07:37 emielsebastiaan: > <@dave:parity.io> I'll put together a fix for this tomorrow anyway and release some new binaries.

Will this release based on GP-0.6.6?
2025-05-20 09:15 gav: No - I'm going to prioritise getting GP to 0.7 over bring the codebase/vectors up to 0.6.6
2025-05-20 18:25 dave: Sorry just got around to looking at this. You currently need to specify the chain parameters separately as they are not included in the spec, so `./polkajam --parameters=tiny --chain chainspecs/dev-spec.json run` should work.
  ↳ 2025-05-20 18:41 sourabhniyogi: Ah, but is there a way to get the `dev-validator` input working with it though?

```
./polkajam --parameters=tiny --chain chainspecs/jamduna-spec.json run --dev-validator 3
```

This is what we are hoping will be possible in your next binary push

In the meantime, we are using the `jamt create-service` to get some work packages using the `dev` bootstrap, and we believe that polkajam CE134 is not sending a `WorkPackageBundle` but merely a `WorkPackage`... because what `polkajam` sends is basically decodable as a `WorkPackage` but not a `WorkPackageBundle` -- could this be a temp solution you've employed or do you think we have our `WorkPackageBundle` decoding concepts wrong when there are 0 extrinsics and 0 justifications?  We are not aware of any testvectors for `WorkPackageBundle`.

PS We have been able to import polkajam-authored blocks with guarantees (from this `jamt create-service` way of triggering CE133/134) followed by assurances -- the CE142/143 situation is bottlenecked by a basic need for pvm execution logs from accumulate.  [edited]
  ↳ 2025-05-20 18:44 dave: Auditing protocols are not currently enabled in PolkaJam releases, this is probably the issue
  ↳ 2025-05-20 18:45 dave: I'll drop the `unimplemented()` and just make PolkaJam close these streams immediately for now
  ↳ 2025-05-20 19:17 sourabhniyogi: https://github.com/davxy/jam-test-vectors/pull/45#issuecomment-2895537979
  ↳ 2025-05-20 20:38 dave: > <@sourabhniyogi:matrix.org> Ah, but is there a way to get the `dev-validator` input working with it though?
> 
> ```
> ./polkajam --parameters=tiny --chain chainspecs/jamduna-spec.json run --dev-validator 3
> ```
> This is what we are hoping will be possible in your next binary push
> 
> In the meantime, we are using the `jamt create-service` to get some work packages using the `dev` bootstrap, and we believe that polkajam CE134 is not sending a `WorkPackageBundle` but merely a `WorkPackage`... because what `polkajam` sends is basically decodable as a `WorkPackage` but not a `WorkPackageBundle` -- could this be a temp solution you've employed or do you think we have our `WorkPackageBundle` decoding concepts wrong when there are 0 extrinsics and 0 justifications?  We are not aware of any testvectors for `WorkPackageBundle`.
> 
> PS We have been able to import polkajam-authored blocks with guarantees (from this `jamt create-service` way of triggering CE133/134) followed by assurances, .. and are checking what's up with our CE137/CE142 life now.  

Yes, binaries coming soon that should make the dev-validator stuff work. Re CE134 I believe our implementation matches the SNP doc. The bundle encoding is as in the GP, note that a number of the lists in the bundle are not length-prefixed, instead having their length implied by the work-package. See 14.15 in the GP and note that lists are only length-prefixed when there is a ↕ symbol in front
  ↳ 2025-05-20 21:21 sourabhniyogi: Hmm -- for a WP with 0 extrinsics, 0 imported segments and thus 0 justifications, for the J term of the work package bundle described in  [14.14](https://graypaper.fluffylabs.dev/#/9a08063/1b43021b4302?v=0.6.6) where there _is_ a  ↕ symbol, do you get _one_ 0x00 byte after the work package a per [C.8](https://graypaper.fluffylabs.dev/#/9a08063/394401394401?v=0.6.6) in the work package bundle?  

Understand about the extrinsic lengths and imported segments implied by the WP items, but some bundle codec test cases here would go a long way.
  ↳ 2025-05-20 21:24 dave: The ↕ symbol in 14.14 is on each justification. There is no ↕ symbol on the list of justifications, the number of justifications is implied by the work-package
  ↳ 2025-05-20 21:25 dave: Agree it would be great to have bundle test vectors
  ↳ 2025-05-20 21:25 sourabhniyogi: Ah got it -- thank you!
  ↳ 2025-05-21 02:04 sourabhniyogi: Your latest binary enabled polkajam to use our chainspec, we can now do things with our bootstrap/null_authorizer/... etc -- thank you again.

Also, we were able to address the WorkPackage/Bundle decoding problem so CE133/134 are happy together... now need to get refine+accumulate alignment.  
  ↳ 2025-05-22 01:21 mkchung: Could we have a codec test vector for WorkPackageBundle?

Also, if a WorkPackage contains multiple WorkItems, and only some of them include imported segments or justifications — should the "S" (imported segments) and "J" (justifications) fields omit entries for WorkItems that don’t have any, or should "J" still be encoded as empty for those items given the  ↕?

In the following example, workItem_1 is the authorization item (which has no importedSegment or justification):
https://gist.github.com/mkchungs/ee6ec72a8ab9d0ee98904a926a427840
The bundle codec is encoded without workItem_1 in "S" and "J".

Can we expect the WorkPackageBundle JSON test vector to follow a similar format to Option 1?
2025-05-20 21:31 dave: New release of PolkaJam here: https://github.com/paritytech/polkajam-releases/releases/tag/manual-2025-05-20. This has the requested change to the `--dev-validator` flag; it will now no longer override an explicitly provided `--chain` option
2025-05-20 21:32 dave: Nightly builds of PolkaJam should now be automatically created and uploaded here: https://github.com/paritytech/polkajam-releases/releases
2025-05-20 21:34 dave: The GP version implemented is now shown by `./polkajam --version`
2025-05-20 23:30 jaymansfield: > <@dave:parity.io> Nightly builds of PolkaJam should now be automatically created and uploaded here: https://github.com/paritytech/polkajam-releases/releases

Should we use the same repo for issues? I’ve had polkajam crash a few times while running. 
2025-05-20 23:33 dave: Yes feel free to open issues there
2025-05-21 06:51 clearloop: on connecting polkajam,

```
 polkajam --chain dev run -d 0 --dev-validator 0  
```

I got

```
// this error is from spacejam
2025-05-21T06:34:29.224367Z ERROR transport::verifier: invalid certificate: expected e3r2oc62zwfj3crnuifuvsxvbtlzetk4o5qyhetkhagsc2fgl2oka, got ehnvcppgow2sc2yvdvdicu3ynonsteflxdxrehjr2ybekdc2z3iuq
```

`e3r2oc62zwfj3crnuifuvsxvbtlzetk4o5qyhetkhagsc2fgl2oka` is defined in the [dev-spec](https://gist.github.com/zdave-parity/72eb9cfe07756d2c0c13c3064600190d) indeed, however I got `ehnvcppgow2sc2yvdvdicu3ynonsteflxdxrehjr2ybekdc2z3iuq` via extracting & encoding the ed25519 public key from the received cert, (which is matched with \[0; 32\] as seed for ed25519 keypair)

anybody knows where `e3r2oc...` comes from? also, if I want to specify a peer-id for polkajam, I'll get

```
polkajam --chain dev run -d 0 --dev-validator 0  --peer-id  ehnvcppgow2sc2yvdvdicu3ynonsteflxdxrehjr2ybekdc2z3iuq
error: invalid value 'ehnvcppgow2sc2yvdvdicu3ynonsteflxdxrehjr2ybekdc2z3iuq' for '--peer-id <PEER_ID>': Non-zero trailing bits

For more information, try '--help'.
```

version: `polkajam-nightly-2025-05-21`

---

my current strategy is disable the check and allow alt_name mismatched with the parsed dns name, anybody met this 'problem' as well? [edited]
  ↳ 2025-05-21 08:38 dave: I recently added a section to the SNP doc which precisely defines how the alt-name should be derived: https://github.com/zdave-parity/jam-np/blob/main/simple.md#alternative-name
  ↳ 2025-05-21 08:42 clearloop: thanks! I had ignored this formula since I thought I have already implemented it correctly > <
  ↳ 2025-05-22 11:58 clearloop: any ideas about

```
ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:40005: Disconnecting: Misbehaviour: Malformed jam_node::sync::message::Announce: Could not decode `Announce::header`:                                           
        Could not decode `Header::parent`:         
                Could not decode `HeaderHash.0`:   
                        Not enough data to fill buffer          
```

we're communicating with the latest polkajam node on osx, for the `up0` steps in spacejam:

1. send \[0\] to open the stream ✅
2. wait for the handshake from polkajam ✅
3. send the handshake from spacejam to polkajam ❌

the handshake message from spacejam follows \[length, encoded\_handshake\], but it seems polkajam is trying to decode the handshake from spacejam as a block announcement

if we skip handshake and enter the announcement loop, we'll get

```
DEBUG jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:55443: Static(BlockAnnouncement) stream closed: First receive killed (Dropped) by local, then transmit killed (Dropped) by local
DEBUG jam_node::net::peer_manager  ede7gocrx5435my626w74zmwejyzqw3wvuvwtnzu4sz2lwib4kxaa@127.0.0.1:55443: Peer disconnected with reason: Unknown: stream reset by peer: error 1                               
``` [edited]
  ↳ 2025-05-22 12:11 clearloop: or we need to embed this handshake in connection level, but we can decode handshake from polkajam in the stream of up0 )) [edited]
  ↳ 2025-05-22 14:04 dave: FWIW you should do (2) and (3) concurrently, and you should only do (1) if you are the one that opened the stream. But I don't think either of these is your issue 😅
2025-05-21 07:52 dvdplas: What I have in mind:
1. Scaffold a new CoreVM app template, ready to build
- Is there a name for apps build on top of CoreVM?
2. Launch JAM locally (either deploys the CoreVm app automatically to JAM, like added to the genesis or separately:)
- Is there the plan for zombienet to support JAM?
3. Deploy the CoreVM app and interact with it.
- Is there an example somewhere of interacting with an app build on top of CoreVM?

This will be added to the Pop CLI: https://github.com/r0gue-io/pop-cli
2025-05-21 07:52 gav: 1. “Guest” is the current term used. 
2025-05-21 07:53 gav: 2. Not as far as I know. 
2025-05-21 07:53 gav: 3. CoreVM doesn’t presently support input. Right now we’re just about finished getting it into a releasable shape. Input could come quite soon after, but it’s not especially trivial.  [edited]
2025-05-21 08:05 dvdplas: Thanks for your response. I will closely follow the developments around JAM and continue the conversation when we get closer to the first hackathon in November. Our team is super motivated to build the tooling so that devs can successfully build CoreVM guests (or any other desired service app) and enjoy the required developer experience.

Daan | R0GUE
2025-05-21 08:33 jan: For tooling you might want to check out this repository: https://github.com/paritytech/polkaports

This is where we're working on a work-in-progress CoreVM SDK, and we already have a prototype toolchain for building C programs (that's how we've been porting Quake to CoreVM). In the future we also plan to add support for other languages and libraries, e.g. C++, Rust, Go, Python, etc. If you're interested in collaborating you're welcome to do so.
2025-05-21 08:59 prematurata: Hello all about state deserialization how could you properly deserialize `a_s` given that the write host call accepts an arbitrary `ko ... kz` from registers 7 and 8 to define the storage key along with the service index and the merklization fn T only uses 27 bytes of such key that gets further reduces when going through the C fn?
2025-05-21 09:04 ascriv: > <@prematurata:matrix.org> Hello all about state deserialization how could you properly deserialize `a_s` given that the write host call accepts an arbitrary `ko ... kz` from registers 7 and 8 to define the storage key along with the service index and the merklization fn T only uses 27 bytes of such key that gets further reduces when going through the C fn?

Yes, you can’t recover the full key when deserializing
2025-05-21 09:04 ascriv: You can only recover 23 bytes actually 
2025-05-21 09:05 ascriv: But it’s still possible to have an implementation which is GP conformant even with this restriction 
2025-05-21 09:07 prematurata: i was more worried about testing the implementation given that my impl should "start" from the same state of someone elses implementation
2025-05-21 09:08 prematurata: if i am unable to reconstruct original from "merklized" which apparently is being used by different "testing suites"
2025-05-21 09:08 ascriv: Yes that “warp sync” ability might require you to rejigger some aspects of your impl, I also had to
2025-05-21 09:10 prematurata: I wonder if we can do any better considering that `a_s` seems to be the only one that is impossible to fully 'recover'
2025-05-21 09:23 dakkk: I would suggest to add the missing part of the key in the beginning of the value; this is a minor edit but it solve the issue. Something like this:

C(s, E4 (2**32 − 1) ⌢ k0...27 ) ↦ k23...32 ⌢ v
2025-05-21 09:41 greywolve: But the traces assume your storage keys are just state keys, but that is certainly another way to do it :)
2025-05-21 09:53 prematurata: correct but this alone prevents anyone from taking the state + block and verify outcome.

Basically right now in order to verify block N you need to have applied yourself the previous blocks where the storage keys required by N were written 

 [edited]
2025-05-21 10:06 greywolve: Not entirely true, see this [comment](https://github.com/davxy/jam-test-vectors/pull/45#issuecomment-2848736219).
2025-05-21 10:50 jaymansfield: > <@prematurata:matrix.org> I wonder if we can do any better considering that `a_s` seems to be the only one that is impossible to fully 'recover'

You also can’t recover the preimage historical lookup key if you dont have possession of the preimage itself.
2025-05-21 11:02 jaymansfield: > <@prematurata:matrix.org> correct but this alone prevents anyone from taking the state + block and verify outcome.
> 
> Basically right now in order to verify block N you need to have applied yourself the previous blocks where the storage keys required by N were written 
> 
> 

State+block is all you really need a few of us have made this work already. You’ll just have to rework your internal storage to use state keys instead of relying on the original values. 
2025-05-21 11:05 prematurata: thanks for the info but isnt that different from what the gp states
2025-05-21 11:05 prematurata: especially for the write and read host callse
2025-05-21 11:06 prematurata: if the implementation is meant to use state key there to fetch/store the data, i guess GP should also state that
2025-05-21 11:09 faiz_871: Can someone please clarify how the data is encoded before signing and then distributing a work report to other nodes?

  ↳ 2025-05-21 11:14 jaymansfield: Which data are you referring too? The work report itself?
  ↳ 2025-05-21 11:22 faiz_871: Yeah we have to make signature using work report  and core\_index  [edited]
2025-05-21 11:13 ascriv: > <@prematurata:matrix.org> if the implementation is meant to use state key there to fetch/store the data, i guess GP should also state that

Your impl’s representation of state does not have to match the GP representation. In fact it can’t, if it supports warp sync
2025-05-21 11:18 prematurata: otherwise the end result would be that we have 2 almost identical impl in terms of behavior. 1 is following GP but makes it impossible to rebuild state from `trace`, the other is not following GP but produces same results as 1.

the only gotcha i can see about using the second solution (besides being out of spec from what GP states) is that it creates another possible hash collision point.

One of which is reducing `k` from 32 bytes to 27 and then 23 and then using this as key for read/write where multiple hashed keys. N

not trying to be picky here but 23 bytes collision between `warp client` and ` full client`... how hard can they be to do?
2025-05-21 11:31 gav: Yes, a change was made fairly recently removing a secondary hash.  [edited]
2025-05-21 11:32 gav: It is true that 5 bytes of the service storage key don't make it into the state merkle tree key. [edited]
2025-05-21 11:33 gav: 
2025-05-21 11:35 gav: But with a secondary hash, between the initial 5 byte removal and the second 4 byte removal, there should still be 27 bytes of entropy in the final key. That's not the case at present, and most likely needs to be fixed.
2025-05-21 11:39 gav: https://github.com/gavofyork/graypaper/issues/403
2025-05-21 12:28 prematurata: another solution would be to re-add the keys before the value. You don't lose entropy and allow warp/full impl to behave exacty the same
2025-05-21 12:29 prematurata: @gav ^^
2025-05-21 12:49 gav: Yeah true. It’s just a little more storage, and there’s UB in the case of a collision, which is quite a bit more likely with only 23 bytes of entropy. We’d need to define which of two colliding keys took precedence.  [edited]
2025-05-21 18:05 nicholasonchain: Are there any way to fetch `block` and C(1)-C(15) `state` from header hash in polkajam binaries?
2025-05-21 18:05 nicholasonchain: We would to see polkajam support new JIP-2 methods to fetch a block and one or more of C(1)-C(15) state by header hash to support basic explorer -- is this possible?
2025-05-21 19:15 dave: Certainly possible, can't promise a time frame though these things should be easy to add
2025-05-21 21:34 sourabhniyogi: Is there an env variable to turn on pvm trace execution logs in `polkajam` to compare with our own binaries logs, e.g something like [this](https://github.com/jam-duna/jamtestnet/blob/main/traces/reports-l0/00000003.log#L2-L3135)?
  ↳ 2025-05-22 10:12 jan: Force the interpreter backend and set `RUST_LOG=polkavm=trace`
  ↳ 2025-05-22 12:53 sourabhniyogi: Awesome -- any way to get the registers to appear at least some of the time, or other options?

```
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter  Compiling block:
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [4]: 8206: charge_gas
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [5]: 8206: sp = sp + 0xfffffffffffffd00
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [6]: 8210: u64 [sp + 0x2f8] = ra
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [7]: 8214: u64 [sp + 0x2f0] = s0
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [8]: 8218: u64 [sp + 0x2e8] = s1
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [9]: 8222: i32 s0 = a0 + 0
2025-05-22 20:22:42 tokio-runtime-worker DEBUG polkavm::interpreter    [10]: 8224: jump 9459 if s0 == 0
2025-05-22 20:22:42 tokio-runtime-worker TRACE polkavm::interpreter::raw_handlers    -> resolved to fallthrough
2025-05-22 20:22:42 tokio-runtime-worker TRACE polkavm::interpreter::raw_handlers  [4]: charge_gas: 6 (49999999 -> 49999993)
```
2025-05-22 13:34 dave: Proposal for a standard secret key derivation method here: https://github.com/polkadot-fellows/JIPs/blob/c888a85736b18261b848224a5e242e6a42f8e4ff/JIP-5.md. We're planning to make PolkaJam follow this method. Note that we intend to use the same method for deriving keys from on-disk seed files as for deriving the "dev chain" validator keys. Currently different methods are used which means for example it is not currently possible to use an on-disk seed file for a dev chain validator.

This change _will_ cause breakage, in particular the dev account keys listed here will change: https://docs.jamcha.in/basics/dev-accounts. The new dev account keys are listed in the "test vectors" section at the bottom of the linked doc. Apologies for any hassle this causes, hopefully this change will make things simpler and easier in the long run though!
